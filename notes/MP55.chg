!Object methodsFor!

inspectorClass
	"Answer the class of inspector to be used when inspecting the receiver."

	^Smalltalk developmentSystem defaultInspectorClass!

snoopAspects
	#idbAdded.
	^(OrderedCollection new)
		addAll: self snoopFirst;
		addAll: self snoopSecond;
		addAll: self snoopThird;
		yourself!

snoopChildren
	"Default for any (leaf) objects that have no children e.g. MenuItem"

	#idbAdded.
	^#()!

snoopDescription
	"Default basic description for a snooped class"

	#idbAdded.
	^self class printString!

snoopDescription: aStringOrNil
	"Answers a description of a snooped object. The class name with, possibly, a 
	descriptive name"

	| stream |
	#idbAdded.
	stream := String writeStream.
	self class printOn: stream.
	(aStringOrNil notNil and: [aStringOrNil notEmpty])
		ifTrue:
			[stream
				space;
				nextPut: $(;
				nextPutAll: aStringOrNil;
				nextPut: $)].
	^stream contents!

snoopFirst
	"Every snooped object has this as its first interest"

	#idbAdded.
	^OrderedCollection with: 'Self' -> self!

snoopIconIndex
	"Default icon index for receiver"

	#idbAdded.
	^self icon imageIndex!

snoopSecond
	#idbAdded.
	^((self class canUnderstand: #commandDescription) and: [self commandDescription notNil])
		ifTrue: [self commandDescription snoopAspects]
		ifFalse: [OrderedCollection new]!

snoopThird
	| interests |
	#idbAdded.
	interests := OrderedCollection new.
	self events keysAndValuesDo: [:key :value | interests add: ('Event - ' , key) -> value].
	(self class publishedAspectsOfInstances keys asOrderedCollection copyWithout: #yourself)
		do: [:each | interests add: each -> (self perform: each asSymbol)].
	^interests! !
!Object categoriesFor: #inspectorClass!constants!development!public! !
!Object categoriesFor: #snoopAspects!accessing!idb goodies!public! !
!Object categoriesFor: #snoopChildren!accessing!idb goodies!public! !
!Object categoriesFor: #snoopDescription!displaying!idb goodies!public! !
!Object categoriesFor: #snoopDescription:!displaying!idb goodies!public! !
!Object categoriesFor: #snoopFirst!accessing!idb goodies!public! !
!Object categoriesFor: #snoopIconIndex!accessing!idb goodies!public! !
!Object categoriesFor: #snoopSecond!accessing!idb goodies!public! !
!Object categoriesFor: #snoopThird!accessing!idb goodies!public! !

Base64Codec comment:
'Base64Codec is a simple but fast implementation of the widely used Base64 binary-to-ASCII text encoding scheme. For further details of Base64 see RFC 3548 (http://www.faqs.org/rfcs/rfc3548.html). Note that the implementation of Base64 provided by this class is compatible with MIME in that it splits encoded output into lines of 76 characters separated by a CR/LF pair. 

At present this class has no public instance protocol. There are class side methods to encode (#encodeFrom:onto:) and decode (#decodeFrom:onto:) the complete contents of one stream onto another. In future it is anticipated that the class will be enhanced so that it can be used as a codec in a hypothetical encoding stream that allows for more flexible usage, and this will almost certainly mean that the instance side protocol is changed. It is also anticipated that the class will permit more control over the output in future, e.g. control over the maximum line length to support different standards, whether or not the encoded data is padded to a multiple of four characters, whether or not invalid characters in the encoded data are ignored, etc.

Class Variables:
	DecodingTable		<ByteArray>
	EncodingTable		<String>

'!
!Base64Codec class methodsFor!

decodeFrom: aGettableStream onto: aPuttableStream 
	"Decode the complete set of future sequence values from the <gettableStream> argument,
	assumed to be a text stream containing Base64 encoded data, onto the <puttableStream>
	argument, assumed to be a byte stream."

	self new decodeFrom: aGettableStream onto: aPuttableStream!

encodeFrom: aGettableStream onto: aPuttableStream 
	"Encode the complete set of future sequence values from the <gettableStream> argument,
	assumed to be a byte stream, onto the <puttableStream> argument, assumed to be a text
	stream, using Base64 encoding."

	self new encodeFrom: aGettableStream onto: aPuttableStream!

initialize
	EncodingTable := 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.
	DecodingTable := ByteArray new: 256 withAll: 255.
	EncodingTable keysAndValuesDo: [:i :each | DecodingTable at: each asInteger + 1 put: i - 1].
	DecodingTable at: $= asInteger + 1 put: EncodingTable size!

new
	^(super new)
		initialize;
		yourself! !
!Base64Codec class categoriesFor: #decodeFrom:onto:!operations!public! !
!Base64Codec class categoriesFor: #encodeFrom:onto:!operations!public! !
!Base64Codec class categoriesFor: #initialize!private! !
!Base64Codec class categoriesFor: #new!instance creation!private! !

!Base64Codec methodsFor!

decodeFrom: aGettableStream onto: aPuttableStream 
	[aGettableStream atEnd] whileFalse: 
			[| t1 t2 |
			(t1 := self nextBase64From: aGettableStream) ifNil: [^self].
			(t2 := self nextBase64From: aGettableStream) ifNil: [^self].
			aPuttableStream nextPut: (t1 bitShift: 2) + (t2 bitShift: -4).
			(t1 := self nextBase64From: aGettableStream) ifNil: [^self].
			aPuttableStream nextPut: ((t2 bitAnd: 16rF) bitShift: 4) + (t1 bitShift: -2).
			(t2 := self nextBase64From: aGettableStream) ifNil: [^self].
			aPuttableStream nextPut: ((t1 bitAnd: 16r3) bitShift: 6) + t2]!

encodeFrom: aGettableStream onto: aPuttableStream 
	| count |
	count := 0.
	[aGettableStream atEnd] whileFalse: 
			[| value |
			count == quadsPerLine 
				ifTrue: 
					[aPuttableStream cr.
					count := 0].
			value := aGettableStream next.
			aPuttableStream nextPut: (EncodingTable at: ((value bitAnd: 2r11111100) bitShift: -2) + 1).
			aGettableStream atEnd 
				ifTrue: 
					["Emit a further character for the remaining two bits, and then two padding characters"
					aPuttableStream nextPut: (EncodingTable at: ((value bitShift: 4) bitAnd: 2r110000) + 1).
					isPadded 
						ifTrue: 
							[aPuttableStream
								nextPut: $=;
								nextPut: $=].
					^self].
			value := ((value bitAnd: 2r11) bitShift: 8) + aGettableStream next.
			aPuttableStream nextPut: (EncodingTable at: ((value bitAnd: 2r1111110000) bitShift: -4) + 1).
			aGettableStream atEnd 
				ifTrue: 
					["Emit a further character for the remaining four bits, and then a padding character."
					aPuttableStream nextPut: (EncodingTable at: ((value bitShift: 2) bitAnd: 2r111100) + 1).
					isPadded ifTrue: [aPuttableStream nextPut: $=].
					^self].
			value := ((value bitAnd: 16rF) bitShift: 8) + aGettableStream next.
			aPuttableStream nextPut: (EncodingTable at: ((value bitAnd: 2r111111000000) bitShift: -6) + 1).
			aPuttableStream nextPut: (EncodingTable at: (value bitAnd: 2r111111) + 1).
			count := count + 1].
	^0!

initialize
	self lineLength: 76.
	isPadded := true!

lineLength: anInteger 
	"Private - Set the maximum length of lines emitted by the receiver to be the <integer>
	argument, which must be a multiple of four."

	anInteger \\ 4 = 0 ifFalse: [^self error: 'line length must be a multiple of four'].
	quadsPerLine := anInteger / 4!

nextBase64From: aGettableStream 
	[aGettableStream atEnd] whileFalse: 
			[| value |
			#todo.	"Invalid characters are currently ignored, but should (optionally)
				be treated as an error - see RFC 3548. This is right for MIME though."
			(value := DecodingTable at: aGettableStream next asInteger + 1) < 64 
				ifTrue: [^value]
				ifFalse: [value == 64 ifTrue: [^nil]]].
	^nil! !
!Base64Codec categoriesFor: #decodeFrom:onto:!private! !
!Base64Codec categoriesFor: #encodeFrom:onto:!private! !
!Base64Codec categoriesFor: #initialize!initializing!private! !
!Base64Codec categoriesFor: #lineLength:!accessing!private! !
!Base64Codec categoriesFor: #nextBase64From:!helpers!private! !

!Canvas methodsFor!

font
	"Answer the current <Font>."

	^font ifNil: [Font fromHandle: (self getCurrentObject: OBJ_FONT)]!

font: aFont
	"Select the specified <Font> into this canvas. Ensure that the font is realized for the
	receiver's resolution. Answer the previously selected <Font>."

	| oldFont |
	oldFont :=self font.
	font := aFont.
	font resolution: self resolution.
	self selectObject: aFont.
	^oldFont! !
!Canvas categoriesFor: #font!accessing!public!tools! !
!Canvas categoriesFor: #font:!accessing!public!tools! !

ChunkBrowserChunk comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ChunkBrowserChunk class methodsFor!

chunkClasses
	"A collection of classes that should be tested to decide the type of a chunk"

	ChunkClasses := nil.
	ChunkClasses
		ifNil:
			[ChunkClasses := OrderedCollection new.
			ChunkClasses
				add: ChunkBrowserClassDefineChunk;
				add: ChunkBrowserClassDeleteChunk;
				add: ChunkBrowserClassCommentChunk;
				add: ChunkBrowserClassGUIDChunk;
				add: ChunkBrowserClassProtocolChunk;
				add: ChunkBrowserClassCategorySeriesStartChunk;
				add: ChunkBrowserMethodCategorySeriesStartChunk;
				add: ChunkBrowserMethodDefineSeriesStartChunk;
				add: ChunkBrowserMethodDeleteChunk;
				add: ChunkBrowserResourceDefineChunk;
				add: ChunkBrowserResourceDefineChunkBase64;
				add: ChunkBrowserResourceDeleteChunk;
				add: ChunkBrowserSystemChunk].
	^ChunkClasses!

chunkType
	self subclassResponsibility!

dotIconIndex
	^self iconIndices at: #dot!

fromText: aString
	^self new initialize: aString!

iconCrossFileName
	^self iconFileName: 'Cross'!

iconDashFileName
	^self iconFileName: 'Dash'!

iconDotFileName
	^self iconFileName: 'Dot'!

iconFileName: aString
	^File
		composePath: SessionManager current idbResourcesFolder
		stem: aString
		extension: 'ico'!

iconIndexFor: aBooleanOrNil
	aBooleanOrNil == nil ifTrue: [^self iconIndices at: #dash].
	^aBooleanOrNil
		ifTrue: [self iconIndices at: #tick]
		ifFalse: [self iconIndices at: #cross]!

iconIndices
	IconIndices
		ifNil:
			[IconIndices := (Dictionary new)
				at: #dash put: (Icon fromFile: self iconDashFileName) imageIndex;
				at: #tick put: (Icon fromFile: self iconTickFileName) imageIndex;
				at: #cross put: (Icon fromFile: self iconCrossFileName) imageIndex;
				at: #dot put: (Icon fromFile: self iconDotFileName) imageIndex;
				yourself.
			SessionManager current
				when: #imageSaveStarting
				send: #onImageSaveStarting
				to: self].
	^IconIndices!

iconTickFileName
	^self iconFileName: 'Tick'!

isChunkClassFor: aString
	self subclassResponsibility!

onImageSaveStarting
	IconIndices := nil! !
!ChunkBrowserChunk class categoriesFor: #chunkClasses!constants!public! !
!ChunkBrowserChunk class categoriesFor: #chunkType!accessing!constants!public! !
!ChunkBrowserChunk class categoriesFor: #dotIconIndex!accessing!public! !
!ChunkBrowserChunk class categoriesFor: #fromText:!instance creation!public! !
!ChunkBrowserChunk class categoriesFor: #iconCrossFileName!constants!public! !
!ChunkBrowserChunk class categoriesFor: #iconDashFileName!constants!public! !
!ChunkBrowserChunk class categoriesFor: #iconDotFileName!constants!public! !
!ChunkBrowserChunk class categoriesFor: #iconFileName:!constants!public! !
!ChunkBrowserChunk class categoriesFor: #iconIndexFor:!accessing!public! !
!ChunkBrowserChunk class categoriesFor: #iconIndices!constants!public! !
!ChunkBrowserChunk class categoriesFor: #iconTickFileName!constants!public! !
!ChunkBrowserChunk class categoriesFor: #isChunkClassFor:!public!testing! !
!ChunkBrowserChunk class categoriesFor: #onImageSaveStarting!constants!public! !

!ChunkBrowserChunk methodsFor!

<= aChunkBrowserChunk
	^index <= aChunkBrowserChunk index!

= aChunk
	^self class == aChunk class
		and: [identity1 = aChunk identity1 and: [identity2 = aChunk identity2]]!

browse
	self browseTarget browse!

canBrowse
	^self browseTarget notNil!

canFilterOnComparison
	^true!

canShowDifferences
	^false!

chunkIconIndex
	^self class iconIndexFor: self isMatch!

chunkText
	self subclassResponsibility!

chunkType
	^self class chunkType!

classNameFromRawText
	| firstSpaceIndex |
	firstSpaceIndex := rawText indexOf: Character space.
	^(rawText indexOfSubCollection: ' class') = firstSpaceIndex
		ifTrue: [rawText copyFrom: 1 to: firstSpaceIndex + 5]
		ifFalse: [rawText copyFrom: 1 to: firstSpaceIndex - 1]!

displayTextUsing: aColor
	^(RichText rtfConverter)
		font: SmalltalkWorkspace actualFont;
		forecolor: aColor;
		readTextFrom: rawText readStream;
		richText!

filter: aCollection types: aSet missing: missingBool match: matchBool differ: differBool range: aRangeOrNil last: lastBool lastSet: lastSet
	"include this type of chunk?"

	| match |
	(aSet includes: self class chunkType) ifFalse: [^self].	"chunk is in range?"
	aRangeOrNil ifNotNil: [:arg | (arg includes: self index) ifFalse: [^self]].	"need to remember last occurrence?"
	lastBool
		ifTrue:
			[| found |
			found := lastSet find: self ifAbsent: [].
			found ifNotNil: [:arg | lastSet remove: arg].
			lastSet add: self].	"probably want this chunk"
	aCollection addLast: self.	"can check on comparison?"
	self canFilterOnComparison ifFalse: [^self].	"check on comparison"
	match := self isMatch.
	(missingBool and: [match isNil]) ifTrue: [^self].
	(matchBool and: [match == true]) ifTrue: [^self].
	(differBool and: [match == false]) ifTrue: [^self].	"don't want this one after all"
	aCollection removeLast.
	lastBool ifTrue: [lastSet remove: self]!

hash
	^(self class hash bitXor: identity1 hash) bitXor: identity2 hash!

identity1
	^identity1!

identity1AndIdentity2AsCompiledMethod
	^self identity1AsClass
		ifNotNil:
			[:arg | 
			(arg includesSelector: identity2 asSymbol)
				ifTrue: [arg compiledMethodAt: identity2 asSymbol]]!

identity1AndIdentity2AsResourceIdentifier
	^self identity1AsClass
		ifNotNil:
			[:arg | 
			| resourceIdentifier |
			resourceIdentifier := ResourceIdentifier class: arg name: identity2.
			(SessionManager current resourceManager resourceAt: resourceIdentifier ifAbsent: [])
				ifNotNil: [:resource | resourceIdentifier]]!

identity1AsClass
	| className metaclass class |
	className := identity1.
	metaclass := false.
	(className includes: Character space)
		ifTrue:
			[className := className copyFrom: 1 to: (className indexOf: Character space) - 1.
			metaclass := true].
	(self class environment includesKey: className) ifFalse: [^nil].
	class := self class environment at: className.
	metaclass ifFalse: [^class].
	^class class!

identity2
	^identity2!

index
	^index!

index: anInteger
	index := anInteger!

initialize: aString
	rawText := aString.
	picked := false!

isChunkSeriesStart
	^false!

isImageSave
	^false!

isMatch
	self subclassResponsibility!

picked
	^picked!

picked: aBoolean
	picked := aBoolean!

pickedIconIndex
	^picked ifTrue: [self class dotIconIndex] ifFalse: [0]!

rawText
	^rawText!

restore
	self subclassResponsibility! !
!ChunkBrowserChunk categoriesFor: #<=!comparing!public! !
!ChunkBrowserChunk categoriesFor: #=!comparing!public! !
!ChunkBrowserChunk categoriesFor: #browse!operations!public! !
!ChunkBrowserChunk categoriesFor: #canBrowse!public!testing! !
!ChunkBrowserChunk categoriesFor: #canFilterOnComparison!public!testing! !
!ChunkBrowserChunk categoriesFor: #canShowDifferences!public!testing! !
!ChunkBrowserChunk categoriesFor: #chunkIconIndex!accessing!public! !
!ChunkBrowserChunk categoriesFor: #chunkText!accessing!public! !
!ChunkBrowserChunk categoriesFor: #chunkType!accessing!constants!public! !
!ChunkBrowserChunk categoriesFor: #classNameFromRawText!helpers!public! !
!ChunkBrowserChunk categoriesFor: #displayTextUsing:!operations!public! !
!ChunkBrowserChunk categoriesFor: #filter:types:missing:match:differ:range:last:lastSet:!operations!public! !
!ChunkBrowserChunk categoriesFor: #hash!comparing!public! !
!ChunkBrowserChunk categoriesFor: #identity1!accessing!public! !
!ChunkBrowserChunk categoriesFor: #identity1AndIdentity2AsCompiledMethod!helpers!public! !
!ChunkBrowserChunk categoriesFor: #identity1AndIdentity2AsResourceIdentifier!helpers!public! !
!ChunkBrowserChunk categoriesFor: #identity1AsClass!helpers!public! !
!ChunkBrowserChunk categoriesFor: #identity2!accessing!public! !
!ChunkBrowserChunk categoriesFor: #index!accessing!public! !
!ChunkBrowserChunk categoriesFor: #index:!accessing!public! !
!ChunkBrowserChunk categoriesFor: #initialize:!initializing!public! !
!ChunkBrowserChunk categoriesFor: #isChunkSeriesStart!public!testing! !
!ChunkBrowserChunk categoriesFor: #isImageSave!public!testing! !
!ChunkBrowserChunk categoriesFor: #isMatch!public!testing! !
!ChunkBrowserChunk categoriesFor: #picked!accessing!public! !
!ChunkBrowserChunk categoriesFor: #picked:!accessing!public! !
!ChunkBrowserChunk categoriesFor: #pickedIconIndex!accessing!public! !
!ChunkBrowserChunk categoriesFor: #rawText!accessing!public! !
!ChunkBrowserChunk categoriesFor: #restore!operations!public! !

!ClassBuilder class methodsFor!

validateClassVarName: aString using: aCollection
	"Private - Ensure that the proposed class variable name is not a
	reserved word and does not duplicate a name defined in aCollecton."

	(self parser isAValidLocalIdentifier: aString)
		ifFalse: [self error: 'Proposed class variable ''', aString, ''' is invalid as a local identifier.'].
	(aCollection includes: aString)
		ifTrue: [self error: 'Proposed class variable ''', aString, ''' is multiply defined.'].
	aString first isUppercase
		ifFalse: [
			aString first == $_ ifTrue: [
				^Smalltalk at: #SmalltalkSystem ifPresent: [:c | 
					c current isOAD ifFalse: [
						Warning signal: 'Identifiers beginning with an underscore, such as ', aString, ', are reserved for system use']]].
			Warning signal: 'Proposed class variable ''', aString, ''' should start with an uppercase letter.']! !
!ClassBuilder class categoriesFor: #validateClassVarName:using:!private!validation! !

!ClassBuilder methodsFor!

validatePoolNames
	"Private - Ensure that the proposed pool dictionary names exists in the environment
	and warn if they don't start with an uppercase letter."

	self sharedPools do: [:poolName | | firstChar |
		self environment at: poolName
			ifAbsentPut: [
				Warning signal: ('Pool dictionary ''%1'' does not exist.%nProceed to create it as an empty constants pool.'
							formatWith: poolName).
				PoolConstantsDictionary named: poolName].
		firstChar := poolName first.
		(firstChar isUppercase or: [firstChar == $_])
			ifFalse: [Warning signal: 'Pool dictionary ''', poolName, ''' should start with an uppercase letter.']]! !
!ClassBuilder categoriesFor: #validatePoolNames!private!validation! !

!Clipboard methodsFor!

getDeviceIndependentBitmap
	"Get a DeviceIndependentBitmap from the Clipboard"

	#idbAdded.
	(registeredFormats includesKey: #DIBSection)
		ifFalse: [self initializeForDeviceIndependentBitmap].
	^self getDeviceIndependentBitmapIfNone: [self errorFormatNotAvailable: #DIB]!

getDeviceIndependentBitmapIfNone: exceptionHandler
	"Get a DeviceIndependentBitmap from the Clipboard"

	| hBitmap pBitmap bitmapInfoHeader colorTable bytes bitmap |
	#idbAdded.
	^self
		apply:
			[hBitmap := UserLibrary default getClipboardData: CF_DIB.
			hBitmap isNull ifTrue: [^exceptionHandler value].
			pBitmap := KernelLibrary default globalLock: hBitmap.
			bitmapInfoHeader := BITMAPINFOHEADER fromAddress: pBitmap.	"Get the color table and image bits from the Clipboard data structure (a packed BITMAPINFO)"
			colorTable := bitmapInfoHeader biBitCount <= 8
				ifTrue:
					[StructureArray
						fromAddress: (pBitmap yourAddress + BITMAPINFOHEADER byteSize) asExternalAddress
						length: (2 raisedToInteger: bitmapInfoHeader biBitCount)
						elementClass: RGBQUAD]
				ifFalse: [StructureArray length: 1 elementClass: RGBQUAD].
			bytes := ByteArray
				fromAddress:
					(pBitmap yourAddress + BITMAPINFOHEADER byteSize + colorTable byteSize) asExternalAddress
				length: bitmapInfoHeader biSizeImage.
			KernelLibrary default globalUnlock: hBitmap.	"We have to create a new DeviceIndependentBitmap of the appropriate size and then 
	copy the color table and image bits"
			bitmap := DeviceIndependentBitmap
				width: bitmapInfoHeader biWidth
				height: bitmapInfoHeader biHeight
				depth: bitmapInfoHeader biBitCount.
			bitmap setColorTable: colorTable.
			bitmap bitmapStruct bmBits
				replaceFrom: 1
				to: bytes size
				with: bytes
				startingAt: 1.
			bitmap]!

initializeForDeviceIndependentBitmap
	"Added to add a clipboard format for DIBSection"

	#idbAdded.
	registeredFormats at: #DIBSection put: CF_DIB!

isDeviceIndependentBitmapAvailable
	"Answer whether the clipboard contains a DIB.(DIBSection or DeviceIndependentBitmap)"

	#idbAdded.
	^self isFormatIdAvailable: CF_DIB!

setDeviceIndependentBitmap: aDeviceIndependentBitmap
	"Transfer the specified DIBSection bitmap to the clipboard."

	#idbAdded.
	(registeredFormats includesKey: #DIBSection)
		ifFalse: [self initializeForDeviceIndependentBitmap].
	self setDeviceIndependentBitmap: aDeviceIndependentBitmap format: #DIBSection!

setDeviceIndependentBitmap: aDeviceIndependentBitmap format: formatName
	"Copy the specified bitmap to the clipboard as an entry
	of the specified format name."

	#idbAdded.
	self
		setDeviceIndependentBitmap: aDeviceIndependentBitmap
		formatId: (registeredFormats at: formatName)!

setDeviceIndependentBitmap: aDeviceIndependentBitmap formatId: formatId
	"Copies a DeviceIndependentBitmap onto the Clipboard
	The clipboard expects a pached BITMAPINFO (a BITMAPINFO followed immediately 
	by the image bits)"

	| bytes hMem pMem |
	#idbAdded.
	bytes := aDeviceIndependentBitmap bitmapInfoStruct asByteArray
		, aDeviceIndependentBitmap imageBytes.
	hMem := KernelLibrary default globalAlloc: ##(GHND | GMEM_DDESHARE) dwBytes: bytes size.
	pMem := KernelLibrary default globalLock: hMem.
	pMem
		replaceFrom: 1
		to: bytes size
		with: bytes
		startingAt: 1.
	KernelLibrary default globalUnlock: hMem.
	self setData: hMem formatId: formatId! !
!Clipboard categoriesFor: #getDeviceIndependentBitmap!accessing!idb goodies!public! !
!Clipboard categoriesFor: #getDeviceIndependentBitmapIfNone:!accessing!idb goodies!public! !
!Clipboard categoriesFor: #initializeForDeviceIndependentBitmap!idb goodies!initializing!public! !
!Clipboard categoriesFor: #isDeviceIndependentBitmapAvailable!idb goodies!public!testing! !
!Clipboard categoriesFor: #setDeviceIndependentBitmap:!accessing!idb goodies!public! !
!Clipboard categoriesFor: #setDeviceIndependentBitmap:format:!accessing!idb goodies!public! !
!Clipboard categoriesFor: #setDeviceIndependentBitmap:formatId:!accessing!idb goodies!public! !

!Color class methodsFor!

caption
	#idbAdded.
	^self systemColor: COLOR_ACTIVECAPTION!

dolphinWorkspace
	#idbAdded.
	^self
		red: 255
		green: 255
		blue: 230! !
!Color class categoriesFor: #caption!idb goodies!instance creation!public! !
!Color class categoriesFor: #dolphinWorkspace!constants!idb goodies!public! !

!CommandDescription methodsFor!

snoopAspects
	#idbAdded.
	self command ifNil: [^OrderedCollection new].
	^(OrderedCollection new)
		add: 'Command' -> self command;
		add: 'Description' -> self description;
		add: 'AcceleratorKey' -> self acceleratorKey;
		add: 'AcceleratorKeyString' -> self acceleratorKeyString;
		add: 'IsModalCommand' -> self isModalCommand;
		add: 'Image' -> self image;
		yourself! !
!CommandDescription categoriesFor: #snoopAspects!idb goodies!operations!public! !

!CompilationResult methodsFor!

rtf: anObject
	rtf := anObject! !
!CompilationResult categoriesFor: #rtf:!accessing!private! !

!CompiledCode methodsFor!

isOverride
	"Answer whether the receiver is overriding a method in a superclass."

	^false! !
!CompiledCode categoriesFor: #isOverride!public!testing! !

!DBAbstractRow methodsFor!

hash
	"Answer the <integer> hash value for the receiver." 

	^self contents hash
! !
!DBAbstractRow categoriesFor: #hash!comparing!public! !

!DBColAttr methodsFor!

initialize
	"Private - Initialize the receiver"

	special := ##(SQL_PARAM_INPUT bitShift: ParameterTypeShift)!

parameterType
	"Answer the SQL_PARAM_XXXX value that defines the type of parameter
	the receiver represents when used in a parameterized statement. The default
	is SQL_PARAM_INPUT, which is appropriate for most cases except some
	stored procedures."

	^(special bitAnd: ParameterTypeMask) >> ParameterTypeShift!

parameterType: anInteger 
	"Set the type of parameter the receiver represents when used in a parameterized 
	statement to the SQL_PARAM_XXXX value specified as the integer argument.
	This must be one of:
		SQL_PARAM_TYPE_UNKNOWN 	- direction unspecified
		SQL_PARAM_INPUT			- input only parameter
		SQL_PARAM_INPUT_OUTPUT         - bidirectional parameter
		SQL_RESULT_COL                   		- result set column
		SQL_PARAM_OUTPUT                 	- output only parameter
		SQL_RETURN_VALUE                 	- stored procedure return value
	The columnType should not be changed from the default (SQL_PARAM_INPUT),
	unless describing an output or input/output parameter to a stored procedure.
	"

	special := (special maskClear: ParameterTypeMask) 
				maskSet: (anInteger bitShift: ParameterTypeShift)! !
!DBColAttr categoriesFor: #initialize!initializing!private! !
!DBColAttr categoriesFor: #parameterType!accessing!public! !
!DBColAttr categoriesFor: #parameterType:!accessing!public! !

!DBConnection class methodsFor!

connectString: aString do: aTwoArgBlock 
	"Private - Interpret the connection string and pass the parameter name and value from each
	$; separated substring to aTwoArgBlock."

	"Implementation Note: We really need a mini-parser here to catch errors in the connection
	string, but for the sake of simplicity we use a less sophisticated approach that may yield
	incorrect results for some malformed connection strings (e.g. those missing the + separator
	between key and value pairs). This is considered less important than parsing well formed
	connection strings correctly."

	| stream |
	stream := aString readStream.
	
	[stream skipWhile: [:ch | ch == $;].
	stream atEnd] whileFalse: 
				[| paramName paramValue |
				paramName := stream upTo: $=.
				"Note that the value can be empty"
				paramValue := (stream peekFor: ${) ifTrue: [stream upTo: $}] ifFalse: [stream upTo: $;].
				aTwoArgBlock value: paramName value: paramValue]! !
!DBConnection class categoriesFor: #connectString:do:!operations!private! !

!DBConnection methodsFor!

exec: aString cursorType: aSymbol 
	"Execute the SQL in aString, answering the type of cursor specified by the
	<Symbol> argument (one of #dynamic, #forwardOnly, #keysetDriven, or 
	#static)."

	| statement |
	statement := self newStatement: aSymbol.
	[statement exec: aString] ifCurtailed: [statement free].
	^statement!

open
	"Open the receiver after prompting for the connection details, but only
	if not already connected."

	| connSz lenConnSz |
	handle isNull ifFalse: [^self].
	
	[| ret |
	"#1306: From MSDN, 'Applications should allocate at least 1,024 bytes for [the connection string] buffer'"
	connSz := String newFixed: 2048.
	lenConnSz := SWORD new.
	ret := ODBCLibrary default 
				sqlDriverConnect: self getHandle
				windowHandle: UserLibrary default getActiveWindow
				inConnectionString: self connectString
				stringLength1: SQL_NTS
				outConnectionString: connSz
				bufferLength: connSz size
				stringLength2Ptr: lenConnSz
				driverCompletion: (self useDriverCompletion 
						ifTrue: [SQL_DRIVER_COMPLETE]
						ifFalse: [SQL_DRIVER_NOPROMPT]).
	self dbCheckException: ret] 
			ifCurtailed: [self free].
	self connectString: (connSz copyFrom: 1 to: (lenConnSz value min: connSz size))!

views
	"Answer a collection of all user views in the database"

	^self tables: nil owners: nil tables: nil types: '''VIEW'''! !
!DBConnection categoriesFor: #exec:cursorType:!executing!public! !
!DBConnection categoriesFor: #open!operations!public! !
!DBConnection categoriesFor: #views!enquiries!public! !

!Exception methodsFor!

description
	"Answer a <readableString> describing the exception which the receiver represents. Note that
	if 'an explicit message text was provided by the signaler of the exception, that text should
	be incorporated into the description.' We don't enforce this (because we take the view that
	it is more important that exceptions carry all necessary details from the signalling point
	that will enable them to be handled correctly, and that presentation to the user is the
	exceptional case).

	N.B. This is an ANSI standard message in a class which is explicitly specified to be
	subclassable, and therefore it must not send any messages to self other than other ANSI
	standard messages, or those prefixed with an underscore. This is to avoid the fragile base
	class problem where subclasses may inadvertantly override a superclass method."

	| desc format |
	format := self _descriptionFormat.
	"An optimisation to speed up notifications - also avoids problem of limited string lengths
	supported by FormatMessage API"
	desc := format = '%1' 
				ifTrue: [self _descriptionArguments first]
				ifFalse: [format formatWithArguments: self _descriptionArguments].
	^desc isEmpty ifTrue: ['An unknown %1 has occurred' formatWith: self class name] ifFalse: [desc]! !
!Exception categoriesFor: #description!displaying!public! !

!ExternalLibrary methodsFor!

invalidCall
	"An invalid external call was attempted through one of the receiver's methods.
	Generate an appropriate error from the following categories:
		-	Argument type error. At least one argument was either out of range or of invalid type.
			Only the first such error is reported. The primitive failure result will be >= 16
			if an argument is invalid, the invalid argument number (from 1) being (failure result - 16)+1.
`		-	Invalid receiver (failure result = 0)
		-	Procedure not found (failure result = 1)
		-	System error.
		-	Unknown primitive failure. An uncategorised primitive failure occurred. Seek assistance."

	| error failureCode proc |
	proc := Processor activeProcess.
	failureCode := proc primitiveFailureCode.
	failureCode < 0 ifTrue: [^HRESULTError signalWith: failureCode].
	failureCode >= 16 
		ifTrue: 
			["An invalid argument was passed"
			| frame arg i descriptor |
			frame := proc topFrame sender.
			descriptor := frame method descriptor.
			i := descriptor argumentIndexFromOffset: failureCode - 16.
			arg := frame method isVirtualFunction ifTrue: [i - 1] ifFalse: [i].
			self invalidArgErrorClass 
				invalidArgument: arg
				got: (frame arguments at: arg)
				expected: (descriptor argumentTypes at: i)]
		ifFalse: 
			[failureCode == 0 ifTrue: [^self error: 'invalid receiver'].
			failureCode == 1 
				ifTrue: 
					["Function name not found in the DLL, i.e. failure of GetProcAddress().
					Often caused by omitting the A (for ASCII) or W (for Wide = Unicode) 
					function name suffix. Note that this may be required even if the function
					has no string arguments."
					^Win32Error signalWith: ERROR_PROC_NOT_FOUND]].

	"All arguments were apparently valid (assuming the Smalltalk validation matches the VM's),
	it must have been some system or unknown error."
	error := KernelLibrary default getLastError.
	^error == 0 ifTrue: [self primitiveFailed] ifFalse: [self systemError: error]! !
!ExternalLibrary categoriesFor: #invalidCall!exceptions!public! !

!ExternalStructure class methodsFor!

fromObject: anObject 
	"Answer an instance of the receiver whose value is the argument."

	^(self newBuffer)
		value: anObject;
		yourself!

GetFieldNames: pcNames rgBstrNames: rgBstrNames 
	"Implement the IRecordInfo::GetFieldNames() method for the UDT described by the receiver.

		HRESULT __stdcall GetFieldNames(
			[in, out] unsigned long* pcNames,
			[out] BSTR* rgBstrNames);
	"

	| names |
	names := self getFieldList.
	rgBstrNames isNull 
		ifTrue: [pcNames value: names size]
		ifFalse: 
			[| namesArray maxNames end |
			maxNames := pcNames value.
			namesArray := DWORDArray fromAddress: rgBstrNames yourAddress length: maxNames.
			end := names size min: maxNames.
			1 to: end do: [:i | namesArray at: i put: (names at: i) asBSTR detach].
			end + 1 to: maxNames do: [:i | namesArray at: i put: 0].
			pcNames value: end].
	^0	"S_OK"! !
!ExternalStructure class categoriesFor: #fromObject:!instance creation!public! !
!ExternalStructure class categoriesFor: #GetFieldNames:rgBstrNames:!COM Interfaces-IRecordInfo!public! !

!File class methodsFor!

isWriteable: aString 
	"Answer whether the file at the specified path is writeable. If there is no such file, then
	the answer will be true. If there file exists then the answer is based on file's attributes
	- i.e. whether or not it has the read-only flag set. Note that file permissions are not
	taken into account, so even if the answer is true a subsequent attempt to open the file for
	writing may fail."

	| attributes |
	attributes := KernelLibrary default getFileAttributes: aString.
	^(attributes ~= -1 and: [attributes allMask: FILE_ATTRIBUTE_READONLY]) not!

lastWriteTime: aString 
	"Answer a <FILETIME> representing the time when the file with the specified filename was
	last modified, or nil if no such file exists."

	| file |
	(self exists: aString) ifFalse: [^nil].
	file := File 
				open: aString
				mode: #read
				check: true
				share: #read.
	^[file lastWriteTime] ensure: [file close]! !
!File class categoriesFor: #isWriteable:!public!testing! !
!File class categoriesFor: #lastWriteTime:!enquiries!public! !

!File methodsFor!

seek: offsetInteger sense: senseFlag 
	"Move the receiver's file pointer to position anInteger
	relative to the postition indicated by senseFlag.

	senseFlag
		must be one of (FILE_BEGIN, FILE_CURRENT, FILE_END).

	Answer the absolute integer position achieved or
	signal a FileException if the operation fails."

	| result high |
	high := DWORDBytes fromInteger: (offsetInteger bitShift: -32).
	result := KernelLibrary default 
				setFilePointer: handle
				lDistanceToMove: (16rFFFFFFFF bitAnd: offsetInteger)
				lpDistanceToMoveHigh: high
				dwMoveMethod: senseFlag.
	"N.B. If you step through this in the debugger you may get a false error because the 
	SetFilePointer API relies on the GetLastError() code to differentiate between
	 a legitimate file pointer low-word value and an error. As you step in the debugger 
	the error code will be altered by other API calls, and so it may no longer be zero
	when tested."
	^(16rFFFFFFFF = result and: [KernelLibrary default getLastError ~~ 0]) 
		ifTrue: [self signalOsError: false]
		ifFalse: [(high asSignedInteger bitShift: 32) bitOr: result]
! !
!File categoriesFor: #seek:sense:!positioning!public! !

FileBrowserAbstract comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!FileBrowserAbstract class methodsFor!

name: aString parent: aFileBrowserFolderOrNil
	"Answers a new instance of the receiver"

	^self new setName: aString parent: aFileBrowserFolderOrNil! !
!FileBrowserAbstract class categoriesFor: #name:parent:!instance creation!public! !

!FileBrowserAbstract methodsFor!

name
	"Answers the name of the receiver. This can be either a complete path (the root folder) or
	a folder name of a file name depending on the subclass used"

	^name!

parent
	"Answers the parent of the receiver or nil if it is the root"

	^parent!

path
	"Creates the path of the receiver by appending to the path of the parent (s)"

	parent isNil ifTrue: [^name].
	^File composePath: parent path subPath: name!

printOn: aStream
	"Answer the String to be used for the receiver in the tree or list"

	aStream nextPutAll: name!

setName: aString parent: aFileBrowserFolderOrNil
	"Sets the name of this objects and remembers its parent. The children (folders
	not files) will be found dynamically by the subclass"

	name := aString.
	parent := aFileBrowserFolderOrNil.
	^self! !
!FileBrowserAbstract categoriesFor: #name!accessing!public! !
!FileBrowserAbstract categoriesFor: #parent!accessing!public! !
!FileBrowserAbstract categoriesFor: #path!accessing!public! !
!FileBrowserAbstract categoriesFor: #printOn:!protocols-Object!public! !
!FileBrowserAbstract categoriesFor: #setName:parent:!initializing!public! !

!FramingConstraints methodsFor!

resolutionScaledBy: aPoint 
	"Private - The receiver is being loaded and it has been determined that the pixel resolution
	has changed since the point at which the view was saved. Scale any internal pixels by the 
	<Point> argument, which contains scaling ratios for x and y extents."

	leftFraming == #relativeParentWidth 
		ifFalse: [leftOffset := (leftOffset * aPoint x) truncated].
	rightFraming == #relativeParentWidth 
		ifFalse: [rightOffset := (rightOffset * aPoint x) truncated].
	topFraming == #relativeParentHeight 
		ifFalse: [topOffset := (topOffset * aPoint y) truncated].
	bottomFraming == #relativeParentHeight 
		ifFalse: [bottomOffset := (bottomOffset * aPoint y) truncated]! !
!FramingConstraints categoriesFor: #resolutionScaledBy:!geometry!private! !

!GraphicsTool class methodsFor!

fromOwnedHandle: aHandle 
	"Answers an instance of the receiver with aHandle. The handle is owned by the instance and
	will therefore be freed by it."

	^(self new)
		ownedHandle: aHandle;
		yourself! !
!GraphicsTool class categoriesFor: #fromOwnedHandle:!instance creation!public! !

!GraphicsTool methodsFor!

basicRealize
	"Private - Realize (create) the external resource associated with the receiver, sent from
	the public method, #realize, if not already realized."

	self ownedHandle: self createHandle!

ownedHandle: aHandle
	"Private - Set the handle of the external graphics's tool object represented and owned by
	the receiver to be the argument."

	self handle: aHandle.
	ownsHandle := true.
	self beFinalizable!

realize
	"Realize (create) the external resource associated with the receiver, but only if not
	already realized."

	^self isRealized ifFalse: [self basicRealize]! !
!GraphicsTool categoriesFor: #basicRealize!private!realizing/unrealizing! !
!GraphicsTool categoriesFor: #ownedHandle:!accessing!private! !
!GraphicsTool categoriesFor: #realize!public!realizing/unrealizing! !

IdeExtensions comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!IdeExtensions class methodsFor!

extendedClasses
	self subclassResponsibility!

extendMenuIn: aBrowser
	!

extendToolbarIn: aBrowser
	!

initializeAfterLoad
	super initializeAfterLoad.
	self isExtension
		ifTrue:
			[self extendedClasses
				do:
					[:each | 
					each
						when: #viewOpened:
						send: #onBrowserOpened:
						to: self]]!

isExtension
	^false!

onBrowserClosed: aBrowser
	aBrowser view menuBar free!

onBrowserOpened: aBrowser
	aBrowser
		when: #viewClosed
		send: #onBrowserClosed:
		to: self
		with: aBrowser.
	self
		extendMenuIn: aBrowser;
		extendToolbarIn: aBrowser! !
!IdeExtensions class categoriesFor: #extendedClasses!accessing!public! !
!IdeExtensions class categoriesFor: #extendMenuIn:!operations!public! !
!IdeExtensions class categoriesFor: #extendToolbarIn:!operations!public! !
!IdeExtensions class categoriesFor: #initializeAfterLoad!initializing!public! !
!IdeExtensions class categoriesFor: #isExtension!constants!public! !
!IdeExtensions class categoriesFor: #onBrowserClosed:!event handling!public! !
!IdeExtensions class categoriesFor: #onBrowserOpened:!event handling!public! !

ILExport comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ILExport class methodsFor!

export: aCollection to: aStream
	(self new setImages: aCollection) exportTo: aStream! !
!ILExport class categoriesFor: #export:to:!operations!public! !

!ILExport methodsFor!

createBitmap: aPoint
	bitmap := DeviceIndependentBitmap
		width: aPoint x
		height: aPoint y
		depth: colorTable size lowBit - 1.
	bitmap
		setMap3DColors: false;
		setColorTable: colorTable.
	bitmap erase!

createColorTable: aBag force256: aBoolean
	| colors |
	colors := (aBag asSet
		asSortedCollection: [:a :b | (aBag occurrencesOf: a) > (aBag occurrencesOf: b)])
		asOrderedCollection.
	colors := (colors copyWithoutAll: (Array with: RGB white with: RGB black))
		addFirst: RGB black;
		addLast: RGB white;
		asArray.
	aBoolean
		ifTrue: [colors := colors resize: 256]
		ifFalse:
			[(colors size between: 3 and: 15) ifTrue: [colors := colors resize: 16].
			(colors size between: 17 and: 255) ifTrue: [colors := colors resize: 256]].
	colors := colors copyReplacing: nil withObject: RGB white.
	colorTable := StructureArray length: colors size elementClass: RGBQUAD.
	1
		to: colors size
		do: [:index | colorTable at: index put: (RGBQUAD fromRGB: (colors at: index))]!

setImages: aCollection
	images := aCollection! !
!ILExport categoriesFor: #createBitmap:!operations!public! !
!ILExport categoriesFor: #createColorTable:force256:!operations!public! !
!ILExport categoriesFor: #setImages:!accessing!public! !

ILImage comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ILImage class methodsFor!

defaultTransparentRGB
	^RGB white!

extent: aPoint
	^self new setExtent: aPoint!

extent: aPoint colors: anArray
	"Creates a new instance and initializes it with the RGB values in anArray"

	^self new setExtent: aPoint colors: anArray!

transparentRGB
	"Answer the RGB used to represent transparency on the current display.
	Dynamically changed to match the current background color"

	TransparentRGB isNil ifTrue: [TransparentRGB := self defaultTransparentRGB].
	^TransparentRGB!

transparentRGB: anRGB
	"Set the RGB used to represent transparency on the current display.
	Dynamically changed to match the current background color"

	TransparentRGB := anRGB! !
!ILImage class categoriesFor: #defaultTransparentRGB!constants!public! !
!ILImage class categoriesFor: #extent:!instance creation!public! !
!ILImage class categoriesFor: #extent:colors:!instance creation!public! !
!ILImage class categoriesFor: #transparentRGB!accessing!public! !
!ILImage class categoriesFor: #transparentRGB:!accessing!public! !

!ILImage methodsFor!

bitmapCache
	"Answer s bitmap with the colors from the receiver drawn onto it. As this is
	expensive we cache this - it will only change during editing"

	| canvas |
	bitmapCache notNil ifTrue: [^bitmapCache].	"Make it compatible with the desktop as we don't care about the colors it actually displays"
	bitmapCache := Bitmap
		compatible: DesktopView current canvas
		width: self width
		height: self height.
	canvas := bitmapCache canvas.	"If the image contains a reference to a transparent point we insert the current transparent
	color (usually set to match the background) otherwise the actual color"
	self pixelPoints
		do:
			[:each | 
			canvas
				pixelAt: each - 1
				put:
					((self isTransparentAt: each)
						ifTrue:
							["need 0 based for the bitmap"
							self class transparentRGB]
						ifFalse: [self getRGBAt: each])].
	^bitmapCache!

clearBitmapCache
	bitmapCache := nil!

colorsUsed
	"Answer a Bag containing the colorsUsed and the count for each, ignoring those 
	with a count of 0 and the transparent color"

	| bag |
	bag := Bag new.
	colorsUsedCount
		keysAndValuesDo:
			[:index :count | 
			index = self transparentColorIndex | count isZero
				ifFalse: [bag add: (self rgbFor: index) withOccurrences: count]].
	^bag!

countColorsUsed
	"Answer the number of colours used in this image
		Always include black and white (index 1 and 2) even if the aren't used
		Always exclude transparent (index 3) even if it is used"

	^2 + ((colorsUsedCount copyFrom: 4) inject: 0 into: [:sum :each | sum + each sign])!

defaultColor
	^RGB darkGray!

drawBitmapOn: aCanvas at: aPoint
	aCanvas
		drawBitmap: self bitmapCache
		at: aPoint
		extent: extent
		from: Point zero
		extent: extent
		rop: SRCCOPY!

editingImage
	"Answer an ILEditingImage which is a copy of the receiver suitable for editing"

	^(ILEditingImage extent: extent colors: (image collect: [:each | self rgbFor: each]))
		hotSpot: self hotSpot;
		yourself!

extent
	^extent!

getRGBAt: aPoint
	"Answers the RGB value at aPoint in the image"

	^self rgbFor: (self imageAt: aPoint)!

height
	^extent y!

hotSpot
	^hotSpot!

hotSpot: aPointOrNil
	hotSpot := aPointOrNil!

imageAt: aPoint
	"Answers the index of the color at aPoint in the image"

	^image at: (self offsetFor: aPoint)!

imageAt: aPoint put: anInteger
	"Puts a color indexat aPoint in the image"

	^image at: (self offsetFor: aPoint) put: anInteger!

imageDescription
	^(String writeStream)
		space;
		print: self width;
		nextPut: $x;
		print: self height;
		nextPutAll: '   Col:';
		print: self countColorsUsed;
		nextPutAll: '   HS:';
		display: hotSpot;
		contents!

indexFor: anRGB
	"Answers the index used for anRGB, creating a new one if needed"

	| index |
	(index := colorsUsed indexOf: anRGB) isZero ifFalse: [^index].
	self assert: [colorsUsed size < 255].
	colorsUsed add: anRGB.
	colorsUsedCount add: 0.
	^colorsUsed size	"= the index of the anRGB"!

isTransparentAt: aPoint
	"Answers true if the pixel at aPoint representes the fixed transparent color"

	^(self imageAt: aPoint) = self transparentColorIndex!

offsetFor: aPoint
	"Answers the offset into the image array for aPoint"

	^(aPoint y - 1) * self width + aPoint x!

pixelCount
	^self width * self height!

pixelPoints
	^self pixelPoints: (Point one corner: extent)!

pixelPoints: aRectangle
	| pixels |
	pixels := OrderedCollection new: aRectangle width * aRectangle height.
	aRectangle left
		to: aRectangle right
		do:
			[:across | aRectangle top to: aRectangle bottom do: [:down | pixels add: across @ down]].
	^pixels!

putRGB: anRGB at: aPoint
	"Puts the RGB value at aPoint in the image. Update the collection
	used to maintain the running count of colors used"

	| oldIndex newIndex |
	oldIndex := self imageAt: aPoint.
	newIndex := self indexFor: anRGB.
	oldIndex = newIndex
		ifFalse:
			[colorsUsedCount at: oldIndex put: (colorsUsedCount at: oldIndex) - 1.
			colorsUsedCount at: newIndex put: (colorsUsedCount at: newIndex) + 1.
			self imageAt: aPoint put: (self indexFor: anRGB).
			self trigger: #imageDescriptionChanged]!

rectangle
	^Point one corner: extent!

rgbFor: anInteger
	"Answers the RGB represented by anInteger"

	^colorsUsed at: anInteger!

setExtent: aPoint
	extent := aPoint.	"Each image must always containg the following three colors and they
	must be placed in the colorsUsed collection in this order"
	colorsUsed := OrderedCollection
		with: RGB black
		with: RGB white
		with: RGB dolphinYellow
		with: self defaultColor.	"We are also going to add this very shortly, so include it here"	"We keep a running count of the number of times each color is used - see below for last"
	colorsUsedCount := OrderedCollection
		with: 0
		with: 0
		with: 0
		with: self pixelCount.	"Create the table and populate it with each pixel set to the defaultColor. Use the index of 
	the color in the above table rather than the color itself"
	image := (Array new: self pixelCount) atAllPut: (colorsUsed indexOf: self defaultColor)!

setExtent: aPoint colors: anArray
	"Initialize the receiver and then add the RGB values form anArray. We have to convert from
	RGB values in the anArray to colours that we know are in our colour table, but we
	can get Windows to do this for us by using a bitmap"

	| converter canvas |
	self setExtent: aPoint.
	converter := DeviceIndependentBitmap
		width: self width
		height: self height
		depth: 8.	"Will use out standard 8 bit colour table"
	converter setMap3DColors: false.
	canvas := converter canvas.
	self pixelPoints
		do:
			[:each | 
			| color |
			color := anArray at: (each y - 1) * self width + each x.
			color = self transparentColor
				ifFalse:
					[canvas pixelAt: each - 1 put: color.
					color := canvas pixelAt: each - 1].
			self putRGB: color at: each]!

transparentColor
	^colorsUsed at: self transparentColorIndex!

transparentColorIndex
	"Answers the index of the fixed color used to represent transparency in the image
	Always in position 3 of the collection set in #setExtent"

	^3!

width
	^extent x! !
!ILImage categoriesFor: #bitmapCache!accessing!public! !
!ILImage categoriesFor: #clearBitmapCache!helpers!public! !
!ILImage categoriesFor: #colorsUsed!helpers!public! !
!ILImage categoriesFor: #countColorsUsed!helpers!public! !
!ILImage categoriesFor: #defaultColor!constants!public! !
!ILImage categoriesFor: #drawBitmapOn:at:!operations!public! !
!ILImage categoriesFor: #editingImage!converting!public! !
!ILImage categoriesFor: #extent!accessing!public! !
!ILImage categoriesFor: #getRGBAt:!accessing!public! !
!ILImage categoriesFor: #height!accessing!public! !
!ILImage categoriesFor: #hotSpot!accessing!public! !
!ILImage categoriesFor: #hotSpot:!accessing!public! !
!ILImage categoriesFor: #imageAt:!accessing!public! !
!ILImage categoriesFor: #imageAt:put:!accessing!public! !
!ILImage categoriesFor: #imageDescription!displaying!public! !
!ILImage categoriesFor: #indexFor:!accessing!public! !
!ILImage categoriesFor: #isTransparentAt:!public!testing! !
!ILImage categoriesFor: #offsetFor:!helpers!public! !
!ILImage categoriesFor: #pixelCount!initializing!public! !
!ILImage categoriesFor: #pixelPoints!helpers!public! !
!ILImage categoriesFor: #pixelPoints:!helpers!public! !
!ILImage categoriesFor: #putRGB:at:!accessing!public! !
!ILImage categoriesFor: #rectangle!helpers!public! !
!ILImage categoriesFor: #rgbFor:!accessing!public! !
!ILImage categoriesFor: #setExtent:!initializing!public! !
!ILImage categoriesFor: #setExtent:colors:!initializing!public! !
!ILImage categoriesFor: #transparentColor!accessing!public! !
!ILImage categoriesFor: #transparentColorIndex!constants!public! !
!ILImage categoriesFor: #width!accessing!public! !

ILImport comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ILImport class methodsFor!

identifyImportFileClass: aStream
	^self importableClasses
		detect: [:each | [each isResponsibleFor: aStream] ensure: [aStream reset]]
		ifNone: []!

importableClasses
	^##((OrderedCollection new)
			add: ILImportBitmap;
			add: ILImportIcon;
			add: ILImportCursor;
			add: ILImportStandardExe;
			add: ILImportToGoExe;
			yourself)!

importFrom: aStream
	^(self new initializeFrom: aStream) images! !
!ILImport class categoriesFor: #identifyImportFileClass:!helpers!public! !
!ILImport class categoriesFor: #importableClasses!helpers!public! !
!ILImport class categoriesFor: #importFrom:!instance creation!public! !

!ILImport methodsFor!

color1atColumn: columnInteger startingFrom: offsetInteger in: anILImportProxy
	| colorIndex |
	colorIndex := (anILImportProxy imageBytes at: offsetInteger + (columnInteger // 8))
		bitAt: 8 - (columnInteger \\ 8).
	^anILImportProxy colorTable at: colorIndex + 1!

color24atColumn: columnInteger startingFrom: offsetInteger in: anILImportProxy
	^(RGBQUAD new)
		rgbRed: (anILImportProxy imageBytes at: columnInteger * 3 + offsetInteger + 2);
		rgbGreen: (anILImportProxy imageBytes at: columnInteger * 3 + offsetInteger + 1);
		rgbBlue: (anILImportProxy imageBytes at: columnInteger * 3 + offsetInteger);
		yourself!

color4atColumn: columnInteger startingFrom: offsetInteger in: anILImportProxy
	| colorIndex |
	colorIndex := anILImportProxy imageBytes at: offsetInteger + (columnInteger // 2).
	columnInteger even ifTrue: [colorIndex := colorIndex bitShift: -4].
	colorIndex := colorIndex bitAnd: 15.
	^anILImportProxy colorTable at: colorIndex + 1!

color8atColumn: columnInteger startingFrom: offsetInteger in: anILImportProxy
	| colorIndex |
	colorIndex := anILImportProxy imageBytes at: offsetInteger + columnInteger.
	^anILImportProxy colorTable at: colorIndex + 1!

colorAtColumn: columnInteger startingFrom: offsetInteger in: anILImportProxy
	^RGB
		fromRGBQUAD:
			(self
				perform: (self columnAddressMethodFor: anILImportProxy colorDepth)
				with: columnInteger
				with: offsetInteger
				with: anILImportProxy)!

colorAtPoint: aPoint in: anILImportProxy
	| rowSize rowStart |
	aPoint x > anILImportProxy width | (aPoint y > anILImportProxy height)
		ifTrue: [^RGB darkGray].
	rowSize := anILImportProxy imageBytes size / anILImportProxy height.
	self assert: [rowSize \\ 4 = 0].	"Can't cope with bitmaps that are not DWORD aligned  - is it legal anyway?"
	rowStart := anILImportProxy isTopDown
		ifTrue: [(aPoint y - 1) * rowSize + 1]
		ifFalse: [(anILImportProxy height - aPoint y) * rowSize + 1].
	^self
		colorAtColumn: aPoint x - 1
		startingFrom: rowStart
		in: anILImportProxy!

columnAddressMethodFor: anInteger
	^##((LookupTable new)
			at: 1 put: #color1atColumn:startingFrom:in:;
			at: 4 put: #color4atColumn:startingFrom:in:;
			at: 8 put: #color8atColumn:startingFrom:in:;
			at: 24 put: #color24atColumn:startingFrom:in:;
			yourself)
		at: anInteger
		ifAbsent:
			[MessageBox
				notify:
					'
Sorry, the ImageLibrary cannot load this bitmap as it''s color
depth or organisation is not supported. However, if you would
like to email me a copy of the bitmap I will see what I can do. 
See the help page for the address, but please check with me 
before sending large files (>50K say) as I may already have 
implemented the format for somebody else'.
			self error: 'Cannot continue with import']!

getBitmapFrom: aByteArray
	| stream bitmapInfoHeader colorTable imageBytes |
	stream := aByteArray readStream.
	bitmapInfoHeader := BITMAPINFOHEADER fromBytes: (stream next: BITMAPINFOHEADER byteSize).
	bitmapInfoHeader biBitCount <= 8
		ifTrue:
			[colorTable := StructureArray
				length: (2 bitShift: bitmapInfoHeader biBitCount - 1)
				elementClass: RGBQUAD.
			colorTable bytes: (stream next: colorTable byteSize)].
	imageBytes := stream upToEnd.
	^self proxyClass
		bitmapInfoHeader: bitmapInfoHeader
		colorTable: colorTable
		imageBytes: imageBytes!

images
	^OrderedCollection new! !
!ILImport categoriesFor: #color1atColumn:startingFrom:in:!operations!public! !
!ILImport categoriesFor: #color24atColumn:startingFrom:in:!operations!public! !
!ILImport categoriesFor: #color4atColumn:startingFrom:in:!operations!public! !
!ILImport categoriesFor: #color8atColumn:startingFrom:in:!operations!public! !
!ILImport categoriesFor: #colorAtColumn:startingFrom:in:!helpers!public! !
!ILImport categoriesFor: #colorAtPoint:in:!helpers!public! !
!ILImport categoriesFor: #columnAddressMethodFor:!constants!public! !
!ILImport categoriesFor: #getBitmapFrom:!operations!public! !
!ILImport categoriesFor: #images!operations!public! !

ILImportBitmapProxy comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ILImportBitmapProxy class methodsFor!

bitmapInfoHeader: aBITMAPINFOHEADER colorTable: aStructureArray imageBytes: aByteArray
	^self new
		setBitmapInfoHeader: aBITMAPINFOHEADER
		colorTable: aStructureArray
		imageBytes: aByteArray! !
!ILImportBitmapProxy class categoriesFor: #bitmapInfoHeader:colorTable:imageBytes:!instance creation!public! !

!ILImportBitmapProxy methodsFor!

colorDepth
	^bitmapInfoHeader biBitCount!

colorTable
	^colorTable!

height
	^bitmapInfoHeader biHeight abs!

imageBytes
	^imageBytes!

isTopDown
	^bitmapInfoHeader biHeight < 0!

setBitmapInfoHeader: aBITMAPINFOHEADER colorTable: aStructureArray imageBytes: aByteArray
	bitmapInfoHeader := aBITMAPINFOHEADER.
	colorTable := aStructureArray.
	imageBytes := aByteArray!

width
	^bitmapInfoHeader biWidth! !
!ILImportBitmapProxy categoriesFor: #colorDepth!accessing!public! !
!ILImportBitmapProxy categoriesFor: #colorTable!accessing!public! !
!ILImportBitmapProxy categoriesFor: #height!accessing!public! !
!ILImportBitmapProxy categoriesFor: #imageBytes!accessing!public! !
!ILImportBitmapProxy categoriesFor: #isTopDown!public!testing! !
!ILImportBitmapProxy categoriesFor: #setBitmapInfoHeader:colorTable:imageBytes:!initializing!public! !
!ILImportBitmapProxy categoriesFor: #width!accessing!public! !

ILLibrary comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ILLibrary class methodsFor!

defaultExtents
	^##((OrderedCollection new)
			add: 16 asPoint;
			add: 32 asPoint;
			add: 48 asPoint;
			add: 64 asPoint;
			yourself)!

importIco: icoFilename exportExe: exeFilename
	| library icoStream exeStream |
	library := self new.
	icoStream := FileStream read: icoFilename text: false.
	exeStream := (FileStream readWrite: exeFilename) beBinary.
	[library
		import: icoStream;
		selectAll;
		exportExeTo: exeStream]
		ensure:
			[icoStream close.
			exeStream close]!

new
	^super new initialize! !
!ILLibrary class categoriesFor: #defaultExtents!constants!public! !
!ILLibrary class categoriesFor: #importIco:exportExe:!operations!public! !
!ILLibrary class categoriesFor: #new!object creation!public! !

!ILLibrary methodsFor!

addImage: aPoint
	Cursor wait showWhile: [images add: (ILImage extent: aPoint)].
	self beModified!

beModified
	modified := true.
	self trigger: #libraryChanged: with: nil!

beNotModified
	modified := false.
	self trigger: #libraryChanged: with: nil!

clearBitmapCache
	images do: [:each | each clearBitmapCache]!

deleteImage
	selectedImages do: [:each | images remove: each].
	selectedImages := Set new.
	self beModified!

editImageWithBackcolor: anRGB
	(ILEditorShell createOn: self selectedImage)
		backcolor: anRGB;
		when: #replaceImage:
			send: #onReplaceImage:
			to: self;
		when: #addImage:
			send: #onAddImage:
			to: self;
		show!

exportBitmapTo: aStream
	ILExportBitmap export: (self sortImages: selectedImages) to: aStream!

exportCursorTo: aStream
	ILExportCursor export: (self sortImages: selectedImages) to: aStream!

exportExeTo: aStream
	ILExportExe export: (self sortImages: selectedImages) to: aStream!

exportIconTo: aStream
	ILExportIcon export: (self sortImages: selectedImages) to: aStream!

hasImages
	^images size ~= 0!

hasMultipleImages
	^images size > 1!

hasSelection
	^selectedImages notEmpty!

hasSingleSelection
	^selectedImages size = 1!

imageCount
	^images size!

images
	^images!

imageSizes
	^((images collect: [:each | each extent]) , self class defaultExtents) asSet
		asSortedCollection!

import: aStream
	| fileClass |
	fileClass := ILImport identifyImportFileClass: aStream.
	fileClass isNil ifTrue: [^self].
	images addAll: (fileClass importFrom: aStream)!

initialize
	super initialize.
	images := OrderedCollection new.
	selectedImages := Set new.
	modified := false!

isModified
	^modified!

isSelected: anILImage
	^selectedImages includes: anILImage!

move: aBoolean
	| oldImages |
	oldImages := images.
	images := OrderedCollection new.
	aBoolean ifFalse: [oldImages := oldImages reverse].
	images add: oldImages removeFirst.
	[oldImages isEmpty]
		whileFalse:
			[| flag temp |
			flag := (self isSelected: images last) not and: [self isSelected: oldImages first].
			flag ifTrue: [temp := images removeLast].
			images addLast: oldImages removeFirst.
			flag ifTrue: [images addLast: temp]].
	aBoolean ifFalse: [images := images reverse].
	self beModified!

moveDown
	self move: false!

moveTo: aBoolean
	| movers stayers |
	movers := (self sortImages: selectedImages) asOrderedCollection.
	stayers := (self sortImages: (images copyWithoutAll: movers)) asOrderedCollection.
	images := aBoolean ifTrue: [movers , stayers] ifFalse: [stayers , movers].
	self beModified!

moveToEnd
	self moveTo: false!

moveToStart
	self moveTo: true!

moveUp
	self move: true!

onAddImage: anILImage
	images add: anILImage.
	self beModified!

onReplaceImage: anILImage
	self hasSingleSelection ifFalse: [^self onAddImage: anILImage].
	images at: (images indexOf: self selectedImage) put: anILImage.
	selectedImages := Set with: anILImage.
	self beModified!

resetAfterImport
	selectedImages := Set new.
	self beModified!

resetAfterLoad
	selectedImages := Set new.
	self beNotModified!

resetAfterSave: anRGB
	ILImage transparentRGB: anRGB.
	self beNotModified!

resetBeforeSave
	self clearBitmapCache.
	ILImage transparentRGB: nil!

selectAll
	selectedImages := Set withAll: images.
	self trigger: #libraryChanged: with: selectedImages!

selectBetween: anILImage1 and: anILImage2
	| changed |
	changed := selectedImages.
	selectedImages := Set
		withAll:
			(images
				copyFrom: (images findFirst: [:each | each == anILImage1 | (each == anILImage2)])
				to: (images findLast: [:each | each == anILImage1 | (each == anILImage2)])).
	changed addAll: selectedImages.
	self trigger: #libraryChanged: with: changed!

selectedImage
	^selectedImages asOrderedCollection first!

selectInvert: anILImage
	(selectedImages includes: anILImage)
		ifTrue: [selectedImages remove: anILImage]
		ifFalse: [selectedImages add: anILImage].
	self trigger: #libraryChanged: with: (Set with: anILImage)!

selectOnly: anILImage
	| changed |
	(selectedImages size = 1 and: [selectedImages includes: anILImage]) ifTrue: [^self].
	changed := selectedImages.
	changed add: anILImage.
	selectedImages := Set with: anILImage.
	self trigger: #libraryChanged: with: changed!

sortImages: aCollection
	^aCollection asSortedCollection: [:a :b | (images indexOf: a) < (images indexOf: b)]! !
!ILLibrary categoriesFor: #addImage:!adding!public! !
!ILLibrary categoriesFor: #beModified!accessing!public! !
!ILLibrary categoriesFor: #beNotModified!accessing!public! !
!ILLibrary categoriesFor: #clearBitmapCache!helpers!public! !
!ILLibrary categoriesFor: #deleteImage!commands!operations!public! !
!ILLibrary categoriesFor: #editImageWithBackcolor:!operations!public! !
!ILLibrary categoriesFor: #exportBitmapTo:!operations!public! !
!ILLibrary categoriesFor: #exportCursorTo:!operations!public! !
!ILLibrary categoriesFor: #exportExeTo:!operations!public! !
!ILLibrary categoriesFor: #exportIconTo:!operations!public! !
!ILLibrary categoriesFor: #hasImages!public!testing! !
!ILLibrary categoriesFor: #hasMultipleImages!public!testing! !
!ILLibrary categoriesFor: #hasSelection!public!testing! !
!ILLibrary categoriesFor: #hasSingleSelection!public!testing! !
!ILLibrary categoriesFor: #imageCount!accessing!public! !
!ILLibrary categoriesFor: #images!accessing!public! !
!ILLibrary categoriesFor: #imageSizes!accessing!public! !
!ILLibrary categoriesFor: #import:!operations!public! !
!ILLibrary categoriesFor: #initialize!initializing!public! !
!ILLibrary categoriesFor: #isModified!public!testing! !
!ILLibrary categoriesFor: #isSelected:!public!testing! !
!ILLibrary categoriesFor: #move:!operations!public! !
!ILLibrary categoriesFor: #moveDown!operations!public! !
!ILLibrary categoriesFor: #moveTo:!operations!public! !
!ILLibrary categoriesFor: #moveToEnd!operations!public! !
!ILLibrary categoriesFor: #moveToStart!operations!public! !
!ILLibrary categoriesFor: #moveUp!operations!public! !
!ILLibrary categoriesFor: #onAddImage:!event handling!public! !
!ILLibrary categoriesFor: #onReplaceImage:!event handling!public! !
!ILLibrary categoriesFor: #resetAfterImport!helpers!public! !
!ILLibrary categoriesFor: #resetAfterLoad!helpers!public! !
!ILLibrary categoriesFor: #resetAfterSave:!helpers!public! !
!ILLibrary categoriesFor: #resetBeforeSave!helpers!public! !
!ILLibrary categoriesFor: #selectAll!operations!public! !
!ILLibrary categoriesFor: #selectBetween:and:!operations!public! !
!ILLibrary categoriesFor: #selectedImage!operations!public! !
!ILLibrary categoriesFor: #selectInvert:!operations!public! !
!ILLibrary categoriesFor: #selectOnly:!operations!public! !
!ILLibrary categoriesFor: #sortImages:!helpers!public! !

!ImageManager methodsFor!

buildImageListWithExtent: aPoint 
	"Private - Build a new image list with the extent specified by the <Point> argument,
	populating it with all existing images."

	| newList |
	newList := self newImageListWithExtent: aPoint.
	self orderedImages do: 
			[:image | 
			(image isNil ifTrue: [Icon question] ifFalse: [image]) addToImageList: newList
				mask: maskcolor].

	"Add the new rendering to our dictionary of those available"
	imageLists at: aPoint put: newList.
	^newList!

orderedImages
	| ordered max |
	max := 0.
	"#1315: The images may not be contiguous due to some Windows oddity, so we must find the max index"
	images do: [:each | each > max ifTrue: [max := each]].
	ordered := Array new: max.
	images 
		keysAndValuesDo: [:eachKey :eachValue | eachValue == 0 ifFalse: [ordered at: eachValue put: eachKey]].
	^ordered! !
!ImageManager categoriesFor: #buildImageListWithExtent:!helpers!private! !
!ImageManager categoriesFor: #orderedImages!accessing!private! !

InputState comment:
'<InputState> is a singleton responsible for managing the windows message loop and related <Process>es.

Instance Variables:
	inputSemaphore	<Semaphore> on which the UI process blocks when the idle (i.e. when message loop is empty).
	idler		<Process>. The idle process responsible for relinquishing control to Windows when no other Smalltalk <Process>es are ready to run.
	idleTimer		<WeakArray> holding <window> currently hosting WM_TIMER used to keep background processing operational when running Windows modal msg loops such as those for common dialogs.
	main		<Process>. The current main UI process.
	windows		<LookupTable> of <Integer>. Map of window handles to associated Smalltalk windows (usually <View>s).
	deferredActions	<SharedQueue> of <niladicValuable>. Actions to be processed by the main process when the message loop is empty.
	lastWindow	<window> that last received a message (cached because most likely to receive next message too).
	wakeupEvent	<ExternalHandle> of Win32 Event object signalled by the VM when it wants the image to wake up.

Class Instance Variables:
	maxIdleSleep		<SmallInteger>. Timeout passed to MsgWaitForMultipleObjects[Ex] by idle process.

Class Variables:
	EnumHandlesDescriptor	<ExternalDescriptor>. Callback descriptor for EnumWindows.
	UserInterruptSignal		<Signal>. Exception raised when Ctrl+Break key press detected.
	SamplingInterval		<SmallInteger> interval (measured in full method/blockactivations) between tests of 					system input queue for host system messsages when running background processes.
'!
!InputState class methodsFor!

initialize
	SamplingInterval := 16384.
	EnumHandlesDescriptor := ExternalDescriptor fromString: 'stdcall: dword handle dword'.
	maxIdleSleep := 15000!

maxIdleSleep
	^maxIdleSleep!

maxIdleSleep: aSmallInteger 
	maxIdleSleep := aSmallInteger!

maxIdleSleep9x: aSmallInteger 
	#deprecated.
	Win9xInputState maxIdleSleep: aSmallInteger!

maxIdleSleepNT: aSmallInteger 
	#deprecated.
	self maxIdleSleep: aSmallInteger!

newFromOld: anInputState 
	^((OSVERSIONINFO current isNT ifTrue: [self] ifFalse: [Win9xInputState]) new)
		initializeFrom: anInputState;
		yourself! !
!InputState class categoriesFor: #initialize!development!initializing!public! !
!InputState class categoriesFor: #maxIdleSleep!accessing!public! !
!InputState class categoriesFor: #maxIdleSleep:!accessing!public! !
!InputState class categoriesFor: #maxIdleSleep9x:!accessing!public! !
!InputState class categoriesFor: #maxIdleSleepNT:!accessing!public! !
!InputState class categoriesFor: #newFromOld:!private! !

!InputState methodsFor!

deferredActions
	^deferredActions!

idle
	"Private - Put the VM thread to sleep until there are messages from the host system, or a
	timer fires, to prevent unecessary consumption of host system time. This is called from the
	idle Process."

	"Implementation Note: This implementation is only suitable for platforms that correctly support
	MsgWaitForMultipleObjectsEx() with the MWMO_ALERTABLE flag,"

	MemoryManager current aboutToIdle.
	UserLibrary default 
		msgWaitForMultipleObjectsEx: 1
		pHandles: wakeupEvent
		dwMilliseconds: self class maxIdleSleep
		dwWakeMask: QS_ALLINPUT
		dwFlags: MWMO_ALERTABLE.
	"Rather than use the return value from MsgWaitForMultipleObjectsEx() we call
	GetQueueStatus(). This has the effect of clearing the 'new message' flag so that the next
	call to MsgWaitFor&c will not return immediately if the UI loop is blocked for some reason
	and so is not calling PeekMessage GetMessage (which also clear the flag). This prevents
	short-cycling where the idle process goes into a tight loop calling MsgWaitFor&c when the
	main UI process is put to sleep."
	self isInputAvailable 
		ifTrue: 
			[self ensureMainRunning.
			inputSemaphore set]!

idleLoop
	"Private - Repeatedly perform system idle processing (this is the control loop of the 
	Idler process). This loop is intended for system idle processing only, and should be
	kept simple to avoid instability. Perform user background processing in a background
	process forked for the purpose."

	[Processor activeProcess == idler] whileTrue: [self idle]!

initializeFrom: anInputState 
	"Private - Initialize the receiver's state instance variables."

	anInputState isNil 
		ifTrue: 
			[deferredActions := SharedQueue new.
			windows := LookupTable new]
		ifFalse: 
			[deferredActions := anInputState deferredActions.
			windows := anInputState windows.
			anInputState main: nil.
			anInputState idler kill].
	idleTimer := WeakArray with: DeadObject current.
	self primaryStartup!

isNewInputAvailable
	"Private - Answer whether any new messages have arrived in the Windows message queue 
	since the last time the queue was checked (i.e. since the last call to GetMessage, PeekMessage, 
	or GetQueueStatus)."

	^(UserLibrary default getQueueStatus: QS_ALLINPUT) anyMask: QS_ALLINPUT!

loopWhile: aBlock 
	"Pump messages until the <niladicValuable> argument evaluates to false."

	"Implementation Note: Host system events are processed at a higher priority to deferred
	actions. A single message/action is processed before testing again to see if the loop should 
	be terminated. A single deferred action is processed between each test to see if there are 
	further Windows messages. Generally however the Windows message queue remains empty 
	for long periods, and all deferred messages will be quickly processed. When both queues
	are empty the active process (which should be the UI process) will yield control to lower priority
	processes, in particular the idle process which is responsible for quiescing the whole system."

	| msg activity |
	msg := MSG new.
	activity := false.
	
	[
	[aBlock value ifFalse: [^self].
	self isInputReady: msg] whileTrue: 
				[activity := true.
				self pumpMessage: msg].
	deferredActions nextNoWait 
		ifNil: 
			[self waitForInput: activity.
			activity := false]
		ifNotNil: 
			[:action | 
			activity := true.
			action value]] 
			repeat!

primaryStartup
	"Private - Re-initialize the receiver on session startup."

	self
		createAndRegisterWakeupEvent;
		registerAsDispatcher;
		createAndRegisterInputSemaphore;
		setSamplingInterval.
!

uiIdle
	"Private - Inform the receiver's registered windows that the UI is going idle so that they
	can update visual elements accordingly - e.g. enable/disable toolbar buttons. The windows
	can do other processing from their idle notification handlers, but it should be of very
	short duration, or the responsiveness of the UI will be adversely affected."

	^self topLevelHandlesDo: 
			[:each | 
			self isInputAvailable 
				ifTrue: 
					[self inputSemaphore set.
					false	"stop enumerating"]
				ifFalse: 
					[self uiIdle: each.
					true	"keep enumerating"]]!

waitForInput: aBoolean 
	"Private - The input queues are empty, so quiesce the main process to avoid
	consuming CPU cycles unecessarily, and to provide an opportunity for background
	processes to run. Before putting the main process to sleep (this method should only
	be invoked by the UI process) on the inputSemaphore, various pre-idle activities 
	may be performed before, depending on whether any input has been processed 
	since the UI process last woke up, as indicated by the <boolean> argument."

	aBoolean ifTrue: [self aboutToIdle].
	self inputSemaphore wait! !
!InputState categoriesFor: #deferredActions!accessing!private! !
!InputState categoriesFor: #idle!idling!private! !
!InputState categoriesFor: #idleLoop!idling!private! !
!InputState categoriesFor: #initializeFrom:!initializing!private! !
!InputState categoriesFor: #isNewInputAvailable!private!testing! !
!InputState categoriesFor: #loopWhile:!message dispatching!public! !
!InputState categoriesFor: #primaryStartup!operations-startup!private! !
!InputState categoriesFor: #uiIdle!idling!private! !
!InputState categoriesFor: #waitForInput:!idling!private! !

!Keyboard class methodsFor!

buildVKeyMap
	^(LookupTable new)
		at: 'BACKSPACE' put: VK_BACK;
		at: 'TAB' put: VK_TAB;
		at: 'ENTER' put: VK_RETURN;
		at: 'SHIFT' put: VK_SHIFT;
		at: 'CTRL' put: VK_CONTROL;
		at: 'ALT' put: VK_MENU;
		at: 'PAUSE' put: VK_PAUSE;
		at: 'CAPSLOCK' put: VK_CAPITAL;
		at: 'ESC' put: VK_ESCAPE;
		at: 'SPACE' put: VK_SPACE;
		at: '0' put: $0 codePoint;
		at: '1' put: $1 codePoint;
		at: '2' put: $2 codePoint;
		at: '3' put: $3 codePoint;
		at: '4' put: $4 codePoint;
		at: '5' put: $5 codePoint;
		at: '6' put: $6 codePoint;
		at: '7' put: $7 codePoint;
		at: '8' put: $8 codePoint;
		at: '9' put: $9 codePoint;
		at: 'A' put: $A codePoint;
		at: 'B' put: $B codePoint;
		at: 'C' put: $C codePoint;
		at: 'D' put: $D codePoint;
		at: 'E' put: $E codePoint;
		at: 'F' put: $F codePoint;
		at: 'G' put: $G codePoint;
		at: 'H' put: $H codePoint;
		at: 'I' put: $I codePoint;
		at: 'J' put: $J codePoint;
		at: 'K' put: $K codePoint;
		at: 'L' put: $L codePoint;
		at: 'M' put: $M codePoint;
		at: 'N' put: $N codePoint;
		at: 'O' put: $O codePoint;
		at: 'P' put: $P codePoint;
		at: 'Q' put: $Q codePoint;
		at: 'R' put: $R codePoint;
		at: 'S' put: $S codePoint;
		at: 'T' put: $T codePoint;
		at: 'U' put: $U codePoint;
		at: 'V' put: $V codePoint;
		at: 'W' put: $W codePoint;
		at: 'X' put: $X codePoint;
		at: 'Y' put: $Y codePoint;
		at: 'Z' put: $Z codePoint;
		at: 'NUM 0' put: VK_NUMPAD0;
		at: 'NUM 1' put: VK_NUMPAD1;
		at: 'NUM 2' put: VK_NUMPAD2;
		at: 'NUM 3' put: VK_NUMPAD3;
		at: 'NUM 4' put: VK_NUMPAD4;
		at: 'NUM 5' put: VK_NUMPAD5;
		at: 'NUM 6' put: VK_NUMPAD6;
		at: 'NUM 7' put: VK_NUMPAD7;
		at: 'NUM 8' put: VK_NUMPAD8;
		at: 'NUM 9' put: VK_NUMPAD9;
		at: 'NUMMULT' put: VK_MULTIPLY;
		at: 'NUM PLUS' put: VK_ADD;
		at: 'NUM SUB' put: VK_SUBTRACT;
		at: 'NUM DECIMAL' put: 16r6E;
		at: '/' put: VK_DIVIDE;
		at: 'F1' put: VK_F1;
		at: 'F2' put: VK_F2;
		at: 'F3' put: VK_F3;
		at: 'F4' put: VK_F4;
		at: 'F5' put: VK_F5;
		at: 'F6' put: VK_F6;
		at: 'F7' put: VK_F7;
		at: 'F8' put: VK_F8;
		at: 'F9' put: VK_F9;
		at: 'F10' put: VK_F10;
		at: 'F11' put: VK_F11;
		at: 'F12' put: VK_F12;
		at: '=' put: VK_OEM_PLUS;
		at: ',' put: VK_OEM_COMMA;
		at: '-' put: VK_OEM_MINUS;
		at: '.' put: VK_OEM_PERIOD;
		at: 'NUM ENTER' put: VK_RETURN | 16r100;
		at: 'PGUP' put: VK_PRIOR | 16r100;
		at: 'PGDOWN' put: VK_NEXT | 16r100;
		at: 'END' put: VK_END | 16r100;
		at: 'HOME' put: VK_HOME | 16r100;
		at: 'LEFT' put: VK_LEFT | 16r100;
		at: 'UP' put: VK_UP | 16r100;
		at: 'RIGHT' put: VK_RIGHT | 16r100;
		at: 'DOWN' put: VK_DOWN | 16r100;
		at: 'INSERT' put: VK_INSERT | 16r100;
		at: 'DEL' put: VK_DELETE | 16r100;
		at: 'DELETE' put: VK_DELETE | 16r100;
		shrink!

initialize
	"Private - Initialize the receiver's class variables.
		Keyboard initialize
	"

	VirtualKeys := self buildVKeyMap!

keyNameFromVKey: anInteger ifNone: exceptionHandler 
	"Private - Answer the name of the specified virtual key code,
	or evaluate the exceptionHandler block if none."

	| scanCode |
	scanCode := self vKeyToScanCode: anInteger.
	scanCode == 0 ifTrue: [^exceptionHandler value].
	^(self keyNameFromScanCode: (scanCode bitOr: (anInteger maskClear: 16rFF))) 
		ifNil: [exceptionHandler value]!

virtualKey: aString 
	"Answer the <integer> virtual key code corresponding to the key with
	English name, aString."

	^VirtualKeys at: aString asUppercase
		ifAbsent: [self error: 'Unrecognised virtual key: ''' , aString , '''']! !
!Keyboard class categoriesFor: #buildVKeyMap!**auto generated**!development!private! !
!Keyboard class categoriesFor: #initialize!development!initializing!private! !
!Keyboard class categoriesFor: #keyNameFromVKey:ifNone:!constants!private! !
!Keyboard class categoriesFor: #virtualKey:!constants!public! !

ListViewColumn comment:
'ListViewColumn is a description of a column held by a <ListView>. Note that, columns are only displayed when a list is in #report mode.

Each column is configurable using a number of valuables (usually blocks) which determine how the item objects held by the list are mapped to information to be presented in the column.The first mapping is achieved by the getContentsBlock which, given the list item, determines the object that the column actually represents. How this contents object is then mapped to the displayed text is determined by the getTextBlock. Similarly, the getImageBlock is used to map a contents object to the index of an image to display in the column (the ImageManager that will be used to obtain the actual image is that of the ListView itself). In order to determine how a column will be sorted (an operation that is automatically perform when a column header is clicked) the getSortValueBlock can be set. This takes a contents object and maps it to an appropriate sort value. If it is necessary for a column to display "tip text" then a getInfoTipBlock can be used to specify the mapping between a contents object and this text. Lastly the customDrawBlock can be used to control the appearance for individual column entries. The above blocks are initialized to defaults with the following actions:

getContentsBlock	- use the list item itself (the primary column object).
getTextBlock		- use #displayString on the contents object.
getImageBlock		- do not display images.
getSortValueBlock	- use the contents object itself.
getTipText			- do not display tip text.
customDrawBlock	- nil, no custom draw.

Unlike the other blocks the customDrawBlock is not passed the column element calculated by the getContentsBlock, but instead receives a 
NMLVCUSTOMDRAW instance. This holds the item for the whole row, and can be updated with the foreground and background colours, and any change of font (such as italics or bold) that the ListView control should use to paint the column item.

One other ListViewColumn aspect worthy of note is #isAutoResize. Normally, columns have a fixed width (specified by the #width aspect) and they do not change size if the parent list is resized. This is the standard behaviour of the underlying Windows control. However, by setting #isAutoResize to true, the ListView will treat the column as dynamically re-sizeable. It will attempt to share the width remaining, after all fixed columns have been accounted for, between each of the auto-resizeable columns.

Instance Variables:
	text				<readableString> that is the heading text for the column.
	width			<integer> width of the column in pixels.
	alignment		<Symbol> describing the alignment  (#left, #center, #right) of the text in the column.
	getTextBlock	<monadicValuable> mapping a contents object to a <readableString> to be displayed.
	getSortValueBlock	<monadicValuable> mapping a contents object to an object that can be used as the sort basis for the column.
	getContentsBlock	<monadicValuable> mapping a list item to the column object presented by this column.
	compareBlock	<dyadicValuable> reserved for future use.
	parent			<ListView> holding this column.
	getImageBlock	<monadicValuable>or nil, mapping a contents object to an image index.
	isAutoResize	<boolean> indicating whether the column should dynamically resize to fill available space.
	getInfoTipBlock	<monadicValuable> mapping a content object to a <readableString> for the column''s tip text.
	customDrawBlock <monadicValuable> evaluated to customise the appearance of individual column entries.'!
!ListViewColumn methodsFor!

snoopDescription
	"Answer a description of the receiver for the snoop tree"

	#idbAdded.
	^self snoopDescription: self text!

snoopSecond
	"Answer any items (name and value) that snoop should disply for the receiver"

	#idbAdded.
	^(super snoopSecond)
		add: 'Parent' -> self parent;
		add: 'Title' -> self text;
		add: 'Width' -> self width;
		add: 'Alignment' -> self alignment;
		add: 'Auto Resize' -> self isAutoResize;
		add: 'Get Text Block' -> self getTextBlock;
		add: 'Get Image Block' -> self getImageBlock;
		add: 'Get Info Tip Block' -> self getInfoTipBlock;
		add: 'Get Contents Block' -> self getContentsBlock;
		add: 'Sort Block' -> self sortBlock;
		add: 'Custom Draw Block' -> self customDrawBlock;
		yourself!

width
	"Answer the real width of the column in pixels."

	| view |
	view := self parent.
	^(view notNil and: [view isOpen and: [view isReportMode]]) 
		ifTrue: [view lvmGetColumnWidth: self index - 1]
		ifFalse: [self basicWidth]!

width: anInteger 
	"Set the width of the column to the specified <integer> number of pixels.
	N.B. This may cause the width of other (auto-resizable) columns to change."

	self basicWidth: anInteger.
	self parent ifNotNil: [:view | view setWidthOfColumn: self index to: anInteger]! !
!ListViewColumn categoriesFor: #snoopDescription!displaying!idb goodies!public! !
!ListViewColumn categoriesFor: #snoopSecond!accessing!idb goodies!public! !
!ListViewColumn categoriesFor: #width!accessing!public! !
!ListViewColumn categoriesFor: #width:!accessing!public! !

!MessageBox methodsFor!

basicOpen
	"Private - Display the receiver, and answer the Win32 Id of the button pressed by the user."

	| lib wasDisabled hWnd |
	lib := UserLibrary default.
	struct owner isNil 
		ifTrue: 
			["Get close to the metal in case there is no active window or the View system 
			is in a perilous state, or we wan't it to be removed from the deployed app."
			struct owner: lib getActiveWindow].
	struct caption isNil ifTrue: [struct caption: self defaultCaption].
	self isTaskModal 
		ifTrue: 
			["If taskModal, then the owner will be the desktop so we need to get actual active view"
			hWnd := lib getActiveWindow.
			"Ensure owner is (temporarily) enabled to prevent losing activation when box is closed"
			(wasDisabled := (lib isWindowEnabled: hWnd) not) 
				ifTrue: [lib enableWindow: hWnd bEnable: true].
			button := 
					[SessionManager inputState startIdleTimer: hWnd.
					"Task modal only disables windows in the calling thread, so we can't use an
					overlapped call here."
					lib messageBoxIndirect: struct] 
							ensure: [SessionManager inputState stopIdleTimer: hWnd]]
		ifFalse: 
			[hWnd := struct owner asParameter.
			wasDisabled := (lib isWindowEnabled: hWnd) not.
			"MessageBoxIndirect is called using an overlapped call on a separate thread to avoid
			losing control of the message loop. If the initiating process is the UI process then its
			priority is boosted so that the operation requested by the user completes more quickly 
			when the dialog is closed."
			Processor forkMainIfMain 
				ifTrue: 
					[| proc |
					proc := Processor activeProcess.
					proc priority: proc priority + 1].
			button := lib overlappedMsgBoxIndirect: struct].

	"The message box will unhelpfully re-enable the window regardless of whether previously disabled"
	wasDisabled ifTrue: [lib enableWindow: hWnd bEnable: false].
	button == 0 ifTrue: [lib systemError].
	^button! !
!MessageBox categoriesFor: #basicOpen!displaying!private! !

NewsArchive comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!NewsArchive methodsFor!

allSelected
	^self articles select: [:each | each isSelected]!

articles
	articles isNil ifTrue: [Cursor wait showWhile: [self loadArticles]].
	^articles!

articlesInConversation: aNewsArchiveArticle
	^self articles select: [:each | each isInConversation: aNewsArchiveArticle]!

copySelectedTo: aStream
	self allSelected do: [:each | each copyTo: aStream]!

countArticles
	^self articles size!

hasAnySelected
	^self articles anySatisfy: [:each | each isSelected]!

loadArticles
	| filenames |
	articles := OrderedCollection new.
	filenames := OrderedCollection new.
	[File
		for: (File composePath: NewsArchiveBrowser archiveFolder subPath: '*.txt')
		do:
			[:each | filenames add: (File composePath: NewsArchiveBrowser archiveFolder subPath: each fileName)]]
		on: Win32Error
		do:
			[:e | ^MessageBox warning: 'The specified folder does not exist (see Tools/Options)'].
	self trigger: #percentageLoaded: with: 0.
	filenames asSortedCollection
		keysAndValuesDo:
			[:index :each | 
			self readArticlesFromFile: each.	"Transcript nextPutAll: each; tab; print: articles size; cr."
			self trigger: #percentageLoaded: with: index / filenames size * 100].
	self trigger: #percentageLoaded: with: 0!

readArticleIn: aString from: startInteger to: stopInteger skip: skipInteger
	| start |
	start := startInteger = 1 ifTrue: [1] ifFalse: [startInteger + skipInteger].
	^NewsArchiveArticle forString: (aString copyFrom: start to: stopInteger)!

readArticlesFromFile: aString
	| stream |
	stream := FileStream read: aString.
	[self readArticlesFromStream: stream] ensure: [stream close]!

readArticlesFromStream: aStream
	| text start delimiter |
	text := aStream contents.
	delimiter := ##(String lineDelimiter , '----------' , String lineDelimiter , 'From: ').
	start := 1.
	[start < text size]
		whileTrue:
			[| stop |
			stop := text indexOfSubCollection: delimiter startingAt: start + 1.
			stop = 0 ifTrue: [stop := text size + 1].
			articles
				add:
					(self
						readArticleIn: text
						from: start
						to: stop - 1
						skip: delimiter size - 6).	"From: "
			start := stop]! !
!NewsArchive categoriesFor: #allSelected!accessing!public! !
!NewsArchive categoriesFor: #articles!accessing!public! !
!NewsArchive categoriesFor: #articlesInConversation:!public!selection! !
!NewsArchive categoriesFor: #copySelectedTo:!operations!public! !
!NewsArchive categoriesFor: #countArticles!accessing!public! !
!NewsArchive categoriesFor: #hasAnySelected!public!testing! !
!NewsArchive categoriesFor: #loadArticles!operations!public! !
!NewsArchive categoriesFor: #readArticleIn:from:to:skip:!operations!public! !
!NewsArchive categoriesFor: #readArticlesFromFile:!operations!public! !
!NewsArchive categoriesFor: #readArticlesFromStream:!operations!public! !

NewsArchiveArticle comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!NewsArchiveArticle class methodsFor!

forString: aString
	^self new forString: aString! !
!NewsArchiveArticle class categoriesFor: #forString:!instance creation!public! !

!NewsArchiveArticle methodsFor!

conversation
	self isParsed ifFalse: [self parse].
	^conversation!

copyTo: aStream
	aStream
		nextPutAll: '~-~-~-~-~-~';
		cr;
		nextPutAll: 'From: ';
		nextPutAll: self from;
		cr;
		nextPutAll: 'Sent: ';
		print: self sent;
		cr;
		nextPutAll: 'Subject: ';
		nextPutAll: self subject;
		cr;
		cr;
		nextPutAll: self text;
		cr!

forString: aString
	raw := aString.
	isSelected := false!

from
	self isParsed ifFalse: [self parse].
	^from!

getHeadingFrom: aString
	"Parse the header information
	Note: written for speed - not peer review"

	| type |
	type := aString copyFrom: 1 to: 4.
	type = 'From' ifTrue: [^self setFrom: aString].
	type = 'Sent' ifTrue: [^self setSent: aString].
	type = 'Subj' ifTrue: [^self setSubject: aString	"ignore any others"]!

icon
	"Answer self as the ListView will then send #imageIndex to this instance
	 and we can answer the appropriate icon index"

	^self!

imageIndex
	"see #icon"

	^isSelected ifTrue: [Model icon imageIndex] ifFalse: [0]!

isInConversation: aNewsArchiveArticle
	self isParsed ifFalse: [self parse].
	^conversation = aNewsArchiveArticle conversation!

isParsed
	^raw isNil!

isSelected
	^isSelected!

parse
	"Strip and parse any header lines from the article. Whats left is the text
	Note: written for speed - not peer review"

	| begin end line |
	subject := 'No subject'.
	begin := 1.
	[line := raw
		copyFrom: begin
		to: (end := raw indexOfSubCollection: String lineDelimiter startingAt: begin) - 1.
	begin := end + String lineDelimiter size.
	line notEmpty] whileTrue: [self getHeadingFrom: line].
	text := raw copyFrom: begin to: raw size.
	self assert: [from notNil & sent notNil & subject notNil].
	raw := nil!

searchFromFor: aString
	self isParsed ifFalse: [self parse].
	^(from asLowercase indexOfSubCollection: aString) ~= 0!

searchSubjectFor: aString
	self isParsed ifFalse: [self parse].
	^(subject asLowercase indexOfSubCollection: aString) ~= 0!

searchTextFor: aString
	self isParsed ifFalse: [self parse].
	^(text asLowercase indexOfSubCollection: aString) ~= 0!

select
	isSelected := true!

sent
	self isParsed ifFalse: [self parse].
	^sent!

setFrom: aString
	from := aString copyFrom: 8!

setSent: aString
	"aString is always in the format
		dd MMM yyyy hh:mm
	and uses English month names -  thats the format used when I create the archive. 
	The users locale might be different  so we can't use built in functions. 
	Note: written for speed - not peer review 
	No error checking!!
	** This is a bottleneck so edit with caution **"

	| dayOfMonth m1 monthIndex yearStart year hour minute |
	dayOfMonth := ((aString at: 8) asciiValue - 48) * 10 + (aString at: 9) asciiValue - 48.
	m1 := aString at: 11.
	monthIndex := m1 = $J
		ifTrue:
			[| m4 |
			(m4 := aString at: 14) = $u ifTrue: [1] ifFalse: [m4 = $e ifTrue: [6] ifFalse: [7]]]
		ifFalse:
			[m1 = $M
				ifTrue: [(aString at: 13) = $r ifTrue: [3] ifFalse: [5]]
				ifFalse:
					[m1 = $A
						ifTrue: [(aString at: 12) = $p ifTrue: [4] ifFalse: [8]]
						ifFalse:
							[m1 = $F
								ifTrue: [2]
								ifFalse:
									[m1 = $S
										ifTrue: [9]
										ifFalse: [m1 = $O ifTrue: [10] ifFalse: [m1 = $N ifTrue: [11] ifFalse: [12]]]]]]].
	yearStart := (#[7 8 5 5 3 4 4 6 9 7 8 8] at: monthIndex) + 11 + 1.
	year := ((aString at: yearStart) asciiValue - 48) * 1000
		+ (((aString at: yearStart + 1) asciiValue - 48) * 100)
		+ (((aString at: yearStart + 2) asciiValue - 48) * 10)
		+ (aString at: yearStart + 3) asciiValue - 48.
	hour := ((aString at: yearStart + 5) asciiValue - 48) * 10
		+ (aString at: yearStart + 6) asciiValue - 48.
	minute := ((aString at: yearStart + 8) asciiValue - 48) * 10
		+ (aString at: yearStart + 9) asciiValue - 48.
	sent := TimeStamp
		date:
			(Date
				newDay: dayOfMonth
				monthIndex: monthIndex
				year: year)
		time: (Time fromSeconds: hour * 3600 + (minute * 60))!

setSubject: aString
	subject := aString copyFrom: 11.
	conversation := (subject size > 4 and: [subject beginsWith: 'Re: '])
		ifTrue: [(subject copyFrom: 5) trimBlanks]
		ifFalse: [subject trimBlanks]!

subject
	self isParsed ifFalse: [self parse].
	^subject!

text
	self isParsed ifFalse: [self parse].
	^text!

toggleSelection
	isSelected := isSelected not!

unSelect
	isSelected := false! !
!NewsArchiveArticle categoriesFor: #conversation!accessing!public! !
!NewsArchiveArticle categoriesFor: #copyTo:!operations!public! !
!NewsArchiveArticle categoriesFor: #forString:!initializing!public! !
!NewsArchiveArticle categoriesFor: #from!accessing!public! !
!NewsArchiveArticle categoriesFor: #getHeadingFrom:!helpers!public! !
!NewsArchiveArticle categoriesFor: #icon!accessing!public! !
!NewsArchiveArticle categoriesFor: #imageIndex!accessing!public! !
!NewsArchiveArticle categoriesFor: #isInConversation:!public!testing! !
!NewsArchiveArticle categoriesFor: #isParsed!public!testing! !
!NewsArchiveArticle categoriesFor: #isSelected!public!testing! !
!NewsArchiveArticle categoriesFor: #parse!initializing!public! !
!NewsArchiveArticle categoriesFor: #searchFromFor:!operations!public! !
!NewsArchiveArticle categoriesFor: #searchSubjectFor:!operations!public! !
!NewsArchiveArticle categoriesFor: #searchTextFor:!operations!public! !
!NewsArchiveArticle categoriesFor: #select!operations!public! !
!NewsArchiveArticle categoriesFor: #sent!accessing!public! !
!NewsArchiveArticle categoriesFor: #setFrom:!initializing!public! !
!NewsArchiveArticle categoriesFor: #setSent:!initializing!public! !
!NewsArchiveArticle categoriesFor: #setSubject:!initializing!public! !
!NewsArchiveArticle categoriesFor: #subject!accessing!public! !
!NewsArchiveArticle categoriesFor: #text!accessing!public! !
!NewsArchiveArticle categoriesFor: #toggleSelection!operations!public! !
!NewsArchiveArticle categoriesFor: #unSelect!operations!public! !

!OAIDEExtensions class methodsFor!

initialize
	"
		self initialize
	"

	self observeToolEvents!

nonClassBrowserTools
	^self allToolClasses difference: self classBrowserClasses!

observeBrowserClass: aClassBrowserClass 
	aClassBrowserClass 
		when: #viewOpened:
		send: #onBrowserOpened:
		to: self!

observeSystemEvents
	Smalltalk developmentSystem 
		when: #classAdded:
		send: #onClassAdded:
		to: self!

observeToolClass: aSmalltalkToolShellClass 
	aSmalltalkToolShellClass 
		when: #viewOpened:
		send: #onToolOpened:
		to: self!

observeToolEvents
	self observeSystemEvents.
	self classBrowserClasses do: [:each | self observeBrowserClass: each].
	self nonClassBrowserTools do: [:each | self observeToolClass: each]!

onBrowserOpened: aClassBrowserAbstract 
	self extendClassCommentMenu: aClassBrowserAbstract.
	self onToolOpened: aClassBrowserAbstract!

onClassAdded: aClass 
	(aClass inheritsFrom: SmalltalkToolShell) 
		ifTrue: 
			[(aClass inheritsFrom: ClassBrowserAbstract) 
				ifTrue: [self observeBrowserClass: aClass]
				ifFalse: [self observeToolClass: aClass]]!

onToolOpened: aSmalltalkToolShell
	self extendHelpMenu: aSmalltalkToolShell! !
!OAIDEExtensions class categoriesFor: #initialize!initializing!private! !
!OAIDEExtensions class categoriesFor: #nonClassBrowserTools!constants!public! !
!OAIDEExtensions class categoriesFor: #observeBrowserClass:!initializing!private! !
!OAIDEExtensions class categoriesFor: #observeSystemEvents!initializing!private! !
!OAIDEExtensions class categoriesFor: #observeToolClass:!initializing!private! !
!OAIDEExtensions class categoriesFor: #observeToolEvents!initializing!private! !
!OAIDEExtensions class categoriesFor: #onBrowserOpened:!event handling!private! !
!OAIDEExtensions class categoriesFor: #onClassAdded:!event handling!private! !
!OAIDEExtensions class categoriesFor: #onToolOpened:!event handling!private! !

!Package class methodsFor!

initialize
	"Private - Initialize the receiver's class variables.
		Package initialize
	"

	_Uncommitted := (self basicNew)
				initialize;
				packagePathname: '<Unpackaged>';
				yourself.
	ClashSignal := Signal resumableDescription: 'Package contents clash'.
	UnsaveableSignal := Signal description: 'Package cannot be saved'.
	"This dictionary is used for loading binary legacy (pre 4.0) packages only"
	VersionLookup := (LookupTable new)
				at: 1 put: #loadVersion1:filer:;
				at: 2 put: #loadVersion2:filer:;
				at: 3 put: #loadVersion3:filer:;
				at: 4 put: #loadVersion4:filer:;
				at: 5 put: #loadVersion5:filer:;
				shrink;
				yourself	"same format as 4, except VM version loaded here".
	CheckTimestamps := true! !
!Package class categoriesFor: #initialize!initializing!private! !

!Package methodsFor!

checkTimestamps
	"Compare the timestamp cached when the package was installed against the timestamp of the
	package file. If the package file has been modified since the package was loaded, then warn
	the user to avoid inadvertent overwrites of later package versions causing loss of changes."

	CheckTimestamps ifFalse: [^self].
	self isRenegade 
		ifTrue: 
			[Warning 
				signal: ('The package ''%1'' has been modified outside this image since it was loaded or last saved. If you proceed and save it from this image then you may lose changes that have been made in another image. It is recommended that before proceeding you first take a backup copy of the current version on disk, or that you abort this operation.' 
						formatWith: self name)]!

fileModificationTime
	"Private - Answer the modification time of the receiver's package file on disk as the
	<integer> number of 100-nanosecond intervals since 12:00 A.M. January 1, 1601 UTC (i.e. a
	Win32 FILETIME), or 0 if it does not currently exist."

	| fileName |
	fileName := self isSystemPackage 
				ifTrue: [self classDefinitionsFileName]
				ifFalse: [self isUsingPAX ifTrue: [self fileOutName] ifFalse: [self packageFileName]].
	^(File lastWriteTime: fileName) ifNil: [0] ifNotNil: [:filetime | filetime asInteger]!

fileOut
	"Private - File out a definition of the receiver to source files. Normally this
	involves saving a PAX file except in the case where the receiver is a system package
	when separate class and resource definitions files are saved instead."

	self isSystemPackage 
		ifFalse: 
			[self
				savePAC;
				savePAX]
		ifTrue: [self fileOutBootDefinitions].
	timestamp := self fileModificationTime.
	self isChanged: false!

fileOutAll
	"Fileout the receiver to a PAX file and all out it's associated source files.
	The .PAC file is also saved when the .PAX is created in order to ensure that
	the two remain in sync."

	self allSourceObjectsDo: [:each | each fileOut]!

fileOutAllOn: aSourceFiler 
	self fileOutOn: aSourceFiler.
	self
		fileOutSourceGlobalsOn: aSourceFiler;
		fileOutClassesOn: aSourceFiler;
		fileOutBinaryGlobalsOn: aSourceFiler;
		fileOutResourcesOn: aSourceFiler!

imageStripper: anImageStripper 
	"Set the image stripper for the receiver to anImageStripper. 
	Since we have to be able to load the receiver into images that do no necessarily 
	have the ImageStripper class installed, we hold the stripper as a binary filed out ByteArray 
	in imageStripperBytes"

	| newBytes |
	newBytes := anImageStripper binaryStoreBytes.
	imageStripperBytes = newBytes ifTrue: [^self].
	self imageStripperBytes: newBytes.
	self ownedUpdated!

initialize
	"Private - Initialize the state of the receiver."

	methodNames := PluggableSet searchPolicy: AssociationSearchPolicy current.
	resourceNames := PluggableSet searchPolicy: AssociationSearchPolicy current.
	classNames := IdentitySet new.
	globalNames := IdentitySet new.
	scripts := IdentityDictionary new.
	comment := ''.
	timestamp := 0!

isRenegade
	"Answer whether the receiver was loaded (or last saved) before its source representation in the file system.
	An example of where a package might be a renegade is if it has been modified and saved from another image."

	| lastWriteTime |
	lastWriteTime := self fileModificationTime.
	^lastWriteTime > timestamp!

isUsingPAX
	"Answer true if the receiver is using PAX mode. If a PAX file of the same name as the
	receiver exists on disk then both PAC and PAX files are saved simultaneously."

	^self isSystemPackage or: [File exists: self fileOutName]!

load
	"Private - Load all the objects owned by the receiver. This assumes that all prerequisite
	packages are currently loaded in."

	((File splitExtensionFrom: self packageFileName) 
		sameAs: self class sourcePackageExtension) ifTrue: [self loadPAX] ifFalse: [self loadPAC].
	self removePAXProperties.
	self synchronizeNames.
	self upateFileNames!

loadPAC
	"Private - Load all the objects owned by the receiver. This assumes that all prerequisite
	packages are currently loaded."

	| filename stream |
	filename := self packageFileName.
	Notification signal: ('Loading package ''%1'' from: %2' formatWith: self name with: filename).
	stream := FileStream read: filename text: false.
	timestamp := stream file lastWriteTime asInteger.
	
	[(STBFiler peekForSignatureIn: stream) 
		ifTrue: 
			[stream reset.
			self loadLegacyPAC: stream]
		ifFalse: 
			[stream beText.
			self loadPAC: stream]] 
			ensure: [stream close]!

loadPAX
	"Private - Load all the objects owned by the receiver. This assumes that all prerequisite
	packages are currently loaded in."

	| filename filer stream |
	filename := self packageFileName.
	Notification 
		signal: ('Loading source package ''%1'' from: %2' formatWith: self name with: filename).
	stream := FileStream read: filename.
	timestamp := stream file lastWriteTime asInteger.
	filer := ChunkSourceFiler on: stream.
	
	[| pax |
	pax := filer nextChunk.	"Skip the first chunk since it represents the receiver."
	self fileInScript: #preinstall.

	"Define any globals that might be referenced from source code, but don't load them as yet as they
		 may be instances of one of the classes in the package."
	self declareGlobals.

	"Load source globals"
	self globalNames - (self propertyAt: #binaryGlobalNames ifAbsent: [#()]) 
		- (self propertyAt: #globalAliases ifAbsent: [#()]) 
			do: [:each | self sourceManager fileIn: (self fileNameForSourceGlobal: each)].

	"Load class definitions, aliases, and loose methods from the remainder of the PAX file"
	filer fileIn.
	self fileInClasses.
	self loadBinaryGlobals.
	self initializeGlobals.
	self loadResources.
	self fileInScript: #postinstall] 
			ensure: [filer close]!

packagePathname: aString 
	"Private - Set the receiver's path and name."

	| oldname |
	packagePathname := aString.
	"The name can no longer be independent of the file name, and is in fact just cached from the file stem"
	oldname := name.
	name := File splitStemFrom: aString.
	(oldname isNil or: [oldname sameAs: name]) ifTrue: [^self].
	self isChanged: true.
	"If a package is renamed, then the dependent packages need to be resaved to update their pre-requisite information"
	self dependentPackages do: [:each | each isChanged: true]!

save
	"Save the receiver to a single PAC file. This includes all of the source for the receiver's contents.
	If the receiver is operating in PAX source mode then all of the source files are also
	filed out, including a .PAX definition. Answer whether the package was actually saved.
	This is the implementation behind the Package Browser's 'Save' command."

	self isUsingPAX ifTrue: [self fileOutAll] ifFalse: [self saveSingleFilePackage].
	^true!

saveChanges
	"Save the receiver, if changed. This includes all of the source for the receiver's contents.
	If the receiver is operating in PAX source mode then all of the changed source files are
	also filed out. including a .PAX definition. Answer whether the package was actually saved.
	This is the implementation behind the Package Browser's 'Save Changes' command."

	self isChanged ifFalse: [^self].
	self isUsingPAX 
		ifTrue: 
			[self fileOutAllChanged.
			self isChanged: false]
		ifFalse: [self saveSingleFilePackage]!

savePAC
	"Private - File out a definition of the receiver and all the objects it owns to a single	
	text .PAC file. Any binary objects (views, non-<sourceObject> globals) are saved
	as the printed representation of their STB'd binary store bytes."

	| filer |
	self okToSaveOrDeploy.
	self checkTimestamps.
	self createPackagePath.
	self manager trigger: #aboutToSave: with: self.
	filer := self sourceManager sourceFilerOn: (FileStream 
						write: (File path: self packageFileName extension: self class packageExtension)).
	[self fileOutAllOn: filer] ensure: [filer close]!

savePACBackupTo: aFolderName
	| pathname |
	#idbAdded.
	(File exists: self packageFileName)
		ifTrue:
			[File createDirectory: aFolderName.
			pathname := File
				composePath: aFolderName
				stem:
					(File splitStemFrom: self packageFileName) , ' ' , Time now asMilliseconds printString
				extension: self class packageExtension.
			File copy: self packageFileName to: pathname]!

savePAX
	"Private - File out a definition of the receiver to a .PAX source file. This does not file
	out the source files of the receiver's contents."

	"Implementation Note: All fileouts use case sensitive collation in order to avoid problem of order
	switches for same named identifiers with different case, which can cause a line-based source
	management system to detect a change where there isn't one."

	| filer |
	self createPackagePath.
	filer := self sourceManager sourceFilerOn: (FileStream write: self fileOutName).
	[self fileOutOn: filer] ensure: [filer close].

	"We must also file out the binary globals at this stage, as they are not <sourceObject>s."
	self fileOutBinaryGlobals!

savePAXAboutBlockOn: stream 
	aboutBlock isNil ifTrue: [^self].
	stream nextPutAll: 'package aboutBlockBytes: '.
	aboutBlock binaryStoreBytes base64StoreOn: stream.
	stream
		nextPut: $.;
		cr!

savePAXStripperBytesOn: stream 
	"Private - File out the PAX source file representation of the receiver's 
	image stripper bytes (if any) onto the <puttableStream>, target."

	imageStripperBytes isNil ifTrue: [^self].
	stream nextPutAll: 'package imageStripperBytes: '.
	imageStripperBytes base64StoreOn: stream.
	stream
		nextPut: $.;
		cr!

saveSingleFilePackage
	"Save the receiver and all owned objects to a single .PAC file.
	The complementary message to save a multi-file package is #fileOutAll."

	self savePAC.
	timestamp := self fileModificationTime.
	self resetChangeFlags!

synchronizeNames
	"Private - Classes in the package may have been renamed (or otherwise refactored) and 
	aliased over, so we want to sync.up to the current names."

	| names |
	names := methodNames copyEmpty.
	self methods do: [:each | names add: (self nameForMethod: each)].
	methodNames := names!

timestamp
	"Answer a <FILETIME> that represents the last write time of the receiver (i.e. the
	modification time of the file from which the package was loaded, or the time when the
	package was last saved) expressed as the number of 100-nanosecond intervals since 12:00 A.M.
	January 1, 1601 UTC. The <integer> value of the FILETIME will be 0 if the package is new and
	has not been written to disk."

	^FILETIME fromInteger: timestamp!

tracePrerequisites: anIdentityDictionary 
	"Private - Answer an <IdentityDictionary> of prerequisite package keys against an
	<OrderedCollection> of traces of the owned objects which forced a prerequisite link and the
	reason why. The argument is an <IdentityDictionary>, the keys of which are# the names of all
	packaged globals, with the associated values being the owning <Package> of the global.

	1	from	The owned object of the receiver
	2	to		The object belonging to a prerequsite package which from references
	3	reason	String description of how from references to.

	There are quite a few reasons for a prequisite being generated:

	*	'from' is a Class which is a subclass of the Class 'to'.
	*	'from' is a directly owned CompiledMethod which is a method of the Class 'to'.
	*	'from' is a directly owned ResourceIdentifier belonging to the Class 'to'.
	*	'from' is a CompiledMethod which references the global object 'to'.
	*	'from' is a Class whose shared pools includes the global object 'to'.
	*	'from' is a global that aliases the class 'to'
	*	'from' is a global that references an instance of the class 'to'."

	| trace |
	trace := IdentityDictionary new.
	self
		tracePrerequisitesOfClasses: trace packagedGlobals: anIdentityDictionary;
		tracePrerequisitesOfMethods: trace;
		tracePrerequisitesOfResources: trace;
		tracePrerequisitesOfImageStripper: trace;
		tracePrerequisiteGlobals: trace packagedGlobals: anIdentityDictionary.
	^trace!

tracePrerequisitesOfImageStripper: anIdentityDictionary 
	| stream hiddenObjects |
	"Only possible to trace the stripper prereqs in DPRO"
	(imageStripperBytes isNil or: [(self environment includesKey: #ImageStripper) not]) ifTrue: [^self].
	stream := imageStripperBytes readStream.
	hiddenObjects := 
			[(STBInFiler on: stream)
				basicNext;
				readMap] ensure: [stream close].
	hiddenObjects do: 
			[:each | 
			each class isMeta 
				ifTrue: 
					[self 
						trace: anIdentityDictionary
						prerequisite: each owningPackage
						from: self
						to: each
						type: 'references class']]!

updateTimestamp
	"Private - Synchronise the receiver's timestamp with its source file."

	timestamp := self fileModificationTime! !
!Package categoriesFor: #checkTimestamps!helpers!private! !
!Package categoriesFor: #fileModificationTime!helpers!private! !
!Package categoriesFor: #fileOut!private!source filing! !
!Package categoriesFor: #fileOutAll!public!source filing! !
!Package categoriesFor: #fileOutAllOn:!public!source filing! !
!Package categoriesFor: #imageStripper:!accessing!public! !
!Package categoriesFor: #initialize!initializing!private! !
!Package categoriesFor: #isRenegade!public!testing! !
!Package categoriesFor: #isUsingPAX!public!testing! !
!Package categoriesFor: #load!operations!private! !
!Package categoriesFor: #loadPAC!helpers!private! !
!Package categoriesFor: #loadPAX!private!source filing-pax! !
!Package categoriesFor: #packagePathname:!accessing!private! !
!Package categoriesFor: #save!operations!public! !
!Package categoriesFor: #saveChanges!operations!public! !
!Package categoriesFor: #savePAC!private!source filing! !
!Package categoriesFor: #savePACBackupTo:!helpers!idb goodies!public! !
!Package categoriesFor: #savePAX!private!source filing-pax! !
!Package categoriesFor: #savePAXAboutBlockOn:!private!source filing-pax! !
!Package categoriesFor: #savePAXStripperBytesOn:!private!source filing-pax! !
!Package categoriesFor: #saveSingleFilePackage!public!source filing! !
!Package categoriesFor: #synchronizeNames!helpers!private! !
!Package categoriesFor: #timestamp!accessing!public! !
!Package categoriesFor: #tracePrerequisites:!operations!private! !
!Package categoriesFor: #tracePrerequisitesOfImageStripper:!operations!private! !
!Package categoriesFor: #updateTimestamp!helpers!private! !

PackageBackup comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!PackageBackup class methodsFor!

backupFolder
	BackupFolder ifNil: [BackupFolder := self defaultBackupFolder].
	^BackupFolder!

backupFolder: anObject
	BackupFolder := anObject!

defaultBackupFolder
	^FileLocator imageRelative localFileSpecFor: 'Package backups'!

onAboutToSavePackage: aPackage
	aPackage savePACBackupTo: self backupFolder! !
!PackageBackup class categoriesFor: #backupFolder!accessing!public! !
!PackageBackup class categoriesFor: #backupFolder:!accessing!public! !
!PackageBackup class categoriesFor: #defaultBackupFolder!accessing!public! !
!PackageBackup class categoriesFor: #onAboutToSavePackage:!event handling!public! !

!PackageManager class methodsFor!

publishedEventsOfInstances
	"Answer a <Set> of <Symbol>s being the names of the events published by
    	instances of the receiver."

	^(super publishedEventsOfInstances)
		add: #loadedChanged;
		add: #prerequisitesReset;
		add: #prerequisitesReset:;
		add: #packageChanged:;
		add: #ownedChanged:;
		add: #classRepackaged:from:to:;
		add: #methodRepackaged:from:to:;
		add: #resourceRepackaged:from:to:;
		add: #globalRepackaged:from:to:;
		add: #aboutToSave:;
		yourself! !
!PackageManager class categoriesFor: #publishedEventsOfInstances!development!events!public! !

!Presenter class methodsFor!

snoop
	"Open up a Snoop shell with the receivers view as the snoopee.
	Do it in this order to ensure that the snooper is on top of the snoopee"

	| shell |
	#idbAdded.
	shell := self show.
	Snoop show snoopOn: shell! !
!Presenter class categoriesFor: #snoop!idb goodies!operations!public! !

!Presenter methodsFor!

snoopChildren
	"Answer a collection containing any children of the receiver that should 
	appear in the snoop tree"

	#idbAdded.
	^subPresenters!

snoopDescription
	"Answer a description of the receiver for the snoop tree"

	#idbAdded.
	^self
		snoopDescription:
			(self parentPresenter isNil ifFalse: [self parentPresenter nameOf: self])!

snoopFirst
	"Answer any items (name and value) that snoop should display for the receiver"

	#idbAdded.
	^(super snoopFirst)
		add: 'Model' -> self model;
		add: 'View' -> self view;
		yourself! !
!Presenter categoriesFor: #snoopChildren!accessing!idb goodies!public! !
!Presenter categoriesFor: #snoopDescription!displaying!idb goodies!public! !
!Presenter categoriesFor: #snoopFirst!accessing!idb goodies!public! !

Profiler comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!Profiler class methodsFor!

default
	"Private - Answer the singleton instance of this class"

	Default isNil ifTrue: [Default := super new initialize].
	^Default!

new
	"Private - Use default to get the Singleton instance"

	^self shouldNotImplement!

openBrowser
	"Open up an ProfileBrowser on the singleton instance of the profiler.
	Multiple browsers can be opened if required"

	ProfileBrowser showOn: self default!

profile: aBlock
	"Profile aBlock, saving the samples in the default sample set after clearing any previous
	samples stored in the default sample set.
	Answers the answer returned by the aBlock when it is evaluated"

	^self profile: aBlock inSetNamed: ProfilerSampleSetManager defaultSetName!

profile: aBlock inSetNamed: aString
	"Profile aBlock, saving the samples in the a sample set named aString after clearing any
	previous samples stored in the this sample set.
	Answers the answer returned by the aBlock when it is evaluated"

	^self
		profile: aBlock
		inSetNamed: aString
		collect: false!

profile: aBlock inSetNamed: aString collect: aBoolean
	"Profile aBlock, saving the samples in the a sample set named aString. If aBoolean is true
	the new samples are added to any samples already existing in the sample set.
	Answers the answer returned by the aBlock when it is evaluated"

	^self
		profile: aBlock
		inSetNamed: aString
		collect: aBoolean
		on: true!

profile: aBlock inSetNamed: aString collect: collectBoolean on: onBoolean
	"Profile aBlock, saving the samples in the a sample set named aString. If collectBoolean is true
	the new samples are added to any samples already existing in the sample set. If onBoolean
	is true then the taking of samples start immediately, otherwise no samples are taken until a
	Profiler profilingOn instruction is executed.	
	Answers the answer returned by the aBlock when it is evaluated"

	^self default
		profile: aBlock
		inSetNamed: aString
		collect: collectBoolean
		on: onBoolean!

removeAllSampleSets
	"Remove all the sample sets"

	ProfilerSampleSetManager default removeAll!

removeSampleSetNamed: aString
	"Remove the sample set named aString"

	^ProfilerSampleSetManager removeSampleSetNamed: aString!

reset
	"Reset the singleton instance so that it will be reinitialized. Should only need to be 
	used when the profiler package is uninstalled - but you never know"

	Default := nil!

samplingInterval: anInteger
	"Set the sampling interval, the delay between samples being taken, to anInteger"

	self default samplingInterval: anInteger!

startSampling
	"Tells the profiler to satrt taking samples and to continue until either the processed 
	block terminates or a stopSampling instruction is executed"

	self default startSampling!

stopSampling
	"Tells the profiler to stop taking samples until a startSampling instruction is executed"

	self default stopSampling! !
!Profiler class categoriesFor: #default!instance creation!public! !
!Profiler class categoriesFor: #new!instance creation!protocols-instantiator!protocols-Object class!public! !
!Profiler class categoriesFor: #openBrowser!operations!public! !
!Profiler class categoriesFor: #profile:!operations!public! !
!Profiler class categoriesFor: #profile:inSetNamed:!operations!public! !
!Profiler class categoriesFor: #profile:inSetNamed:collect:!operations!public! !
!Profiler class categoriesFor: #profile:inSetNamed:collect:on:!operations!public! !
!Profiler class categoriesFor: #removeAllSampleSets!operations!public! !
!Profiler class categoriesFor: #removeSampleSetNamed:!operations!public! !
!Profiler class categoriesFor: #reset!operations!public! !
!Profiler class categoriesFor: #samplingInterval:!operations!public! !
!Profiler class categoriesFor: #startSampling!operations!public! !
!Profiler class categoriesFor: #stopSampling!operations!public! !

!Profiler methodsFor!

initialize
	"Initialize the singleton instance of this class"

	samplingInterval := 3.
	isSampling := true.
	mutex := Mutex new.
	^self!

profile: aProcess forSet: aProfilerSampleSet ignoring: anInteger
	"This is the main profiling method. While the sample set is active, i.e. the process
	being profiled is still alive,  collect stack frames at appropriate intervals and save 
	them in the sample set. The mutex allows multiple processes to be profiled
	at the sume time, as long as they use different sample sets"

	[| started elapsed |
	started := Time millisecondClockValue.
	(Delay forMilliseconds: samplingInterval) wait.
	elapsed := Time millisecondClockValue - started.
	(isSampling and: [aProfilerSampleSet isActive])
		ifTrue:
			[mutex
				critical:
					[self
						sampleProcess: aProcess
						forSet: aProfilerSampleSet
						elapsedTime: elapsed
						ignoring: anInteger]].
	aProfilerSampleSet isActive] whileTrue!

profile: aBlock inSetNamed: aString collect: collectBoolean on: onBoolean
	"Profile aBlock storing the results in the sample set named aString which will be cleared 
	first if collectBoolean is false.. If onBoolean is true we satrt taking samples straight away
	(after the first timing interval) otherwise we wait until a startSampling instruction is executed.
	The profiler is given its own process with a priority slightly higher than the process being
	profiled. Profiling continues until the profiled block terminates. Multiple profiling
	process can be started with the results of each being saved in a different sample set. If a
	profile is already in progress for the requested sample set then no new profile is started..
	Answers the result of evaluating the profiled block"

	| sampleSet thisProcess ignoreFrames semaphore answer |
	sampleSet := ProfilerSampleSetManager default sampleSetNamed: aString.
	(sampleSet notNil and: [sampleSet isActive]) ifTrue: [^self].
	sampleSet isNil
		ifTrue: [sampleSet := ProfilerSampleSetManager default addSampleSetNamed: aString].
	collectBoolean ifFalse: [sampleSet initialize].
	sampleSet
		clearCaches;
		isActive: true.
	isSampling := onBoolean.
	thisProcess := Processor activeProcess.
	ignoreFrames := (thisProcess stackDepthFrom: thisProcess topFrame) + 5.
	semaphore := Semaphore new.
	[semaphore wait.
	self
		profile: thisProcess
		forSet: sampleSet
		ignoring: ignoreFrames.
	semaphore signal] forkAt: thisProcess priority + 1.
	[semaphore signal.
	answer := [[aBlock value] value] value]
		ensure:
			[sampleSet isActive: false.
			semaphore wait.
			sampleSet update].
	^answer!

sampleProcess: aProcess forSet: aProfilerSampleSet elapsedTime: anInteger ignoring: ignoreInteger
	"Add the required stack frames to the sample set"

	| topFrame size |
	topFrame := aProcess topFrame.
	size := (aProcess stackDepthFrom: topFrame) - ignoreInteger.
	size > 0
		ifTrue:
			[aProfilerSampleSet
				addSample: (aProcess stackFramesFrom: aProcess topFrame depth: size)
				elapsedTime: anInteger]!

samplingInterval: anInteger
	"Set the sampling interval, the delay between samples being taken, to anInteger"

	samplingInterval := anInteger!

startSampling
	"Set the state of the isSampling flag to true. If a profile is in progress the change in
	state of the flag will be noticed by the main profiling process and it will start sampling"

	isSampling := true!

stopSampling
	"Set the state of the isSampling flag to trufalse. If a profile is in progress the change in
	state of the flag will be noticed by the main profiling process and it will start sampling"

	isSampling := false! !
!Profiler categoriesFor: #initialize!initializing!public! !
!Profiler categoriesFor: #profile:forSet:ignoring:!profiling!public! !
!Profiler categoriesFor: #profile:inSetNamed:collect:on:!operations!public! !
!Profiler categoriesFor: #sampleProcess:forSet:elapsedTime:ignoring:!profiling!public! !
!Profiler categoriesFor: #samplingInterval:!operations!public! !
!Profiler categoriesFor: #startSampling!operations!public! !
!Profiler categoriesFor: #stopSampling!operations!public! !

ProfilerFrame comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ProfilerFrame class methodsFor!

frame: aStackFrame
	"Answer an instance of the receiver initialized from aStackFrame, which may be a StackFrame
	instance or an instance of one of its subclasses"

	^super new setFrame: aStackFrame!

new
	"Should only create a new instance using #frame:"

	^self shouldNotImplement! !
!ProfilerFrame class categoriesFor: #frame:!instance creation!public! !
!ProfilerFrame class categoriesFor: #new!instance creation!protocols-instantiator!protocols-Object class!public! !

!ProfilerFrame methodsFor!

coloredSource
	"Answer a RichText containing the colored source for the receivers compiledCode"

	^compiledCode getColoredSource!

disassemblySelectionLine
	"Answer the selectionLine for the ip in the receivers *disassembled* source"

	^compiledCode interpreterClass
		indexOfIP: (compiledCode interpreter prevIP: ip)
		in: compiledCode!

disassemblySource
	"Answer the disassembled source code for the receiver. We need more information than 
	the straight disassembly, such as statement numbers and source code"

	| inStream outStream textMap text |
	textMap := compiledCode textMap.
	inStream := compiledCode disassembly readStream.
	outStream := String writeStream.
	[inStream atEnd]
		whileFalse:
			[| line thisIP index |
			line := inStream nextLine trimBlanks.	"D5 fix - ignore extra data in disassembly"
			(thisIP := Integer readFrom: line readStream) = 0
				ifFalse:
					[index := 1.
					[index <= textMap size and: [(textMap at: index) key < thisIP]]
						whileTrue: [index := index + 1].
					outStream
						nextPut: $(;
						print: index;
						nextPut: $);
						space;
						nextPutAll: line;
						cr]].
	outStream cr.
	text := compiledCode getSource.
	textMap
		keysAndValuesDo:
			[:index :each | 
			outStream
				nextPut: $(;
				print: index;
				nextPut: $);
				space;
				nextPutAll: (text copyFrom: each value start to: each value stop);
				cr].
	^outStream contents!

doClassAndSelectorMatch: aCompiledMethod
	"Answers true if the class and selector of the receiver match aCompiledMethod.
	Done this way as it it a lot quicker than comparing compiledMethods"

	^self isCompiledExpression not
		and:
			[aCompiledMethod methodClass == methodClass and: [aCompiledMethod selector == selector]]!

icon
	"Answer the icon for the frame's object"

	^receiverClass instanceClass icon!

ip
	"Answer the value of the receiver's instance variable ip.
	This method was automatically generated, but may be modified."

	^ip!

isCompiledExpression
	"Answers true if the compiledCode for this frame is part of a CompiledExpression"

	^compiledCode isKindOf: CompiledExpression!

isInSystemPackage
	"Answers true if the compiledCode for the receiver is not part of the system (Dolphin) package.
	Check for instances of CompiledExpression first as we want those. Used by the
	Dolphin filter in the browser"

	^self isCompiledExpression not
		and:
			[compiledCode owningPackage notNil and: [compiledCode owningPackage isSystemPackage]]!

isSameFrameAs: aStackFrame
	"Answers true if the receiver represents the same evaluation point as anIProfilerSampleFrame.
	CompiledCode>>= causes quite a performance hit so only use it for blocks. Note that
	we base the comparison on the receiverClass and not the methodClass"

	isBlock
		ifTrue: [compiledCode = aStackFrame method ifFalse: [^false]]
		ifFalse:
			[(receiverClass = aStackFrame receiver class and: [selector = aStackFrame method selector])
				ifFalse: [^false]].
	^ip = aStackFrame ip!

methodClass
	"Answer the value of the receiver's instance variable methodClass.
	This method was automatically generated, but may be modified."

	^methodClass!

printOn: aStream
	"Add a description of the receiver onto aStream"

	isBlock ifTrue: [aStream nextPutAll: '[] in '].
	aStream print: receiverClass.
	receiverClass == methodClass
		ifFalse:
			[aStream
				space;
				nextPut: $(;
				print: methodClass;
				nextPut: $)].
	aStream
		space;
		nextPutAll: selector!

profilerIconIndex
	"Answer the icon index for the frame's object"

	^self icon imageIndex!

selectionRange
	"Answer the selectionRange for the ip in the receivers source"

	| previousIP textMap index |
	previousIP := compiledCode interpreter prevIP: ip.
	textMap := compiledCode textMap.
	index := 1.
	[index <= textMap size and: [(textMap at: index) key < previousIP]]
		whileTrue: [index := index + 1].
	^(textMap at: index ifAbsent: [^0 to: 0]) value!

selector
	"Answer the value of the receiver's instance variable selector.
	This method was automatically generated, but may be modified."

	^selector!

selectorDescription
	"Answer a description of the compiled code. We use this as the comparison operator
	for compiledCode is quite slow and it is quicker (when building Sets for example) to use
	this description and then collect the actual compiled code later"

	^methodClass -> selector!

setFrame: aStackFrame
	"Initialize the receiver from aStackFrame"

	compiledCode := aStackFrame method.
	methodClass := compiledCode methodClass.
	receiverClass := aStackFrame receiver class.
	selector := compiledCode selector.
	ip := aStackFrame ip.
	isBlock := aStackFrame isKindOf: BlockFrame.
	^self! !
!ProfilerFrame categoriesFor: #coloredSource!displaying!public! !
!ProfilerFrame categoriesFor: #disassemblySelectionLine!displaying!public! !
!ProfilerFrame categoriesFor: #disassemblySource!displaying!public! !
!ProfilerFrame categoriesFor: #doClassAndSelectorMatch:!public!testing! !
!ProfilerFrame categoriesFor: #icon!accessing!public! !
!ProfilerFrame categoriesFor: #ip!accessing!public! !
!ProfilerFrame categoriesFor: #isCompiledExpression!public!testing! !
!ProfilerFrame categoriesFor: #isInSystemPackage!public!testing! !
!ProfilerFrame categoriesFor: #isSameFrameAs:!public!testing! !
!ProfilerFrame categoriesFor: #methodClass!accessing!public! !
!ProfilerFrame categoriesFor: #printOn:!ANSI protocols-Object!protocols-Object!public! !
!ProfilerFrame categoriesFor: #profilerIconIndex!accessing!public! !
!ProfilerFrame categoriesFor: #selectionRange!displaying!public! !
!ProfilerFrame categoriesFor: #selector!accessing!public! !
!ProfilerFrame categoriesFor: #selectorDescription!accessing!public! !
!ProfilerFrame categoriesFor: #setFrame:!initializing!public! !

ProfilerListItem comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ProfilerListItem class methodsFor!

for: anObject
	"Answer a new instance of the receiver for anObject"

	^super new setObject: anObject! !
!ProfilerListItem class categoriesFor: #for:!instance creation!public! !

!ProfilerListItem methodsFor!

convertTally: tallyInteger time: timeInteger
	"Now we know the final totals for each of the fields we can convert then to a percentage"

	tallyAll := tallyAll asPercentageOf: tallyInteger.
	tallyActive := tallyActive asPercentageOf: tallyInteger.
	timeAll := timeAll asPercentageOf: timeInteger.
	timeActive := timeActive asPercentageOf: timeInteger!

incrementTallyActive
	"Add one to the tallyActive count"

	tallyActive := tallyActive + 1!

incrementTallyAll
	"Add one to the tallyAll count"

	tallyAll := tallyAll + 1!

incrementTimeActiveBy: anInteger
	"Add anInteger to the timeActive count"

	timeActive := timeActive + anInteger!

incrementTimeAllBy: anInteger
	"Add anInteger to the timeAll count"

	timeAll := timeAll + anInteger!

isAbove: aFloat
	"Answers true if any of the fields isAbove aFloat (a percentage)"

	^tallyAll > aFloat
		or: [tallyActive > aFloat or: [timeAll > aFloat or: [timeActive > aFloat]]]!

object
	"Answer the value of the receiver's instance variable object.
	This method was automatically generated, but may be modified."

	^object!

object: anObject
	"Set the value of the receiver's instance variable object to anObject.
	This method was automatically generated, but may be modified."

	object := anObject!

profilerIconIndex
	"Answer the icon index for the list items object"

	^object profilerIconIndex!

reportOn: aStream
	"Add the four fields to aStream which will be used for the report"

	aStream
		nextPutAll: ('%6s' sprintfWith: tallyAll printString);
		nextPutAll: '    ';
		nextPutAll: ('%6s' sprintfWith: tallyActive printString);
		nextPutAll: '    ';
		nextPutAll: ('%6s' sprintfWith: timeAll printString);
		nextPutAll: '    ';
		nextPutAll: ('%6s' sprintfWith: timeActive printString);
		nextPutAll: '    ';
		cr!

setObject: anObject
	"Initialize the new instance of the receiver"

	object := anObject.
	tallyAll := 0.
	tallyActive := 0.
	timeAll := 0.
	timeActive := 0.
	^self!

tallyActive
	"Answer the value of the receiver's instance variable tallyActive.
	This method was automatically generated, but may be modified."

	^tallyActive!

tallyAll
	"Answer the value of the receiver's instance variable tallyAll.
	This method was automatically generated, but may be modified."

	^tallyAll!

timeActive
	"Answer the value of the receiver's instance variable timeActive.
	This method was automatically generated, but may be modified."

	^timeActive!

timeAll
	"Answer the value of the receiver's instance variable timeAll.
	This method was automatically generated, but may be modified."

	^timeAll! !
!ProfilerListItem categoriesFor: #convertTally:time:!converting!public! !
!ProfilerListItem categoriesFor: #incrementTallyActive!operations!public! !
!ProfilerListItem categoriesFor: #incrementTallyAll!operations!public! !
!ProfilerListItem categoriesFor: #incrementTimeActiveBy:!operations!public! !
!ProfilerListItem categoriesFor: #incrementTimeAllBy:!operations!public! !
!ProfilerListItem categoriesFor: #isAbove:!public!testing! !
!ProfilerListItem categoriesFor: #object!accessing!public! !
!ProfilerListItem categoriesFor: #object:!accessing!public! !
!ProfilerListItem categoriesFor: #profilerIconIndex!accessing!public! !
!ProfilerListItem categoriesFor: #reportOn:!public!reporting! !
!ProfilerListItem categoriesFor: #setObject:!initializing!public! !
!ProfilerListItem categoriesFor: #tallyActive!accessing!public! !
!ProfilerListItem categoriesFor: #tallyAll!accessing!public! !
!ProfilerListItem categoriesFor: #timeActive!accessing!public! !
!ProfilerListItem categoriesFor: #timeAll!accessing!public! !

ProfilerSample comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ProfilerSample class methodsFor!

root: rootNode leaf: leafNode elapsedTime: anInteger
	"Answer a new, initialized, instance of the receiver"

	^super new
		setRoot: rootNode
		leaf: leafNode
		elapsedTime: anInteger! !
!ProfilerSample class categoriesFor: #root:leaf:elapsedTime:!instance creation!public! !

!ProfilerSample methodsFor!

classInformation
	"Answer an Association with the key being a Set containing all the classes
	representerd in this sample and the value the class of the leaf (active) node.
	This information (key) is cached in the tree"

	^leaf allClasses -> leaf object methodClass!

elapsedTime
	"Answer the value of the receiver's instance variable elapsedTime.
	This method was automatically generated, but may be modified."

	^elapsedTime!

frames
	"Answers a collection of all the ProfilerFrames associated with this sample. This is obtained
	by walking the tree, starting from leaf back up to root, collecting the object at each node"

	^leaf allParentFrames!

isChildOfFrameFor: aCompiledCode
	"Answer true if any of the frames above this one in the tree have the same class 
	and method as aCompiledCode"

	^leaf isChildOfFrameFor: aCompiledCode!

selectorInformation
	"Answer an Association with the key being a Set containing all the methods (in the
	form of an Association giving the method class and selector) representerd in this 
	sample and the value the method (description) of the leaf (active) node.
	This  information (key) is cached in the tree"

	^leaf allSelectors -> leaf object selectorDescription!

setRoot: rootNode leaf: leafNode elapsedTime: anInteger
	"Initialze the receiver"

	super initialize.
	root := rootNode.
	leaf := leafNode.
	elapsedTime := anInteger.
	^self! !
!ProfilerSample categoriesFor: #classInformation!accessing!public! !
!ProfilerSample categoriesFor: #elapsedTime!accessing!public! !
!ProfilerSample categoriesFor: #frames!accessing!public! !
!ProfilerSample categoriesFor: #isChildOfFrameFor:!public!testing! !
!ProfilerSample categoriesFor: #selectorInformation!accessing!public! !
!ProfilerSample categoriesFor: #setRoot:leaf:elapsedTime:!initializing!public! !

ProfilerSampleSet comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ProfilerSampleSet class methodsFor!

name: aString
	"Answer a new initialized instance of the receiver named aString"

	^super new initialize setName: aString!

new
	"Should only create a new instance using #name:"

	^self shouldNotImplement! !
!ProfilerSampleSet class categoriesFor: #name:!instance creation!public! !
!ProfilerSampleSet class categoriesFor: #new!instance creation!protocols-instantiator!protocols-Object class!public! !

!ProfilerSampleSet methodsFor!

addItem: anAssociation to: aLookupTable elapsedTime: anInteger
	"Add all the items in the Collection referenced by anAssociation's key to aLookupTable.
	If the item doesn't exist then add a new instance of ProfilerListItem to accomodate it.
	anAssociation's value is the identity of the active node in the sample.
	Increment the value for both the all and active counts"

	| entry |
	anAssociation key
		do:
			[:eachItem | 
			entry := aLookupTable at: eachItem ifAbsentPut: [ProfilerListItem for: eachItem].
			entry
				incrementTallyAll;
				incrementTimeAllBy: anInteger].
	(aLookupTable at: anAssociation value)
		incrementTallyActive;
		incrementTimeActiveBy: anInteger!

addSample: aCollection elapsedTime: anInteger
	"Add the frames from aCollection to the tree starting at root. For each frame
	the node finds a clild of the current node corresponding to the frame (creating one if 
	necessary), updates its values and answers the new node. We can also check here for 
	the ip of the active (top) frame being 1. If it is we need to remove it as it causes confusion 
	as the sample really represents the state at the end of the previous frame"

	| leaf frames |
	frames := aCollection reverse.
	frames last ip = 1 ifTrue: [frames removeLast].
	leaf := frames
		inject: root
		into: [:node :each | node addFrame: each elapsedTime: anInteger].
	samples
		add:
			(ProfilerSample
				root: root
				leaf: leaf
				elapsedTime: anInteger)!

clearCaches
	"Clear the receiver of any cached values held in instVars or in the tree nodes. We must not
	clear the samples collection or the tree itself as we may be profiling in collect mode"

	root clearCache.
	samplesElapsedTime := nil.
	samplesClasses := nil.
	samplesSelectors := nil!

initialize
	"Initialize a new instance of the receiver"

	super initialize.
	samples := OrderedCollection new.
	samplingCount := 0.
	isActive := false.
	root := ProfilerTreeNode for: nil.
	^self!

isActive
	"Answer the value of the receiver's instance variable isActive.
	This method was automatically generated, but may be modified."

	^isActive!

isActive: anObject
	"Set the value of the receiver's instance variable isActive to anObject.
	This method was automatically generated, but may be modified."

	isActive := anObject!

name
	"Answer the name of this sample set"

	^name!

profilerIconIndex
	"Answer the index of the icon to use for the sample set
		green (Presenter) if the data has been analysed.
		red (Model) if not"

	^samplesClasses isNil
		ifTrue: [Model icon imageIndex]
		ifFalse: [Presenter icon imageIndex]!

reportTo: aStream
	"Put the preamble for the report into aStream"

	aStream
		nextPutAll: 'Profiler Report';
		cr;
		cr;
		nextPutAll: 'Set: ';
		nextPutAll: self name;
		cr;
		nextPutAll: 'Samples: ';
		print: self samplesSize;
		cr;
		nextPutAll: 'Elapsed Time: ';
		print: self samplesElapsedTime;
		cr;
		nextPutAll: 'Samplings: ';
		print: self samplingCount;
		cr;
		nextPutAll: 'Last Sampling: ';
		print: self samplingTimeStamp;
		cr!

rootNodes
	"Answer a collection of nodes that will form the root nodes of the tree"

	^root children!

sampleAt: anInteger
	"Answer the sample at index anInteger"

	^samples at: anInteger!

samplesClasses
	"Answer the classes used by this set. They are cached so check first"

	samplesClasses isNil ifTrue: [self scanSamples].
	^samplesClasses!

samplesElapsedTime
	"Answer (and cache) the total time taken by the samples held by this sample set"

	samplesElapsedTime isNil
		ifTrue:
			[samplesElapsedTime := samples inject: 0 into: [:total :each | total + each elapsedTime]].
	^samplesElapsedTime!

samplesSelectors
	"Answer the methods used by this set. They are cached so check first"

	samplesSelectors isNil ifTrue: [self scanSamples].
	^samplesSelectors!

samplesSize
	"Answer the number of samples held by this sample set"

	^samples size!

samplingCount
	"Answer the value of the receiver's instance variable samplingCount.
	This method was automatically generated, but may be modified."

	^samplingCount!

samplingTimeStamp
	"Answer the value of the receiver's instance variable samplingTimeStamp.
	This method was automatically generated, but may be modified."

	^samplingTimeStamp!

scanSamples
	"Scan all the samples for this sample set to collect lists of all the classes and methods
	represented by the receiver. Initially use a LookupTable, to enable rapid location
	of a previous occurrence of an item, but save OrderedCollections in the instVars
	as this format will be needed to display the lists. Convert the raw counts to percentages
	once we know the final totals. Trigger an event every so often to allow a progress indicator 
	to be maintained in the main shell"

	| classes selectors updateIndicatorAt |
	classes := LookupTable new.
	selectors := LookupTable new.
	updateIndicatorAt := (self samplesSize * 5.0e-002) truncated max: 1.
	samples
		keysAndValuesDo:
			[:index :eachSample | 
			index \\ updateIndicatorAt = 0
				ifTrue:
					[self
						trigger: #updateIndicator:of:
						with: index
						with: self samplesSize].
			self
				addItem: eachSample classInformation
				to: classes
				elapsedTime: eachSample elapsedTime.
			self
				addItem: eachSample selectorInformation
				to: selectors
				elapsedTime: eachSample elapsedTime].
	samplesClasses := classes asOrderedCollection.
	samplesClasses
		do: [:each | each convertTally: self samplesSize time: self samplesElapsedTime].
	samplesSelectors := selectors asOrderedCollection.
	samplesSelectors
		do: [:each | each convertTally: self samplesSize time: self samplesElapsedTime]!

setName: aString
	"Set the name of this sample set"

	name := aString.
	^self!

update
	"Update the count of the number of times a set of samples has been added
	to this sample set and also the time of the last sampling"

	samplingCount := samplingCount + 1.
	samplingTimeStamp := TimeStamp date: Date today time: Time now.
	samplesElapsedTime := nil.
	self trigger: #sampleSetUpdated: with: self! !
!ProfilerSampleSet categoriesFor: #addItem:to:elapsedTime:!private helpers!public! !
!ProfilerSampleSet categoriesFor: #addSample:elapsedTime:!profiling!public! !
!ProfilerSampleSet categoriesFor: #clearCaches!operations!public! !
!ProfilerSampleSet categoriesFor: #initialize!initializing!public! !
!ProfilerSampleSet categoriesFor: #isActive!accessing!public! !
!ProfilerSampleSet categoriesFor: #isActive:!accessing!public! !
!ProfilerSampleSet categoriesFor: #name!accessing!public! !
!ProfilerSampleSet categoriesFor: #profilerIconIndex!accessing!public! !
!ProfilerSampleSet categoriesFor: #reportTo:!public!reporting! !
!ProfilerSampleSet categoriesFor: #rootNodes!accessing!public! !
!ProfilerSampleSet categoriesFor: #sampleAt:!accessing!public! !
!ProfilerSampleSet categoriesFor: #samplesClasses!accessing!public! !
!ProfilerSampleSet categoriesFor: #samplesElapsedTime!accessing!public! !
!ProfilerSampleSet categoriesFor: #samplesSelectors!accessing!public! !
!ProfilerSampleSet categoriesFor: #samplesSize!accessing!public! !
!ProfilerSampleSet categoriesFor: #samplingCount!accessing!public! !
!ProfilerSampleSet categoriesFor: #samplingTimeStamp!accessing!public! !
!ProfilerSampleSet categoriesFor: #scanSamples!operations!public! !
!ProfilerSampleSet categoriesFor: #setName:!initializing!public! !
!ProfilerSampleSet categoriesFor: #update!public!updating! !

ProfilerSampleSetManager comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ProfilerSampleSetManager class methodsFor!

default
	"Answer the singleton instance"

	Default isNil ifTrue: [Default := super new initialize].
	^Default!

defaultSetName
	"Answer a String giving the name of the default sample set"

	^'Default'!

new
	"Private - Use default to get the Singleton instance"

	^self shouldNotImplement!

reset
	"Clear the singleton instance of this class"

	Default := nil! !
!ProfilerSampleSetManager class categoriesFor: #default!instance creation!public! !
!ProfilerSampleSetManager class categoriesFor: #defaultSetName!constants!public! !
!ProfilerSampleSetManager class categoriesFor: #new!instance creation!protocols-instantiator!protocols-Object class!public! !
!ProfilerSampleSetManager class categoriesFor: #reset!operations!public! !

!ProfilerSampleSetManager methodsFor!

addSampleSetNamed: aString
	"Add a new sample set named aString. Remove, without warning, any existing sample set
	with the same name.
	Answer the new sample set"

	| sampleSet |
	(sampleSet := self sampleSetNamed: aString) notNil ifTrue: [sampleSets remove: sampleSet].
	sampleSet := ProfilerSampleSet name: aString.
	sampleSet
		when: #sampleSetUpdated:
		send: #onSampleSetUpdated:
		to: self.
	^sampleSets add: sampleSet!

initialize
	"Initialize the receiver"

	super initialize.
	sampleSets := ListModel on: OrderedCollection new.
	^self!

onSampleSetUpdated: aProfilerSampleSet
	"aProfilerSampleSet has been updated, some new samples have been added, so
	tell the ListModel to refresh it. This will also be passed on to the ProfilerBrowser"

	sampleSets updateAtIndex: (sampleSets indexOf: aProfilerSampleSet)!

removeAll
	"Remove all the sample sets"

	self sampleSetNames do: [:each | self removeSampleSetNamed: each]!

removeSampleSetNamed: aString
	"Remove the sample set named aString. Raise an exception if it does not exist.(trys to remove nil)
	Answer the removed sample set"

	^sampleSets remove: (self sampleSetNamed: aString)!

sampleSetNamed: aString
	"Answer the sample set named aString. Answer nil if no such sample set exists"

	^sampleSets list detect: [:each | each name = aString] ifNone: []!

sampleSetNames
	"Answer a collection containg the names of all the current sample sets"

	^sampleSets list collect: [:each | each name]!

sampleSets
	"Answer the value of the receiver's instance variable sampleSets.
	This method was automatically generated, but may be modified."

	^sampleSets! !
!ProfilerSampleSetManager categoriesFor: #addSampleSetNamed:!operations!public! !
!ProfilerSampleSetManager categoriesFor: #initialize!initializing!public! !
!ProfilerSampleSetManager categoriesFor: #onSampleSetUpdated:!event handling!public! !
!ProfilerSampleSetManager categoriesFor: #removeAll!operations!public! !
!ProfilerSampleSetManager categoriesFor: #removeSampleSetNamed:!operations!public! !
!ProfilerSampleSetManager categoriesFor: #sampleSetNamed:!operations!public! !
!ProfilerSampleSetManager categoriesFor: #sampleSetNames!accessing!public! !
!ProfilerSampleSetManager categoriesFor: #sampleSets!accessing!public! !

!Rectangle methodsFor!

containsPointInclusive: aPoint
	"Private - Answer whether aPoint is contained by the receiver. Containment is
	defined by origin point <= aPoint (inclusive), and aPoint corner point 
	(inclusive)"

	#idbAdded.
	^origin <= aPoint and: [aPoint <= corner]!

increaseCornerBy: delta
	#idbAdded.
	^origin corner: corner + delta! !
!Rectangle categoriesFor: #containsPointInclusive:!idb goodies!public!testing! !
!Rectangle categoriesFor: #increaseCornerBy:!idb goodies!public!rectangle functions! !

!ResourceIdentifier methodsFor!

isChanged: aBoolean 
	"Flag the receiver as changed or not changed, according to the value of the <Boolean>
	argument. If the receiver is marked as changed, then its owning package (if any) is also so
	marked."

	self resourceOrNil 
		ifNotNil: 
			[:resource | 
			aBoolean ifTrue: [self owningPackage ifNotNil: [:package | package isChanged: true]].
			resource isChanged: aBoolean]!

resource
	"Answer the resource represented by the receiver. If the receiver is not recognized by the
	ResourceManager an error is raised."

	^SessionManager current resourceManager resourceAt: self
		ifAbsent: [self error: 'No such resource: ' , self printString]! !
!ResourceIdentifier categoriesFor: #isChanged:!development!public!source filing! !
!ResourceIdentifier categoriesFor: #resource!accessing!public! !

SelectorParser comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!SelectorParser class methodsFor!

parse: aString
	"Shortcut to create the receiver and perform the parsing "

	^self new parse: aString! !
!SelectorParser class categoriesFor: #parse:!instance creation!public! !

!SelectorParser methodsFor!

binaryTokenFrom: aStream
	"Answer the binary token from aStream"

	| start stop |
	start := aStream position.
	[aStream atEnd
		ifTrue:
			[aStream position: start.
			^aStream upToEnd].
	(self isBinaryDelimiter: aStream next)
		ifTrue:
			[stop := aStream position.
			aStream position: start.
			^aStream next: stop - start - 1]] repeat!

firstTokenFrom: aStream
	"Answer the first token from the current position in the stream. After skipping 
	separators and (recursively) comment we know the next token will be either a 
	binary selector or unary/keyword selector"

	aStream skipSeparators ifFalse: [^String new].
	(aStream peekFor: $")
		ifTrue:
			[aStream skipTo: $".
			^self firstTokenFrom: aStream].
	^(self isBinaryStarter: aStream peek)
		ifTrue: [self binaryTokenFrom: aStream]
		ifFalse: [self keywordOrUnaryTokenFrom: aStream]!

isBinaryDelimiter: aCharacter
	"Answer true is aCharacter cannot be part of a binary selector"

	^(##(' "_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
			, Character tab asString , Character cr asString , Character nl asString
			, Character newPage asString) indexOf: aCharacter) ~= 0!

isBinaryStarter: aCharacter
	"Answer true is aCharacter can be the first character in a binary selector.
	Defined with regard to the current image. Adding binary selectors to the
	image may also require modifications here. See class comment"

	^(##('<=>\@|~&%*+,-/') indexOf: aCharacter) ~= 0!

isKeyword: aString
	"Answer true if aString is a valid keyword token"

	^aString size >= 2 and: [aString last = $: and: [self isKeywordStarter: aString first]]!

isKeywordStarter: aCharacter
	"Answer true is aCharacter is the first character of a keyword selector"

	^(##('_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ') indexOf: aCharacter) ~= 0!

isNonBinaryDelimiter: aCharacter
	"Answer true is aCharacter cannot be part of a unary selector, keyword
	selector or the arguments in a selector string"

	^(##(' "#''^([<|-' , Character tab asString , Character cr asString
			, Character nl asString , Character newPage asString) indexOf: aCharacter) ~= 0!

keywordOrArgumentTokenFrom: aStream
	"Answer the next token from aStream. Once we have got past separators
	and (possibly recursive) comments we can treat it in the same way (in terms 
	of character sequences) as the initial unary/keyword token. "

	| start stop char |
	aStream skipSeparators ifFalse: [^String new].
	(aStream peekFor: $")
		ifTrue:
			[aStream skipTo: $".
			^self keywordOrArgumentTokenFrom: aStream].
	^self keywordOrUnaryTokenFrom: aStream!

keywordOrUnaryTokenFrom: aStream
	"Answer the unary or keyword token from aStream. The only difference
	is that the unary token needs to be answered without it's delimiter but the
	keyword tokens needs to include it's delimiter - a colon"

	| start stop char |
	start := aStream position.
	[aStream atEnd
		ifTrue:
			[aStream position: start.
			^aStream upToEnd].
	(char := aStream next) = $:
		ifTrue:
			[stop := aStream position.
			aStream position: start.
			^aStream next: stop - start].
	(self isNonBinaryDelimiter: char)
		ifTrue:
			[stop := aStream position.
			aStream position: start.
			^aStream next: stop - start - 1]] repeat!

parse: aString
	"Answer the Smalltalk selector parsed from aString. If the first token
	is a binary or unary token we need do no more, otherwise we have to
	get keyword tokens but omit the intervening arguments"

	| readStream writeStream token |
	readStream := aString readStream.
	token := self firstTokenFrom: readStream.
	(self isKeyword: token) ifFalse: [^token].
	writeStream := String writeStream: 100.
	[self isKeyword: token]
		whileTrue:
			[writeStream nextPutAll: token.
			self keywordOrArgumentTokenFrom: readStream.
			token := self keywordOrArgumentTokenFrom: readStream].
	^writeStream contents! !
!SelectorParser categoriesFor: #binaryTokenFrom:!operations!public! !
!SelectorParser categoriesFor: #firstTokenFrom:!operations!public! !
!SelectorParser categoriesFor: #isBinaryDelimiter:!public!testing! !
!SelectorParser categoriesFor: #isBinaryStarter:!public!testing! !
!SelectorParser categoriesFor: #isKeyword:!public!testing! !
!SelectorParser categoriesFor: #isKeywordStarter:!public!testing! !
!SelectorParser categoriesFor: #isNonBinaryDelimiter:!public!testing! !
!SelectorParser categoriesFor: #keywordOrArgumentTokenFrom:!operations!public! !
!SelectorParser categoriesFor: #keywordOrUnaryTokenFrom:!operations!public! !
!SelectorParser categoriesFor: #parse:!operations!public! !

SerialIO comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!SerialIO class methodsFor!

connectTo: aString
	"Answer a new instance of the receiver connected to the device named aString"

	^self new connectTo: aString! !
!SerialIO class categoriesFor: #connectTo:!instance creation!public! !

!SerialIO methodsFor!

connectionParameters
	"Answers a String giving the basic connection parameters"

	| dcb |
	dcb := DCB new.
	KernelLibrary default getCommState: handle lpDCB: dcb.
	^(String writeStream)
		print: dcb baudRate;
		nextPut: $-;
		print: dcb dataByteSize;
		nextPut: $-;
		nextPut:
				(##((LookupTable new)
							at: NOPARITY put: $N;
							at: ODDPARITY put: $O;
							at: EVENPARITY put: $E;
							at: MARKPARITY put: $M;
							at: SPACEPARITY put: $S;
							yourself) at: dcb parity);
		nextPut: $-;
		nextPutAll:
				(##((LookupTable new)
							at: ONESTOPBIT put: '1';
							at: ONE5STOPBITS put: '1.5';
							at: TWOSTOPBITS put: '2';
							yourself) at: dcb stopBits);
		contents!

connectTo: aString
	"Connects the receiver to the serial device named aString"

	deviceName := aString.
	(deviceName indexOfSubCollection: 'COM') = 1
		ifFalse: [^self error: 'The device name must be COMn'].
	(handle := KernelLibrary default
		createFile: deviceName
		dwDesiredAccess: GENERIC_READ | GENERIC_WRITE
		dwSharedMode: 0
		lpSecurityAttributes: nil
		dwCreationDistribution: OPEN_EXISTING
		dwFlagsAndAttributes: 0
		hTemplateFile: nil) = INVALID_HANDLE_VALUE ifTrue: [self error: 'Unable to open device'].
	self
		initializeComms;
		beFinalizable.
	^self!

disconnect
	"If the device is still open, the handle has not been set to nil
	then restore the old values that were saved when the device 
	was opened and then close the handle"

	handle isNil
		ifFalse:
			[(KernelLibrary default)
				setCommTimeouts: handle lpCommTimeouts: oldCOMMTIMEOUTS;
				setCommState: handle lpDCB: oldDCB;
				closeHandle: handle.
			handle := nil].
	self beUnfinalizable!

enableRTS
	"A fix that forces the RTS line to be permanently enabled. If this is not enabled
	then the remote device might refuse to transmit data"

	| dcb |
	dcb := DCB new.
	KernelLibrary default getCommState: handle lpDCB: dcb.
	dcb fRtsControl: RTS_CONTROL_ENABLE.
	KernelLibrary default setCommState: handle lpDCB: dcb!

finalize
	"Ensure that the device has been disconnected before it is destroyed. Failure
	to do this can result in the device becoming unavailable"

	self disconnect!

initializeComms
	"Initialize the hardware "

	self
		initializeDCB;
		initializeCOMMTIMEOUTS	"Insert fix initialisation calls here"!

initializeCOMMTIMEOUTS
	"The only initialization we are going to do is to set the timeouts to a more suitable
	scheme. 

	The effect of the default values is to disable timeouts, therefore if you ask for 100 
	characters from the device then the read operations will not return, and Dolphin
	is therefore disabled, until all 100 character have been read.

	The values below set the following (assume 100 characters are asked for) -
		The api will return if 100 character become available in less than 150 mS 
			which is made up of the constant, 50 mS, plus the number of character, 100,
			multiplied by the multiplier, 1.    50 + (100 * 1)
		The api will return, with any available characters, when the timeout of 150mS expires.
		The api will return if there is a gap of 20mS after a character is received even if 
			less than 100 characters have arrived and the timeout has not matured.

	For a fuller explanation see the API docs"

	| timeouts |
	oldCOMMTIMEOUTS := COMMTIMEOUTS new.
	KernelLibrary default getCommTimeouts: handle lpCommTimeouts: oldCOMMTIMEOUTS.
	timeouts := COMMTIMEOUTS new.
	timeouts
		readIntervalTimeout: 20;
		readTotalTimeoutMultiplier: 1;
		readTotalTimeoutConstant: 50;
		writeTotalTimeoutMultiplier: 0;
		writeTotalTimeoutConstant: 0.
	KernelLibrary default setCommTimeouts: handle lpCommTimeouts: timeouts!

initializeDCB
	"Set some parameters. If you always want to use the windows default values
	then omit the changes. This method must always be called, even if it makes no
	changes, as we always restore the original DCB.

	For a fuller explanation see the API docs"

	| dcb |
	oldDCB := DCB new.
	KernelLibrary default getCommState: handle lpDCB: oldDCB.
	dcb := DCB new.
	KernelLibrary default getCommState: handle lpDCB: dcb.
	dcb
		baudRate: CBR_9600;
		parity: NOPARITY;
		stopBits: ONESTOPBIT.
	KernelLibrary default setCommState: handle lpDCB: dcb!

read: anInteger
	"Read up to anInteger number of characters from the serial device. If less than anInteger
	number are read then the size of the buffer indicates how many.
	Any errors are ignored!!!!"

	| byteBuffer bytesRead |
	byteBuffer := ByteArray new: anInteger.
	bytesRead := DWORD new.
	KernelLibrary default
		readFile: handle
		lpBuffer: byteBuffer
		nNumberOfBytesToRead: anInteger
		lpNumberOfBytesRead: bytesRead
		lpOverlapped: nil.
	^byteBuffer copyFrom: 1 to: bytesRead asInteger!

write: aByteArrayOrString
	"Writes aByteArrayOrString to the serial device and doesn't return until all the characters
	have been written.
	Answers the object written and ignores any errors"

	KernelLibrary default
		writeFile: handle
		lpBuffer: aByteArrayOrString
		nNumberOfBytesToWrite: aByteArrayOrString size
		lpNumberOfBytesWritten: DWORD new
		lpOverlapped: nil.
	^aByteArrayOrString! !
!SerialIO categoriesFor: #connectionParameters!accessing!public! !
!SerialIO categoriesFor: #connectTo:!operations!operations-startup!public! !
!SerialIO categoriesFor: #disconnect!operations-shutdown!public! !
!SerialIO categoriesFor: #enableRTS!initializing!public!serial fix! !
!SerialIO categoriesFor: #finalize!finalizing!public! !
!SerialIO categoriesFor: #initializeComms!initializing!public! !
!SerialIO categoriesFor: #initializeCOMMTIMEOUTS!initializing!public! !
!SerialIO categoriesFor: #initializeDCB!initializing!public! !
!SerialIO categoriesFor: #read:!operations!public! !
!SerialIO categoriesFor: #write:!operations!public! !

!SessionManager class methodsFor!

installNew
	"Install a new instance of the receiver as the current SessionManager.
	Answer the PREVIOUS SessionManager."

	| newSM |
	newSM := self basicNew.
	SessionManager current retire.
	SessionManager current: newSM.		
	SessionManager current initializeFromSessionManager: newSM.
	^newSM	"actually the old SessionManager, since #become: used to swap"
! !
!SessionManager class categoriesFor: #installNew!instance creation!public! !

!SessionManager methodsFor!

basicPrimaryStartup
	"Perform critical startup operations which initialize the basic
	services in the image such as the process system. These startup activities
	should be kept to a minimal set, as there is no opportunity to repair any
	damage until these are completed, so if they fail, you've had it."

	VMLibrary default onStartup.	"The VMLibrary must be initialized before we do anything else."
	self openLibraries.	"Now we can open the permanent libraries"
	self imagePath: imagePath.	"Split off the extension now can use lib functions."
	ExternalCallback onStartup.	"Old callbacks will be invalid"
	self createInputState.	"Register input semaphore, etc, kill previous idler in case on a different host OS"
	self class environment at: #Delay ifPresent: [:d | d onStartup].	"Reschedule delays etc."
	MemoryManager current onStartup	"Start (if necessary) finalization/bereavement processing, etc"!

createInputState
	inputState := InputState newFromOld: inputState!

idbDocumentationFolder
	"Answers the folder where all the idb goodies files are located"

	#idbAdded.
	^FileLocator imageRelative localFileSpecFor: 'Ian Bartholomew\Documentation'!

idbPackageFolder
	"Answers the folder where all the idb goodies files are located"

	#idbAdded.
	^FileLocator imageRelative localFileSpecFor: 'Ian Bartholomew'!

idbResourcesFolder
	"Answers the folder where all the idb goodies files are located"

	#idbAdded.
	^FileLocator imageRelative localFileSpecFor: 'Ian Bartholomew\Resources'!

imageFileName
	"Answer the file name of the current image."

	^File path: self imagePath extension: self imageExtension!

inputState
	"Answer the receiver's <InputState>, lazily creating it if necessary."

	^inputState!

onQueryEndSession
	"The system is shutting down. Either shut down the image, or return false to prevent the session shutdown"

	self queryEndSession ifTrue: [self quit: 0].
	^false!

onQuit: anInteger 
	"Handle a request to exit - the argument is the exit code.
	This message is normally sent from the InputState message pump.
	The request may be aborted if #queryEndSession: answers false."

	self queryEndSession ifTrue: [self quit: anInteger]!

queryEndSession
	"Fire off an event to enquire of observers whether they object to the end of this session.
	If any observer does, then it must set the boolean value argument to the event to false."

	| okToQuit |
	okToQuit := true asValue.
	self trigger: #queryEndSession: with: okToQuit.
	^okToQuit value!

retire
	"This SessionManager instance is stepping down in favour of a new boy. Perform any
	uninitialisation that might be required."!

windowsDirectory
	"Answer the path of the Windows directory on the host computer for the current session. Note
	that under Terminal Server this will be the shared Windows directory, not the per-user
	Windows directory. See MSDN KB281316  for further information."

	^OSVERSIONINFO current dwMajorVersion >= 5 
		ifTrue: 
			[| path len |
			path := File pathBuffer.
			len := KernelLibrary default getSystemWindowsDirectory: path uSize: path size.
			len == 0 ifTrue: [^KernelLibrary default systemError].
			path leftString: len]
		ifFalse: 
			["The system call returns the path sans a delimiter, so we must maintain that behaviour"
			File removePathDelimiter: (File splitPathFrom: (File removePathDelimiter: self systemDirectory))]! !
!SessionManager categoriesFor: #basicPrimaryStartup!operations-startup!public! !
!SessionManager categoriesFor: #createInputState!operations-startup!private! !
!SessionManager categoriesFor: #idbDocumentationFolder!accessing!idb goodies!public! !
!SessionManager categoriesFor: #idbPackageFolder!accessing!idb goodies!public! !
!SessionManager categoriesFor: #idbResourcesFolder!accessing!idb goodies!public! !
!SessionManager categoriesFor: #imageFileName!accessing!public! !
!SessionManager categoriesFor: #inputState!accessing!public! !
!SessionManager categoriesFor: #onQueryEndSession!event handling!public! !
!SessionManager categoriesFor: #onQuit:!event handling!public! !
!SessionManager categoriesFor: #queryEndSession!event handling!public! !
!SessionManager categoriesFor: #retire!public! !
!SessionManager categoriesFor: #windowsDirectory!accessing!public! !

!SmalltalkScanner methodsFor!

illegalNumber: anInteger 
	^self lexicalError: LErrBadNumber range: (anInteger to: self errorPosition)!

scanNumber
	| start number stop |
	start := stream position.
	[number := self readNumber] on: Error do: [:ex | self illegalNumber: start].
	stop := self previousStepPosition.
	^StNumberLiteralToken 
		value: number
		start: start
		stop: stop
		source: (stream copyFrom: start to: stop)! !
!SmalltalkScanner categoriesFor: #illegalNumber:!error handling!private! !
!SmalltalkScanner categoriesFor: #scanNumber!private!scanning! !

!SocketAbstract methodsFor!

queryPort
	"Lookup the port using getsockname().  Answer the result as a SmallInteger,
	or signal a socket error."

	| name nameLength |
	name := (SOCKADDR_IN new)
				sin_family: AF_INET;
				yourself.
	nameLength := (SDWORD new)
				value: name size;
				yourself.
	(WSockLibrary default 
		getsockname: self asParameter
		name: name
		namelen: nameLength) < 0 
		ifTrue: [self error].
	^WSockLibrary default ntohs: name sin_port! !
!SocketAbstract categoriesFor: #queryPort!accessing!public! !

!SourceManager methodsFor!

allChunksIn: aStream forClass: aString
	"Private - Answer a collection containing all the chunks in aStream 
	giving methods definitions belonging to class given in aString"

	#idbAdded.
	^self
		chunksIn: aStream
		forClass: aString
		oneOnly: false!

chunksIn: aStream forClass: aString oneOnly: aBoolean
	"Private - Answer a collection containing all the chunks in aStream pertaining
	to the class given in aString.  #positionsOf: does a fast scan and answers the 
	offsets of all the occurrences, this method just gets  the chain of chunks starting 
	at those offsets"

	| chunks |
	#idbAdded.
	chunks := OrderedCollection new.
	aStream reset.
	(aStream positionsOf: aString oneOnly: aBoolean)
		do:
			[:offset | 
			| reader |
			aStream position: offset.
			reader := ChunkReader
				do: [:each | (chunks isEmpty or: [chunks last ~= each]) ifTrue: [chunks add: each]].
			reader fileInFrom: (ChunkSourceFiler on: aStream)].
	^chunks!

fileOutMethod: aCompiledMethod to: aFileName
	"File out the source and category for aCompiledMethod to aFileName"

	| filer |
	#idbAdded.
	filer := self newSourceFiler: aFileName.
	filer
		fileOutMessages: (OrderedCollection with: aCompiledMethod selector)
		ofBehavior: aCompiledMethod methodClass.
	filer close!

firstChunksIn: aStream forClass: aString
	"Private - Answer a collection containing the first chunks in aStream 
	giving methods definitions belonging to class given in aString"

	#idbAdded.
	^self
		chunksIn: aStream
		forClass: aString
		oneOnly: true!

historicMethodsIn: aClass
	"Private - Scan the change and source files for references to methods in the
	given class. Answers an Array with the collection of source file method sources 
	 in position 1 and change file entries in position 2.
	NB For performance we only need to look for the first block in the sources file
	as we know that all the methods will be located together"

	| target |
	#idbAdded.
	target := (String writeStream)
		nextPut: $!!;
		nextPutAll: aClass name;
		nextPutAll: ' methodsFor!!';
		cr;
		contents.
	^Array
		with: (self firstChunksIn: self sourcesFileStream forClass: target)
		with: (self allChunksIn: self changesStream forClass: target)!

historyOfClass: aClass
	"Private - Answers a Array containing the symbolic names of 
	all the methods in aClass that we hold historic source for. Index 1
	holds the selectors defined in the sources file and index 2 the changes file"

	| methods |
	#idbAdded.
	methods := self historicMethodsIn: aClass.
	^Array
		with: ((methods at: 1) collect: [:each | (SelectorParser parse: each) asSymbol])
		with: ((methods at: 2) collect: [:each | (SelectorParser parse: each) asSymbol])!

historyOfClass: aClass selector: aSymbol
	"Private - Answers a Collection containing the source chunks for the given method.
	Source from the sources file always comes befor source from the changes file"

	| methods |
	#idbAdded.
	methods := self historicMethodsIn: aClass.
	^(methods at: 1) , (methods at: 2)
		select: [:each | aSymbol = (SelectorParser parse: each) asSymbol]! !
!SourceManager categoriesFor: #allChunksIn:forClass:!accessing!idb goodies!public! !
!SourceManager categoriesFor: #chunksIn:forClass:oneOnly:!accessing!idb goodies!public! !
!SourceManager categoriesFor: #fileOutMethod:to:!idb goodies!public!source filing! !
!SourceManager categoriesFor: #firstChunksIn:forClass:!accessing!idb goodies!public! !
!SourceManager categoriesFor: #historicMethodsIn:!idb goodies!public!source filing! !
!SourceManager categoriesFor: #historyOfClass:!idb goodies!public!source filing! !
!SourceManager categoriesFor: #historyOfClass:selector:!idb goodies!public!source filing! !

!StatusBarItemAbstract methodsFor!

snoopDescription
	"Answer a description of the receiver for the snoop tree"

	#idbAdded.
	^self snoopDescription: (self parentView nameOf: self)!

snoopSecond
	"Answer any items (name and value) that snoop should display for the receiver"

	#idbAdded.
	^(super snoopSecond)
		add: 'Parent View' -> self parentView;
		add: 'Model' -> self model;
		add: 'Rectangle' -> self rectangle;
		add: 'Width' -> self width;
		add:
				'Border'
						->
							(ControlBarConstants
								snoopConstant: self border
								from: #(#SBT_NOBORDERS #SBT_OWNERDRAW #SBT_POPOUT #SBT_RTLREADING));
		yourself! !
!StatusBarItemAbstract categoriesFor: #snoopDescription!accessing!idb goodies!public! !
!StatusBarItemAbstract categoriesFor: #snoopSecond!accessing!idb goodies!public! !

!TestCase methodsFor!

shouldnt: aZeroArgBlock triggerAnyOf: aCollectionOfSymbols against: anObject 
	"Example usage:
		self 
			shouldnt: [presenter model remove: objects last]
			triggerAnyOf: #(#selectionChanged #selectionChanging:)
			against: presenter.
	"

	self 
		should: aZeroArgBlock
		triggerAllOf: #()
		matching: [:message | true]
		butNoneOf: aCollectionOfSymbols
		against: anObject! !
!TestCase categoriesFor: #shouldnt:triggerAnyOf:against:!helpers!public! !

!View methodsFor!

hasWindowEdge
	"Answer whether the receiver has the Window Edge style (a raised 3D edge)"

	^self exStyleAllMask: WS_EX_WINDOWEDGE!

hasWindowEdge: aBoolean
	"Sets the receiver to have a Window Edge style (a raised 3D edge).
	This is the WS_EX_WINDOWEDGE style."

	self exStyleMask: WS_EX_WINDOWEDGE set: aBoolean.
	self invalidateLayout!

sendMessage: anIntegerMessageID wpParam: wpParam lpParam: lpParam
	"Private - Send the Win32 message anIntegerMessageID with parameters wpParam 
	and lpParam (pointers) to the receiver's Window."

	#idbAdded.
	^UserLibrary default
		sendMessage: self asParameter
		msg: anIntegerMessageID
		wpParam: wpParam
		lpParam: lpParam!

snoopChildren
	"Answer a collection containing any children of the receiver that should 
	appear in the snoop tree. Check here for menuBar and menu (they are 
	not sub views) before adding any other sub views"

	| children |
	#idbAdded.
	children := OrderedCollection new.
	((self respondsTo: #menuBar) and: [self menuBar notNil])
		ifTrue: [children add: self menuBar].
	self contextMenu notNil ifTrue: [children add: self contextMenu].
	^children , self subViews!

snoopDescription
	"Answer the default description of the receiver in the snoop tree"

	#idbAdded.
	^self snoopDescription: self name!

snoopFirst
	"Answer any items (name and value) that snoop should disply for the receiver"

	| interests parent |
	#idbAdded.
	interests := super snoopFirst.
	interests
		add: 'Model' -> self model;
		add: 'Presenter' -> self presenter.
	parent := self presenter parentPresenter.
	[parent notNil]
		whileTrue:
			[interests add: 'Parent Presenter' -> parent.
			parent := parent parentPresenter].
	^interests!

snoopSecond
	"Answer any items (name and value) that snoop should disply for the receiver"

	#idbAdded.
	^(super snoopSecond)
		add:
				'Style'
						->
							(Win32Constants
								snoopFlags: self getWindowStyle
								from:
									#(#WS_BORDER #WS_CHILD #WS_CLIPCHILDREN #WS_CLIPSIBLINGS #WS_DISABLED #WS_DLGFRAME #WS_GROUP #WS_HSCROLL #WS_MAXIMIZE #WS_MAXIMIZEBOX #WS_MINIMIZE #WS_MINIMIZEBOX #WS_OVERLAPPED #WS_POPUP #WS_SYSMENU #WS_TABSTOP #WS_THICKFRAME #WS_VISIBLE #WS_VSCROLL));
		add:
				'Ex Style'
						->
							(Win32Constants
								snoopFlags: self getWindowExStyle
								from:
									#(#WS_EX_CLIENTEDGE #WS_EX_CONTROLPARENT #WS_EX_DLGMODALFRAME #WS_EX_NOTIFYDRAG #WS_EX_OVERLAPPEDWINDOW #WS_EX_STATICEDGE #WS_EX_TOOLWINDOW #WS_EX_TRANSPARENT #WS_EX_WINDOWEDGE));
		yourself! !
!View categoriesFor: #hasWindowEdge!accessing-styles!public! !
!View categoriesFor: #hasWindowEdge:!accessing-styles!public! !
!View categoriesFor: #sendMessage:wpParam:lpParam:!idb goodies!operations!public! !
!View categoriesFor: #snoopChildren!accessing!idb goodies!public! !
!View categoriesFor: #snoopDescription!displaying!idb goodies!public! !
!View categoriesFor: #snoopFirst!accessing!idb goodies!public! !
!View categoriesFor: #snoopSecond!accessing!idb goodies!public! !

!AXInterfaceTypeAnalyzer class methodsFor!

optimizedSelectors
	^#(#and: #or: #ifTrue: #ifFalse: #ifTrue:ifFalse: #ifFalse:ifTrue: #ifNil: #ifNotNil: #ifNil:ifNotNil: #ifNotNil:ifNil:)!

overridableIDispatchSelectors
	^#(#_newEnum #isVBCollection #isExtensible)!

overridableIUnknownSelectors
	^#(#value #value: #size #copy #hash)!

reservedDispSelectors
	ReservedDispSelectors isNil 
		ifTrue: 
			[ReservedDispSelectors := (IDispatch allSelectors)
						removeAll: self overridableIUnknownSelectors;
						removeAll: self overridableIDispatchSelectors;
						addAll: self optimizedSelectors;
						yourself].
	^ReservedDispSelectors!

reservedUnkSelectors
	ReservedUnkSelectors isNil 
		ifTrue: 
			[ReservedUnkSelectors := (IUnknown allSelectors)
						removeAll: self overridableIUnknownSelectors;
						addAll: self optimizedSelectors;
						addAll: self optimizedSelectors;
						yourself].
	^ReservedUnkSelectors! !
!AXInterfaceTypeAnalyzer class categoriesFor: #optimizedSelectors!constants!public! !
!AXInterfaceTypeAnalyzer class categoriesFor: #overridableIDispatchSelectors!constants!public! !
!AXInterfaceTypeAnalyzer class categoriesFor: #overridableIUnknownSelectors!constants!public! !
!AXInterfaceTypeAnalyzer class categoriesFor: #reservedDispSelectors!accessing!public! !
!AXInterfaceTypeAnalyzer class categoriesFor: #reservedUnkSelectors!accessing!public! !

!AXInterfaceTypeAnalyzer methodsFor!

generateClassCLSIDForCoclass: aTKindCoclassAnalyzer 
	| target |
	target := String writeStream: 256.
	target
		nextPutAll: 'clsid';
		crtab;
		nextPutAll: '"Private - Answer the CLSID of the coclass (';
		nextPutAll: aTKindCoclassAnalyzer name;
		nextPutAll: ') for which the receiver is the default interface.'.
	self printAutoGenMethodPostambleOn: target.
	target
		nextPutAll: '^CLSID fromString: ';
		print: aTKindCoclassAnalyzer guid asString;
		cr.
	self compileClassMethod: target contents categories: self classConstantsCategories!

generateClassInstanceCreation
	"Private - Generate the class #clsid method for an interface wrapper, 
	but only if this interface is a default interface."

	| coclasses iid |
	(self canGenerateClassMessage: #clsid) ifFalse: [^nil].
	iid := self guid.
	coclasses := self typeLib coclasses select: [:c | c defaultInterface guid = iid].
	coclasses isEmpty ifTrue: [^self].
	coclasses size > 1 
		ifTrue: 
			[| instantiable |
			instantiable := coclasses select: [:c | c isInstantiable].
			instantiable size = 1 ifTrue: [coclasses := instantiable]].
	coclasses size > 1 
		ifTrue: [coclasses do: [:each | self generateNewForCoclass: each]]
		ifFalse: [self generateClassCLSIDForCoclass: coclasses first]!

generateClassSide: aClass 
	self generateClassInitialize.
	aClass initialize.
	self generateClassComment.
	self generateClassInstanceCreation!

generateNewForCoclass: aTKindCoclassAnalyzer 
	| target |
	target := String writeStream: 256.
	target
		nextPutAll: 'new';
		nextPutAll: aTKindCoclassAnalyzer name;
		crtab;
		nextPutAll: '"Answer a new instance of the receiver on the ';
		nextPutAll: aTKindCoclassAnalyzer name;
		nextPutAll: ' COM object'.
	self printAutoGenMethodPostambleOn: target.
	target
		nextPutAll: '^self onCLSID: (CLSID fromString: ';
		print: aTKindCoclassAnalyzer clsid asString;
		nextPut: $);
		cr.
	self compileClassMethod: target contents
		categories: (Array with: (self classMethodCategoryClass name: self autoGenCategoryName)
				with: (self classMethodCategoryClass name: 'instance creation'))! !
!AXInterfaceTypeAnalyzer categoriesFor: #generateClassCLSIDForCoclass:!development!private! !
!AXInterfaceTypeAnalyzer categoriesFor: #generateClassInstanceCreation!development!private! !
!AXInterfaceTypeAnalyzer categoriesFor: #generateClassSide:!development!private! !
!AXInterfaceTypeAnalyzer categoriesFor: #generateNewForCoclass:!development!private! !

!TKindDispatchAnalyzer methodsFor!

printPropGet: aFUNCDESC wrapping: anAXMethodName on: aPuttableStream defaultOptionals: aBoolean 
	"Private - Generate the main body of a high-level accessor for the prop-get method described
	by the <FUNCDESC>, method. Answer nil if no method is to be emitted."

	^aBoolean 
		ifTrue: 
			[self 
				printDefaultMethodBody: aFUNCDESC
				wrapping: anAXMethodName
				on: aPuttableStream]
		ifFalse: 
			[self 
				printRawPropGetBody: aFUNCDESC
				name: anAXMethodName
				on: aPuttableStream]! !
!TKindDispatchAnalyzer categoriesFor: #printPropGet:wrapping:on:defaultOptionals:!development!private! !

!ClassDescription methodsFor!

idbDefaultIconName
	"Answers the default icon name for the receiver. Overrrrrridden to point into 
	the /packages/idb folder."

	#idbAdded.
	^File
		composePath: SessionManager current idbResourcesFolder
		stem: self name
		extension: 'ico'!

profilerIconIndex
	"Answer the icon idex for the receiver"

	#idbAdded.
	^self icon imageIndex!

stbReadFrom: anSTBInFiler format: anSTBClassConversion 
	"Read an instance of the receiver from the binary filer, aSTBInFiler. In most cases we can
	just bat this right back to the in-filer, and let it read its standard format from the
	stream. Custom format (or read routines) are useful where the standard STB format, and/or
	reader, is too inefficient in terms of space, or time, or both. It can also be used to avoid
	the need to create a proxy class; an example of this in D6 is the filing of symbols, which
	relegates the old STBSymbolProxy class to use only for reading older STB files."

	^anSTBInFiler readObjectOfClass: self format: anSTBClassConversion! !
!ClassDescription categoriesFor: #idbDefaultIconName!constants!idb goodies!public! !
!ClassDescription categoriesFor: #profilerIconIndex!accessing!idb goodies!public! !
!ClassDescription categoriesFor: #stbReadFrom:format:!accessing!binary filing!public! !

!Class methodsFor!

comment: blahBlah
	"Set the class comment for the receiver to the readableString, blahBlah."

	self sourceManager storeCommentString: blahBlah forClass: self.
	self isChanged: true.
	"No need to clear the class caches in this case"
	self environment trigger: #classCommented: with: self!

isAbstract
	^(self whichMethodsReferTo: #subclassResponsibility) notEmpty 
		or: [(self class whichMethodsReferTo: #subclassResponsibility) notEmpty]! !
!Class categoriesFor: #comment:!accessing!development!public! !
!Class categoriesFor: #isAbstract!public!testing! !

!PackageEnvironment methodsFor!

classesDo: aBlock 
	"Note that the classes of the loose methods and the package's owned classes are non-overlapping sets, however since
	we (potentially) have multiple packages we have to be careful not to enumerate classes more than once as a result
	of them being both owned by a package in the environment, and having loose methods in another package in the
	environment (#1324)."

	| seen |
	seen := Set new.
	packages do: 
			[:eachPackage | 
			eachPackage behaviorsDo: 
					[:each | 
					(environment includesClass: each) 
						ifTrue: 
							[seen add: each name.	"#1324"
							aBlock value: each]].
			eachPackage methodNames do: 
					[:each | 
					| className |
					className := each key.
					(seen includes: className) 
						ifFalse: 
							[| class |
							class := (eachPackage behaviorFromName: className ifAbsent: []) instanceClass.
							(class notNil and: [environment includesClass: class]) 
								ifTrue: 
									["Both class and metaclass must be in the environment, regardless of the where loose methods reside."
									aBlock
										value: class;
										value: class class].
							seen
								add: class name;
								add: class class name]]]!

isSinglePackage
	^packages size = 1!

selectorsForClass: aClass do: aBlock 
	| name comparer |
	(self definesClass: aClass) 
		ifTrue: 
			[aClass selectorsAndMethodsDo: 
					[:eachSelector :eachMethod | 
					(eachMethod isLoose not and: [environment includesSelector: eachSelector in: aClass]) 
						ifTrue: [aBlock value: eachSelector]].
			"If only one package in the environment, can skip enumeration of loose methods since there cannot be any"
			self isSinglePackage ifTrue: [^self]].

	"#1325: Must enumerate any loose methods, regardless of whether one of the packages in this environment defines the class."
	comparer := SymbolStringSearchPolicy current.
	name := aClass displayString.
	packages do: 
			[:eachPackage | 
			eachPackage methodNames do: 
					[:each | 
					(comparer compare: each key with: name) 
						ifTrue: 
							[(environment includesSelector: each value in: aClass) ifTrue: [aBlock value: each value]]]]! !
!PackageEnvironment categoriesFor: #classesDo:!accessing/classes!public! !
!PackageEnvironment categoriesFor: #isSinglePackage!public!testing! !
!PackageEnvironment categoriesFor: #selectorsForClass:do:!accessing!public! !

ChunkBrowserExpressionChunk comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ChunkBrowserExpressionChunk methodsFor!

chunkText
	^Compiler syntaxColorOfExpression: rawText!

restore
	"Override for evaluations that don't automatically log"

	^self restoreAndLog: false!

restoreAndLog: aBoolean
	| answer |
	[Compiler evaluate: self rawText logged: aBoolean]
		on: CompilerNotification
		do:
			[:e | 
			answer := index -> e errorMessage.
			e resume].
	^answer! !
!ChunkBrowserExpressionChunk categoriesFor: #chunkText!accessing!public! !
!ChunkBrowserExpressionChunk categoriesFor: #restore!operations!public! !
!ChunkBrowserExpressionChunk categoriesFor: #restoreAndLog:!operations!public! !

ChunkBrowserSeriesChunk comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ChunkBrowserSeriesChunk methodsFor!

initializeFrom: aChunkBrowserSeriesStartChunk
	identity1 := aChunkBrowserSeriesStartChunk identity1! !
!ChunkBrowserSeriesChunk categoriesFor: #initializeFrom:!initializing!public! !

ChunkBrowserSeriesStartChunk comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ChunkBrowserSeriesStartChunk methodsFor!

initialize: aString
	| space |
	super initialize: aString.
	identity1 := self classNameFromRawText!

isChunkSeriesStart
	^true!

seriesChunk: aString
	| chunk |
	chunk := self seriesChunkClass fromText: aString.
	chunk initializeFrom: self.
	^chunk! !
!ChunkBrowserSeriesStartChunk categoriesFor: #initialize:!initializing!public! !
!ChunkBrowserSeriesStartChunk categoriesFor: #isChunkSeriesStart!public!testing! !
!ChunkBrowserSeriesStartChunk categoriesFor: #seriesChunk:!initializing!public! !

ChunkBrowserClassCommentChunk comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ChunkBrowserClassCommentChunk class methodsFor!

chunkType
	^#'Class Comment'!

isChunkClassFor: aString
	"Abc comment: ''''
	Don't check for trailing space in aString as the change log adds multiple entries for class
	comments - some delimited with a space but some with a crlf"

	| firstSpaceIndex |
	(firstSpaceIndex := aString indexOf: Character space) = 0 ifTrue: [^false].
	^(aString indexOfSubCollection: ' comment:') = firstSpaceIndex! !
!ChunkBrowserClassCommentChunk class categoriesFor: #chunkType!constants!public! !
!ChunkBrowserClassCommentChunk class categoriesFor: #isChunkClassFor:!public!testing! !

!ChunkBrowserClassCommentChunk methodsFor!

browseTarget
	^self identity1AsClass!

initialize: aString
	"Abc comment: ''"

	super initialize: aString.
	identity1 := rawText copyFrom: 1 to: (rawText indexOf: $ ).
	identity2 := String new.
	comment := rawText
		copyFrom: (rawText findFirst: [:each | each = $'])
		to: (rawText findLast: [:each | each = $'])!

isMatch
	^self identity1AsClass ifNotNil: [:arg | arg instanceClass comment printString = comment]! !
!ChunkBrowserClassCommentChunk categoriesFor: #browseTarget!operations!public! !
!ChunkBrowserClassCommentChunk categoriesFor: #initialize:!initializing!public! !
!ChunkBrowserClassCommentChunk categoriesFor: #isMatch!public!testing! !

ChunkBrowserClassDefineChunk comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ChunkBrowserClassDefineChunk class methodsFor!

chunkType
	^#'Class Define'!

isChunkClassFor: aString
	"Abd subclass: #Def instanceVariableNames: ''	classVariableNames: '' poolDictionaries: '' classInstanceVariableNames: ''
	Abd variableSubclass: #Def instanceVariableNames: ''	classVariableNames: '' poolDictionaries: '' classInstanceVariableNames: ''
	Abd variableByteSubclass: #Def instanceVariableNames: ''	classVariableNames: '' poolDictionaries: '' classInstanceVariableNames: ''"

	| firstSpaceIndex |
	(firstSpaceIndex := aString indexOf: Character space) = 0 ifTrue: [^false].
	^(#(' subclass: ' ' variableSubclass: ' ' variableByteSubclass: ')
		anySatisfy: [:each | (aString indexOfSubCollection: each) = firstSpaceIndex])
		and:
			[#('instanceVariableNames: ' 'classVariableNames: ' 'poolDictionaries: ' 'classInstanceVariableNames: ')
				allSatisfy: [:each | (aString indexOfSubCollection: each) ~= 0]]! !
!ChunkBrowserClassDefineChunk class categoriesFor: #chunkType!constants!public! !
!ChunkBrowserClassDefineChunk class categoriesFor: #isChunkClassFor:!public!testing! !

!ChunkBrowserClassDefineChunk methodsFor!

browseTarget
	^self identity1AsClass!

canShowDifferences
	^self identity1AsClass notNil!

initialize: aString
	"Abd subclass: #Def instanceVariableNames: ''	classVariableNames: '' poolDictionaries: '' classInstanceVariableNames: ''
	Abd variableSubclass: #Def instanceVariableNames: ''	classVariableNames: '' poolDictionaries: '' classInstanceVariableNames: ''
	Abd variableByteSubclass: #Def instanceVariableNames: ''	classVariableNames: '' poolDictionaries: '' classInstanceVariableNames: ''"

	| space1 space2 eol |
	super initialize: aString.
	space1 := rawText indexOf: $ .
	space2 := rawText
		nextIndexOf: $ 
		from: space1 + 1
		to: rawText size.
	eol := rawText
		nextIndexOf: String lineDelimiter first
		from: space2 + 1
		to: rawText size.
	identity1 := rawText copyFrom: space2 + 2 to: eol - 1.
	identity2 := rawText copyFrom: 1 to: space1 - 1!

isMatch
	^self identity1AsClass ifNotNil: [:arg | arg instanceClass definition = rawText]!

restore
	^self restoreAndLog: true!

sourceText
	^self identity1AsClass instanceClass coloredDefinition! !
!ChunkBrowserClassDefineChunk categoriesFor: #browseTarget!operations!public! !
!ChunkBrowserClassDefineChunk categoriesFor: #canShowDifferences!public!testing! !
!ChunkBrowserClassDefineChunk categoriesFor: #initialize:!initializing!public! !
!ChunkBrowserClassDefineChunk categoriesFor: #isMatch!public!testing! !
!ChunkBrowserClassDefineChunk categoriesFor: #restore!operations!public! !
!ChunkBrowserClassDefineChunk categoriesFor: #sourceText!accessing!public! !

ChunkBrowserClassDeleteChunk comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ChunkBrowserClassDeleteChunk class methodsFor!

chunkType
	^#'Class Delete'!

isChunkClassFor: aString
	"Abcd removeFromSystem"

	| firstSpaceIndex |
	(firstSpaceIndex := aString indexOf: Character space) = 0 ifTrue: [^false].
	^(aString indexOfSubCollection: ' removeFromSystem') = firstSpaceIndex! !
!ChunkBrowserClassDeleteChunk class categoriesFor: #chunkType!constants!public! !
!ChunkBrowserClassDeleteChunk class categoriesFor: #isChunkClassFor:!public!testing! !

!ChunkBrowserClassDeleteChunk methodsFor!

browseTarget
	^self identity1AsClass!

initialize: aString
	"Abcd removeFromSystem"

	super initialize: aString.
	identity1 := rawText copyFrom: 1 to: (rawText indexOf: $ ).
	identity2 := String new!

isMatch
	^self identity1AsClass isNil! !
!ChunkBrowserClassDeleteChunk categoriesFor: #browseTarget!operations!public! !
!ChunkBrowserClassDeleteChunk categoriesFor: #initialize:!initializing!public! !
!ChunkBrowserClassDeleteChunk categoriesFor: #isMatch!public!testing! !

ChunkBrowserClassGUIDChunk comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ChunkBrowserClassGUIDChunk class methodsFor!

chunkType
	^#'Class GUID'!

isChunkClassFor: aString
	"Abc guid: (GUID fromString: '{6AA41459-4B33-412A-95A7-261C78522521}'
	Abc guid: (IID fromString: '{6AA41459-4B33-412A-95A7-261C78522521}'
	Abc guid: (CLSID fromString: '{6AA41459-4B33-412A-95A7-261C78522521}'"

	| firstSpaceIndex |
	(firstSpaceIndex := aString indexOf: Character space) = 0 ifTrue: [^false].
	^(aString indexOfSubCollection: ' guid: (GUID fromString: ''{') = firstSpaceIndex
		or:
			[(aString indexOfSubCollection: ' guid: (IID fromString: ''{') = firstSpaceIndex
				or:
					[(aString indexOfSubCollection: ' guid: (CLSID fromString: ''{') = firstSpaceIndex]]! !
!ChunkBrowserClassGUIDChunk class categoriesFor: #chunkType!constants!public! !
!ChunkBrowserClassGUIDChunk class categoriesFor: #isChunkClassFor:!public!testing! !

!ChunkBrowserClassGUIDChunk methodsFor!

browseTarget
	^self identity1AsClass!

initialize: aString
	"Abc guid: (GUID fromString: '{6AA41459-4B33-412A-95A7-261C78522521}'
	Abc guid: (IID fromString: '{6AA41459-4B33-412A-95A7-261C78522521}'
	Abc guid: (CLSID fromString: '{6AA41459-4B33-412A-95A7-261C78522521}'"

	super initialize: aString.
	identity1 := rawText copyFrom: 1 to: (rawText indexOf: $ ).
	identity2 := String new.
	id := rawText
		copyFrom: (rawText findFirst: [:each | each = $']) + 1
		to: (rawText findLast: [:each | each = $']) - 1!

isMatch
	^self identity1AsClass ifNotNil: [:arg | arg instanceClass guid asString = id]! !
!ChunkBrowserClassGUIDChunk categoriesFor: #browseTarget!operations!public! !
!ChunkBrowserClassGUIDChunk categoriesFor: #initialize:!initializing!public! !
!ChunkBrowserClassGUIDChunk categoriesFor: #isMatch!public!testing! !

ChunkBrowserClassProtocolChunk comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ChunkBrowserClassProtocolChunk class methodsFor!

chunkType
	^#'Class Protocol'!

isChunkClassFor: aString
	"Abc methodProtocol: aSymbol attributes: anArrayOfSymbols selectors: anArrayOfSymbols
	Abc class methodProtocol: aSymbol attributes: anArrayOfSymbols selectors: anArrayOfSymbols"

	| firstSpaceIndex |
	(firstSpaceIndex := aString indexOf: Character space) = 0 ifTrue: [^false].
	^#(' methodProtocol: #' ' class methodProtocol: #')
		anySatisfy: [:each | (aString indexOfSubCollection: each) = firstSpaceIndex]! !
!ChunkBrowserClassProtocolChunk class categoriesFor: #chunkType!constants!public! !
!ChunkBrowserClassProtocolChunk class categoriesFor: #isChunkClassFor:!public!testing! !

!ChunkBrowserClassProtocolChunk methodsFor!

browseTarget
	^self identity1AsClass!

initialize: aString
	"Abc methodProtocol: aSymbol attributes: anArrayOfSymbols selectors: anArrayOfSymbols
	Abc class methodProtocol: aSymbol attributes: anArrayOfSymbols selectors: anArrayOfSymbols"

	| target1 target2 target3 |
	super initialize: aString.
	identity1 := self classNameFromRawText.
	target1 := aString indexOf: $#.
	target2 := aString indexOfSubCollection: 'attributes:'.
	target3 := aString indexOfSubCollection: 'selectors:'.
	identity2 := ((aString copyFrom: target1 to: target2 - 1) copyWithoutAll: '#''')
		trimBlanks.
	attributes := ((aString copyFrom: target2 + 'attributes:' size to: target3 - 1)
		copyWithoutAll: '#()') trimBlanks subStrings collect: [:each | each asSymbol].
	selectors := ((aString copyFrom: target3 + 'selectors:' size to: aString size)
		copyWithoutAll: '#()') trimBlanks subStrings collect: [:each | each asSymbol]!

isMatch
	^self identity1AsClass
		ifNotNil:
			[:arg | 
			(MethodProtocol exists: identity2)
				and:
					[| protocol |
					protocol := MethodProtocol name: identity2.
					(protocol selectors symmetricDifference: selectors) isEmpty
						and: [(protocol attributes symmetricDifference: attributes) isEmpty]]]! !
!ChunkBrowserClassProtocolChunk categoriesFor: #browseTarget!operations!public! !
!ChunkBrowserClassProtocolChunk categoriesFor: #initialize:!initializing!public! !
!ChunkBrowserClassProtocolChunk categoriesFor: #isMatch!public!testing! !

ChunkBrowserMethodDeleteChunk comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ChunkBrowserMethodDeleteChunk class methodsFor!

chunkType
	^#'Method Delete'!

isChunkClassFor: aString
	"	ClassName removeSelector: #SelectorSymbol
		ClassName class removeSelector: #SelectorSymbol
		ClassName removeSelector: #SelectorSymbol ifAbsent: []
		ClassName class removeSelector: #SelectorSymbol ifAbsent: []
		ClassName removeSelectors: #(SelectorSymbols)
		ClassName class removeSelectors: #(SelectorSymbols)"

	| firstSpaceIndex |
	(firstSpaceIndex := aString indexOf: Character space) = 0 ifTrue: [^false].
	^#(' removeSelector: #' ' class removeSelector: #' ' removeSelectors: #(' ' class removeSelectors: #(')
		anySatisfy: [:each | (aString indexOfSubCollection: each) = firstSpaceIndex]! !
!ChunkBrowserMethodDeleteChunk class categoriesFor: #chunkType!constants!public! !
!ChunkBrowserMethodDeleteChunk class categoriesFor: #isChunkClassFor:!public!testing! !

!ChunkBrowserMethodDeleteChunk methodsFor!

browseTarget
	^self identity1AndIdentity2AsCompiledMethod!

identity1AndIdentity2AsCompiledMethod
	"Overridden for browse"

	^self identity1AsClass
		ifNotNil:
			[:arg | 
			| selectors |
			selectors := identity2 subStrings.
			(selectors notEmpty and: [arg includesSelector: selectors first asSymbol])
				ifTrue: [arg compiledMethodAt: selectors first asSymbol]]!

initialize: aString
	"	ClassName removeSelector: #SelectorSymbol
		ClassName class removeSelector: #SelectorSymbol
		ClassName removeSelector: #SelectorSymbol ifAbsent: []
		ClassName class removeSelector: #SelectorSymbol ifAbsent: []
		ClassName removeSelectors: #(SelectorSymbols)
		ClassName class removeSelectors: #(SelectorSymbols)"

	| hashIndex |
	super initialize: aString.
	identity1 := self classNameFromRawText.
	hashIndex := aString indexOf: $#.
	identity2 := (aString indexOfSubCollection: #removeSelectors:) == 0
		ifTrue:
			[| stop |
			stop := aString
				nextIndexOf: Character space
				from: hashIndex
				to: aString size.
			aString copyFrom: hashIndex + 1 to: (stop == 0 ifTrue: [aString size] ifFalse: [stop])]
		ifFalse:
			[(aString
				copyFrom: hashIndex + 1
				to:
					(aString
						nextIndexOf: $)
						from: hashIndex
						to: aString size)) copyWithoutAll: '#()'].
	identity2 := identity2 trimBlanks	"PE/27/05/2004: remove trailing blank (thanks Pieter)"!

isMatch
	"Answer true if class missing as the method must be deleted?"

	^self identity1AsClass
		ifNil: [true]
		ifNotNil:
			[:arg | (identity2 subStrings anySatisfy: [:each | arg includesSelector: each asSymbol]) not]! !
!ChunkBrowserMethodDeleteChunk categoriesFor: #browseTarget!operations!public! !
!ChunkBrowserMethodDeleteChunk categoriesFor: #identity1AndIdentity2AsCompiledMethod!helpers!public! !
!ChunkBrowserMethodDeleteChunk categoriesFor: #initialize:!initializing!public! !
!ChunkBrowserMethodDeleteChunk categoriesFor: #isMatch!public!testing! !

ChunkBrowserOtherChunk comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ChunkBrowserOtherChunk class methodsFor!

chunkType
	^#Other! !
!ChunkBrowserOtherChunk class categoriesFor: #chunkType!constants!public! !

!ChunkBrowserOtherChunk methodsFor!

= aChunk
	^super = aChunk and: [rawText = aChunk rawText]!

canBrowse
	^false!

canFilterOnComparison
	^false!

chunkIconIndex
	"Override for no icon at all"

	^0!

chunkText
	"^self displayTextUsing: Color black"

	^Compiler syntaxColorOfExpression: rawText!

hash
	^super hash bitXor: rawText hash!

initialize: aString
	super initialize: aString.
	identity1 := String new.
	identity2 := String new.
	self initializeIdentity!

initializeIdentity
	| tidy |
	identity1 := (rawText first = $" and: [rawText last = $"])
		ifTrue: ['comment']
		ifFalse: ['evaluation'].
	tidy := rawText copyReplacing: Character cr withObject: $_.
	tidy := tidy copyWithout: Character lf.
	identity2 := tidy copyFrom: 1 to: (tidy size min: 100)!

isMatch
	^nil! !
!ChunkBrowserOtherChunk categoriesFor: #=!comparing!public! !
!ChunkBrowserOtherChunk categoriesFor: #canBrowse!public!testing! !
!ChunkBrowserOtherChunk categoriesFor: #canFilterOnComparison!public!testing! !
!ChunkBrowserOtherChunk categoriesFor: #chunkIconIndex!accessing!public! !
!ChunkBrowserOtherChunk categoriesFor: #chunkText!accessing!public! !
!ChunkBrowserOtherChunk categoriesFor: #hash!comparing!public! !
!ChunkBrowserOtherChunk categoriesFor: #initialize:!initializing!public! !
!ChunkBrowserOtherChunk categoriesFor: #initializeIdentity!initializing!public! !
!ChunkBrowserOtherChunk categoriesFor: #isMatch!public!testing! !

ChunkBrowserResourceDefineChunk comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ChunkBrowserResourceDefineChunk class methodsFor!

chunkType
	^#'Resource Define'!

isChunkClassFor: aString
	"(ResourceIdentifier class: DsdnDynamicPresenterAbstract name: 'Default view') assign: (Object fromBinaryStoreBytes:
(ByteArray fromHexString: 'BLAH'))
	NOTE embedded crlf"

	^(aString beginsWith: '(ResourceIdentifier class: ')
		and:
			[(aString indexOfSubCollection: ') assign: (') ~= 0
				and:
					[(aString
						indexOfSubCollection:
							##(' fromBinaryStoreBytes:' , String lineDelimiter , '(ByteArray fromHexString:'))
						~= 0]]! !
!ChunkBrowserResourceDefineChunk class categoriesFor: #chunkType!constants!public! !
!ChunkBrowserResourceDefineChunk class categoriesFor: #isChunkClassFor:!public!testing! !

!ChunkBrowserResourceDefineChunk methodsFor!

browseTarget
	^self identity1AndIdentity2AsResourceIdentifier!

initialize: aString
	"(ResourceIdentifier class: DsdnDynamicPresenterAbstract name: 'Default view') assign: (Object fromBinaryStoreBytes: (ByteArray fromHexString: 'BLAH'))"

	| target1 target2 target3 |
	super initialize: aString.
	target1 := '(ResourceIdentifier class: '.
	target2 := ' name: '.
	target3 := ') assign: ('.
	identity1 := aString
		copyFrom: (aString indexOfSubCollection: target1) + target1 size
		to: (aString indexOfSubCollection: target2) - 1.
	identity2 := aString
		copyFrom: (aString indexOfSubCollection: target2) + target2 size + 1
		to: (aString indexOfSubCollection: target3) - 2.
	chunkText := rawText
		copyFrom: (rawText indexOfSubCollection: '(ByteArray from')
		to: rawText size - 1!

isMatch
	^self identity1AndIdentity2AsResourceIdentifier
		ifNotNil:
			[:arg | 
			| stream |
			stream := String writeStream.
			(SessionManager current resourceManager resourceAt: arg) asInternalResource
				binaryStoreBytes hexStoreOn: stream.
			chunkText = stream contents]! !
!ChunkBrowserResourceDefineChunk categoriesFor: #browseTarget!operations!public! !
!ChunkBrowserResourceDefineChunk categoriesFor: #initialize:!initializing!public! !
!ChunkBrowserResourceDefineChunk categoriesFor: #isMatch!public!testing! !

ChunkBrowserResourceDeleteChunk comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ChunkBrowserResourceDeleteChunk class methodsFor!

chunkType
	^#'Resource Delete'!

isChunkClassFor: aString
	"SessionManager current resourceManager removeResource: (ResourceIdentifier class: Abcd name: 'name')"

	^aString
		beginsWith:
			'SessionManager current resourceManager removeResource: (ResourceIdentifier class: '! !
!ChunkBrowserResourceDeleteChunk class categoriesFor: #chunkType!constants!public! !
!ChunkBrowserResourceDeleteChunk class categoriesFor: #isChunkClassFor:!public!testing! !

!ChunkBrowserResourceDeleteChunk methodsFor!

browseTarget
	^self identity1AndIdentity2AsResourceIdentifier!

initialize: aString
	"SessionManager current resourceManager removeResource: (ResourceIdentifier class: Abcd name: 'name')"

	| target1 target2 target3 |
	super initialize: aString.
	target1 := '(ResourceIdentifier class: '.
	target2 := ' name: '.
	identity1 := aString
		copyFrom: (aString indexOfSubCollection: target1) + target1 size
		to: (aString indexOfSubCollection: target2) - 1.
	identity2 := aString
		copyFrom: (aString indexOfSubCollection: target2) + target2 size + 1
		to: aString size - 2!

isMatch
	^self identity1AndIdentity2AsResourceIdentifier isNil! !
!ChunkBrowserResourceDeleteChunk categoriesFor: #browseTarget!operations!public! !
!ChunkBrowserResourceDeleteChunk categoriesFor: #initialize:!initializing!public! !
!ChunkBrowserResourceDeleteChunk categoriesFor: #isMatch!public!testing! !

ChunkBrowserSystemChunk comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ChunkBrowserSystemChunk class methodsFor!

chunkType
	^#System!

isChunkClassFor: aString
	"
	''11:06:39, 03 April 2002: Dolphin Smalltalk
	''11:06:39, 03 April 2002: Loading package
	''11:06:39, 03 April 2002: Loading source package
	''11:06:39, 03 April 2002: Uninstalling package
	''11:06:39, 03 April 2002: Image saved
	''11:06:39, 03 April 2002: Compressed sources
	''11:06:39, 03 April 2002: Compressed changes
	''11:06:39, 03 April 2002: Compressing sources...
	"

	| stream |
	(aString size > 10 and: [aString first = $" and: [aString last = $"]]) ifFalse: [^false].
	stream := aString readStream.
	[Time readFrom: stream] on: InvalidFormat do: [:e | ^false].
	^(self symbolFor: aString) notNil!

symbolFor: aString
	| lookup |
	lookup := ##((Dictionary new)
			at: ': Dolphin Smalltalk' put: #imageStart;
			at: ': Loading package' put: #loadPackage;
			at: ': Loading source package' put: #loadPackage;
			at: ': Uninstalling package' put: #uninstallPackage;
			at: ': Image saved' put: #imageSave;
			at: ': Compressed sources' put: #compressedSources;
			at: ': Compressed changes' put: #compressedChanges;
			at: ': Compressing sources...' put: #compressedSources;
			yourself).
	^(lookup associations
		detect: [:each | (aString indexOfSubCollection: each key) ~= 0]
		ifNone: [^nil]) value! !
!ChunkBrowserSystemChunk class categoriesFor: #chunkType!constants!public! !
!ChunkBrowserSystemChunk class categoriesFor: #isChunkClassFor:!public!testing! !
!ChunkBrowserSystemChunk class categoriesFor: #symbolFor:!constants!public! !

!ChunkBrowserSystemChunk methodsFor!

compressedChanges
	identity1 := 'Compressed changes'!

compressedSources
	identity1 := 'Compressed sources'!

imageSave
	identity1 := 'Image save'!

imageStart
	identity1 := 'Image start'!

initializeIdentity
	"
	''11:06:39, 03 April 2002: Dolphin Smalltalk
	''11:06:39, 03 April 2002: Loading package
	''11:06:39, 03 April 2002: Loading source package
	''11:06:39, 03 April 2002: Uninstalling package
	''11:06:39, 03 April 2002: Image saved
	''11:06:39, 03 April 2002: Compressed sources
	''11:06:39, 03 April 2002: Compressed changes
	"

	| terminate |
	self perform: (self class symbolFor: rawText).
	(identity2 isEmpty and: [(terminate := rawText indexOfSubCollection: ': ') ~= 0])
		ifTrue: [identity2 := rawText copyFrom: 2 to: terminate - 1]!

isImageSave
	^identity1 = 'Image save'!

loadPackage
	"11:28:22, 06 April 2002: Loading package 'DSDN' from: C:\Documents and Settings\Ian\My Documents\Dolphin Smalltalk 5.0\DSDN\DSDN.pac"

	identity1 := 'Load package'.
	identity2 := self packageName!

packageName
	| quoteIndex |
	quoteIndex := (rawText indexOf: $') + 1.
	^rawText
		copyFrom: quoteIndex
		to:
			(rawText
				nextIndexOf: $'
				from: quoteIndex
				to: rawText size) - 1!

restore
	^nil!

uninstallPackage
	"15:15:09, 07 April 2002: Uninstalling package 'ChunkBrowser'"

	identity1 := 'Uninstall package'.
	identity2 := self packageName! !
!ChunkBrowserSystemChunk categoriesFor: #compressedChanges!operations!public! !
!ChunkBrowserSystemChunk categoriesFor: #compressedSources!operations!public! !
!ChunkBrowserSystemChunk categoriesFor: #imageSave!operations!public! !
!ChunkBrowserSystemChunk categoriesFor: #imageStart!operations!public! !
!ChunkBrowserSystemChunk categoriesFor: #initializeIdentity!initializing!public! !
!ChunkBrowserSystemChunk categoriesFor: #isImageSave!public!testing! !
!ChunkBrowserSystemChunk categoriesFor: #loadPackage!operations!public! !
!ChunkBrowserSystemChunk categoriesFor: #packageName!helpers!public! !
!ChunkBrowserSystemChunk categoriesFor: #restore!operations!public! !
!ChunkBrowserSystemChunk categoriesFor: #uninstallPackage!operations!public! !

ChunkBrowserResourceDefineChunkBase64 comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ChunkBrowserResourceDefineChunkBase64 class methodsFor!

isChunkClassFor: aString
	"(ResourceIdentifier class: DsdnDynamicPresenterAbstract name: 'Default view') assign: (Object fromBinaryStoreBytes:
(ByteArray fromBase64String: 'BLAH'))
	NOTE embedded crlf
	Needed for D5.1.4 onwards"

	^(aString beginsWith: '(ResourceIdentifier class: ')
		and:
			[(aString indexOfSubCollection: ') assign: (') ~= 0
				and:
					[(aString
						indexOfSubCollection:
							##(' fromBinaryStoreBytes:' , String lineDelimiter , '(ByteArray fromBase64String:'))
						~= 0]]! !
!ChunkBrowserResourceDefineChunkBase64 class categoriesFor: #isChunkClassFor:!public!testing! !

!ChunkBrowserResourceDefineChunkBase64 methodsFor!

isMatch
	"Needed for D5.1.4 onwards"

	^self identity1AndIdentity2AsResourceIdentifier
		ifNotNil:
			[:arg | 
			| stream |
			stream := String writeStream.
			(SessionManager current resourceManager resourceAt: arg) asInternalResource
				binaryStoreBytes base64StoreOn: stream.
			chunkText = stream contents]! !
!ChunkBrowserResourceDefineChunkBase64 categoriesFor: #isMatch!public!testing! !

ChunkBrowserCategoryChunk comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ChunkBrowserCategoryChunk methodsFor!

chunkText
	^self displayTextUsing: Color blue!

initializeFrom: aChunkBrowserSeriesStartChunk
	super initializeFrom: aChunkBrowserSeriesStartChunk.
	identity2 := aChunkBrowserSeriesStartChunk identity2! !
!ChunkBrowserCategoryChunk categoriesFor: #chunkText!accessing!public! !
!ChunkBrowserCategoryChunk categoriesFor: #initializeFrom:!initializing!public! !

ChunkBrowserMethodDefineChunk comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ChunkBrowserMethodDefineChunk class methodsFor!

chunkType
	^#'Method Define'! !
!ChunkBrowserMethodDefineChunk class categoriesFor: #chunkType!constants!public! !

!ChunkBrowserMethodDefineChunk methodsFor!

browseTarget
	^self identity1AndIdentity2AsCompiledMethod!

canShowDifferences
	^self identity1AndIdentity2AsCompiledMethod notNil!

chunkText
	^self identity1AsClass
		ifNil: [super displayTextUsing: Color red]
		ifNotNil: [:arg | Compiler syntaxColorOfMethod: rawText in: arg]!

initializeFrom: aChunkBrowserSeriesStartChunk
	super initializeFrom: aChunkBrowserSeriesStartChunk.
	identity2 := SelectorParser parse: rawText!

isMatch
	^self identity1AndIdentity2AsCompiledMethod
		ifNotNil:
			[:arg | 
			arg getSource = rawText
				or:
					[ChunkBrowser compareMethodsUsingParser
						and:
							[arg parseTree
								=
									(SmalltalkParser
										parseMethod: rawText
										in: self identity1AsClass
										onError: [:aString :pos | ^nil])]]]!

restore
	| answer |
	self identity1AsClass
		ifNil: [answer := index -> 'Target class missing']
		ifNotNil:
			[:arg | 
			[arg compile: self rawText]
				on: CompilerNotification
				do:
					[:e | 
					answer := index -> e errorMessage.
					e resume]].
	^answer!

sourceText
	^self identity1AndIdentity2AsCompiledMethod getColoredSource! !
!ChunkBrowserMethodDefineChunk categoriesFor: #browseTarget!operations!public! !
!ChunkBrowserMethodDefineChunk categoriesFor: #canShowDifferences!public!testing! !
!ChunkBrowserMethodDefineChunk categoriesFor: #chunkText!accessing!public! !
!ChunkBrowserMethodDefineChunk categoriesFor: #initializeFrom:!initializing!public! !
!ChunkBrowserMethodDefineChunk categoriesFor: #isMatch!public!testing! !
!ChunkBrowserMethodDefineChunk categoriesFor: #restore!operations!public! !
!ChunkBrowserMethodDefineChunk categoriesFor: #sourceText!accessing!public! !

ChunkBrowserClassCategoryChunk comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ChunkBrowserClassCategoryChunk class methodsFor!

chunkType
	^#'Class Category'! !
!ChunkBrowserClassCategoryChunk class categoriesFor: #chunkType!constants!public! !

!ChunkBrowserClassCategoryChunk methodsFor!

= aChunk
	^super = aChunk and: [rawText = aChunk rawText]!

browseTarget
	^self identity1AsClass!

hash
	^super hash bitXor: rawText hash!

isMatch
	^self identity1AsClass
		ifNotNil:
			[:arg | 
			| categories |
			categories := arg instanceClass categories collect: [:each | each name].
			categories anySatisfy: [:each | each = rawText]]!

restore
	| answer |
	self identity1AsClass
		ifNil: [answer := index -> 'Target class missing']
		ifNotNil: [:arg | (ClassCategory name: rawText) addClass: arg].
	^answer! !
!ChunkBrowserClassCategoryChunk categoriesFor: #=!comparing!public! !
!ChunkBrowserClassCategoryChunk categoriesFor: #browseTarget!operations!public! !
!ChunkBrowserClassCategoryChunk categoriesFor: #hash!comparing!public! !
!ChunkBrowserClassCategoryChunk categoriesFor: #isMatch!public!testing! !
!ChunkBrowserClassCategoryChunk categoriesFor: #restore!operations!public! !

ChunkBrowserMethodCategoryChunk comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ChunkBrowserMethodCategoryChunk class methodsFor!

chunkType
	^#'Method Category'! !
!ChunkBrowserMethodCategoryChunk class categoriesFor: #chunkType!constants!public! !

!ChunkBrowserMethodCategoryChunk methodsFor!

browseTarget
	^self identity1AndIdentity2AsCompiledMethod!

isMatch
	^self identity1AndIdentity2AsCompiledMethod
		ifNotNil:
			[:arg | 
			| categories |
			categories := arg categories collect: [:each | each name].
			categories anySatisfy: [:each | each = rawText]]!

restore
	| answer |
	self identity1AndIdentity2AsCompiledMethod
		ifNil: [answer := index -> 'Target class or method missing']
		ifNotNil: [:arg | (MethodCategory name: rawText) addMethod: arg].
	^answer! !
!ChunkBrowserMethodCategoryChunk categoriesFor: #browseTarget!operations!public! !
!ChunkBrowserMethodCategoryChunk categoriesFor: #isMatch!public!testing! !
!ChunkBrowserMethodCategoryChunk categoriesFor: #restore!operations!public! !

ChunkBrowserClassCategorySeriesStartChunk comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ChunkBrowserClassCategorySeriesStartChunk class methodsFor!

isChunkClassFor: aString
	"Abc categoriesForClass"

	| firstSpaceIndex |
	(firstSpaceIndex := aString indexOf: Character space) = 0 ifTrue: [^false].
	^(aString indexOfSubCollection: ' categoriesForClass') = firstSpaceIndex! !
!ChunkBrowserClassCategorySeriesStartChunk class categoriesFor: #isChunkClassFor:!public!testing! !

!ChunkBrowserClassCategorySeriesStartChunk methodsFor!

initialize: aString
	"Abc categoriesForClass"

	super initialize: aString.
	identity2 := String new!

seriesChunkClass
	^ChunkBrowserClassCategoryChunk! !
!ChunkBrowserClassCategorySeriesStartChunk categoriesFor: #initialize:!initializing!public! !
!ChunkBrowserClassCategorySeriesStartChunk categoriesFor: #seriesChunkClass!constants!public! !

ChunkBrowserMethodCategorySeriesStartChunk comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ChunkBrowserMethodCategorySeriesStartChunk class methodsFor!

isChunkClassFor: aString
	"'Abc categoriesFor: #abc' or 'Abc class categoriesFor: #abc'"

	| firstSpaceIndex |
	(firstSpaceIndex := aString indexOf: Character space) = 0 ifTrue: [^false].
	^(aString indexOfSubCollection: ' categoriesFor: #') = firstSpaceIndex
		or: [(aString indexOfSubCollection: ' class categoriesFor: #') = firstSpaceIndex]! !
!ChunkBrowserMethodCategorySeriesStartChunk class categoriesFor: #isChunkClassFor:!public!testing! !

!ChunkBrowserMethodCategorySeriesStartChunk methodsFor!

initialize: aString
	"'Abc categoriesFor: #abc' or 'Abc class categoriesFor: #abc'"

	super initialize: aString.
	identity2 := aString copyFrom: (aString indexOf: $#) + 1!

seriesChunkClass
	^ChunkBrowserMethodCategoryChunk! !
!ChunkBrowserMethodCategorySeriesStartChunk categoriesFor: #initialize:!initializing!public! !
!ChunkBrowserMethodCategorySeriesStartChunk categoriesFor: #seriesChunkClass!constants!public! !

ChunkBrowserMethodDefineSeriesStartChunk comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ChunkBrowserMethodDefineSeriesStartChunk class methodsFor!

isChunkClassFor: aString
	"'Abc methodsFor' or 'Abc class methodsFor'"

	| firstSpaceIndex |
	(firstSpaceIndex := aString indexOf: Character space) = 0 ifTrue: [^false].
	^(aString indexOfSubCollection: ' methodsFor') = firstSpaceIndex
		or: [(aString indexOfSubCollection: ' class methodsFor') = firstSpaceIndex]! !
!ChunkBrowserMethodDefineSeriesStartChunk class categoriesFor: #isChunkClassFor:!public!testing! !

!ChunkBrowserMethodDefineSeriesStartChunk methodsFor!

initialize: aString
	"'Abc methodsFor' or 'Abc class methodsFor'"

	super initialize: aString.
	identity2 := String new!

seriesChunkClass
	^ChunkBrowserMethodDefineChunk! !
!ChunkBrowserMethodDefineSeriesStartChunk categoriesFor: #initialize:!initializing!public! !
!ChunkBrowserMethodDefineSeriesStartChunk categoriesFor: #seriesChunkClass!constants!public! !

!SequenceableCollection methodsFor!

associations
	"Answer a <SequenceableCollection>, like the receiver, containing the receiver's associations."

	"Implementation Note: SequenceableCollections don't actually contain associations so the result 
	is built afresh each time and modifying its contents will not affect the original collection. However
	this is no different to the implementation for LookupTable/IdentityDictionary."

	| answer |
	answer := self copyLikeOfSize: self copySize.
	self keysAndValuesDo: [:i :each | answer at: i put: i -> each].
	^answer!

from: startInteger to: stopInteger keysAndValuesDo: operation 
	"Evaluate the <dyadicValuable>, operation, for each element of the receiver
	between the <integer> indices, start and stop, inclusive with the element and its
	index as respectively the second and first arguments."

	"Implementation Note: Do the bounds check up front to avoid the need to check
	on each access."

	startInteger < 1 ifTrue: [self errorSubscriptBounds: startInteger].
	stopInteger > self size ifTrue: [self errorSubscriptBounds: stopInteger].
	self 
		uncheckedFrom: startInteger
		to: stopInteger
		keysAndValuesDo: operation!

includesAnyOf: aCollection 
	"Answer whether the receiver includes any of the elements in the <collection> argument."

	^(self indexOfAnyOf: aCollection startingAt: 1) ~~ 0!

indexOfAnyOf: aCollection startingAt: anInteger 
	"Answer the one-based integer index of the first encountered element of the receiver which 
	is equal to one of the elements of the <Collection> argument, starting from the specified
	one-based <integer> index. If no occurrences are found, then answer 0."

	self from: anInteger
		keysAndValuesDo: [:i :elem | (aCollection includes: elem) ifTrue: [^i]].
	^0!

inverseMatchVector: matchVector
	"If matchVector maps the matching elements of another collection onto me, compute the matchVector that maps me onto the collection."

	| inverseMatchVector |
	#idbAdded.
	inverseMatchVector := Array new: self size.
	1
		to: matchVector size
		do: [:i | (matchVector at: i) ifNotNil: [:arg | inverseMatchVector at: arg put: i]].
	^inverseMatchVector!

longestCommonSubsequenceInInterval: aInterval withCollection: anOrderedCollection inInterval: bInterval
	"This method computes the longest common subsequence in self and anOrderedCollection, restricted to aInterval and bInterval respectively.  It uses the algorithm described in A Fast Algorithm for Computing Longest Common Subsequences, CACM, vol.20, no.5, pp.350-353, May 1977, with a few minor improvements to improve the speed."

	"First we prune off any common elements at the beginning or end."

	| aStart aFinish bStart bFinish matchVector bMatches thresh ai k link links |
	#idbAdded.
	aStart := aInterval first.
	aFinish := aInterval last.
	bStart := bInterval first.
	bFinish := bInterval last.
	matchVector := Array new: aInterval size.
	[(aStart <= aFinish and: [bStart <= bFinish])
		and: [(self at: aStart) = (anOrderedCollection at: bStart)]]
		whileTrue:
			[matchVector at: aStart - aInterval first + 1 put: bStart.
			aStart := aStart + 1.
			bStart := bStart + 1].	"now the end"
	[(aStart <= aFinish and: [bStart <= bFinish])
		and: [(self at: aFinish) = (anOrderedCollection at: bFinish)]]
		whileTrue:
			[matchVector at: aFinish - aInterval first + 1 put: bFinish.
			aFinish := aFinish - 1.
			bFinish := bFinish - 1].	"Now compute the equivalence classes of positions of elements"
	bMatches := Dictionary
		withPositionsOf: anOrderedCollection
		inInterval: (bStart to: bFinish).
	thresh := SortedCollection new sortBlock: [:x :y | x < y].
	links := Array new: (aFinish - aStart + 1 min: bFinish - bStart + 1).
	aStart
		to: aFinish
		do:
			[:i | 
			ai := self at: i.
			(bMatches includesKey: ai)
				ifTrue:
					[(bMatches at: ai)
						reverseDo:
							[:j | 
							k := thresh replaceNextLargerWith: j.
							k notNil
								ifTrue:
									[link := DiffLink new.
									k > 1 ifTrue: [link nextLink: (links at: k - 1)].
									link value: (Array with: i with: j).
									links at: k put: link]]]].
	thresh size > 0
		ifTrue:
			[link := links at: thresh size.
			[matchVector at: (link value at: 1) put: (link value at: 2).
			link nextLink notNil] whileTrue: [link := link nextLink]].
	^matchVector!

uncheckedFrom: startInteger to: stopInteger keysAndValuesDo: aDyadicValuable 
	"Private - Evaluate the <dyadicValuable> argument for each element of the receiver in the
	specified inclusive range, with the element and its index as respectively the second and
	first arguments. No bounds checks need be performed since the caller has established that
	the start and stop indices are in bounds."

	"Implementation Note: Subclasses should override this method in order to replace all #do:
	family enumerators (#do:, #keysAndValuesDo:, #from:to:do:, and, of course,
	#from:to:keysAndValuesDo:). Subclasses may also want to override this if they have a slow
	implementation of the random accessor method #at:, but can be more efficiently accessed
	serially (e.g. a singly Linked List), or if they have to calculate their size using
	#countElements (which would cause an infinite recursion as it uses #do:, which uses #size,
	...)."

	startInteger to: stopInteger do: [:i | aDyadicValuable value: i value: (self at: i)]! !
!SequenceableCollection categoriesFor: #associations!accessing!public! !
!SequenceableCollection categoriesFor: #from:to:keysAndValuesDo:!enumerating!public! !
!SequenceableCollection categoriesFor: #includesAnyOf:!public!searching! !
!SequenceableCollection categoriesFor: #indexOfAnyOf:startingAt:!public!searching! !
!SequenceableCollection categoriesFor: #inverseMatchVector:!diff!idb goodies!public! !
!SequenceableCollection categoriesFor: #longestCommonSubsequenceInInterval:withCollection:inInterval:!idb goodies!operations!public! !
!SequenceableCollection categoriesFor: #uncheckedFrom:to:keysAndValuesDo:!enumerating!private! !

!ADOCollection methodsFor!

at: aStringOrInteger 
	"Answer the element of the receiver with the specified subscript. The subscript could be the
	one-based <integer> index of the element in the collection, or the <readableString> name of
	an element."

	"Implementation Note: Assume the underlying collection uses zero based indices."

	^interface 
		item: (aStringOrInteger isInteger ifTrue: [aStringOrInteger - 1] ifFalse: [aStringOrInteger])! !
!ADOCollection categoriesFor: #at:!accessing!public! !

!DBResultSet methodsFor!

approxSize
	"Private - Answer the approximate size of the receiver."

	"Implementation Note: It is very important that this be a quick calculation (indeed that 
	is the whole point of the #approxSize message). Calculating the size of a result set can 
	be slow, indeed it can involve enumerating the entire result set in the worst case, 
	and so we must override for acceptable performance."

	| rowCount |
	rowCount := self numRows.
	^rowCount < 0 ifTrue: [50] ifFalse: [rowCount]!

findLast: discriminator 
	"Answer the <integer> index of the last element of the receiver for which the 
	<monadicValuable> argument, discriminator, evaluates to true. If there are 
	If there are no such elements, answer 0."

	^self numRows < 0 
		ifTrue: 
			[| last |
			last := 0.
			self keysAndValuesDo: [:i :row | (discriminator value: row) ifTrue: [last := i]].
			last]
		ifFalse: [super findLast: discriminator]!

size
	"Answer the size of the receiver's result set."

	"Implemementation Note: ODBC drivers cannot always report the number of rows for a 
	SELECT statement in which case they return -1 (SQL Anywhere's driver has a bug and 
	may return another negative number hence we test for < 0), so we must then enumerate 
	the entire result set to count the elements. This behaviour makes it necessary to override 
	a number of superclass messages to avoid the use of #size, as otherwise performance will 
	be poor."

	| rowCount |
	rowCount := self numRows.
	^rowCount < 0 ifTrue: [self countElements] ifFalse: [rowCount]!

with: otherCollection do: operation 
	"Evaluate the <dyadicValuable> argument, operation, with each of 
	the receiver's elements along with the corresponding element from the 
	<sequencedReadableCollection> argument, otherCollection. 
	Raise an exception if otherCollection is not the same size as the receiver."

	"Implementation Note: Override because calculating the receiver's size may involve 
	enumerating the entire record set. This implementation is more efficient, but does
	mean that we won't detect any size mismatch until we have enumerated elements
	up to the size of the smaller of the two collection."

	| i |
	i := 1.
	self rawDo: 
			[operation value: buffer asObject value: (otherCollection at: i).
			i := i + 1].
	i > otherCollection size ifFalse: [^self error: 'collections are of different sizes']! !
!DBResultSet categoriesFor: #approxSize!accessing!private! !
!DBResultSet categoriesFor: #findLast:!public!searching! !
!DBResultSet categoriesFor: #size!accessing!public! !
!DBResultSet categoriesFor: #with:do:!enumerating!public! !

!Interval class methodsFor!

newAspect: aspectClass name: aSymbol 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
    	which is appropriate for representing aspects of the receiver's type."

	^(aspectClass collection: aSymbol)
		beReadOnly;
		yourself! !
!Interval class categoriesFor: #newAspect:name:!adapters!development!private! !

!Interval methodsFor!

= anObject 
	"Answer whether the receiver and the <Object>, comparand, 
	are considered equivalent (that is they contain the same number
	of equivalent objects in the same order, and are of like class).
	The supersend ensures that expressions such as '(1 to: 5) = #(1 2 3 4 5)' are true"

	^(anObject isKindOf: self class) 
		ifTrue: [start = anObject start and: [step = anObject step and: [self size = anObject size]]]
		ifFalse: [super = anObject]!

storeOn: aStream 
	"Append to the <puttableStream> argument, target, an expression which when 
	evaluated will answer a collection similar to the receiver."

	self printOn: aStream!

uncheckedFrom: startInteger to: stopInteger keysAndValuesDo: aDyadicValuable 
	"Private - Evaluate the <dyadicValuable> argument for each element of the receiver
	between the specified <integer> indices, inclusive, with the element and its index as
	respectively the second and first arguments. No bounds checks are performed."

	"Implementation Note: Override because #at: is relative slow on Intervals. By overriding
	this one method we effectively replace the implementation of all the #do: family of
	enumerators."

	startInteger to: stopInteger do: [:i | aDyadicValuable value: i value: start + (step * (i - 1))]! !
!Interval categoriesFor: #=!comparing!public! !
!Interval categoriesFor: #storeOn:!printing!public! !
!Interval categoriesFor: #uncheckedFrom:to:keysAndValuesDo:!enumerating!private! !

!Array methodsFor!

storeOn: aStream 
	"Append to the <puttableStream> argument, target, an expression which when 
	evaluated will answer a collection similar to the receiver."

	"Implementation Note: The receiver has a compact literal form, so use that. Any
	elements that are not themselves representable as literals are embedded as 
	expressions to be evaluated at compile time, i.e. using ##()."

	aStream nextPutAll: '#('.
	self do: 
			[:each | 
			each isLiteral 
				ifTrue: [each storeOn: aStream]
				ifFalse: 
					[aStream nextPutAll: '##('.
					each storeOn: aStream.
					aStream nextPut: $)]]
		separatedBy: 
			[aStream
				cr;
				space].
	aStream nextPut: $)! !
!Array categoriesFor: #storeOn:!printing!public! !

!ByteArray class methodsFor!

fromBase64String: aString 
	| stream |
	stream := self writeStream: (aString size * 0.75) truncated.
	Base64Codec decodeFrom: aString readStream onto: stream.
	^stream contents!

stbReadFrom: anSTBInFiler format: anSTBClassConversion 
	"Read an instance of the receiver from the binary filer, aSTBInFiler. Note that we can
	ignore the format argument, since ByteArray is a pre-registered class that cannot be
	versioned. The format we read here is the same as that which would be read by the in-filer
	itself, but we can do the job more efficiently since we know that a block read from the
	stream is possible."

	| stream size answer |
	stream := anSTBInFiler stream.
	size := stream nextSDWORD.
	answer := stream next: size.
	anSTBInFiler register: answer.
	^answer! !
!ByteArray class categoriesFor: #fromBase64String:!instance creation!public! !
!ByteArray class categoriesFor: #stbReadFrom:format:!binary filing!public! !

!ByteArray methodsFor!

base64StoreOn: puttableStream 
	puttableStream
		nextPut: $(;
		print: self class;
		space;
		nextPutAll: #fromBase64String:;
		space;
		nextPut: $'.
	self printBase64On: puttableStream.
	puttableStream nextPutAll: ''')'!

basicDwordAtOffset: anInteger put: anObject 
	"Private - Replace the internal contents of the receiver from offset anInteger with
	the first 4 bytes of anObject."

	<primitive: 121>
	(self validateOffset: anInteger) == 2 
		ifTrue: 
			["Not a suitable value - could be non-Numeric, or not in unsigned 32-bit range.
			Atempt to coerce to Integer and retry. anObject may not understand asInteger."
			| intVal |
			intVal := anObject asInteger.
			(intVal >= 0 and: [intVal <= 16rFFFFFFFF]) 
				ifTrue: [^self basicDwordAtOffset: anInteger put: intVal]].
	^self errorCantHold: anObject!

printBase64On: aStream 
	"Append a base64 string representation of the receiver to the <puttableStream> argument."

	Base64Codec encodeFrom: self readStream onto: aStream!

retryDwordAtOffset: anInteger put: anObject 
	"Private - Fallback code for storing unsigned 32-bit integer into the receiver when a
	primitive fails. Either raises an appropriate error, or converts the argument to an Integer
	and retries."

	(self validateOffset: anInteger) == 2 
		ifTrue: 
			["Not a suitable value - could be non-Numeric, or not in unsigned 32-bit
			 range. Attempt to coerce to Integer and retry. anObject may not understand
			 asInteger."
			| intVal |
			intVal := anObject asInteger.
			(intVal >= 0 and: [intVal <= 16rFFFFFFFF]) ifTrue: [^self dwordAtOffset: anInteger put: intVal]].
	^self errorCantHold: anObject!

retryWordAtOffset: anInteger put: anObject 
	"Private - Fallback code for storing unsigned word into the receiver when a primitive fails.
	Either raises an appropriate error, or converts the argument to an Integer and retries."

	(self validateOffset: anInteger) == 2 
		ifTrue: 
			["Not a suitable value - could be non-Numeric, or not in unsigned 16-bit
			 range. Attempt to coerce to Integer and retry. anObject may not understand
			 asInteger."
			| int |
			int := anObject asInteger.
			(int >= 0 and: [int <= 16rFFFF]) ifTrue: [^self wordAtOffset: anInteger put: int]].
	^self errorCantHold: anObject!

stbSaveOn: anSTBOutFiler 
	"Save out a binary representation of the receiver to anSTBOutFiler.
	We override because we know we can use a block write here. The format
	of the serialized byte array in the resulting STB stream is the same though."

	| size |
	anSTBOutFiler writePreambleFor: self.
	size := self basicSize.
	anSTBOutFiler writeInteger: size.
	anSTBOutFiler stream 
		next: size
		putAll: self
		startingAt: 1! !
!ByteArray categoriesFor: #base64StoreOn:!printing!public! !
!ByteArray categoriesFor: #basicDwordAtOffset:put:!accessing!primitives!private! !
!ByteArray categoriesFor: #printBase64On:!printing!public! !
!ByteArray categoriesFor: #retryDwordAtOffset:put:!accessing!private! !
!ByteArray categoriesFor: #retryWordAtOffset:put:!accessing!private! !
!ByteArray categoriesFor: #stbSaveOn:!binary filing!public! !

!String methodsFor!

asHexText
	"Converts? the receiver into a string containing the hex representation of the receiver"

	| stream |
	#idbAdded.
	stream := String writeStream.
	0
		to: self size - 1
		by: 16
		do:
			[:index | 
			stream nextPutAll: ('%08x  ' sprintfWith: index).
			0
				to: 15
				do:
					[:offset | 
					index + offset + 1 <= self size
						ifTrue: [stream nextPutAll: ('%02x ' sprintfWith: (self at: index + offset + 1))]
						ifFalse: [stream nextPutAll: '   ']].
			0
				to: 15
				do:
					[:offset | 
					index + offset + 1 <= self size
						ifTrue:
							[((self at: index + offset + 1) isPrintable
								and: [(self at: index + offset + 1) ~= Character tab])
								ifTrue: [stream nextPut: (self at: index + offset + 1)]
								ifFalse: [stream nextPut: $.]]].
			stream cr].
	^stream contents!

expandMacros
	^self expandMacrosWithArguments: #()!

expandMacrosWith: anObject 
	^self expandMacrosWithArguments: (Array with: anObject)!

expandMacrosWith: anObject with: anotherObject 
	^self expandMacrosWithArguments: (Array with: anObject with: anotherObject)!

expandMacrosWith: anObject with: anotherObject with: thirdObject 
	^self expandMacrosWithArguments: (Array
			with: anObject
			with: anotherObject
			with: thirdObject)!

expandMacrosWith: anObject with: anotherObject with: thirdObject with: fourthObject 
	^self expandMacrosWithArguments: (Array
			with: anObject
			with: anotherObject
			with: thirdObject
			with: fourthObject)!

expandMacrosWithArguments: anArray 
	| newStream readStream index |
	newStream := WriteStream on: (String new: self size).
	readStream := ReadStream on: self.
	[readStream atEnd] whileFalse: 
			[| char |
			char := readStream next.
			char == $< 
				ifTrue: 
					[| nextChar |
					nextChar := readStream next asUppercase.
					nextChar == $N ifTrue: [newStream cr].
					nextChar == $T ifTrue: [newStream tab].
					nextChar isDigit 
						ifTrue: 
							[index := nextChar digitValue.
							[readStream atEnd or: [(nextChar := readStream next asUppercase) isDigit not]] 
								whileFalse: [index := index * 10 + nextChar digitValue]].
					nextChar == $? 
						ifTrue: 
							[| trueString falseString |
							trueString := readStream upTo: $:.
							falseString := readStream upTo: $>.
							readStream position: readStream position - 1.
							newStream nextPutAll: ((anArray at: index) ifTrue: [trueString] ifFalse: [falseString])].
					nextChar == $P ifTrue: [newStream nextPutAll: (anArray at: index) printString].
					nextChar == $S ifTrue: [newStream nextPutAll: (anArray at: index)].
					readStream skipTo: $>]
				ifFalse: [newStream nextPut: (char == $% ifTrue: [readStream next] ifFalse: [char])]].
	^newStream contents!

indexOfAnyOf: characters startingAt: start 
	"Answer the one-based integer index of the first encountered element of the receiver which 
	is equal to one of the characters in the <readableString>, characters, starting from the one-based
	<integer> index, start, in the receiver. If no occurrences are found, then answer 0."

	| span |
	span := self strcspn: characters start: start.
	^span + start > self size 
		ifTrue: [0]
		ifFalse: 
			["CRT function will stop if it hits a null embedded in the string, so we must fall back
			on slower superclass implementation in that case."
			^(self basicAt: span + start) == 0 
				ifTrue: [super indexOfAnyOf: characters startingAt: start]
				ifFalse: [span + start]]!

strcspn: aString start: anInteger 
	^CRTLibrary default strcspn: self yourAddress + anInteger - 1 strCharSet: aString!

trimZeros
	"Answer the receiver but with trailing 0s removed from the fractional part (if any).
	xxxx.0123 -> xxx.0123
	xxxx.0123000 -> xxxx.0123
	xxxx.0000 -> xxxx.0
	xxxx.0 -> xxxx.0
	xxx0 -> xxx0"

	| index |
	#idbAdded.
	(self includes: $.) ifFalse: [^self copy].
	index := self size.
	[(self at: index) = $0 and: [index > 1 and: [(self at: index - 1) isDigit]]]
		whileTrue:
			[self at: index put: Character space.
			index := index - 1].
	^self trimBlanks!

unescapePercents
	"Answer a copy of the receiver with each %XY substring replaced by 
	the character with hex ASCII value XY and $+'s replaced by spaces."

	| answer pos oldPos |
	answer := self species writeStream: self size.
	oldPos := 1.
	
	[pos := self indexOfAnyOf: '+%' startingAt: oldPos.
	pos > 0] whileTrue: 
				[| char |
				answer 
					next: pos - oldPos
					putAll: self
					startingAt: oldPos.
				char := self at: pos.
				char == $+ 
					ifTrue: [answer nextPut: $ ]
					ifFalse: 
						[(char == $% and: [pos + 2 <= self size]) 
							ifTrue: 
								[| digit1 digit2 |
								digit1 := (self at: pos + 1) asUppercase.
								digit2 := (self at: pos + 2) asUppercase.
								(digit1 isHexDigit and: [digit2 isHexDigit]) ifFalse: [^self].	"not really an escaped string"
								answer nextPut: (Character value: digit1 digitValue * 16 + digit2 digitValue).
								pos := pos + 2]
							ifFalse: [answer nextPut: char]].
				oldPos := pos + 1].
	answer 
		next: self size - oldPos + 1
		putAll: self
		startingAt: oldPos.
	^answer contents! !
!String categoriesFor: #asHexText!converting!idb goodies!public! !
!String categoriesFor: #expandMacros!printing!public! !
!String categoriesFor: #expandMacrosWith:!printing!public! !
!String categoriesFor: #expandMacrosWith:with:!printing!public! !
!String categoriesFor: #expandMacrosWith:with:with:!printing!public! !
!String categoriesFor: #expandMacrosWith:with:with:with:!printing!public! !
!String categoriesFor: #expandMacrosWithArguments:!printing!public! !
!String categoriesFor: #indexOfAnyOf:startingAt:!public!searching! !
!String categoriesFor: #strcspn:start:!private!searching! !
!String categoriesFor: #trimZeros!copying!idb goodies!public! !
!String categoriesFor: #unescapePercents!operations!public! !

!BSTR class methodsFor!

fromObject: anObject
	^self fromString: anObject!

fromString: aString 
	"Answer a new instance of the receiver with the same contents as aString."

	| wstr |
	wstr := aString asUnicodeString.
	wstr size == 0 ifTrue: [^self new].
	^self fromInteger: wstr yourAddress! !
!BSTR class categoriesFor: #fromObject:!instance creation!public! !
!BSTR class categoriesFor: #fromString:!instance creation!public! !

!UnicodeString methodsFor!

beginsWith: aCollection
	"Answer whether the receiver begins with the sequence
	of objects in the <Collection> argument."

	^self basicBeginsWith: aCollection!

strcspn: aString start: anInteger 
	^CRTLibrary default wcscspn: self yourAddress + ((anInteger - 1) * 2)
		strCharSet: aString asUnicodeString! !
!UnicodeString categoriesFor: #beginsWith:!comparing!public! !
!UnicodeString categoriesFor: #strcspn:start:!private!searching! !

!ListModel class methodsFor!

publishedEventsOfInstances
    	"Answer a Set of Symbols that describe the published events triggered
    	by instances of the receiver."
    
    	^super publishedEventsOfInstances
    		add: #itemUpdatedAtIndex:;
    		add: #item:updatedAtIndex:;
    		add: #item:addedAtIndex:;
    		add: #listChanged;
    		add: #itemRemovedAtIndex:;
    		add: #item:removedAtIndex:;
    		yourself.
    ! !
!ListModel class categoriesFor: #publishedEventsOfInstances!development!events!public! !

!ListModel methodsFor!

notifyUpdatedAtIndex: anInteger 
	self
		trigger: #itemUpdatedAtIndex: with: anInteger;
		trigger: #item:updatedAtIndex:
			with: (self at: anInteger)
			with: anInteger!

removeAtIndex: anInteger 
	"Remove, and answer, the element of the receiver at the specified 
	<integer> index, by shuffling elements which succeed it down one slot.
	Raise an BoundsError if there is no element with that index."

	| elem |
	elem := self list removeAtIndex: anInteger.
	self
		trigger: #itemRemovedAtIndex: with: anInteger;
		trigger: #item:removedAtIndex:
			with: elem
			with: anInteger.
	^elem! !
!ListModel categoriesFor: #notifyUpdatedAtIndex:!private!updating! !
!ListModel categoriesFor: #removeAtIndex:!public!removing! !

!OrderedCollection methodsFor!

addAllFirst: aCollection 
	"Prepend all elements of the <collection> argument to the receiver,
	in the order that they appear in the argument, as determined by
	its implementation of #do:. Answer the new elements."

	"Implementation Note: Override for better performance by
	opening up a space at the front in one operation."

	| extra |
	extra := aCollection size.
	firstIndex <= extra ifTrue: [self makeRoomAtFirstFor: extra - firstIndex + 1].
	firstIndex := firstIndex - extra.
	aCollection inject: firstIndex
		into: 
			[:i :e | 
			self basicAt: i put: e.
			i + 1].
	^aCollection!

uncheckedFrom: startInteger to: stopInteger keysAndValuesDo: aDyadicValuable 
	"Private - Evaluate the <dyadicValuable> argument for each element of the receiver
	between the specified <integer> indices, inclusive, with the element and its index as
	respectively the second and first arguments. No bounds checks are performed."

	startInteger to: stopInteger
		do: [:i | aDyadicValuable value: i value: (self basicAt: i + firstIndex - 1)]! !
!OrderedCollection categoriesFor: #addAllFirst:!adding!public! !
!OrderedCollection categoriesFor: #uncheckedFrom:to:keysAndValuesDo:!enumerating!private! !

!SortedCollection methodsFor!

indexForInserting: anObject
	"Answer the index at which anObject would be added."

	| index low high |
	#idbAdded.
	low := firstIndex.
	high := lastIndex.
	[index := (high + low) // 2.
	low > high]
		whileFalse:
			[(sortBlock value: (self basicAt: index) value: anObject)
				ifTrue: [low := index + 1]
				ifFalse: [high := index - 1]].
	^low!

replaceNextLargerWith: aValue
	"Find the place at which aValue would normally be inserted into
	 the collection.  If that place is already occupied by aValue, do 
	 nothing, and return nil.  If the place does not exist (i.e., it is off
	 the end of the collection), add it to the end, otherwise replace
	 the element at that point with aValue.

	Because this operation preserves the sort order, it can be implemented
	in an efficient and direct way."

	| index |
	#idbAdded.
	index := self indexForInserting: aValue.
	index > lastIndex
		ifTrue:
			[self add: aValue.
			^self size].
	(self basicAt: index) = aValue ifTrue: [^nil].
	self basicAt: index put: aValue.
	^index - firstIndex + 1! !
!SortedCollection categoriesFor: #indexForInserting:!diff!helpers!idb goodies!public! !
!SortedCollection categoriesFor: #replaceNextLargerWith:!diff!idb goodies!operations!public! !

!Dictionary class methodsFor!

withPositionsOf: aCollection
	"Create a Dictionary that maps each element of aCollection to the set of positions it occupies in aCollection."

	#idbAdded.
	^self withPositionsOf: aCollection inInterval: (1 to: aCollection size)!

withPositionsOf: aCollection inInterval: anInterval
	"Create a Dictionary that maps each element of aCollection to the set of positions it occupies in aCollection, restricted to the elements within the range of indexes specified by anInterval."

	| d |
	#idbAdded.
	d := self new.
	anInterval
		do:
			[:index | (d at: (aCollection at: index) ifAbsentPut: [OrderedCollection new]) add: index].
	^d! !
!Dictionary class categoriesFor: #withPositionsOf:!diff!idb goodies!instance creation!public! !
!Dictionary class categoriesFor: #withPositionsOf:inInterval:!diff!idb goodies!instance creation!public! !

!RegKeyAbstract methodsFor!

newSubKey: aString sam: anInteger 
	| path splits |
	path := self pathFromRoot.
	splits := self splitPath: (path isEmpty ifTrue: [aString] ifFalse: [(path copyWith: $\) , aString]).
	^self subKeyClass 
		name: (splits at: 2)
		parentPath: (splits at: 1)
		rootKey: self rootKey
		sam: anInteger!

parentKey
	"Answer the parent key of the receiver, or nil if at a root."

	| path splits |
	self isRoot ifTrue: [^nil].
	path := self parentPath.
	path isEmpty ifTrue: [^self rootKey].
	splits := self splitPath: path.
	^self subKeyClass 
		name: (splits at: 2)
		parentPath: (splits at: 1)
		rootKey: self rootKey
		sam: self sam!

pathFromRoot
	"Answer the full path to the receiver from the root key (N.B. doesn't include the hive such
	as HKEY_CLASSES_ROOT)."

	^self isRoot 
		ifTrue: ['']
		ifFalse: [parentPath isEmpty ifTrue: [name] ifFalse: [(parentPath copyWith: $\) , name]]!

privateCreateKey: aString 
	"Private - Create or open a registry key under the receiver with the specified relative path
	from here (note that this implies that more than one level can be created at once, and this
	is indeed the case!!). Answers the new key. N.B. The new key is still open at this time, and
	MUST be freed."

	| subKey dwErr rights |
	subKey := ExternalHandle new.
	rights := self sam.
	dwErr := self registryLibrary 
				regCreateKeyEx: self asParameter
				lpSubKey: aString
				reserved: nil
				lpClass: ''
				dwOptions: REG_OPTION_NON_VOLATILE
				samDesired: self sam
				lpSecurityAttributes: nil
				phkResult: subKey
				lpdwDisposition: nil.
	dwErr == ERROR_SUCCESS ifFalse: [^Win32Error signal: dwErr].
	keyInfo := nil.	"keyInfo invalidated"
	self free.
	^(self newSubKey: aString sam: rights)
		handle: subKey;
		yourself!

sam
	"Answer an <Integer> representing the receiver's access right flags."

	^sam!

splitPath: path 
	| stem lastSlash superPath |
	lastSlash := path lastIndexOf: $\.
	lastSlash == 0 
		ifTrue: 
			[superPath := ''.
			stem := path]
		ifFalse: 
			[superPath := path leftString: lastSlash - 1.
			stem := path rightString: path size - lastSlash].
	^Array with: superPath with: stem! !
!RegKeyAbstract categoriesFor: #newSubKey:sam:!helpers!private! !
!RegKeyAbstract categoriesFor: #parentKey!accessing!public! !
!RegKeyAbstract categoriesFor: #pathFromRoot!accessing!public! !
!RegKeyAbstract categoriesFor: #privateCreateKey:!helpers!private! !
!RegKeyAbstract categoriesFor: #sam!accessing!public! !
!RegKeyAbstract categoriesFor: #splitPath:!helpers!private! !

!SystemDictionary class methodsFor!

publishedEventsOfInstances
	"Answer a <Set> of <Symbol>s, being the names all the events published
    	by instances of the receiver."

	"Note that there are currently no #globalAdded: and #protocolAdded: events"

	^(super publishedEventsOfInstances)
		add: #methodAdded:;
		add: #methodUpdated:;
		add: #methodRemoved:;
		add: #methodCategorized:;
		add: #classAdded:;
		add: #classUpdated:;
		add: #classRemoved:;
		add: #classCategorized:;
		add: #classCommented:;
		add: #globalRenamed:from:;
		add: #globalRemoved:;
		add: #protocolUpdated:;
		add: #protocolRemoved:;
		yourself! !
!SystemDictionary class categoriesFor: #publishedEventsOfInstances!development!events!public! !

!PoolConstantsDictionary methodsFor!

snoopConstant: anInteger from: aCollection
	"Answer the one constant from aCollection that matches anInteger"

	#idbAdded.
	^aCollection
		detect: [:each | (self at: each) = anInteger]
		ifNone: ['Not found (' , anInteger printString , ')']!

snoopFlags: anInteger from: aCollection
	"Answer a collection of all the constants in aCollection that 
	match (bitwise) the value anInteger"

	#idbAdded.
	^aCollection select: [:each | ((self at: each) bitAnd: anInteger) = (self at: each)]! !
!PoolConstantsDictionary categoriesFor: #snoopConstant:from:!idb goodies!public!searching! !
!PoolConstantsDictionary categoriesFor: #snoopFlags:from:!idb goodies!public!searching! !

!RegKey methodsFor!

privateAt: aString 
	"Private - Answer the named sub-key of the receiver without error checking.
	The new key inherits the same access rights."

	^self newSubKey: aString sam: self sam! !
!RegKey categoriesFor: #privateAt:!accessing!private! !

!RGB class methodsFor!

dolphinYellow
	"Private - Answer the color used in the ILLibray to denote transparent areas"

	#idbAdded.
	^self
		red: 255
		green: 255
		blue: 230!

fromRGBQUAD: anRGBQUAD
	#idbAdded.
	^self
		red: anRGBQUAD rgbRed
		green: anRGBQUAD rgbGreen
		blue: anRGBQUAD rgbBlue!

toolbarGray
	#idbAdded.
	^self
		red: 192
		green: 192
		blue: 192! !
!RGB class categoriesFor: #dolphinYellow!idb goodies!instance creation!public! !
!RGB class categoriesFor: #fromRGBQUAD:!idb goodies!instance creation!public! !
!RGB class categoriesFor: #toolbarGray!idb goodies!instance creation!public! !

!ClosedCommandDescription methodsFor!

snoopAspects
	#idbAdded.
	^(super snoopAspects)
		add: 'Receiver' -> self receiver;
		add: 'QueryBlock' -> queryBlock;
		yourself! !
!ClosedCommandDescription categoriesFor: #snoopAspects!accessing!idb goodies!public! !

!CompiledMethod methodsFor!

fileOut
	"File out the receiver in a st file with the default filename"

	#idbAdded.
	self fileOutTo: self fileOutName!

fileOutName
	"Answers a string that can be used as a filename for the receiver"

	#idbAdded.
	^(String writeStream)
		nextPutAll: self methodClass printString;
		space;
		nextPutAll: (self selector copyReplacing: $: withObject: $_) trimBlanks;
		nextPutAll: '.st';
		contents!

fileOutTo: aString
	"File out the receiver in a st file using aString as the filename"

	#idbAdded.
	SourceManager default fileOutMethod: self to: aString!

profilerIconIndex
	"Answer the icon idex for the receiver's class"

	#idbAdded.
	^self methodClass icon imageIndex!

undefinedSelectors
	| behaviors |
	#idbAdded.
	behaviors := Smalltalk allBehaviors.
	^(self messages
		reject:
			[:eachMessage | behaviors anySatisfy: [:eachClass | eachClass includesSelector: eachMessage]])
		asSortedCollection! !
!CompiledMethod categoriesFor: #fileOut!idb goodies!public!source filing! !
!CompiledMethod categoriesFor: #fileOutName!idb goodies!public!source filing! !
!CompiledMethod categoriesFor: #fileOutTo:!idb goodies!public!source filing! !
!CompiledMethod categoriesFor: #profilerIconIndex!accessing!idb goodies!public! !
!CompiledMethod categoriesFor: #undefinedSelectors!helpers!idb goodies!public! !

!CompileFailedMethod class methodsFor!

buildSourceForSelector: aSymbol class: aBehavior 
	"Private - Construct a method with a correct message pattern for the <Symbol>, aSelector, in the
	class, aBehavior, but which, when invoked, raises an exception to the effect that the original 
	method source failed to compile."

	| argc stream |
	stream := String writeStream: 128.
	argc := aSymbol argumentCount.
	argc == 0 
		ifTrue: [stream nextPutAll: aSymbol]
		ifFalse: 
			[(argc == 1 and: [aSymbol isInfix]) 
				ifTrue: 
					["Assume a binary selector"
					stream
						nextPutAll: aSymbol;
						nextPutAll: ' operand']
				ifFalse: 
					[| inUse |
					inUse := Set withAll: aBehavior allInstVarNames.
					aSymbol keywords do: 
							[:keyword | 
							| x argName |
							stream
								nextPutAll: keyword;
								space.
							x := 1.
							
							[argName := 'arg' , (x := x + 1) displayString.
							inUse includes: argName] whileTrue.
							inUse add: argName.
							stream
								nextPutAll: argName;
								space]]].
	stream
		crtab;
		nextPutAll: ' self error: ''This method did not compile'''.
	^stream contents! !
!CompileFailedMethod class categoriesFor: #buildSourceForSelector:class:!helpers!private! !

!CompileFailedMethod methodsFor!

getDebugInfo
	"Private - Invoke the compiler to answer a compilation result containing a 
	recompilation of the receiver, RTF, a map between IP ranges and expressions 
	in the source, and a map between IP ranges and an OrderedCollection of 
	Associations between IP positions and temporaries up to that position in 
	the receiver, ordered by IP."

	| answer |
	answer := self compilerClass 
				debugInfoFor: (self class buildSourceForSelector: selector class: methodClass)
				in: self methodClass
				debug: self isDebugMethod.
	answer rtf: self getColoredSource rtf.
	^answer! !
!CompileFailedMethod categoriesFor: #getDebugInfo!development!private! !

!DBParameterizedStatement methodsFor!

setParams
	"Private - Bind parameter columns for a prepared SQL statement so that when we 
	subsequently fill the buffer fields the statement is ready to exec. Normally only done 
	just before first exec (from #parameters)."

	paramCols keysAndValuesDo: 
			[:i :eachCol | 
			| buf eachField |
			eachField := parameters at: i.
			buf := eachField fieldBuf.
			self dbCheckException: (ODBCLibrary default 
						sqlBindParameter: self allocatedHandle
						parameterNumber: i
						inputOutputType: eachCol parameterType
						valueType: SQL_C_DEFAULT
						parameterType: eachCol type
						columnSize: eachCol precision
						decimalDigits: eachCol scale
						parameterValuePtr: buf
						bufferLength: buf byteSize
						strLenOrIndPtr: eachField lengthBuf)]! !
!DBParameterizedStatement categoriesFor: #setParams!operations!private! !

!WindowsEvent methodsFor!

printOn: aStream 
	"Append a textual representation of the receiver to aStream."

	| msg window |
	self basicPrintOn: aStream.
	msg := View selectorForMessage: self message.
	aStream nextPut: $(.
	window := self window.
	aStream
		print: (window isNil ifTrue: [self hwnd] ifFalse: [window]);
		space.
	msg isNil 
		ifTrue: [self message printOn: aStream base: 16]
		ifFalse: [aStream nextPutAll: msg].
	aStream
		space;
		print: self wParam;
		space.
	self printLParamOn: aStream.
	aStream nextPut: $)! !
!WindowsEvent categoriesFor: #printOn:!development!printing!public! !

!HRESULTError methodsFor!

hresult
	"Answer the HRESULT error code associated with the receiver."

	^tag ifNil: [HRESULT fail]! !
!HRESULTError categoriesFor: #hresult!accessing!public! !

!Win32Fault methodsFor!

exceptionRecord
	"Answer an <EXCEPTION_RECORD> detailing the original Win32 structured exception."

	^exceptionRecord! !
!Win32Fault categoriesFor: #exceptionRecord!accessing!public! !

!MethodCompileFailed methodsFor!

resumeWithStubMethod
	"Create a stub method which causes an error if evaluated but has the source of the
	proposed method that did not compile. Answer this as the result of resuming the
	notification"

	| selector methodClass result |
	selector := compilerErrorNotification selector asSymbol.
	selector isEmpty ifTrue: [^nil].
	methodClass := compilerErrorNotification methodClass.
	result := methodClass compilerClass 
				compile: (CompileFailedMethod buildSourceForSelector: selector class: methodClass)
				in: methodClass
				flags: 0.
	result method becomeA: CompileFailedMethod.

	"Resume with this stub"
	self resume: result! !
!MethodCompileFailed categoriesFor: #resumeWithStubMethod!handler responses!operations!public! !

!OLEAutLibrary methodsFor!

safeArrayGetRecordInfo: aSAFEARRAY prinfo: anIRecordInfo 
	<stdcall: hresult SafeArrayGetRecordInfo SAFEARRAY* IRecordInfo**>
	^self invalidCall! !
!OLEAutLibrary categoriesFor: #safeArrayGetRecordInfo:prinfo:!Automation Functions-Array Manipulation!public! !

!KernelLibrary methodsFor!

getCommState: aHandle lpDCB: aDCB
	"The GetCommState function fills in a device-control block (a DCB structure) with the current
	control settings for a specified communications device. 

	BOOL GetCommState(
		HANDLE  hFile,	// handle of communications device
		LPDCB  lpDCB	// address of device-control block structure
		);"

	<stdcall: bool GetCommState handle DCB*>
	#idbAdded.
	^self invalidCall!

getCommTimeouts: aHandle lpCommTimeouts: aCOMMTIMEOUTS
	"
	BOOL GetCommTimeouts(
		HANDLE hFile,
		LPCOMMTIMEOUTS lpCommTimeouts,
		);"

	<stdcall: bool GetCommTimeouts handle COMMTIMEOUTS*>
	#idbAdded.
	^self invalidCall!

getSystemWindowsDirectory: lpBuffer uSize: uSize 
	"	UINT GetSystemWindowsDirectory(
			LPTSTRlpBuffer, 
			UINTuSize); "

	<stdcall: dword GetSystemWindowsDirectoryA lpstr dword>
	^self invalidCall!

setCommState: aHandle lpDCB: aDCB
	"The SetCommState function configures a communications device according to the specifications in a device-control block (a DCB structure). The function reinitializes all hardware and control settings, but it does not empty output or input queues. 

	BOOL SetCommState(
		HANDLE  hFile,	// handle of communications device
		LPDCB  lpDCB	// address of device-control block structure
		);"

	<stdcall: bool SetCommState handle DCB*>
	#idbAdded.
	^self invalidCall!

setCommTimeouts: aHandle lpCommTimeouts: aCOMMTIMEOUTS
	"
	BOOL SetCommTimeouts(
		HANDLE hFile,
		LPCOMMTIMEOUTS lpCommTimeouts,
		);"

	<stdcall: bool SetCommTimeouts handle COMMTIMEOUTS*>
	#idbAdded.
	^self invalidCall!

setFilePointer: aHandle lDistanceToMove: loInteger lpDistanceToMoveHigh: anAddress dwMoveMethod: senseOfMove
	"Moves the file pointer of an open file. 

	DWORD SetFilePointer(
		HANDLE hFile, 				// handle of file 
		LONG lDistanceToMove, 		// number of bytes to move file pointer 
		PLONG lpDistanceToMoveHigh, // address of high-order word of distance to move  
		DWORD dwMoveMethod 			// how to move 
		);"

	<stdcall: dword SetFilePointer handle dword lpvoid dword>
	^self invalidCall! !
!KernelLibrary categoriesFor: #getCommState:lpDCB:!idb goodies!public!win32 functions-communications! !
!KernelLibrary categoriesFor: #getCommTimeouts:lpCommTimeouts:!idb goodies!public!win32 functions-communications! !
!KernelLibrary categoriesFor: #getSystemWindowsDirectory:uSize:!public!win32 functions-system information! !
!KernelLibrary categoriesFor: #setCommState:lpDCB:!idb goodies!public!win32 functions-communications! !
!KernelLibrary categoriesFor: #setCommTimeouts:lpCommTimeouts:!idb goodies!public!win32 functions-communications! !
!KernelLibrary categoriesFor: #setFilePointer:lDistanceToMove:lpDistanceToMoveHigh:dwMoveMethod:!public!win32 functions-file! !

!UserLibrary methodsFor!

keybdEvent: bVk bScan: bScan dwFlags: dwFlags dwExtraInfo: dwExtraInfo
	"
	VOID keybd_event(
		BYTE  bVk,	// virtual-key code
    		BYTE  bScan,	// hardware scan code
    		DWORD  dwFlags,	// flags specifying various function options
    		DWORD  dwExtraInfo 	// additional data associated with keystroke
  		);"

	<stdcall: void keybd_event byte byte dword dword>
	#idbAdded.
	^self invalidCall! !
!UserLibrary categoriesFor: #keybdEvent:bScan:dwFlags:dwExtraInfo:!idb goodies!public!win32 functions-timer! !

!COMInterface class methodsFor!

fromObject: anObject 
	"Answer an instance of the receiver whose value is the argument."

	^anObject queryInterface: self! !
!COMInterface class categoriesFor: #fromObject:!instance creation!public! !

!ExternalArray methodsFor!

asVariant
	"Answer the VARIANT representation of the receiver (a VT_ARRAY|VT_XX)."

	^VARIANT fromCollection: self!

at: anInteger 
	"Answer the element of the receiver at the specified index.
	Raise an error if the index if out of bounds."

	(anInteger < 1 or: [anInteger > self size]) 
		ifTrue: [^self errorSubscriptBounds: anInteger].
	^self uncheckedAt: anInteger!

at: anInteger put: newValue 
	"Set the element of the receiver at the specified index.
	Raise an error if the index is out of bounds."

	(anInteger < 1 or: [anInteger > self size]) 
		ifTrue: [self errorSubscriptBounds: anInteger].
	^self uncheckedAt: anInteger put: newValue!

from: startInteger to: stopInteger keysAndValuesDo: operation 
	"Evaluate the <dyadicValuable>, operation, for each element of the receiver
	between the <integer> indices, start and stop, inclusive with the element and its
	index as respectively the second and first arguments."

	"Implementation Note: Do the bounds check up front to avoid the need to check
	on each access."

	startInteger < 1 ifTrue: [self errorSubscriptBounds: startInteger].
	stopInteger > self size ifTrue: [self errorSubscriptBounds: stopInteger].
	self 
		uncheckedFrom: startInteger
		to: stopInteger
		keysAndValuesDo: operation!

uncheckedFrom: startInteger to: stopInteger keysAndValuesDo: operation 
	"Private - Evaluate the <dyadicValuable>, operation, for each element of the receiver
	between the <integer> indices, start and stop, inclusive with the element and its
	index as respectively the second and first arguments. No bounds checking is
	performed. "

	"Subclasses should override this method in order to replace all #do: family enumerators 
	(#do:, #keysAndValuesDo:, #from:to:do:, and,	of course, #from:to:keysAndValuesDo:)."

	startInteger to: stopInteger do: [:i | operation value: i value: (self uncheckedAt: i)]! !
!ExternalArray categoriesFor: #asVariant!converting!public! !
!ExternalArray categoriesFor: #at:!accessing!public!testing! !
!ExternalArray categoriesFor: #at:put:!accessing!public! !
!ExternalArray categoriesFor: #from:to:keysAndValuesDo:!enumerating!public! !
!ExternalArray categoriesFor: #uncheckedFrom:to:keysAndValuesDo:!enumerating!private! !

!ExternalInteger methodsFor!

displayOn: aStream
	"Append, to aStream, a String whose characters are a representation of the receiver as a user
	would want to see it."

	self value displayOn: aStream! !
!ExternalInteger categoriesFor: #displayOn:!printing!public! !

!ADODBConnection15 methodsFor!

query: aString 
	"Execute the SQL in aString.
	Answer an <ADODB_Recordset> representing the resultant result set."

	^(self execute: aString options: adCmdText) second! !
!ADODBConnection15 categoriesFor: #query:!executing!public! !

!ADODBRecordset15 methodsFor!

_collect: index 
	"Answer the <variant> value of the 'Collect' property of the receiver."

	| answer |
	answer := VARIANT new.
	self get_Collect: index asVariant pvar: answer.
	^answer asObject!

collect: transformer 
	"Evaluate the <monadicValuable> argument, transformer, for each of the 
	receiver's elements in the order defined by the receiver's implementation of #do:,
	collecting the results into an OrderedCollection which is answered."

	| answer |
	answer := OrderedCollection new.
	self do: [:each | answer add: (transformer value: each)].
	^answer!

do: operation
	"Evaluate the <monadicValuable> argument, operation, for each of the 
	records in the receiver."

	| fields |
	self bof ifFalse: [self MoveFirst].
	fields := self fields.
	[self eof] whileFalse: [
		operation value: fields.
		self MoveNext]!

isEmpty
	"Answer whether the receiver is devoid of any rows."

	^self bof and: [self eof]! !
!ADODBRecordset15 categoriesFor: #_collect:!**auto generated**!properties!public! !
!ADODBRecordset15 categoriesFor: #collect:!enumerating!public! !
!ADODBRecordset15 categoriesFor: #do:!enumerating!public! !
!ADODBRecordset15 categoriesFor: #isEmpty!public!testing! !

!DOUBLEArray methodsFor!

uncheckedAt: anInteger 
	"Private - Answer the double-precision floating point value at the specified index in the receiver."

	^bytes doubleAtOffset: (anInteger - 1) * 8!

uncheckedAt: anInteger put: aFloat 
	"Private - Replace the double-precision floating point value at the specified index in the receiver
	with the Float argument."

	^bytes doubleAtOffset: (anInteger - 1) * 8 put: aFloat! !
!DOUBLEArray categoriesFor: #uncheckedAt:!accessing!private! !
!DOUBLEArray categoriesFor: #uncheckedAt:put:!accessing!private! !

!DWORDArray methodsFor!

uncheckedAt: index 
	"Private - Answer the 32-bit unsigned integer value at the specified index in the receiver."

	^bytes dwordAtOffset: (index - 1) * 4!

uncheckedAt: indexInteger put: valueInteger 
	"Private - Replace the 32-bit unsigned integer value at the specified <integer> index in the receiver
	with the <integer> value argument."

	^bytes dwordAtOffset: (indexInteger - 1) * 4 put: valueInteger! !
!DWORDArray categoriesFor: #uncheckedAt:!accessing!private! !
!DWORDArray categoriesFor: #uncheckedAt:put:!accessing!private! !

!FLOATArray methodsFor!

uncheckedAt: anInteger 
	"Private - Answer the single-precision floating point value at the specified index in the receiver."

	^bytes floatAtOffset: (anInteger - 1) * 4!

uncheckedAt: anInteger put: aFloat 
	"Private - Replace the single-precision floating point value at the specified index in the receiver
	with the Float argument.."

	^bytes floatAtOffset: (anInteger - 1) * 4 put: aFloat! !
!FLOATArray categoriesFor: #uncheckedAt:!accessing!private! !
!FLOATArray categoriesFor: #uncheckedAt:put:!accessing!private! !

!OLECountedArray methodsFor!

uncheckedAt: anInteger 
	"Private - Answer the 32-bit unsigned integer value at the specified index in the receiver."

	^self elements at: anInteger!

uncheckedAt: anInteger put: anObject 
	"Private - Replace the value at the specified <integer> index in the receiver
	with the value argument."

	^self elements at: anInteger put: anObject! !
!OLECountedArray categoriesFor: #uncheckedAt:!accessing!private!testing! !
!OLECountedArray categoriesFor: #uncheckedAt:put:!accessing!private! !

!SAFEARRAY methodsFor!

deduceElementClass
	"Private - Deduce an appropriate class of object to be used to represent the elements of the
	receiver by examining the fFeatures field."

	| f |
	f := self fFeatures.
	(f allMask: FADF_BSTR) ifTrue: [^BSTR].
	(f allMask: FADF_VARIANT) ifTrue: [^VARIANT].
	(f allMask: FADF_HAVEIID) 
		ifTrue: 
			[| class |
			class := COMInterface classForIID: self iid ifNone: [].
			class isNil 
				ifTrue: 
					["Not a recognised interface class so drop through and
					 return IDispatch or IUnknown depending on remaining flags"
					]
				ifFalse: [^class]].
	(f allMask: FADF_DISPATCH) ifTrue: [^IDispatch].
	(f allMask: FADF_UNKNOWN) ifTrue: [^IUnknown].
	(f allMask: FADF_RECORD) ifTrue: [^self recordClass ifNil: [self genericRecordClass]].
	(f allMask: FADF_HAVEVARTYPE) ifTrue: [^VARIANT classForVT: self vartype].
	^self error: 'Unrecognised safe array element type'!

genericRecordClass
	^AXRecord!

hasRecordInfo
	"Private - Answer whether there an <IRecordInfo> describing the receiver's elements is
	available."

	^recordInfo notNull or: [self fFeatures allMask: FADF_RECORD]!

newElementAt: anAddress 
	"Private - Answer a new reference instance of the receiver's element class, pointing at the
	element at the specified memory address."

	| elemFactory |
	elemFactory := self elementClass.
	^elemFactory == self genericRecordClass 
		ifTrue: 
			[elemFactory 
				fromAddress: anAddress
				recordInfo: self recordInfo
				owner: self]
		ifFalse: [elemFactory atAddress: anAddress]!

queryRecordInfo
	| recInfo |
	self hasRecordInfo ifFalse: [^nil].
	recInfo := IRecordInfo newPointer.
	OLEAutLibrary default safeArrayGetRecordInfo: self prinfo: recInfo.
	^recInfo!

recordClass
	"Private - Answer the <ExternalStructure> class registered for the <GUID> of the receiver's
	record information, of nil if none is registered. Note that even if no precompiled structure
	class is registered for the GUID, the array elements can still be accessed using the generic
	AXRecord class, which implements late bound access to the structure elements using the
	information supplied by the <IRecordInfo> interrface."

	^ExternalStructure classForGUID: self recordInfo guid ifNone: []!

recordInfo
	"Answer the <IRecordInfo> associated with the receiver (if the receiver is of type
	VT_RECORD), or nil if the receiver's elements are not of type VT_RECORD, or if no record
	info was provided when the array was constructed."

	recordInfo isNull ifTrue: [recordInfo := self queryRecordInfo].
	^recordInfo!

uncheckedAt: anInteger 
	"Private - Answer an instance of the receiver's elementClass which is a reference to the
	element of the receiver at the specified <integer> index. No bounds checks are performed on
	the subscript."

	^self newElementAt: self base + ((anInteger - 1) * self elementSize)!

uncheckedAt: index put: value 
	"Private - Set the value of the element of the receiver at the specified <integer> index
	to the specified value, which must be representable by the element class of
	the receiver. Assumes that the receiver is a single-dimensioned array, if
	not an error will result. .
	Note: This isn't likely to be terribly fast!!"

	self elementAt: (Array with: index + self start - 1)
		put: (self elementClass fromObject: value).
	^value!

uncheckedFrom: startInteger to: stopInteger keysAndValuesDo: operation 
	"Private - Evaluate the <dyadicValuable>, operation, for each element of the receiver
	between the specified, inclusive, <integer> indices with the element and its index as
	respectively the second and first arguments. No bounds checking is performed. "

	"Implementation Note: Override for improved performance (reduction of address calculations).
	By overriding this one method, we improve the performance of all enumerators."

	| address spacing |
	spacing := self elementSize.
	address := self base + ((startInteger - 1) * spacing).
	startInteger to: stopInteger
		do: 
			[:i | 
			operation value: i value: (self newElementAt: address).
			address := address + spacing]! !
!SAFEARRAY categoriesFor: #deduceElementClass!helpers!private! !
!SAFEARRAY categoriesFor: #genericRecordClass!constants!private! !
!SAFEARRAY categoriesFor: #hasRecordInfo!private!testing! !
!SAFEARRAY categoriesFor: #newElementAt:!helpers!private! !
!SAFEARRAY categoriesFor: #queryRecordInfo!helpers!private! !
!SAFEARRAY categoriesFor: #recordClass!helpers!private! !
!SAFEARRAY categoriesFor: #recordInfo!accessing!public! !
!SAFEARRAY categoriesFor: #uncheckedAt:!accessing!private! !
!SAFEARRAY categoriesFor: #uncheckedAt:put:!accessing!private! !
!SAFEARRAY categoriesFor: #uncheckedFrom:to:keysAndValuesDo:!enumerating!private! !

!StructureArray class methodsFor!

withAll: aCollection elementClass: structClass 
	"Answer a new instance of the receiver containing all of the elements of the <collection> 
	argument, represented in the format of the <ExternalStructure> class argument.  An error 
	will be raised if any of the elements cannot be represented as instances of the element class."

	| answer |
	answer := self length: aCollection size elementClass: structClass.
	aCollection inject: 1
		into: 
			[:i :elem | 
			answer at: i put: elem.
			i + 1].
	^answer! !
!StructureArray class categoriesFor: #withAll:elementClass:!instance creation!public! !

!StructureArray methodsFor!

uncheckedAt: anInteger 
	"Private - Answer an instance of the receiver's elementClass which is a reference to the element 
	of the receiver at the specified <integer> index. No bounds checks are performed on the subscript."

	^self elementClass atAddress: self yourAddress + ((anInteger - 1) * self packing)!

uncheckedAt: anInteger put: anObject 
	"Private - Replace the element of the receiver at the specified <integer> index
	with the <Object> argument. No bounds checks are performed on the subscript."

	| offset |
	offset := (anInteger - 1) * self packing.
	anObject 
		replaceBytesOf: bytes
		from: 1 + offset
		to: offset + self elementSize
		startingAt: 1.
	^anObject! !
!StructureArray categoriesFor: #uncheckedAt:!accessing!private! !
!StructureArray categoriesFor: #uncheckedAt:put:!accessing!private! !

!WORDArray methodsFor!

uncheckedAt: anInteger 
	"Private - Answer an 16-bit unsigned <SmallInteger> representing the element of the 
	receiver at the specified <integer> index. No bounds checks are performed on the subscript."

	^bytes wordAtOffset: anInteger + anInteger - 2!

uncheckedAt: indexInteger put: valueInteger 
	"Private - Replace the 16-bit unsigned integer value at the specified index in the receiver
	with the <integer> argument. No bounds checks are performed on the subscript."

	^bytes wordAtOffset: indexInteger + indexInteger - 2 put: valueInteger! !
!WORDArray categoriesFor: #uncheckedAt:!private! !
!WORDArray categoriesFor: #uncheckedAt:put:!accessing!private! !

!PointerArray methodsFor!

uncheckedAt: anInteger 
	"Private - Answer the element of the receiver at the specified index."

	^elementClass fromAddress: (super uncheckedAt: anInteger)!

uncheckedAt: anInteger put: newValue 
	"Private - Set the element of the receiver at the specified index."

	super uncheckedAt: anInteger put: newValue yourAddress.
	^newValue! !
!PointerArray categoriesFor: #uncheckedAt:!accessing!private! !
!PointerArray categoriesFor: #uncheckedAt:put:!accessing!private! !

!SDWORDArray methodsFor!

uncheckedAt: anInteger 
	"Private - Answer the 32-bit unsigned integer value at the specified index in the receiver."

	^bytes sdwordAtOffset: (anInteger - 1) * 4!

uncheckedAt: indexInteger put: valueInteger 
	"Private - Replace the 32-bit signed integer value at the specified <integer> index in the receiver
	with the <integer> value argument."

	^bytes sdwordAtOffset: (indexInteger - 1) * 4 put: valueInteger! !
!SDWORDArray categoriesFor: #uncheckedAt:!accessing!private! !
!SDWORDArray categoriesFor: #uncheckedAt:put:!accessing!private! !

!SWORDArray methodsFor!

uncheckedAt: anInteger 
	"Private - Answer an 16-bit signed <SmallInteger> representing the element of the 
	receiver at the specified <integer> index. No bounds checks are performed on the subscript."

	^bytes swordAtOffset: anInteger + anInteger - 2!

uncheckedAt: indexInteger put: valueInteger 
	"Private - Replace the 16-bit signed integer value at the specified index in the receiver
	with the <integer> argument. No bounds checks are performed on the subscript."

	^bytes swordAtOffset: indexInteger + indexInteger - 2 put: valueInteger! !
!SWORDArray categoriesFor: #uncheckedAt:!accessing!private! !
!SWORDArray categoriesFor: #uncheckedAt:put:!accessing!private! !

!VARIANT class methodsFor!

fromCollection: objects 
	"Answer a new instance of the receiver of type VT_ARRAY|VT_VARIANT containing
	the <VARIANT> representations of the elements of the <collection>, objects."

	^(self new)
		array: objects asSAFEARRAY;
		yourself! !
!VARIANT class categoriesFor: #fromCollection:!instance creation!public! !

BITMAPFILEHEADER comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!BITMAPFILEHEADER class methodsFor!

defineFields
	"Define the Win32 BITMAPFILEHEADER structure

		typedef struct tagBITMAPFILEHEADER {  // bmfh 
			 WORD   bfType; 
			 DWORD   bfSize; 
			 WORD   bfReserved1; 
			 WORD   bfReserved2; 
			 DWORD   bfOffBits; 
		} BITMAPFILEHEADER;"

	self
		defineField: #bfType type: WORDField new;
		defineField: #bfSize type: DWORDField new;
		defineField: #bfReserved1 type: WORDField new;
		defineField: #bfReserved2 type: WORDField new;
		defineField: #bfOffBits type: DWORDField new!

packing
	"Answer the default packing for instances of the receiver. 
	BITMAPFILEHEADER is unusual for a Windows structure in being packed to 
	1-byte boundaries - probably a 16-bit inheritance."

	^1! !
!BITMAPFILEHEADER class categoriesFor: #defineFields!initializing!public! !
!BITMAPFILEHEADER class categoriesFor: #packing!constants!public! !

!BITMAPINFO class methodsFor!

colorDepthEx: colorDepth
	"Answer a new instance of the receiver capable of representing information about
	a bitmap with the specified colour depth (e.g. 8, 16, 24 or 32 bpp)."

	"Fixed to answer 0 for 32 bit depth on assumption of BI_RGB compression
	See BITMAPINFOHEADER>>numQuads
	Problem reported and fix suggested by Steve Waring"

	| quads |
	#idbAdded.
	quads := colorDepth < 16
		ifTrue: [2 raisedToInteger: colorDepth]
		ifFalse: [colorDepth >= 24 ifTrue: [0] ifFalse: [3]].
	^self new: self byteSize + ((quads - 1) * RGBQUAD byteSize)! !
!BITMAPINFO class categoriesFor: #colorDepthEx:!idb goodies!instance creation!public! !

COMMTIMEOUTS comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!COMMTIMEOUTS class methodsFor!

defineFields
	"Private - Define the fields for a Win32 COMMTIMEOUTS structure

		COMMTIMEOUTS compileDefinition
		COMMTIMEOUTS beUncompiled"

	self
		defineField: #readIntervalTimeout type: DWORDField new;
		defineField: #readTotalTimeoutMultiplier type: DWORDField new;
		defineField: #readTotalTimeoutConstant type: DWORDField new;
		defineField: #writeTotalTimeoutMultiplier type: DWORDField new;
		defineField: #writeTotalTimeoutConstant type: DWORDField new! !
!COMMTIMEOUTS class categoriesFor: #defineFields!initializing!public! !

DCB comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!DCB class methodsFor!

defineFields
	"The DCB structure defines the control setting for a serial communications device. 
	typedef struct _DCB { // dcb 
		DWORD DCBlength;           // sizeof(DCB) 
		DWORD BaudRate;            // current baud rate 
		DWORD fBinary: 1;          // binary mode, no EOF check 
		DWORD fParity: 1;          // enable parity checking 
		DWORD fOutxCtsFlow:1;      // CTS output flow control 
		DWORD fOutxDsrFlow:1;      // DSR output flow control 
		DWORD fDtrControl:2;       // DTR flow control type 
		DWORD fDsrSensitivity:1;   // DSR sensitivity 
		DWORD fTXContinueOnXoff:1; // XOFF continues Tx 
		DWORD fOutX: 1;        // XON/XOFF out flow control 
		DWORD fInX: 1;         // XON/XOFF in flow control 
		DWORD fErrorChar: 1;   // enable error replacement 
		DWORD fNull: 1;        // enable null stripping 
		DWORD fRtsControl:2;   // RTS flow control 
		DWORD fAbortOnError:1; // abort reads/writes on error 
		DWORD fDummy2:17;      // reserved 
		WORD wReserved;        // not currently used 
		WORD XonLim;           // transmit XON threshold 
		WORD XoffLim;          // transmit XOFF threshold 
		BYTE ByteSize;         // number of bits/byte, 4-8 
		BYTE Parity;           // 0-4=no,odd,even,mark,space 
		BYTE StopBits;         // 0,1,2 = 1, 1.5, 2 
		char XonChar;          // Tx and Rx XON character 
		char XoffChar;         // Tx and Rx XOFF character 
		char ErrorChar;        // error replacement character 
		char EofChar;          // end of input character 
		char EvtChar;          // received event character 
		WORD wReserved1;       // reserved; do not use 
		} DCB; "

	self
		defineField: #dwSize type: DWORDField writeOnly beOverride;
		defineField: #baudRate type: DWORDField new;
		defineField: #flags type: DWORDField new;
		defineField: #wReserved type: WORDField filler;
		defineField: #xOnLim type: WORDField new;
		defineField: #xOffLim type: WORDField new;
		defineField: #dataByteSize type: BYTEField new;
		defineField: #parity type: BYTEField new;
		defineField: #stopBits type: BYTEField new;
		defineField: #xOnChar type: BYTEField new;
		defineField: #xOffChar type: BYTEField new;
		defineField: #errorChar type: BYTEField new;
		defineField: #eofChar type: BYTEField new;
		defineField: #evtChar type: BYTEField new;
		defineField: #wReserved1 type: WORDField filler!

packing
	"Answer the default packing for instances of the receiver.
	This is the maximum alignment to which members of the structure
	after the first are padded. Each field type has a natural alignment
	(e.g. ints align to 32-bit boundaries), and it is the smaller of the
	packing and the natural alignment which is used to decide the
	padding necessary for the field in the structure.
	PRINTDLG is an old Win16 structure with byte packing."

	^1! !
!DCB class categoriesFor: #defineFields!initializing!public! !
!DCB class categoriesFor: #packing!constants!public! !

!DCB methodsFor!

fAbortOnError
	^(self flags bitAt: 15) ~= 0!

fBinary
	^(self flags bitAt: 1) ~= 0!

fDsrSensitivity
	^(self flags bitAt: 7) ~= 0!

fDtrControl
	^(self flags bitShift: -4) bitAnd: 3!

fDtrControl: anInteger
	self flags: ((self flags bitAnd: 4294967247) bitOr: (anInteger bitShift: 4))!

fErrorChar
	^(self flags bitAt: 11) ~= 0!

fInX
	^(self flags bitAt: 10) ~= 0!

fNull
	^(self flags bitAt: 12) ~= 0!

fOutX
	^(self flags bitAt: 9) ~= 0!

fOutxCtsFlow
	^(self flags bitAt: 3) ~= 0!

fOutxDsrFlow
	^(self flags bitAt: 4) ~= 0!

fParity
	^(self flags bitAt: 2) ~= 0!

fRtsControl
	^(self flags bitShift: -12) bitAnd: 3!

fRtsControl: anInteger
	self flags: ((self flags bitAnd: 4294955007) bitOr: (anInteger bitShift: 12))!

fTXContinueOnXoff
	^(self flags bitAt: 8) ~= 0! !
!DCB categoriesFor: #fAbortOnError!accessing!public! !
!DCB categoriesFor: #fBinary!accessing!public! !
!DCB categoriesFor: #fDsrSensitivity!accessing!public! !
!DCB categoriesFor: #fDtrControl!accessing!public! !
!DCB categoriesFor: #fDtrControl:!accessing!public! !
!DCB categoriesFor: #fErrorChar!accessing!public! !
!DCB categoriesFor: #fInX!accessing!public! !
!DCB categoriesFor: #fNull!accessing!public! !
!DCB categoriesFor: #fOutX!accessing!public! !
!DCB categoriesFor: #fOutxCtsFlow!accessing!public! !
!DCB categoriesFor: #fOutxDsrFlow!accessing!public! !
!DCB categoriesFor: #fParity!accessing!public! !
!DCB categoriesFor: #fRtsControl!accessing!public! !
!DCB categoriesFor: #fRtsControl:!accessing!public! !
!DCB categoriesFor: #fTXContinueOnXoff!accessing!public! !

ICONDIR comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ICONDIR class methodsFor!

defineFields
	" ICONDIR compileDefinition 
	ALWAY precompile because of var struct!!!! "

	self
		defineField: #idReserved type: WORDField readOnly;
		defineField: #idType type: WORDField new;
		defineField: #idCount type: WORDField new;
		defineField: #idEntries
			type: (VariableStructureArrayField type: ICONDIRENTRY length: #idCount)!

for: anInteger
	"Create an ICONDIR using this method and not new as we need to know
	how many bytes to allocate for the var struct"

	^self new: self byteSize + ((anInteger - 1) * ICONDIRENTRY byteSize)!

packing
	^1! !
!ICONDIR class categoriesFor: #defineFields!initializing!public! !
!ICONDIR class categoriesFor: #for:!instance creation!public! !
!ICONDIR class categoriesFor: #packing!constants!public! !

!ICONDIR methodsFor!

idCount
	"Answer the receiver's idCount field as a Smalltalk object."

	^bytes wordAtOffset: 4!

idCount: anObject
	"Set the receiver's idCount field to the value of anObject."

	bytes wordAtOffset: 4 put: anObject!

idEntries
	"Answer the receiver's idEntries field as a Smalltalk object."

	^StructureArray
		fromAddress: bytes yourAddress + 6
		length: self idCount
		elementClass: ICONDIRENTRY!

idEntries: anObject
	"Set the receiver's idEntries field to the value of anObject."

	| size |
	size := anObject byteSize min: self idCount * 0.
	anObject
		replaceBytesOf: bytes
		from: 7
		to: 6 + size
		startingAt: 1!

idReserved
	"Answer the receiver's idReserved field as a Smalltalk object."

	^bytes wordAtOffset: 0!

idType
	"Answer the receiver's idType field as a Smalltalk object."

	^bytes wordAtOffset: 2!

idType: anObject
	"Set the receiver's idType field to the value of anObject."

	bytes wordAtOffset: 2 put: anObject! !
!ICONDIR categoriesFor: #idCount!**compiled accessors**!public! !
!ICONDIR categoriesFor: #idCount:!**compiled accessors**!public! !
!ICONDIR categoriesFor: #idEntries!**compiled accessors**!public! !
!ICONDIR categoriesFor: #idEntries:!**compiled accessors**!public! !
!ICONDIR categoriesFor: #idReserved!**compiled accessors**!public! !
!ICONDIR categoriesFor: #idType!**compiled accessors**!public! !
!ICONDIR categoriesFor: #idType:!**compiled accessors**!public! !

ICONDIRENTRY comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ICONDIRENTRY class methodsFor!

defineFields
	self
		defineField: #bWidth type: BYTEField new;
		defineField: #bHeight type: BYTEField new;
		defineField: #bColorCount type: BYTEField new;
		defineField: #bReserved type: BYTEField readOnly;
		defineField: #wPlanes type: WORDField new;
		defineField: #wBitCount type: WORDField new;
		defineField: #dwBytesInRes type: DWORDField new;
		defineField: #dwImageOffset type: DWORDField new!

packing
	^1! !
!ICONDIRENTRY class categoriesFor: #defineFields!initializing!public! !
!ICONDIRENTRY class categoriesFor: #packing!constants!public! !

!RGBQUAD class methodsFor!

fromRGB: anRGB
	#idbAdded.
	^(self new)
		rgbRed: anRGB red;
		rgbGreen: anRGB green;
		rgbBlue: anRGB blue! !
!RGBQUAD class categoriesFor: #fromRGB:!idb goodies!instance creation!public! !

!SCROLLINFO methodsFor!

range: anInterval
	"Set the range through which the scroll bars thumb can be positioned."

	self
		nMin: anInterval start;
		nMax: anInterval stop;
		maskIn: SIF_RANGE! !
!SCROLLINFO categoriesFor: #range:!accessing!public! !

TIMEZONEINFORMATION comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!TIMEZONEINFORMATION class methodsFor!

defineFields
	"typedef struct _TIME_ZONE_INFORMATION { 
		LONG Bias; 
		WCHAR StandardName[ 32 ]; 
		SYSTEMTIME StandardDate; 
		LONG StandardBias; 
		WCHAR DaylightName[ 32 ]; 
		SYSTEMTIME DaylightDate; 
		LONG DaylightBias; } 
	TIME_ZONE_INFORMATION, 
	*PTIME_ZONE_INFORMATION; "

	self
		defineField: #bias type: SDWORDField new;
		defineField: #standardName type: (ArrayField type: ByteArray length: 64);
		defineField: #standardDate type: (StructureField type: SYSTEMTIME);
		defineField: #standardBias type: SDWORDField new;
		defineField: #daylightName type: (ArrayField type: ByteArray length: 64);
		defineField: #daylightDate type: (StructureField type: SYSTEMTIME);
		defineField: #daylightBias type: SDWORDField new! !
!TIMEZONEINFORMATION class categoriesFor: #defineFields!initializing!public! !

UDACCEL comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!UDACCEL class methodsFor!

defineFields
	"Define the layout of the Win32 common control UDACCEL structure.
		UDACCEL compileDefinition
	"

	self
		defineField: #nSec type: DWORDField new;
		defineField: #nInc type: DWORDField new! !
!UDACCEL class categoriesFor: #defineFields!initializing!public! !

!UDACCEL methodsFor!

nInc
	"Answer the receiver's nInc field as a Smalltalk object."

	^bytes dwordAtOffset: 4!

nInc: anObject
	"Set the receiver's nInc field to the value of anObject."

	bytes dwordAtOffset: 4 put: anObject!

nSec
	"Answer the receiver's nSec field as a Smalltalk object."

	^bytes dwordAtOffset: 0!

nSec: anObject
	"Set the receiver's nSec field to the value of anObject."

	bytes dwordAtOffset: 0 put: anObject! !
!UDACCEL categoriesFor: #nInc!**compiled accessors**!public! !
!UDACCEL categoriesFor: #nInc:!**compiled accessors**!public! !
!UDACCEL categoriesFor: #nSec!**compiled accessors**!public! !
!UDACCEL categoriesFor: #nSec:!**compiled accessors**!public! !

NMUPDOWN comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!NMUPDOWN class methodsFor!

defineFields
	"Define the fields of the Win32 NMUPDOWN structure.
		NMUPDOWN compileDefinition
	"

	super
		defineFields;
		defineField: #iPos type: SDWORDField new;
		defineField: #iDelta type: SDWORDField new! !
!NMUPDOWN class categoriesFor: #defineFields!initializing!public! !

!NMUPDOWN methodsFor!

iDelta
	"Answer the receiver's iDelta field as a Smalltalk object."

	^bytes sdwordAtOffset: 16!

iDelta: anObject
	"Set the receiver's iDelta field to the value of anObject."

	bytes sdwordAtOffset: 16 put: anObject!

iPos
	"Answer the receiver's iPos field as a Smalltalk object."

	^bytes sdwordAtOffset: 12!

iPos: anObject
	"Set the receiver's iPos field to the value of anObject."

	bytes sdwordAtOffset: 12 put: anObject! !
!NMUPDOWN categoriesFor: #iDelta!**compiled accessors**!public! !
!NMUPDOWN categoriesFor: #iDelta:!**compiled accessors**!public! !
!NMUPDOWN categoriesFor: #iPos!**compiled accessors**!public! !
!NMUPDOWN categoriesFor: #iPos:!**compiled accessors**!public! !

FileBrowserFile comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!FileBrowserFile methodsFor!

isChunkFile
	"Answers true if the file type is st or cls"

	^self isTypeIn: #('st' 'cls')!

isHTMLFile
	"Answers true if the file type is htm or html"

	^self isTypeIn: #('htm' 'html')!

isImageFile
	"Answers true if the file type is an image
	tif, tiff and png are (currently?) not displayed as images"

	^self isTypeIn: #('bmp' 'ico' 'jpg' 'jpeg' 'gif' 'tif' 'tiff' 'png')!

isTypeIn: aCollection
	"Answers true if the file extension is included in aCollection (case insensitive)"

	^aCollection anySatisfy: [:each | each sameAs: type]!

setName: aString parent: aFileBrowserFolderOrNil
	"initializes the extra information held about a file"

	| data |
	super setName: aString parent: aFileBrowserFolderOrNil.
	data := (File find: self path) first.
	size := data fileSize.
	type := File splitExtensionFrom: data fileName.
	timeStamp := TimeStamp fromSYSTEMTIME: data ftLastWriteTime asSYSTEMTIME.
	^self!

size
	"Answer the value of the receiver's 'size' instance variable."

	^size!

timeStamp
	"Answer the value of the receiver's 'timeStamp' instance variable."

	^timeStamp!

type
	"Answer the value of the receiver's 'type' instance variable."

	^type! !
!FileBrowserFile categoriesFor: #isChunkFile!public!testing! !
!FileBrowserFile categoriesFor: #isHTMLFile!public!testing! !
!FileBrowserFile categoriesFor: #isImageFile!public!testing! !
!FileBrowserFile categoriesFor: #isTypeIn:!public!testing! !
!FileBrowserFile categoriesFor: #setName:parent:!initializing!public! !
!FileBrowserFile categoriesFor: #size!accessing!public! !
!FileBrowserFile categoriesFor: #timeStamp!accessing!public! !
!FileBrowserFile categoriesFor: #type!accessing!public! !

FileBrowserFolder comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!FileBrowserFolder methodsFor!

children
	"Answers the children (folders) of the receiver"

	children isNil ifTrue: [children := self getChildren].
	^children!

files
	"Answers the children (files) of the receiver sorted in alpha order"

	| files |
	files := (File find: self searchPath)
		select: [:each | (each dwFileAttributes bitAnd: 16) = 0].
	files := files collect: [:each | FileBrowserFile name: each cFileName parent: self].
	^files asSortedCollection: [:a :b | a name <= b name]!

getChildren
	"Answers the cildren (folders) of the receiver sorted in alpha order"

	| folders |
	folders := (File find: self searchPath)
		select: [:each | (each dwFileAttributes bitAnd: 16) ~= 0].
	folders := folders reject: [:each | each cFileName first = $.].
	folders := folders collect: [:each | FileBrowserFolder name: each fileName parent: self].
	^folders asSortedCollection: [:a :b | a name <= b name]!

searchPath
	"Answers the search path, the path appended with *.*, for the receiver"

	^File
		composePath: self path
		stem: '*'
		extension: '*'! !
!FileBrowserFolder categoriesFor: #children!accessing!public! !
!FileBrowserFolder categoriesFor: #files!accessing!public! !
!FileBrowserFolder categoriesFor: #getChildren!accessing!public! !
!FileBrowserFolder categoriesFor: #searchPath!accessing!public! !

!Menu methodsFor!

setItem: anInteger info: aMENUITEMINFO 
	"Private - Set state and type information for the item of the receiver with specified
	<integer> index. This can control features such as whether the item is enabled or disabled,
	checked or unchecked (and if checked whether check-box or radio button style), command
	string, bitmap, etc. Answer whether the call succeeded."

	^UserLibrary default 
		setMenuItemInfo: self handle
		uItem: anInteger - 1
		fByPosition: true
		lpmii: aMENUITEMINFO!

snoopChildren
	"Answer a collection containing any children of the receiver that should 
	appear in the snoop tree"

	#idbAdded.
	^self items!

snoopDescription
	"Answer a description of the receiver for the snoop tree"

	#idbAdded.
	^self snoopDescription: self text! !
!Menu categoriesFor: #setItem:info:!accessing!private! !
!Menu categoriesFor: #snoopChildren!accessing!idb goodies!public! !
!Menu categoriesFor: #snoopDescription!displaying!idb goodies!public! !

!StockBrush methodsFor!

ownedHandle: aHandle 
	"Private - Set the handle of the external graphics's tool object represented and owned by
	the receiver to be the argument."

	"Implementation Note: Stock objects should never be free'd"

	self handle: aHandle! !
!StockBrush categoriesFor: #ownedHandle:!accessing!private! !

!StockFont methodsFor!

ownedHandle: aHandle 
	"Private - Set the handle of the external graphics's tool object represented and owned by
	the receiver to be the argument."

	"Implementation Note: Stock objects should never be free'd"

	self handle: aHandle! !
!StockFont categoriesFor: #ownedHandle:!accessing!private! !

DeviceIndependentBitmap comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!DeviceIndependentBitmap class methodsFor!

colorTableDepth1
	"Answer a default color table to be used for depth 1 (monochrome) bitmaps"

	^(StructureArray length: 2 elementClass: RGBQUAD)
		at: 1
			put:
				((RGBQUAD new)
						rgbRed: 0;
						rgbBlue: 0;
						rgbGreen: 0);
		at: 2
			put:
				((RGBQUAD new)
						rgbRed: 255;
						rgbBlue: 255;
						rgbGreen: 255);
		yourself!

colorTableDepth16
	^StructureArray length: 1 elementClass: RGBQUAD!

colorTableDepth24
	^StructureArray length: 1 elementClass: RGBQUAD!

colorTableDepth32
	^StructureArray length: 1 elementClass: RGBQUAD!

colorTableDepth4
	"Answer a default color table to be used for depth 4 (VGA) bitmaps"

	^(StructureArray length: 16 elementClass: RGBQUAD)
		at: 1
			put:
				((RGBQUAD new)
						rgbRed: 0;
						rgbBlue: 0;
						rgbGreen: 0);
		at: 2
			put:
				((RGBQUAD new)
						rgbRed: 128;
						rgbBlue: 0;
						rgbGreen: 0);
		at: 3
			put:
				((RGBQUAD new)
						rgbRed: 0;
						rgbBlue: 0;
						rgbGreen: 128);
		at: 4
			put:
				((RGBQUAD new)
						rgbRed: 128;
						rgbBlue: 0;
						rgbGreen: 128);
		at: 5
			put:
				((RGBQUAD new)
						rgbRed: 0;
						rgbBlue: 128;
						rgbGreen: 0);
		at: 6
			put:
				((RGBQUAD new)
						rgbRed: 128;
						rgbBlue: 128;
						rgbGreen: 0);
		at: 7
			put:
				((RGBQUAD new)
						rgbRed: 0;
						rgbBlue: 128;
						rgbGreen: 128);
		at: 8
			put:
				((RGBQUAD new)
						rgbRed: 192;
						rgbBlue: 192;
						rgbGreen: 192);
		at: 9
			put:
				((RGBQUAD new)
						rgbRed: 128;
						rgbBlue: 128;
						rgbGreen: 128);
		at: 10
			put:
				((RGBQUAD new)
						rgbRed: 255;
						rgbBlue: 0;
						rgbGreen: 0);
		at: 11
			put:
				((RGBQUAD new)
						rgbRed: 0;
						rgbBlue: 0;
						rgbGreen: 255);
		at: 12
			put:
				((RGBQUAD new)
						rgbRed: 255;
						rgbBlue: 0;
						rgbGreen: 255);
		at: 13
			put:
				((RGBQUAD new)
						rgbRed: 0;
						rgbBlue: 255;
						rgbGreen: 0);
		at: 14
			put:
				((RGBQUAD new)
						rgbRed: 255;
						rgbBlue: 255;
						rgbGreen: 0);
		at: 15
			put:
				((RGBQUAD new)
						rgbRed: 0;
						rgbBlue: 255;
						rgbGreen: 255);
		at: 16
			put:
				((RGBQUAD new)
						rgbRed: 255;
						rgbBlue: 255;
						rgbGreen: 255);
		yourself!

colorTableDepth8
	"Answer a default color table to be used for depth 8 (super VGA) bitmaps"

	| table index |
	table := StructureArray length: 256 elementClass: RGBQUAD.
	table
		at: 1
			put:
				((RGBQUAD new)
						rgbRed: 0;
						rgbGreen: 0;
						rgbBlue: 0);
		at: 2
			put:
				((RGBQUAD new)
						rgbRed: 0;
						rgbGreen: 0;
						rgbBlue: 128);
		at: 3
			put:
				((RGBQUAD new)
						rgbRed: 0;
						rgbGreen: 128;
						rgbBlue: 0);
		at: 4
			put:
				((RGBQUAD new)
						rgbRed: 0;
						rgbGreen: 128;
						rgbBlue: 128);
		at: 5
			put:
				((RGBQUAD new)
						rgbRed: 128;
						rgbGreen: 0;
						rgbBlue: 0);
		at: 6
			put:
				((RGBQUAD new)
						rgbRed: 128;
						rgbGreen: 0;
						rgbBlue: 128);
		at: 7
			put:
				((RGBQUAD new)
						rgbRed: 128;
						rgbGreen: 128;
						rgbBlue: 0);
		at: 8
			put:
				((RGBQUAD new)
						rgbRed: 192;
						rgbGreen: 192;
						rgbBlue: 192);
		at: 9
			put:
				((RGBQUAD new)
						rgbRed: 128;
						rgbGreen: 128;
						rgbBlue: 128);
		at: 10
			put:
				((RGBQUAD new)
						rgbRed: 0;
						rgbGreen: 0;
						rgbBlue: 255);
		at: 11
			put:
				((RGBQUAD new)
						rgbRed: 0;
						rgbGreen: 255;
						rgbBlue: 0);
		at: 12
			put:
				((RGBQUAD new)
						rgbRed: 0;
						rgbGreen: 255;
						rgbBlue: 255);
		at: 13
			put:
				((RGBQUAD new)
						rgbRed: 255;
						rgbGreen: 0;
						rgbBlue: 0);
		at: 14
			put:
				((RGBQUAD new)
						rgbRed: 255;
						rgbGreen: 0;
						rgbBlue: 255);
		at: 15
			put:
				((RGBQUAD new)
						rgbRed: 255;
						rgbGreen: 255;
						rgbBlue: 0);
		at: 16
			put:
				((RGBQUAD new)
						rgbRed: 255;
						rgbGreen: 255;
						rgbBlue: 255).
	index := 17.
	#(0 50 101 152 203 254)
		do:
			[:red | 
			#(0 50 101 152 203 254)
				do:
					[:green | 
					#(0 50 101 152 203 254)
						do:
							[:blue | 
							table
								at: index
								put:
									((RGBQUAD new)
										rgbRed: red;
										rgbGreen: green;
										rgbBlue: blue).
							index := index + 1]]].
	0
		to: 242
		by: 11
		do:
			[:all | 
			table
				at: index
				put:
					((RGBQUAD new)
						rgbRed: all;
						rgbGreen: all;
						rgbBlue: all).
			index := index + 1].
	table
		at: index
		put:
			((RGBQUAD new)
				rgbRed: 255;
				rgbGreen: 255;
				rgbBlue: 255).
	^table!

colorTableForDepth: anInteger
	"Answer an instance of the default color table to be used for 
	DeviceIndependentBitmaps with anInteger color depth"

	^self perform: ('colorTableDepth' , anInteger printString) asSymbol!

width: width height: height depth: depth
	"Answer a DeviceIndependentBitmap with the appropritae parameters
	depth = 1, 4, 8, 16, 24 or 32"

	^self new
		width: width
		height: height
		depth: depth! !
!DeviceIndependentBitmap class categoriesFor: #colorTableDepth1!constants!public! !
!DeviceIndependentBitmap class categoriesFor: #colorTableDepth16!constants!public! !
!DeviceIndependentBitmap class categoriesFor: #colorTableDepth24!constants!public! !
!DeviceIndependentBitmap class categoriesFor: #colorTableDepth32!constants!public! !
!DeviceIndependentBitmap class categoriesFor: #colorTableDepth4!constants!public! !
!DeviceIndependentBitmap class categoriesFor: #colorTableDepth8!constants!public! !
!DeviceIndependentBitmap class categoriesFor: #colorTableForDepth:!accessing!public! !
!DeviceIndependentBitmap class categoriesFor: #width:height:depth:!instance creation!public! !

!DeviceIndependentBitmap methodsFor!

baseLoadFlags
	"Answer the basic load flags to be used when calling LoadImage() to realize the receiver."

	^##(LR_COLOR | LR_CREATEDIBSECTION)!

bitmapInfoStruct
	"Answer the value of the receiver's instance variable bitmapInfoStruct"

	self cacheInfo.
	^bitmapInfoStruct!

bitmapStruct
	"Answer the value of the receiver's instance variable bitmapStruct"

	self cacheInfo.
	^bitmapStruct!

cacheInfo
	"Cache all the information about the receiver that we can, but only once. We save 
	the structures containing the information, rather than just the information itself, as 
	these may be useful later.
	Note that this works for both created and fileIn DeviceIndependentBitmaps"

	dibSectionStruct isNil ifFalse: [^self].
	dibSectionStruct := DIBSECTION new.
	self getData: dibSectionStruct.
	bitmapStruct := BITMAP fromBytes: dibSectionStruct dsBm.
	bitmapInfoHeaderStruct := BITMAPINFOHEADER fromBytes: dibSectionStruct dsBmih.
	bitmapInfoStruct := BITMAPINFO colorDepthEx: bitmapInfoHeaderStruct biBitCount.
	bitmapInfoStruct bmiHeader: bitmapInfoHeaderStruct.
	bitmapInfoHeaderStruct biBitCount <= 8
		ifTrue: [bitmapInfoStruct bmiColors: self getColorTable bytes]!

clearCached
	"Not sure if this is absolutely necessary..."

	super clearCached.
	bitmapStruct := bitmapInfoStruct := bitmapInfoHeaderStruct := dibSectionStruct := nil!

copyToClipboard
	"Copy the receiver to the Clipboard using the DIBSection format"

	Clipboard current setDeviceIndependentBitmap: self copy!

createHandle
	"If the receiver is not a resource (identifier not nil) then we create it here. Some of the
	options, (bottom up, no compression, RGB not PAL etc) are hard wired here but
	could be dynamically altered if this is not the format required"

	| bitmapInfo |
	identifier isNil ifFalse: [^super createHandle].
	bitmapInfo := BITMAPINFO colorDepthEx: depth.
	bitmapInfo
		bmiHeader:
				((BITMAPINFOHEADER new)
						biWidth: extent x;
						biHeight: extent y;
						biPlanes: 1;
						biBitCount: depth;
						biCompression: BI_RGB;
						biSizeImage: 0;
						biXPelsPerMeter: 0;
						biYPelsPerMeter: 0;
						biClrUsed: 0;
						biClrImportant: 0;
						yourself);
		bmiColors: (self class colorTableForDepth: depth) bytes.
	^GDILibrary default
		createDIBSection: 0
		pbmi: bitmapInfo
		iUsage: DIB_RGB_COLORS
		ppvBits: ExternalAddress new
		hSection: 0
		dwOffset: 0!

depth
	"Answer the bitmap color depth.
	Note that this does not just answer the depth IV as that is not initialized by fileIn bitmaps"

	self cacheInfo.
	^bitmapInfoHeaderStruct biBitCount!

erase
	"Clear the receivers image to white"

	self canvas
		fillRectangle: (Rectangle origin: Point zero extent: self extent)
		brush: Brush white!

extent
	"Answer the bitmap extent
	Note that this does not just answer the extent IV as that is not initialized by fileIn bitmaps"

	self cacheInfo.
	^bitmapInfoHeaderStruct biWidth @ bitmapInfoHeaderStruct biHeight!

getColorTable
	"Answer the color table being used by the receiver. If there is no table (the color
	depth > 8) then we answer nil. We make an attempt to check the number of colors used, and
	create a table of that size, but most bitmaps will probably provide a full table"

	| colorsUsed table colorsLoaded |
	self cacheInfo.
	bitmapInfoHeaderStruct biBitCount > 8 ifTrue: [^nil].
	colorsUsed := bitmapInfoHeaderStruct biClrUsed = 0
		ifTrue: [2 raisedToInteger: bitmapInfoHeaderStruct biBitCount]
		ifFalse: [bitmapInfoHeaderStruct biClrUsed].
	table := StructureArray length: colorsUsed elementClass: RGBQUAD.
	colorsLoaded := GDILibrary default
		getDIBColorTable: self canvas asParameter
		uStartIndex: 0
		cEntries: colorsUsed
		pColors: table.
	colorsLoaded == colorsUsed ifFalse: [^Win32Error signal].
	^table!

imageBytes
	"Answer a ByteArray initialized from the receivers image bits"

	self cacheInfo.
	^ByteArray fromAddress: bitmapStruct bmBits length: bitmapInfoHeaderStruct biSizeImage!

saveToFile: aString
	"Save the receiver to a file named aString. Overwrites without warning"

	| stream |
	stream := FileStream write: aString text: false.
	[self saveToStream: stream] ensure: [stream close]!

saveToStream: aStream
	"Save the receiver to aStream"

	| bitmapFileHeaderStruct |
	self cacheInfo.
	bitmapFileHeaderStruct := BITMAPFILEHEADER new.
	bitmapFileHeaderStruct
		bfType: 19778;
		bfSize:
				bitmapFileHeaderStruct size + bitmapInfoStruct size + bitmapInfoHeaderStruct biSizeImage;
		bfOffBits: bitmapFileHeaderStruct size + bitmapInfoStruct size.
	aStream
		nextPutAll: bitmapFileHeaderStruct bytes;
		nextPutAll: bitmapInfoStruct bytes;
		nextPutAll: self imageBytes!

setColorTable: anRGBQUADArray
	"If the receivers color depth is less than or equal to 8 then set its color table 
	to anRGBQuadArray."

	| colorsUsed colorsSet |
	self cacheInfo.
	bitmapInfoHeaderStruct biBitCount <= 8 ifFalse: [^self].
	colorsUsed := 2 raisedToInteger: bitmapInfoHeaderStruct biBitCount.
	self assert: [anRGBQUADArray size = colorsUsed].
	colorsSet := GDILibrary default
		setDIBColorTable: self canvas asParameter
		uStartIndex: 0
		cEntries: colorsUsed
		pColors: anRGBQUADArray.
	colorsUsed = colorsSet ifFalse: [^Win32Error signal].	"reset the cache"
	bitmapInfoStruct bmiColors: self getColorTable bytes!

width: widthInteger height: heightInteger depth: depthInteger
	"Answer a new instance of the required type. 
	Note that the extent and depth IVs are only used by the createHandle method, any requests
	for the receivers extent and depth will use the cached information"

	self assert: [#(1 4 8 16 24 32) includes: depthInteger].
	extent := widthInteger @ heightInteger.
	depth := depthInteger.	"IRV"
	^self! !
!DeviceIndependentBitmap categoriesFor: #baseLoadFlags!constants!public! !
!DeviceIndependentBitmap categoriesFor: #bitmapInfoStruct!accessing!public! !
!DeviceIndependentBitmap categoriesFor: #bitmapStruct!accessing!public! !
!DeviceIndependentBitmap categoriesFor: #cacheInfo!private helpers!public! !
!DeviceIndependentBitmap categoriesFor: #clearCached!private helpers!public! !
!DeviceIndependentBitmap categoriesFor: #copyToClipboard!copying!public! !
!DeviceIndependentBitmap categoriesFor: #createHandle!public!realizing/unrealizing! !
!DeviceIndependentBitmap categoriesFor: #depth!accessing!public! !
!DeviceIndependentBitmap categoriesFor: #erase!drawing!public! !
!DeviceIndependentBitmap categoriesFor: #extent!accessing!public! !
!DeviceIndependentBitmap categoriesFor: #getColorTable!accessing!public! !
!DeviceIndependentBitmap categoriesFor: #imageBytes!accessing!public! !
!DeviceIndependentBitmap categoriesFor: #saveToFile:!file operations!public! !
!DeviceIndependentBitmap categoriesFor: #saveToStream:!file operations!public! !
!DeviceIndependentBitmap categoriesFor: #setColorTable:!accessing!public! !
!DeviceIndependentBitmap categoriesFor: #width:height:depth:!initializing!public! !

!StockPen methodsFor!

ownedHandle: aHandle 
	"Private - Set the handle of the external graphics's tool object represented and owned by
	the receiver to be the argument."

	"Implementation Note: Stock objects should never be free'd"

	self handle: aHandle! !
!StockPen categoriesFor: #ownedHandle:!accessing!private! !

IdeClassBrowserExtensions comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!IdeClassBrowserExtensions class methodsFor!

extendedClasses
	^Set
		with: SmalltalkSystem current hierarchyBrowserClass
		with: SmalltalkSystem current systemBrowserClass! !
!IdeClassBrowserExtensions class categoriesFor: #extendedClasses!accessing!public! !

IdePackageBrowserExtensions comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!IdePackageBrowserExtensions class methodsFor!

extendedClasses
	^Set with: SmalltalkSystem current packageBrowserClass! !
!IdePackageBrowserExtensions class categoriesFor: #extendedClasses!accessing!public! !

IdeViewComposerExtensions comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!IdeViewComposerExtensions class methodsFor!

extendedClasses
	^Set with: SmalltalkSystem current viewComposerClass! !
!IdeViewComposerExtensions class categoriesFor: #extendedClasses!accessing!public! !

IdeMethodFilerExtension comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!IdeMethodFilerExtension class methodsFor!

extendedClasses
	^(super extendedClasses)
		add: SmalltalkSystem current methodBrowserClass;
		yourself!

extendMenuIn: aBrowser
	| menu |
	menu := aBrowser view menuBar find: 'Method'.
	menu
		insertItem:
			(CommandMenuItem
				commandDescription:
					(ClosedCommandDescription
						command: #fileOutMethod
						description: 'File Out...'
						queryBlock:
							[:query | 
							query isEnabled: aBrowser hasMethodSelected.
							true]
						receiver: aBrowser))
		after: #methodRefactoringsMenu.
	menu insertItem: DividerMenuItem separator before: #fileOutMethod!

isExtension
	^true! !
!IdeMethodFilerExtension class categoriesFor: #extendedClasses!accessing!public! !
!IdeMethodFilerExtension class categoriesFor: #extendMenuIn:!operations!public! !
!IdeMethodFilerExtension class categoriesFor: #isExtension!constants!public!testing! !

IdeMethodHistoryExtension comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!IdeMethodHistoryExtension class methodsFor!

extendMenuIn: aBrowser
	| menu |
	menu := (aBrowser view menuBar find: 'Class') find: 'Browse'.
	menu
		insertItem:
			(CommandMenuItem
				commandDescription:
					(ClosedCommandDescription
						command: #browseMethodHistoryForClass
						description: 'Method History'
						queryBlock:
							[:query | 
							query isEnabled: aBrowser hasClassSelected.
							true]
						receiver: aBrowser))
		after: #browseChangedMethods.
	menu := (aBrowser view menuBar find: 'Method') find: 'Browse'.
	menu
		addCommandDescription:
			(ClosedCommandDescription
				command: #browseMethodHistory
				description: 'Method History'
				queryBlock:
					[:query | 
					query isEnabled: aBrowser hasMethodSelected.
					true]
				receiver: aBrowser)!

isExtension
	^true! !
!IdeMethodHistoryExtension class categoriesFor: #extendMenuIn:!operations!public! !
!IdeMethodHistoryExtension class categoriesFor: #isExtension!constants!public! !

IdeRunCommandExtension comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!IdeRunCommandExtension class methodsFor!

extendMenuIn: aBrowser
	| subView menu |
	subView := (aBrowser view viewNamed: 'classes') referee.
	menu := ((aBrowser isKindOf: ClassBrowserShell)
		ifTrue: [subView viewNamed: 'classes']
		ifFalse: [subView subViews detect: [:each | each class == CardContainer]]) contextMenu.
	menu
		addCommandDescription:
			(ClosedCommandDescription
				command: #runCommand
				description: 'Run'
				queryBlock:
					[:query | 
					query
						isEnabled:
							(aBrowser hasClassSelected and: [aBrowser selectedClass instanceClass canUnderstand: #run]).
					true]
				receiver: aBrowser)!

isExtension
	^true! !
!IdeRunCommandExtension class categoriesFor: #extendMenuIn:!operations!public! !
!IdeRunCommandExtension class categoriesFor: #isExtension!constants!public! !

IdeBrowseAllExtension comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!IdeBrowseAllExtension class methodsFor!

extendMenuIn: aBrowser
	| menu |
	menu := (aBrowser view viewNamed: 'methods') contextMenu.
	menu
		insertItem:
			(CommandMenuItem
				commandDescription:
					(ClosedCommandDescription
						command: #browseAllMethods
						description: 'Browse All'
						queryBlock:
							[:query | 
							query isEnabled: aBrowser hasMethods.
							true]
						receiver: aBrowser))
		after: #browseMethods!

isExtension
	^true! !
!IdeBrowseAllExtension class categoriesFor: #extendMenuIn:!operations!public! !
!IdeBrowseAllExtension class categoriesFor: #isExtension!constants!public! !

IdePositioningExtension comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!IdePositioningExtension class methodsFor!

extendMenuIn: aBrowser
	| menu |
	menu := (aBrowser view menuBar find: 'Modify')
		insertItem: (Menu description: 'Nudge')
		at: 10.	"Yuk. Work out how to find the index of a sub menu"
	((OrderedCollection new)
		add: #(#moveLeft 'Move Left');
		add: #(#moveRight 'Move Right');
		add: #(#moveUp 'Move Up');
		add: #(#moveDown 'Move Down');
		add: #(#increaseWidth 'Increase Width');
		add: #(#decreaseWidth 'Decrease Width');
		add: #(#increaseHeight 'Increase Height');
		add: #(#decreaseHeight 'Decrease Height');
		yourself)
		do:
			[:each | 
			menu
				addItem:
					(CommandMenuItem
						commandDescription:
							(ClosedCommandDescription
								command: (each at: 1)
								description: (each at: 2)
								queryBlock:
									[:query | 
									query isEnabled: aBrowser hasSelection.
									true]
								receiver: aBrowser))].
	menu insertItem: DividerMenuItem separator at: 5!

extendToolbarIn: aBrowser
	| toolbar bitmap |
	toolbar := (aBrowser view viewNamed: 'viewComposerTools') referee.
	bitmap := Bitmap
		fromFile: SessionManager current idbResourcesFolder , '\ViewComposer.bmp'.
	((OrderedCollection new)
		add: #(0 #alignLefts 'Align Lefts' false);
		add: #(1 #alignCenters 'Align Centres' false);
		add: #(2 #alignRights 'Align Rights' false);
		add: #(3 #alignTops 'Align Tops' false);
		add: #(5 #alignMiddles 'Align Middles' false);
		add: #(4 #alignBottoms 'Align Bottoms' false);
		add: #(6 #matchWidths 'Match Widths' false);
		add: #(7 #matchHeights 'Match Heights' false);
		add: #(8 #moveLeft 'Move Left' true);
		add: #(9 #moveRight 'Move Right' true);
		add: #(10 #moveUp 'Move Up' true);
		add: #(11 #moveDown 'Move Down' true);
		add: #(13 #increaseWidth 'Increase Width' true);
		add: #(12 #decreaseWidth 'Decrease Width' true);
		add: #(15 #increaseHeight 'Increase Height' true);
		add: #(14 #decreaseHeight 'DecreaseHeight' true);
		yourself)
		do:
			[:each | 
			toolbar
				addItem:
					(ToolbarButton
						bitmap: bitmap
						index: (each at: 1)
						commandDescription:
							(ClosedCommandDescription
								command: (each at: 2)
								description: (each at: 3)
								queryBlock:
									((each at: 4)
										ifTrue:
											[[:query | 
											query isEnabled: aBrowser hasSelection.
											true]]
										ifFalse:
											[[:query | 
											query isEnabled: aBrowser selections size >= 2.
											true]])
								receiver: aBrowser))]!

isExtension
	^true! !
!IdePositioningExtension class categoriesFor: #extendMenuIn:!operations!public! !
!IdePositioningExtension class categoriesFor: #extendToolbarIn:!operations!public! !
!IdePositioningExtension class categoriesFor: #isExtension!constants!public! !

ILExportBitmap comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ILExportBitmap methodsFor!

exportTo: aStream
	| imageExtent canvas |
	imageExtent := self maximumSize extent.
	self
		createColorTable:
			(images
				inject: Bag new
				into:
					[:colors :each | 
					colors addAll: each colorsUsed.
					colors])
		force256: false.
	self createBitmap: images size @ 1 * imageExtent.
	canvas := bitmap canvas.
	images
		keysAndValuesDo:
			[:index :each | each drawBitmapOn: canvas at: ((index - 1) * imageExtent x) @ 0].
	bitmap saveToStream: aStream!

maximumSize
	^images
		inject: Rectangle new
		into: [:rect :each | rect merge: (Point zero extent: each extent)]! !
!ILExportBitmap categoriesFor: #exportTo:!operations!public! !
!ILExportBitmap categoriesFor: #maximumSize!helpers!public! !

ILExportIcon comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ILExportIcon methodsFor!

createColorBitmapFor: anImage force256: aBoolean
	self createColorTable: anImage colorsUsed force256: aBoolean.
	self createBitmap: anImage extent.
	anImage drawBitmapOn: bitmap canvas at: Point zero.
	^bitmap!

createICONDIR
	^(ICONDIR for: iconImages size)
		idType: self icondirType;
		idCount: iconImages size!

createIconImages
	iconImages := OrderedCollection new.
	images
		keysAndValuesDo:
			[:index :each | 
			| maskBitmap colorBitmap iconImage header |
			iconImage := Array new: 5.
			colorBitmap := self createColorBitmapFor: each force256: false.
			maskBitmap := self createMaskBitmapFor: each updating: colorBitmap.
			header := colorBitmap bitmapInfoStruct bmiHeader copy.
			header
				biHeight: header biHeight * 2;
				biSizeImage: header biSizeImage + maskBitmap bitmapInfoStruct bmiHeader biSizeImage;
				biClrUsed: 0;
				biClrImportant: 0.
			iconImage
				at: 1 put: each;
				at: 2 put: header;
				at: 3 put: colorBitmap imageBytes copy;
				at: 4 put: colorBitmap getColorTable copy;
				at: 5 put: maskBitmap imageBytes copy.
			iconImages add: iconImage].
	^iconImages!

createMaskBitmapFor: anImage updating: aBitmap
	| canvas colorCanvas |
	self createColorTable: (Array with: RGB black with: RGB white) force256: false.
	self createBitmap: anImage extent.
	canvas := bitmap canvas.
	colorCanvas := aBitmap canvas.
	0
		to: anImage extent x - 1
		do:
			[:x | 
			0
				to: anImage extent y - 1
				do:
					[:y | 
					(anImage isTransparentAt: x @ y + 1)
						ifTrue:
							[colorCanvas pixelAt: x @ y put: RGB black.
							canvas pixelAt: x @ y put: RGB white]
						ifFalse: [canvas pixelAt: x @ y put: RGB black]]].
	^bitmap!

exportTo: aStream
	| iconDir offset |
	self createIconImages.
	iconDir := self createICONDIR.
	offset := ICONDIR byteSize + ((iconImages size - 1) * ICONDIRENTRY byteSize).
	iconImages
		keysAndValuesDo:
			[:index :each | 
			(iconDir idEntries at: index)
				bWidth: (each at: 1) extent x;
				bHeight: (each at: 1) extent y;
				bColorCount: ((each at: 4) size bitAnd: 255);
				dwBytesInRes:
						BITMAPINFOHEADER byteSize + (each at: 3) size + (each at: 4) byteSize + (each at: 5) size;
				dwImageOffset: offset.
			(self hotSpotFor: (each at: 1)) notNil
				ifTrue:
					["HotSpots are 0 based"
					(iconDir idEntries at: index)
						wPlanes: (self hotSpotFor: (each at: 1)) x - 1;
						wBitCount: (self hotSpotFor: (each at: 1)) y - 1].
			offset := offset + (iconDir idEntries at: index) dwBytesInRes].
	aStream nextPutAll: iconDir bytes.
	iconImages
		do:
			[:each | 
			aStream
				nextPutAll: (each at: 2) bytes;
				nextPutAll: (each at: 4) asByteArray;
				nextPutAll: (each at: 3);
				nextPutAll: (each at: 5)]!

hotSpotFor: anImage
	^nil!

icondirType
	^1! !
!ILExportIcon categoriesFor: #createColorBitmapFor:force256:!operations!public! !
!ILExportIcon categoriesFor: #createICONDIR!operations!public! !
!ILExportIcon categoriesFor: #createIconImages!operations!public! !
!ILExportIcon categoriesFor: #createMaskBitmapFor:updating:!operations!public! !
!ILExportIcon categoriesFor: #exportTo:!operations!public! !
!ILExportIcon categoriesFor: #hotSpotFor:!accessing!public! !
!ILExportIcon categoriesFor: #icondirType!constants!public! !

ILExportCursor comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ILExportCursor methodsFor!

hotSpotFor: anILImage
	"Cursors must have an hot spot so use the middle if needed"

	^anILImage hotSpot isNil
		ifTrue: [anILImage rectangle center]
		ifFalse: [anILImage hotSpot]!

icondirType
	^2! !
!ILExportCursor categoriesFor: #hotSpotFor:!accessing!public! !
!ILExportCursor categoriesFor: #icondirType!constants!public! !

ILExportExe comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ILExportExe methodsFor!

createIconImages
	| bitmapInfoHeader |
	super createIconImages.	"must be 2 images"
	iconImages size = 2 ifFalse: [^false].	"first must be 32x32@16"
	bitmapInfoHeader := iconImages first at: 2.
	bitmapInfoHeader biWidth = 32 & (bitmapInfoHeader biHeight = 64) ifFalse: [^false].
	bitmapInfoHeader biBitCount = 4 ifFalse: [^false].	"last must be 32x32@256"
	bitmapInfoHeader := iconImages last at: 2.
	bitmapInfoHeader biWidth = 32 & (bitmapInfoHeader biHeight = 64) ifFalse: [^false].
	bitmapInfoHeader biBitCount = 8 ifFalse: [self upgradeTo256: iconImages last].
	^true!

errorMessage
	MessageBox
		notify:
			'Unable to export icons to Exe file because of one (or more) of the following.

The file named is not a exe file.
The file named was not created by Dolphin V5.
There must be 2 images selected.
The selection does not provide 2 icons with the following attributes and in the following order
	32 x 32 using 3 to 16 colours.
	32 x 32 using 3 to 256 colours'!

exportTo: aStream
	| importClass |
	self createIconImages ifFalse: [^self errorMessage].
	importClass := (OrderedCollection with: ILImportStandardExe with: ILImportToGoExe)
		detect: [:each | [each isResponsibleFor: aStream] ensure: [aStream reset]]
		ifNone: [^self errorMessage].
	aStream position: importClass iconsStartAddress.
	iconImages
		do:
			[:each | 
			aStream
				nextPutAll: (each at: 2) bytes;
				nextPutAll: (each at: 4) asByteArray;
				nextPutAll: (each at: 3);
				nextPutAll: (each at: 5)].
	self assert: [aStream position = importClass iconsEndAddress]!

upgradeTo256: anIconImage
	| colorBitmap maskBitmap header |
	colorBitmap := self createColorBitmapFor: (anIconImage at: 1) force256: true.
	maskBitmap := self createMaskBitmapFor: (anIconImage at: 1) updating: colorBitmap.
	header := colorBitmap bitmapInfoStruct bmiHeader copy.
	header
		biHeight: header biHeight * 2;
		biSizeImage: header biSizeImage + maskBitmap bitmapInfoStruct bmiHeader biSizeImage;
		biClrUsed: 0;
		biClrImportant: 0.
	anIconImage
		at: 2 put: header;
		at: 3 put: colorBitmap imageBytes copy;
		at: 4 put: colorBitmap getColorTable copy;
		at: 5 put: maskBitmap imageBytes copy! !
!ILExportExe categoriesFor: #createIconImages!operations!public! !
!ILExportExe categoriesFor: #errorMessage!helpers!public! !
!ILExportExe categoriesFor: #exportTo:!operations!public! !
!ILExportExe categoriesFor: #upgradeTo256:!operations!public! !

ILEditingImage comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ILEditingImage methodsFor!

beModified
	self isModified
		ifFalse:
			[modified := true.
			self trigger: #toolbarChanged.
			self trigger: #modifiedDescriptionChanged]!

beNotModified
	self isModified
		ifTrue:
			[modified := false.
			self trigger: #toolbarChanged.
			self trigger: #modifiedDescriptionChanged]!

brushFor: aPoint
	^brushCache at: (self imageAt: aPoint)!

canPaste
	^Clipboard current isObjectAvailable!

canRedo
	^redoStack notEmpty!

canUndo
	^undoStack notEmpty | undoCollector notEmpty!

draw: aDyadicBlock location: aRectangle with: anRGB
	| bitmap canvas drawnRectangle |
	self undoCommit.
	bitmap := Bitmap
		compatible: DesktopView current canvas
		width: aRectangle width + 10
		height: aRectangle height + 10.
	canvas := bitmap canvas.
	canvas
		brush: Brush white;
		pen: Pen black;
		erase.
	drawnRectangle := aDyadicBlock
		value: canvas
		value: (Point zero corner: aRectangle extent).
	(self pixelPoints: drawnRectangle)
		do:
			[:each | 
			(canvas pixelAt: each) = RGB black
				ifTrue: [self putRGB: anRGB at: each + aRectangle origin - drawnRectangle origin]].
	self undoCommit.
	self notifyChangedRectangle: aRectangle!

draw: aPoint on: aCanvas in: aRectangle
	aCanvas
		brush: (self brushFor: aPoint);
		rectangle: aRectangle!

editCopy: aRectangle
	Clipboard current
		setObject:
			(Array
				with: 'ImageEditor'
				with:
					((self pixelPoints: aRectangle)
						collect: [:each | each - aRectangle origin -> (self getRGBAt: each)]))!

editCut: aRectangle with: anRGB
	self undoCommit.
	self editCopy: aRectangle.
	self fill: aRectangle with: anRGB.
	self notifyChangedRectangle: aRectangle!

editPaste: aRectangle
	| object |
	self canPaste ifFalse: [^self].
	object := Clipboard current getObject.
	(object class == Array and: [object size = 2 and: [(object at: 1) = 'ImageEditor']])
		ifFalse: [^self].
	self undoCommit.
	(object at: 2)
		do:
			[:each | 
			| pixel |
			pixel := each key + aRectangle origin.
			(aRectangle containsPointInclusive: pixel) ifTrue: [self putRGB: each value at: pixel]].
	self notifyChangedRectangle: aRectangle!

editRedo
	| pixels |
	pixels := redoStack removeFirst.
	undoStack addLast: (pixels collect: [:each | each key -> (self getRGBAt: each key)]).
	pixels do: [:each | super putRGB: each value at: each key].
	self notifyChangedPoints: (pixels collect: [:each | each key])!

editUndo
	| pixels |
	self undoCommit.
	pixels := undoStack removeLast.
	redoStack addFirst: (pixels collect: [:each | each key -> (self getRGBAt: each key)]).
	pixels reverseDo: [:each | super putRGB: each value at: each key].
	self notifyChangedPoints: (pixels collect: [:each | each key])!

ellipse: aRectangle with: anRGB
	self
		draw:
			[:canvas :drawRectangle | 
			canvas ellipse: (drawRectangle increaseCornerBy: 1).
			drawRectangle]
		location: aRectangle
		with: anRGB!

fill: aRectangle with: anRGB
	self
		draw:
			[:canvas :drawRectangle | 
			canvas fillRectangle: (drawRectangle increaseCornerBy: 1) brush: Brush black.
			drawRectangle]
		location: aRectangle
		with: anRGB!

hotSpot: aPoint
	super hotSpot: aPoint.
	self beModified.
	self trigger: #imageDescriptionChanged!

indexFor: anRGB
	| index |
	index := super indexFor: anRGB.	"If the brush cache is nil we haven't got to the stage where we need brushes, so don't bother"
	(brushCache notNil and: [index > brushCache size])
		ifTrue: [brushCache add: (Brush color: (self rgbFor: index))].
	^index!

isModified
	^modified!

libraryImage
	"Answer an ILmage which is a copy of the receiver suitable for the library"

	^(ILImage extent: extent colors: (image collect: [:each | self rgbFor: each]))
		hotSpot: self hotSpot;
		yourself!

lineTlBr: aRectangle with: anRGB
	self
		draw:
			[:canvas :drawRectangle | 
			| rectangle |
			rectangle := drawRectangle increaseCornerBy: 1.
			canvas
				moveTo: rectangle origin;
				lineTo: rectangle corner.
			drawRectangle]
		location: aRectangle
		with: anRGB!

lineTrBl: aRectangle with: anRGB
	self
		draw:
			[:canvas :drawRectangle | 
			| rectangle |
			rectangle := drawRectangle increaseCornerBy: 1.
			canvas
				moveTo: rectangle right @ -1;
				lineTo: -1 @ rectangle bottom.
			drawRectangle]
		location: aRectangle
		with: anRGB!

modifiedDescription
	^self isModified ifTrue: [' modified'] ifFalse: [String new]!

notifyChangedPoints: aCollection
	self
		notifyChangedRectangle:
			(aCollection
				inject: (aCollection first extent: 0)
				into: [:rectangle :each | rectangle merge: (each extent: 0)])!

notifyChangedRectangle: aRectangle
	self
		clearBitmapCache;
		beModified;
		trigger: #imageChanged: with: aRectangle!

plot: aPoint with: anRGB
	self putRGB: anRGB at: aPoint.
	self notifyChangedPoints: (OrderedCollection with: aPoint)!

putRGB: anRGB at: aPoint
	self undoAdd: aPoint -> (self getRGBAt: aPoint).
	super putRGB: anRGB at: aPoint!

rectangle: aRectangle with: anRGB
	self
		draw:
			[:canvas :drawRectangle | 
			canvas rectangle: (drawRectangle increaseCornerBy: 1).
			drawRectangle]
		location: aRectangle
		with: anRGB!

setExtent: aPoint colors: anArray
	super setExtent: aPoint colors: anArray.
	modified := false.
	brushCache := colorsUsed collect: [:each | Brush color: each].
	undoStack := OrderedCollection new.
	redoStack := OrderedCollection new.
	undoCollector := OrderedCollection new!

text: aRectangle with: anRGB displaying: aString
	self
		draw:
			[:canvas :drawRectangle | 
			| pixelSize bitmapRectangle |
			pixelSize := 6.
			[pixelSize := pixelSize + 1.
			canvas
				erase;
				font: (Font name: 'Arial' pixelSize: pixelSize) beBold;
				text: aString at: Point zero.
			(self usedRectangleIn: canvas within: drawRectangle extent + 10) extent
				<= drawRectangle extent] whileTrue.
			canvas erase.
			pixelSize = 7
				ifFalse:
					[canvas
						font: (Font name: 'Arial' pixelSize: pixelSize - 1) beBold;
						text: aString at: Point zero].
			self usedRectangleIn: canvas within: drawRectangle extent + 10]
		location: aRectangle
		with: anRGB!

undoAdd: anAssociation
	redoStack isNil ifTrue: [^self].
	redoStack notEmpty | undoCollector isEmpty
		ifTrue:
			[redoStack := OrderedCollection new.
			self trigger: #toolbarChanged].
	undoCollector addLast: anAssociation!

undoCommit
	undoCollector isEmpty ifTrue: [^self].
	undoStack addLast: undoCollector.
	undoCollector := OrderedCollection new!

usedRectangleIn: aCanvas within: aPoint
	| left right top bottom |
	left := (0 to: aPoint x)
		detect:
			[:across | (0 to: aPoint y) anySatisfy: [:down | (aCanvas pixelAt: across @ down) = RGB black]].
	right := (aPoint x to: 0 by: -1)
		detect:
			[:across | (0 to: aPoint y) anySatisfy: [:down | (aCanvas pixelAt: across @ down) = RGB black]].
	top := (0 to: aPoint y)
		detect:
			[:down | (0 to: aPoint x) anySatisfy: [:across | (aCanvas pixelAt: across @ down) = RGB black]].
	bottom := (aPoint y to: 0 by: -1)
		detect:
			[:down | (0 to: aPoint x) anySatisfy: [:across | (aCanvas pixelAt: across @ down) = RGB black]].
	^left @ top corner: right @ bottom! !
!ILEditingImage categoriesFor: #beModified!accessing!public! !
!ILEditingImage categoriesFor: #beNotModified!accessing!public! !
!ILEditingImage categoriesFor: #brushFor:!accessing!public! !
!ILEditingImage categoriesFor: #canPaste!public!testing! !
!ILEditingImage categoriesFor: #canRedo!public!testing! !
!ILEditingImage categoriesFor: #canUndo!public!testing! !
!ILEditingImage categoriesFor: #draw:location:with:!operations!public! !
!ILEditingImage categoriesFor: #draw:on:in:!operations!public! !
!ILEditingImage categoriesFor: #editCopy:!operations!public! !
!ILEditingImage categoriesFor: #editCut:with:!operations!public! !
!ILEditingImage categoriesFor: #editPaste:!operations!public! !
!ILEditingImage categoriesFor: #editRedo!operations!public! !
!ILEditingImage categoriesFor: #editUndo!operations!public! !
!ILEditingImage categoriesFor: #ellipse:with:!operations!public! !
!ILEditingImage categoriesFor: #fill:with:!operations!public! !
!ILEditingImage categoriesFor: #hotSpot:!accessing!public! !
!ILEditingImage categoriesFor: #indexFor:!accessing!public! !
!ILEditingImage categoriesFor: #isModified!public!testing! !
!ILEditingImage categoriesFor: #libraryImage!converting!public! !
!ILEditingImage categoriesFor: #lineTlBr:with:!operations!public! !
!ILEditingImage categoriesFor: #lineTrBl:with:!operations!public! !
!ILEditingImage categoriesFor: #modifiedDescription!displaying!public! !
!ILEditingImage categoriesFor: #notifyChangedPoints:!helpers!public! !
!ILEditingImage categoriesFor: #notifyChangedRectangle:!helpers!public! !
!ILEditingImage categoriesFor: #plot:with:!operations!public! !
!ILEditingImage categoriesFor: #putRGB:at:!accessing!public! !
!ILEditingImage categoriesFor: #rectangle:with:!operations!public! !
!ILEditingImage categoriesFor: #setExtent:colors:!initializing!public! !
!ILEditingImage categoriesFor: #text:with:displaying:!operations!public! !
!ILEditingImage categoriesFor: #undoAdd:!operations!public! !
!ILEditingImage categoriesFor: #undoCommit!operations!public! !
!ILEditingImage categoriesFor: #usedRectangleIn:within:!helpers!public! !

ILImportBitmap comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ILImportBitmap class methodsFor!

isResponsibleFor: aStream
	^(aStream next: 2) = 'BM' asByteArray! !
!ILImportBitmap class categoriesFor: #isResponsibleFor:!public!testing! !

!ILImportBitmap methodsFor!

images
	| imageSize images |
	images := OrderedCollection new.
	imageSize := self requestImageSize.
	imageSize isNil ifTrue: [^images].	"Cursor needed here cos of the dialog just opened"
	Cursor wait
		showWhile:
			[0
				to: bitmap width - 1
				by: imageSize x
				do:
					[:offset | 
					| colors |
					colors := Array writeStream.
					1
						to: imageSize y
						do:
							[:y | 
							1
								to: imageSize x
								do: [:x | colors nextPut: (self colorAtPoint: (x + offset) @ y in: bitmap)]].
					images add: (ILImage extent: imageSize colors: colors contents)]].
	^images!

initializeFrom: aStream
	bitmapFileHeader := BITMAPFILEHEADER fromBytes: (aStream next: BITMAPFILEHEADER byteSize).
	bitmap := self getBitmapFrom: aStream upToEnd!

proxyClass
	^ILImportBitmapProxy!

requestImageSize
	^(ILBitmapExtentDialog create)
		bitmapExtent: bitmap width @ bitmap height;
		showModal! !
!ILImportBitmap categoriesFor: #images!operations!public! !
!ILImportBitmap categoriesFor: #initializeFrom:!initializing!public! !
!ILImportBitmap categoriesFor: #proxyClass!constants!public! !
!ILImportBitmap categoriesFor: #requestImageSize!helpers!public! !

ILImportIcon comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ILImportIcon class methodsFor!

isResponsibleFor: aStream
	^(aStream next: 3) = #[0 0 1]! !
!ILImportIcon class categoriesFor: #isResponsibleFor:!public!testing! !

!ILImportIcon methodsFor!

hotSpotFor: anInteger
	^nil!

images
	| images |
	images := OrderedCollection new.
	icons
		keysAndValuesDo:
			[:index :each | 
			| colors image |
			colors := Array writeStream.
			1
				to: each height
				do:
					[:y | 
					1
						to: each width
						do:
							[:x | 
							each useMaskBytes.
							(self colorAtPoint: x @ y in: each) = RGB white
								ifTrue: [colors nextPut: RGB dolphinYellow]
								ifFalse:
									[each useColorBytes.
									colors nextPut: (self colorAtPoint: x @ y in: each)]]].
			image := ILImage extent: each width @ each height colors: colors contents.
			(self hotSpotFor: index) notNil ifTrue: [image hotSpot: (self hotSpotFor: index) + 1].
			images add: image].
	^images!

initializeFrom: aStream
	| iconDirSize |
	aStream
		nextWORD;
		nextWORD.
	iconDirSize := aStream nextWORD * ICONDIRENTRY byteSize + ICONDIR byteSize.
	aStream reset.
	iconDir := (ICONDIR new: iconDirSize) bytes: (aStream next: iconDirSize).
	icons := OrderedCollection new.
	iconDir idEntries
		do:
			[:each | 
			icons
				add:
					(self
						getBitmapFrom:
							(aStream
								position: each dwImageOffset;
								next: each dwBytesInRes))]!

proxyClass
	^ILImportIconProxy! !
!ILImportIcon categoriesFor: #hotSpotFor:!accessing!public! !
!ILImportIcon categoriesFor: #images!operations!public! !
!ILImportIcon categoriesFor: #initializeFrom:!initializing!public! !
!ILImportIcon categoriesFor: #proxyClass!constants!public! !

ILImportLibrary comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ILImportLibrary class methodsFor!

isResponsibleFor: aStream
	[^(aStream next: 3) = 'LIB' asByteArray] ensure: [aStream reset]! !
!ILImportLibrary class categoriesFor: #isResponsibleFor:!public!testing! !

!ILImportLibrary methodsFor!

initializeFrom: aStream
	aStream skip: 3.
	^Object binaryReadFrom: aStream! !
!ILImportLibrary categoriesFor: #initializeFrom:!initializing!public! !

ILImportCursor comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ILImportCursor class methodsFor!

isResponsibleFor: aStream
	^(aStream next: 3) = #[0 0 2]! !
!ILImportCursor class categoriesFor: #isResponsibleFor:!public!testing! !

!ILImportCursor methodsFor!

hotSpotFor: anInteger
	| iconDirEntry |
	iconDirEntry := iconDir idEntries at: anInteger.
	^iconDirEntry wPlanes @ iconDirEntry wBitCount!

proxyClass
	^ILImportCursorProxy! !
!ILImportCursor categoriesFor: #hotSpotFor:!accessing!public! !
!ILImportCursor categoriesFor: #proxyClass!constants!public! !

ILImportExe comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ILImportExe class methodsFor!

iconsCheck: aStream
	"The bytes that must be found to make sure there is an icon in the correct place"

	"Check for a 32x32@16 BITMAPINFOHEADER"

	aStream position: self iconsStartAddress.
	(aStream next: BITMAPINFOHEADER byteSize)
		=
			((BITMAPINFOHEADER new)
				biWidth: 32;
				biHeight: 64;
				biPlanes: 1;
				biBitCount: 4;
				biSizeImage: 640;
				bytes) ifFalse: [^false].	"Check for a following 32x32@256 BITMAPINFOHEADER"
	aStream position: self iconsStartAddress + self iconsSizes first.
	^(aStream next: BITMAPINFOHEADER byteSize)
		=
			((BITMAPINFOHEADER new)
				biWidth: 32;
				biHeight: 64;
				biPlanes: 1;
				biBitCount: 8;
				biSizeImage: 1152;
				bytes)!

iconsEndAddress
	self subclassResponsibility!

iconsSizes
	"The size of the 2 icons in the correct order -
	32x32@16  32x32@256"

	^#(744 2216)!

iconsStartAddress
	self subclassResponsibility!

isResponsibleFor: aStream
	^(aStream next: 2) = 'MZ' asByteArray
		and: [aStream size > self iconsEndAddress and: [self iconsCheck: aStream]]! !
!ILImportExe class categoriesFor: #iconsCheck:!constants!public! !
!ILImportExe class categoriesFor: #iconsEndAddress!constants!public! !
!ILImportExe class categoriesFor: #iconsSizes!constants!public! !
!ILImportExe class categoriesFor: #iconsStartAddress!constants!public! !
!ILImportExe class categoriesFor: #isResponsibleFor:!public!testing! !

!ILImportExe methodsFor!

initializeFrom: aStream
	| offset |
	icons := OrderedCollection new.
	offset := self class iconsStartAddress.
	self class iconsSizes
		do:
			[:size | 
			icons
				add:
					(self
						getBitmapFrom:
							(aStream
								position: offset;
								next: size)).
			offset := offset + size].
	self assert: [aStream position = self class iconsEndAddress]! !
!ILImportExe categoriesFor: #initializeFrom:!initializing!public! !

ILImportStandardExe comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ILImportStandardExe class methodsFor!

iconsEndAddress
	^9484!

iconsStartAddress
	"The start address of the icons in a Dolphin exe"

	^6524! !
!ILImportStandardExe class categoriesFor: #iconsEndAddress!constants!public! !
!ILImportStandardExe class categoriesFor: #iconsStartAddress!constants!public! !

ILImportToGoExe comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ILImportToGoExe class methodsFor!

iconsEndAddress
	^212724!

iconsStartAddress
	"The start address of the icons in a Dolphin exe"

	^209764! !
!ILImportToGoExe class categoriesFor: #iconsEndAddress!constants!public! !
!ILImportToGoExe class categoriesFor: #iconsStartAddress!constants!public! !

ILImportIconProxy comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ILImportIconProxy methodsFor!

colorBytes
	colorBytes isNil
		ifTrue:
			[colorBytes := imageBytes
				copyFrom: 1
				to: imageBytes size - (((self width - 1) // 32 + 1) * 4 * self height)].
	^colorBytes!

colorDepth
	useMaskBytes ifTrue: [^1].
	^super colorDepth!

colorTable
	useMaskBytes ifTrue: [^DeviceIndependentBitmap colorTableForDepth: 1].
	^super colorTable!

height
	^super height // 2!

imageBytes
	^useMaskBytes ifTrue: [self maskBytes] ifFalse: [self colorBytes]!

maskBytes
	maskBytes isNil
		ifTrue:
			[maskBytes := imageBytes
				copyFrom: imageBytes size - (((self width - 1) // 32 + 1) * 4 * self height) + 1
				to: imageBytes size].
	^maskBytes!

setBitmapInfoHeader: aBITMAPINFOHEADER colorTable: aStructureArray imageBytes: aByteArray
	super
		setBitmapInfoHeader: aBITMAPINFOHEADER
		colorTable: aStructureArray
		imageBytes: aByteArray.
	useMaskBytes := false!

useColorBytes
	useMaskBytes := false!

useMaskBytes
	useMaskBytes := true! !
!ILImportIconProxy categoriesFor: #colorBytes!accessing!public! !
!ILImportIconProxy categoriesFor: #colorDepth!accessing!public! !
!ILImportIconProxy categoriesFor: #colorTable!accessing!public! !
!ILImportIconProxy categoriesFor: #height!accessing!public! !
!ILImportIconProxy categoriesFor: #imageBytes!accessing!public! !
!ILImportIconProxy categoriesFor: #maskBytes!accessing!public! !
!ILImportIconProxy categoriesFor: #setBitmapInfoHeader:colorTable:imageBytes:!initializing!public! !
!ILImportIconProxy categoriesFor: #useColorBytes!accessing!public! !
!ILImportIconProxy categoriesFor: #useMaskBytes!accessing!public! !

ILImportCursorProxy comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
Win9xInputState comment:
'<Win9xInputState> is a specialised <InputState> that is used when the system is running on Win9x hosts. This class will be removed from a future release when support for Win98 is withdrawn.
'!
!Win9xInputState class methodsFor!

initialize
	maxIdleSleep := 5000! !
!Win9xInputState class categoriesFor: #initialize!development!initializing!public! !

!Win9xInputState methodsFor!

idle
	"Private - Put the VM thread to sleep until there are messages from the host system, or a timer
	fires, to prevent unecessary consumption of host system time."

	"Implementation Note: At the time of writing it appears that there are some bugs in Windows
	98's implementation of MsgWaitForMultipleObjectsEx(), and on some early versions of 98 the
	function isn't even available, so it is safest to use the MsgWaitForMultipleObjects(). This
	means that on 9x platforms overlapped calls will be less efficient."

	MemoryManager current aboutToIdle.
	UserLibrary default 
		msgWaitForMultipleObjects: 1
		pHandles: wakeupEvent
		fWaitAll: false
		dwMilliseconds: self class maxIdleSleep
		dwWakeMask: QS_ALLINPUT.
	self isInputAvailable 
		ifTrue: 
			[self ensureMainRunning.
			inputSemaphore set]!

uiIdle
	"Private - Inform the receiver's registered windows that the UI is going idle so that they
	can update visual elements accordingly - e.g. enable/disable toolbar buttons. The windows
	can do other processing from their idle notification handlers, but it should be of very
	short duration, or the responsiveness of the UI will be adversely affected."

	^self topLevelHandlesDo: 
			[:each | 
			"#1272: Idle time UI validation stalls intermittently on Windows 98: There
			seems to be a bug in Win98 such that it doesn't reset the top queue status
			bits correctly, so we must terminate on new input availability, not old
			input, as otherwise the UI may never go idle."
			self isNewInputAvailable 
				ifTrue: 
					[self inputSemaphore set.
					false	"stop enumerating"]
				ifFalse: 
					[self uiIdle: each.
					true	"keep enumerating"]]! !
!Win9xInputState categoriesFor: #idle!idling!private! !
!Win9xInputState categoriesFor: #uiIdle!idling!private! !

!BorderLayout methodsFor!

resolutionScaledBy: aPoint 
	"Private - The receiver is being loaded and it has been determined that the pixel resolution
	has changed since the point at which the view was saved. Scale any internal pixels by the
	<Point> argument."

	hgap := (hgap * aPoint x) truncated.
	vgap := (vgap * aPoint y) truncated! !
!BorderLayout categoriesFor: #resolutionScaledBy:!geometry!private! !

ScrollingDecoratorLayout comment:
'ScrollingDecoratorLayout implements a specialised <layoutManager> to layout a single <view> object contained within a <scrolllingDecoratorView>. The ScrollingDecoratorLayout does not attempt to resize the managed view (although see the #shouldStretchToFit aspect) but, instead, it repositions it according to scroll information that it receives from the view''s parent. Scrollbars will become available in the parent <scrollingDecoratorView> when its extent goes below the preferred extent recommended by the ScrollingDecoratorLayout.'!
!ScrollingDecoratorLayout class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^(super publishedAspectsOfInstances)
		add: (Aspect boolean: #shouldStretchToFit);
		yourself!

stbConvertFrom: anSTBClassFormat 
	"Convert from earlier schema."

	^
	[:data | 
	| newInstance |
	newInstance := self new.
	1 to: data size do: [:i | newInstance instVarAt: i put: (data at: i)].
	newInstance]!

stbVersion
	^1! !
!ScrollingDecoratorLayout class categoriesFor: #publishedAspectsOfInstances!constants!development!public! !
!ScrollingDecoratorLayout class categoriesFor: #stbConvertFrom:!binary filing!public! !
!ScrollingDecoratorLayout class categoriesFor: #stbVersion!constants!public! !

!ScrollingDecoratorLayout methodsFor!

initialize
	stretchToFit := true!

layoutContainer: aScrollingDecorator 
	"Performs a layout operation on the contents in aScrollingDecorator."

	| subviews newScroll |
	subviews := aScrollingDecorator managedSubViews.
	subviews isEmpty 
		ifTrue: [newScroll := 0 @ 0]
		ifFalse: 
			[| clientExtent desiredExtent scrollOffset viewExtent rectangles |
			clientExtent := aScrollingDecorator clientExtent.
			desiredExtent := self preferredLayoutExtentOf: aScrollingDecorator.
			viewExtent := self shouldStretchToFit 
						ifTrue: [clientExtent max: desiredExtent]
						ifFalse: [desiredExtent].
			scrollOffset := aScrollingDecorator scrollOffset.
			newScroll := ((scrollOffset x min: viewExtent x - clientExtent x) max: 0) 
						@ ((scrollOffset y min: viewExtent y - clientExtent y) max: 0).
			rectangles := self 
						rectangles: subviews
						offset: newScroll
						extent: viewExtent.
			subviews with: rectangles do: [:view :rectangle | view rectangle: rectangle]].
	aScrollingDecorator
		scrollOffset: newScroll;
		updateScrollBars!

shouldStretchToFit
	"Answer whether subviews that are smaller than the available client area of the
	<ScrollingDecorator> managed by the receiver should be expanded to fill that area. Note that
	when this option is enabled (it is the default) the subviews may have an extent greater than
	their preferred extent, but they are never shrunk below that preferred extent. Scrollbars
	will appear only if the available client area shrinks below that required to display the
	subviews at their preferred extents."

	^stretchToFit!

shouldStretchToFit: aBoolean 
	stretchToFit := aBoolean! !
!ScrollingDecoratorLayout categoriesFor: #initialize!initializing!public! !
!ScrollingDecoratorLayout categoriesFor: #layoutContainer:!geometry!private! !
!ScrollingDecoratorLayout categoriesFor: #shouldStretchToFit!accessing!public! !
!ScrollingDecoratorLayout categoriesFor: #shouldStretchToFit:!accessing!public! !

DiffLink comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!DiffLink methodsFor!

value
	^value!

value: aValue
	value := aValue! !
!DiffLink categoriesFor: #value!accessing!public! !
!DiffLink categoriesFor: #value:!accessing!public! !

!Process methodsFor!

inspectorClass
	"Answer the class of inspector to be used when inspecting the receiver."

	^self isMain ifTrue: [self alternateInspectorClass] ifFalse: [super inspectorClass]!

stackDepthFrom: aStackFrame
	"Answer the number of frames on the stack below aStackFrame"

	| frame i |
	#idbAdded.
	frame := aStackFrame.
	i := 0.
	[frame notNil and: [frame method selector notNil]]
		whileTrue:
			[frame := frame sender.
			i := i + 1].
	^i! !
!Process categoriesFor: #inspectorClass!constants!development!public! !
!Process categoriesFor: #stackDepthFrom:!accessing!idb goodies!public! !

!Date class methodsFor!

fromDateAndTime: aDateAndTime
	"Answer an instance of Date initialized from aDateAndTime's local time
	i.e. Any time zone offset in aDateAndTime is ignored"

	#idbAdded.
	^self
		newDay: aDateAndTime dayOfMonth
		monthIndex: aDateAndTime month
		year: aDateAndTime year!

fromString: aString
	"Answer an instance of the receiver constructed from the string,
	aString, using the default conversion format."

	| stream answer |
	stream := aString readStream.
	answer := self readFrom: stream.
	stream atEnd ifFalse: [^self errorInvalidFormat].
	^answer
! !
!Date class categoriesFor: #fromDateAndTime:!idb goodies!instance creation!public! !
!Date class categoriesFor: #fromString:!instance creation!public! !

DateAndTime comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!DateAndTime class methodsFor!

clockPrecision
	"Answer a <Duration> such that after that period of time passes, #now is guaranteed
	to answer a different <DateAndTime>. Ideally this should be the minimum such duration.
	(idb) The #now method on my box (Win2000) answers with a 10mS precision.  If we assume
	that the current machine talkes less than 10 mS to execute #now (reasonable?) then the 
	minimum clockPrecision of #now is 10mS

	Test using the following. Use a Bag to see how many of each occurs (About 1%
	are above 10mS on my box (GC?))
	diff := Set new.
		current := SYSTEMTIME now wMilliseconds.
		1000000 timesRepeat: [
			now := SYSTEMTIME now wMilliseconds.
			now = current
				ifFalse: [
					now > current ifTrue: [diff add: now - current].
					current := now]].
			diff asSortedCollection first / 1000"

	^Duration seconds: 1 / 100!

daysInMonth: monthInteger forYear: yearInteger
	"Answer the number of days in monthInteger for yearInteger. 
	Adjustment is for February in leap years"

	| days |
	days := #(31 28 31 30 31 30 31 31 30 31 30 31) at: monthInteger.
	(monthInteger = 2 and: [self isLeapYear: yearInteger]) ifTrue: [^days + 1].
	^days!

daysToMonth: monthInteger forYear: yearInteger
	"Answer the number of days preceeding monthInteger for yearInteger. 
	Adjustment is for all months after February in leap years"

	| days |
	days := #(0 31 59 90 120 151 181 212 243 273 304 334) at: monthInteger.
	(monthInteger > 2 and: [self isLeapYear: yearInteger]) ifTrue: [^days + 1].
	^days!

defaultOffset
	"Answer the offset (TimeZone) set for the current machine"

	| tzi current offset |
	tzi := TIMEZONEINFORMATION new.
	current := KernelLibrary default getTimeZoneInformation: tzi.
	offset := tzi bias.
	current = 1 ifTrue: [offset := offset + tzi standardBias].
	current = 2 ifTrue: [offset := offset + tzi daylightBias].	"offset = the change in minutes to go from LOCAL time to UTC time"
	^(Duration seconds: offset * 60) negated!

encodeRataDieYear: year day: dayOfYear
	"Encode dayOfYear in year into an Integer representing the number of days
	since 1/1/1 (= day 1). Will answer a negative Integer for earlier dates.
	See http://www.capecod.net/~pbaum/date/date0.htm"

	^(self
		encodeRataDieYear: year
		month: 1
		day: 1) + dayOfYear - 1!

encodeRataDieYear: year month: month day: dayOfMonth
	"Encode day in month in year into an Integer representing the number of days
	since 1/1/1 (= day 1). Will answer a negative Integer for earlier dates
	See http://www.capecod.net/~pbaum/date/date0.htm"

	| m y |
	m := month.
	y := year.
	m < 3
		ifTrue:
			[m := m + 12.
			y := y - 1].
	^dayOfMonth + ((153 * m - 457) // 5) + (365 * y) + (y // 4) - (y // 100) + (y // 400)
		- 306!

errorInvalidFormat
	"Private - Raise an error that some attempt to create an instance of the receiver failed because the some input was in the wrong format."

	#DtTmX.	"2001/07/18 Harmon, R. Added for DateAndTimeExtra support."
	^InvalidFormat signalWith: self!

fromDate: aDate time: aTime
	"Answers a new instance of DateAndTime initialized from aDate and aTime.
	NB: The offset defaults to the machines current time zone"

	^self
		year: aDate year
		month: aDate monthIndex
		day: aDate dayOfMonth
		hour: aTime hours
		minute: aTime minutes
		second: aTime seconds!

fromString: aString
	"Answer a new <DateAndTime> constructed from aString <String> in the Reg. Ex. format:
		[- ]YYYY-MM-DDThh:mm:ss(.ss*)?[-+]ZZ:zz(:zz*)?.
which represents a local date and time."

	#DtTmX.	"2001/07/18 Harmon, R. Added for <DateAndTimeExtra factory>."
	^self readFrom: (ReadStream on: aString)!

fromSYSTEMTIME: aSYSTEMTIME offset: offset
	"Answer a <DateAndTime> from SYSTEMTIME in local time."

	#DtTmX.	"2001/07/18 Harmon, R. Added for <DateAndTimeExtra factory>."
	^self
		year: aSYSTEMTIME wYear
		month: aSYSTEMTIME wMonth
		day: aSYSTEMTIME wDay
		hour: aSYSTEMTIME wHour
		minute: aSYSTEMTIME wMinute
		second: aSYSTEMTIME wSecond + (aSYSTEMTIME wMilliseconds / 1000)
		offset: offset!

fromTimeStamp: aTimeStamp
	"Answers a new instance of DateAndTime initialized from aTimeStamp
	NB: The offset defaults to the machines current time zone"

	^self fromDate: aTimeStamp date time: aTimeStamp time!

initialize
	" Set up the offsets into the cache instVar fieldValues
	DateAndTime initialize  "

	Year := 1.
	Month := 2.
	DayOfMonth := 3.
	Hour := 4.
	Minute := 5.
	Second := 6.
	DayOfWeek := 7!

isLeapYear: year
	"Answer true if year is a leap year"

	^year \\ 400 = 0 or: [year \\ 4 = 0 and: [year \\ 100 ~= 0]]!

now
	"Answer the current <DateAndTime> in local time. The new offset
	(TimeZone) is set to the value set bu #defaultOffset"

	^self fromSYSTEMTIME: SYSTEMTIME now offset: self defaultOffset!

readDateFrom: aStream
	"Private - Answers yyyy, mm, and dd list read from aStream <gettableStream> in the Reg. Ex. format: YYYY-MM-DD.  Signal an error if not in specified format."

	| dd mm yyyy pos |
	#DtTmX.	"2001/07/18 Harmon, R. Added for DateAndTimeExtra support."
	pos := aStream position.
	yyyy := Integer readFrom: aStream radix: 10.
	pos + 4 = aStream position ifFalse: [self errorInvalidFormat].
	(aStream peekFor: $-) ifFalse: [self errorInvalidFormat].
	pos := aStream position.
	mm := Integer readFrom: aStream radix: 10.
	pos + 2 = aStream position ifFalse: [self errorInvalidFormat].
	(aStream peekFor: $-) ifFalse: [self errorInvalidFormat].
	pos := aStream position.
	dd := Integer readFrom: aStream radix: 10.
	pos + 2 = aStream position ifFalse: [self errorInvalidFormat].
	^Array
		with: yyyy
		with: mm
		with: dd!

readFrom: aStream
	"Answers a new instance of the receiver read from aStream <gettableStream> in the Reg. Ex. format:
		[- ]YYYY-MM-DDThh:mm:ss(.ss*)?[-+]ZZ:zz(:zz*)?."

	| aYMD aHMS negativeDate offset newDT |
	#DtTmX.	"2001/07/18 Harmon, R. Added for <DateAndTimeExtra factory>."
	aStream skipWhile: [:c | c isWhitespace].
	negativeDate := aStream peekFor: $-.
	aYMD := self readDateFrom: aStream.
	(aStream peekFor: $T) ifFalse: [self errorInvalidFormat].
	aHMS := self readTimeFrom: aStream.
	aStream peekFor: $+.
	offset := Duration readOffsetFrom: aStream.
	newDT := self
		year: (aYMD at: 1)
		month: (aYMD at: 2)
		day: (aYMD at: 3)
		hour: (aHMS at: 1)
		minute: (aHMS at: 2)
		second: (aHMS at: 3)
		offset: offset.
	negativeDate ifFalse: [^newDT].
	^self zero - newDT!

readTimeFrom: aStream
	"Private - Answers hh, mm, and ss list read from aStream <gettableStream> in the Reg. Ex. format: hh:mm:ss(.ss*)?.  Signal an error if not in specified format."

	| hh mm ss pos |
	#DtTmX.	"2001/07/18 Harmon, R. Added for DateAndTimeExtra support."
	pos := aStream position.
	hh := Integer readFrom: aStream radix: 10.
	pos + 2 = aStream position ifFalse: [self errorInvalidFormat].
	(aStream peekFor: $:) ifFalse: [self errorInvalidFormat].
	pos := aStream position.
	mm := Integer readFrom: aStream radix: 10.
	pos + 2 = aStream position ifFalse: [self errorInvalidFormat].
	(aStream peekFor: $:) ifFalse: [self errorInvalidFormat].
	pos := aStream position.
	ss := Number readFrom: aStream.
	pos + 2 = aStream position ifFalse: [self errorInvalidFormat].
	^Array
		with: hh
		with: mm
		with: ss!

seconds: aNumber offset: aDuration
	"Answer a new <DateAndTime> representing aNumber of seconds since 1/1/1. aNumber
	may be negative in which case the answer will be a <DateAndTime> prior to 1/1/1. 
	This method is private as it is for internal use only"

	^self new setSeconds: aNumber asRestrictedFraction offset: aDuration!

year: year day: dayOfYear hour: hour minute: minute second: second
	"Answer a <DateAndTime> which is the <number> second, of the <integer>
	minute, of the <integer> hour, of the <integer> day of the year, dayOfYear, of the
	<integer> year, of the astronomical Gregorian calendar in implementation defined 
	local time, where
		0 <= second < 60, 0 <= minute <= 59, 0 <= hour <= 23, 1 <= day <= 366,
		and year can be any <integer>. 
	If the specified time does not exist in the local time defined by the implementation
	the result is the least <DateAndTime> that conforms to the given parameters."

	^self
		year: year
		day: dayOfYear
		hour: hour
		minute: minute
		second: second
		offset: self defaultOffset!

year: year day: dayOfYear hour: hour minute: minute second: second offset: offset
	"Answer a <DateAndTime> which is the <number> second, of the <integer>
	minute, of the <integer> hour, of the <integer> day of the year, dayOfYear, of the
	<integer> year, of the astronomical Gregorian calendar offset from UTC by the
	<Duration> offset, where 
		0 <= second < 60, 0 <= minute <= 59, 0 <= hour <= 23, 1 <= day <= 366,
		and year can be any <integer>. 
	If the specified time does not exist in the local time defined by the implementation
	the result is the least <DateAndTime> that conforms to the given parameters."

	self assert: [dayOfYear >= 1 & (dayOfYear <= 366)].
	self assert: [hour >= 0 & (hour <= 23)].
	self assert: [minute >= 0 & (minute <= 59)].
	self assert: [second >= 0 & (second < 60)].
	^self new
		setSeconds:
			(((self encodeRataDieYear: year day: dayOfYear) * 24 + hour) * 60 + minute) * 60
				+ second asRestrictedFraction
		offset: offset!

year: year month: month day: dayOfMonth hour: hour minute: minute second: second
	"Answer a <DateAndTime> which is the <number> second, of the <integer>
	minute, of the <integer> hour, of the <integer> day, dayOfMonth, of the
	<integer> month, of the <integer> year, of the astronomical Gregorian 
	calendar in local time, where 
		0 <= second < 60, 0 <= minute <= 59, 0 <= hour <= 23, 1 <= day <= 31,
		1 <= month <= 12, and year can be any <integer>. 
	If the specified time does not exist in the local time defined by the implementation
	the result is the least <DateAndTime> that conforms to the given parameters."

	^self
		year: year
		month: month
		day: dayOfMonth
		hour: hour
		minute: minute
		second: second
		offset: self defaultOffset!

year: year month: month day: dayOfMonth hour: hour minute: minute second: second offset: offset
	"Answer a <DateAndTime> which is the <number> second, of the <integer>
	minute, of the <integer> hour, of the <integer> day, dayOfMonth, of the
	<integer> month, of the <integer> year, of the astronomical Gregorian calendar 
	offset from UTC by the <Duration> offset, where 
		0 <= second < 60, 0 <= minute <= 59, 0 <= hour <= 23, 1 <= day <= 31,
		1 <= month <= 12, and year can be any <integer>. 
	If the specified time does not exist in the local time defined by the implementation
	the result is the least <DateAndTime> that conforms to the given parameters."

	self assert: [month >= 1 & (month <= 12)].
	self assert: [dayOfMonth >= 1 & (month <= 31)].
	self assert: [hour >= 0 & (hour <= 23)].
	self assert: [minute >= 0 & (minute <= 59)].
	self assert: [second >= 0 & (second < 60)].
	self assert: [(self daysInMonth: month forYear: year) >= dayOfMonth].
	^self new
		setSeconds:
			(((self
				encodeRataDieYear: year
				month: month
				day: dayOfMonth) * 24 + hour) * 60 + minute) * 60 + second asRestrictedFraction
		offset: offset! !
!DateAndTime class categoriesFor: #clockPrecision!constants!public! !
!DateAndTime class categoriesFor: #daysInMonth:forYear:!enquiries!public! !
!DateAndTime class categoriesFor: #daysToMonth:forYear:!enquiries!public! !
!DateAndTime class categoriesFor: #defaultOffset!enquiries!public! !
!DateAndTime class categoriesFor: #encodeRataDieYear:day:!instance creation!operations!public! !
!DateAndTime class categoriesFor: #encodeRataDieYear:month:day:!instance creation!operations!public! !
!DateAndTime class categoriesFor: #errorInvalidFormat!exceptions!public! !
!DateAndTime class categoriesFor: #fromDate:time:!instance creation!public! !
!DateAndTime class categoriesFor: #fromString:!instance creation!public! !
!DateAndTime class categoriesFor: #fromSYSTEMTIME:offset:!instance creation!public! !
!DateAndTime class categoriesFor: #fromTimeStamp:!instance creation!public! !
!DateAndTime class categoriesFor: #initialize!initializing!public! !
!DateAndTime class categoriesFor: #isLeapYear:!public!testing! !
!DateAndTime class categoriesFor: #now!instance creation!public! !
!DateAndTime class categoriesFor: #readDateFrom:!helpers!public! !
!DateAndTime class categoriesFor: #readFrom:!instance creation!public! !
!DateAndTime class categoriesFor: #readTimeFrom:!helpers!public! !
!DateAndTime class categoriesFor: #seconds:offset:!instance creation!public! !
!DateAndTime class categoriesFor: #year:day:hour:minute:second:!instance creation!public! !
!DateAndTime class categoriesFor: #year:day:hour:minute:second:offset:!instance creation!public! !
!DateAndTime class categoriesFor: #year:month:day:hour:minute:second:!instance creation!public! !
!DateAndTime class categoriesFor: #year:month:day:hour:minute:second:offset:!instance creation!public! !

!DateAndTime methodsFor!

- operand
	"Answer a <DateAndTime>, or a <Duration> that is the result of subtracting the 
	<DateAndTime>, or <Duration>, argument from the receiver.
	If the argument is a <DateAndTime>, then answer a <Duration> whose value
	is the period of time between the argument and the receiver. The answer may be
	a negative <Duration> if the argument is prior to the receiver in time."

	^operand subtractFromDateAndTime: self!

+ operand
	"Answer the result of adding the <Duration> argument, operand to
	the receiver. More specifically: Answer a <DateAndTime> that represents 
	the UTC time that is the <Duration> argument, operand, after the receiver, 
	and whose local time is the same as the receiver's. If the argument is a negative
	<Duration>, then the result is a <DateAndTime> prior to the receiver."

	^self class seconds: seconds + operand asSeconds offset: self offset!

< operand
	"Answer whether the receiver is less than the <DateAndTime> argument, operand,
	i.e. answer whether the receiver is prior to UTC time represented by the argument."

	^self asSecondsUTC < operand asSecondsUTC	"Equivalent to -
	^self offset = operand offset
		ifTrue: [self < operand]
		ifFalse: [self asUTC < operand asUTC]"!

= comparand
	"Answer whether the argument is a <DateAndTime> representing the same UTC
	time as the receiver. The local times of the receiver and the operand are ignored."

	^self species == comparand species
		and:
			[self asSecondsUTC = comparand asSecondsUTC	"Equivalent to -
	^self asUTC = operand asUTC"]!

> operand
	"Answer whether the receiver is greater than the <DateAndTime> argument, operand,
	i.e. answer whether the receiver is after the UTC time represented by the argument."

	^self asSecondsUTC > operand asSecondsUTC	"Equivalent to -
	^self offset = operand offset
		ifTrue: [self > operand]
		ifFalse: [self asUTC > operand asUTC]"!

asLocal
	"Answer a <DateAndTime> that represents the same UTC time as the receiver,
	but in the local time specified by the implementation."

	^self class
		seconds: self asSecondsUTC + self class defaultOffset asSeconds
		offset: self class defaultOffset	"Equivalent to -
	^self asUTC offset: self class defaultOffset"!

asSeconds
	"Answer the receiver as the number of seconds (includion fractional part) since 00:00 1/1/1.
	Always answers an Integer of Fraction"

	^seconds!

asSecondsUTC
	"Answer the receiver as the number of seconds (includion fractional part) since 00:00 1/1/1
	but corrected to UTC. Always answers an Integer of Fraction"

	^seconds + timeZoneOffset asSeconds negated!

asUTC
	"Answer a <DateAndTime> that represents the same absolute time as the receiver
	but in the local time UTC."

	^self class seconds: self asSecondsUTC offset: Duration zero!

dayOfMonth
	"Answer an <integer> between 1 and 31, inclusive, representing the day 
	of the month in the local time of the receiver, which includes the receiver."

	^self decodeRataDie at: DayOfMonth!

dayOfWeek
	"Answer an <integer> between 1 and 7, inclusive, representing the day 
	of the week in the local time of the receiver, which includes the receiver.
	Sunday is 1, Monday 2, and so on."

	^self decodeRataDie at: DayOfWeek!

dayOfWeekAbbreviation
	"Answer a <readableString> which is the abbreviated  name of the day of 
	the week in the local time of the receiver, which includes the receiver.
	(idb) api needs mon=1 through to sun=7 (sigh)"

	^Locale default nameOfDay: (#(7 1 2 3 4 5 6) at: self dayOfWeek) abbrev: true!

dayOfWeekName
	"Answer a <readableString> which is the name of the day of the week in 
	the local time of the receiver, which includes the receiver.
	(idb) api needs mon=1 through to sun=7 (sigh)"

	^Locale default nameOfDay: (#(7 1 2 3 4 5 6) at: self dayOfWeek) abbrev: false!

dayOfYear
	"Answer an <integer> between 1 and 366, inclusive, representing the day 
	of the year in the local time of the receiver, which includes the receiver."

	^(self class daysToMonth: self month forYear: self year) + self dayOfMonth!

decodeRataDie
	"Decode the seconds count of the receiver to y/m/d/h/m/s and cache 
	in the fieldValues instVar. Only do this once as D&T are immutable.
	See http://www.capecod.net/~pbaum/date/date0.htm"

	| date time answer z h a b c dayOfMonth month year |
	fieldValues isNil ifFalse: [^fieldValues].
	fieldValues := Array new: 7.
	date := seconds // ##(24 * 60 * 60).
	time := seconds \\ ##(24 * 60 * 60).
	z := date + 306.
	h := 100 * z - 25.
	a := (h / 3652425) floor.
	b := a - (a / 4) floor.
	year := ((100 * b + h) / 36525) floor.
	c := b + z - (365 * year) - (year / 4) floor.
	month := ((5 * c + 456) / 153) truncated.
	dayOfMonth := c - ((153 * month - 457) / 5) truncated.
	month > 12
		ifTrue:
			[year := year + 1.
			month := month - 12].
	fieldValues
		at: Year put: year;
		at: Month put: month;
		at: DayOfMonth put: dayOfMonth;
		at: Hour put: (time rem: ##(24 * 60 * 60)) // ##(60 * 60);
		at: Minute put: (time rem: ##(60 * 60)) // 60;
		at: Second put: (time rem: 60);
		at: DayOfWeek put: date \\ 7 + 1.
	^fieldValues!

hash
	"Answer the SmallInteger hash value for the receiver. Use asUTC because
	#= uses this and the answers must correspond"

	^self asSecondsUTC hash!

hour
	"Answer an <integer> between 0 and 23, inclusive, representing the hour
	of the day in the local time of the receiver. This may be in either the 12 or 24 hour clock."

	^self hour24!

hour12
	"Answer an <integer> between 1 and 12, inclusive, representing the hour
	of the day in the 12-hour clock of the local time of the receiver."

	| hour12 |
	(hour12 := self hour \\ 12) = 0 ifTrue: [^12].
	^hour12!

hour24
	"Answer an <integer> between 0 and 23, inclusive, representing the hour
	of the day in the 24-hour clock of the local time of the receiver."

	^self decodeRataDie at: Hour!

isLeapYear
	"Answer whether the local time year which includes the receiver is a leap year."

	^self class isLeapYear: self year!

meridianAbbreviation
	"Answer a <readableString> which is the abbreviated name of the half
	of the day in the local time of the receiver, which includes the receiver."

	^self hour < 12
		ifTrue: [Locale default amDesignator]
		ifFalse: [Locale default pmDesignator]!

minute
	"Answer an <integer> between 0 and 59, inclusive, representing the minute
	of the hour in the local time of the receiver."

	^self decodeRataDie at: Minute!

month
	"Answer an <integer> between 1 and 12, inclusive, representing the month
	of the year in the local time of the receiver."

	^self decodeRataDie at: Month!

monthAbbreviation
	"Answer a <readableString> which is the abbreviated  name of the month of 
	the year in the local time of the receiver, which includes the receiver."

	^Locale default nameOfMonth: self month abbrev: true!

monthName
	"Answer a <readableString> which is the name of the month of  the 
	year in the local time of the receiver, which includes the receiver."

	^Locale default nameOfMonth: self month abbrev: false!

offset
	"Answer a <Duration> which is the difference between the local time
	of the receiver, and UTC at the time of the receiver."

	^timeZoneOffset!

offset: aDuration
	"Answer a <DateAndTime> equivalent to the receiver, but with its
	local time offset from UTC by the <Duration>, offset.
	(idb) to +13 as there is a TZ at +13 (Tonga)

	x := DateAndTime now.   --> 2001-07-20T22:31:14.467+01:00
	y := x offset: (Duration hours: -5).  --> 2001-07-20T16:31:14.467-05:0
	x = y --> true

	Is that right????"

	self
		assert:
			[aDuration
				>=
					##(Duration
							days: 0
							hours: -12
							minutes: 0
							seconds: 0)
				&
					(aDuration
						<=
							##(Duration
									days: 0
									hours: 13
									minutes: 0
									seconds: 0))].
	^DateAndTime seconds: self asSecondsUTC + aDuration asSeconds offset: aDuration!

printOn: target
	"Append a default string representation of the receiver to the <readableStream>.
	The string written to target will represent the UTC time of the receiver offset from
	UTC by the offset of the receiver. All dates are in the astronomical Gregorian
	calendar. The result will be of the format:
		-YYYY-MM-DDThh:mm:ss.s+ZZ:zz:z
	where the z's specify the offset from UTC. e.g. 8:33:14.321 PM EST Jan 5, 1200 B.C.
	would be:
		-1199-01-05T20:33:14.321-05:00"

	target
		nextPut: (self year < 0 ifTrue: [$-] ifFalse: [Character space]);
		nextPutAll: ('%04d' sprintfWith: self year abs);
		nextPutAll: ('-%02d' sprintfWith: self month);
		nextPutAll: ('-%02d' sprintfWith: self dayOfMonth);
		nextPutAll: ('T%02d' sprintfWith: self hour24);
		nextPutAll: (':%02d' sprintfWith: self minute).
	target nextPut: $:.
	self second abs < 10 ifTrue: [target nextPut: $0].
	self second fractionPart isZero
		ifTrue: [target print: self second]
		ifFalse:
			[| s |
			s := String writeStream.
			self second abs asFloat printOn: s decimalPlaces: 6.
			target nextPutAll: s contents trimZeros].
	target
		nextPut: (self offset positive ifTrue: [$+] ifFalse: [$-]);
		nextPutAll: ('%02d' sprintfWith: self offset hours abs);
		nextPutAll: (':%02d' sprintfWith: self offset minutes abs).
	self offset seconds isZero
		ifFalse:
			[target nextPut: $:.
			self offset seconds fractionPart isZero
				ifTrue: [target print: self offset seconds]
				ifFalse: [target print: (self offset seconds abs asFloat roundTo: 1.0e-002)]]!

second
	"Answer a <number> in the range 0 <= s < 60, representing the second
	of the minute of the local time of the receiver, including any fractional part."

	^self decodeRataDie at: Second!

setSeconds: aNumber offset: aDuration
	"Initialize the receiver with the appropriate values"

	seconds := aNumber.
	timeZoneOffset := aDuration!

subtractFromDateAndTime: aDateAndTime
	"Part of a double dispatch for <DateAndTime> subtraction. 
	Answers a <Duration> representing the argument subtracted from the receiver.

	NB.This operation does not match the selector as the selector is fixed (part of a 
	double dispatch) and the operation is done this way to avoid extra calculations 
	that would be needed to comply with ANSI if performed in the order specified 
	by the selector"

	^Duration seconds: self asSecondsUTC - aDateAndTime asSecondsUTC!

timeZoneAbbreviation
	"Answer a <readableString> which is the abbreviated  name of the month of 
	the time zone of the local time of the receiver.
	(idb) This isn't right but I can't see how you can decide which TimeZone information
	this method should answer. One offset can refer to different TZ descriptions?"

	^(String writeStream)
		nextPutAll: 'GMT ';
		nextPut: (self offset positive ifTrue: [$+] ifFalse: [$-]);
		print: (self offset asSeconds abs / 3600 roundTo: 1.0e-002);
		contents!

timeZoneName
	"Answer a <readableString> which is the name of the month of 
	the time zone of the local time of the receiver.
	(idb) see comment in #timeZone"

	^self timeZoneAbbreviation!

year
	"Answer an <integer> representing the year of the local time which
	includes the receiver."

	^self decodeRataDie at: Year! !
!DateAndTime categoriesFor: #-!arithmetic!public! !
!DateAndTime categoriesFor: #+!arithmetic!public! !
!DateAndTime categoriesFor: #<!comparing!public! !
!DateAndTime categoriesFor: #=!comparing!public! !
!DateAndTime categoriesFor: #>!comparing!public! !
!DateAndTime categoriesFor: #asLocal!comparing!public! !
!DateAndTime categoriesFor: #asSeconds!accessing!public! !
!DateAndTime categoriesFor: #asSecondsUTC!accessing!public! !
!DateAndTime categoriesFor: #asUTC!converting!public! !
!DateAndTime categoriesFor: #dayOfMonth!accessing!public! !
!DateAndTime categoriesFor: #dayOfWeek!accessing!public! !
!DateAndTime categoriesFor: #dayOfWeekAbbreviation!accessing!public! !
!DateAndTime categoriesFor: #dayOfWeekName!accessing!public! !
!DateAndTime categoriesFor: #dayOfYear!accessing!public! !
!DateAndTime categoriesFor: #decodeRataDie!converting!public! !
!DateAndTime categoriesFor: #hash!comparing!public! !
!DateAndTime categoriesFor: #hour!accessing!public! !
!DateAndTime categoriesFor: #hour12!accessing!public! !
!DateAndTime categoriesFor: #hour24!accessing!public! !
!DateAndTime categoriesFor: #isLeapYear!public!testing! !
!DateAndTime categoriesFor: #meridianAbbreviation!constants!public! !
!DateAndTime categoriesFor: #minute!accessing!public! !
!DateAndTime categoriesFor: #month!accessing!public! !
!DateAndTime categoriesFor: #monthAbbreviation!accessing!public! !
!DateAndTime categoriesFor: #monthName!accessing!public! !
!DateAndTime categoriesFor: #offset!accessing!public! !
!DateAndTime categoriesFor: #offset:!converting!public! !
!DateAndTime categoriesFor: #printOn:!printing!public! !
!DateAndTime categoriesFor: #second!accessing!public! !
!DateAndTime categoriesFor: #setSeconds:offset:!initializing!public! !
!DateAndTime categoriesFor: #subtractFromDateAndTime:!arithmetic!double dispatch!public! !
!DateAndTime categoriesFor: #timeZoneAbbreviation!accessing!public! !
!DateAndTime categoriesFor: #timeZoneName!accessing!public! !
!DateAndTime categoriesFor: #year!accessing!public! !

Duration comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!Duration class methodsFor!

days: days
	"Answer a <Duration> representing days. If days is negative then
	answer a <Duration> less than <Duration factory>#zero"

	^self
		days: days
		hours: 0
		minutes: 0
		seconds: 0!

days: days hours: hours minutes: minutes seconds: seconds
	"Answer a <Duration> of the number of days, hours, minutes, and seconds. If any 
	of the operands are negative, the result is smaller by that number of days, hours, 
	minutes, or seconds as appropriate."

	^self seconds: ((days * 24 + hours) * 60 + minutes) * 60 + seconds!

errorInvalidFormat
	"Private - Raise an error that some attempt to create an instance of the receiver failed because the some input was in the wrong format."

	#DtTmX.	"2001/07/18 Harmon, R. Added for DateAndTimeExtra support."
	^InvalidFormat signalWith: self!

fromString: aString
	"Answer an instance of the receiver constructed from aString <String> in the Reg. Ex. format: -*D:HH:MM:SS(.SS*)?."

	#DtTmX.	"2001/07/18 Harmon, R. Added for <DurationExtra factory>."
	^self readFrom: (ReadStream on: aString)!

hours: hours
	"Answer a <Duration> representing hours. If hours is negative then
	answer a <Duration> less than <Duration factory>#zero"

	^self
		days: 0
		hours: hours
		minutes: 0
		seconds: 0!

minutes: minutes
	"Answer a <Duration> representing minutes. If minutes is negative then
	answer a <Duration> less than <Duration factory>#zero"

	^self
		days: 0
		hours: 0
		minutes: minutes
		seconds: 0!

readFrom: aStream
	"Answers a new instance of the receiver read from aStream in the Reg. Ex. format: -*D:HH:MM:SS(.SS*)?."

	| d aHMS negative newDuration pos |
	#DtTmX.	"2001/07/18 Harmon, R. Added for <DurationExtra factory>."
	aStream skipWhile: [:c | c isWhitespace].
	negative := aStream peekFor: $-.
	pos := aStream position.
	d := Integer readFrom: aStream radix: 10.
	pos + 1 = aStream position ifFalse: [self errorInvalidFormat].
	(aStream peekFor: $:) ifFalse: [self errorInvalidFormat].
	aHMS := self readHMSFrom: aStream secondsRequired: true.
	newDuration := Duration
		days: d
		hours: (aHMS at: 1)
		minutes: (aHMS at: 2)
		seconds: (aHMS at: 3).
	negative ifFalse: [^newDuration].
	^newDuration negated!

readHMSFrom: aStream secondsRequired: secondsRequired
	"Private - Answers hh, mm, and ss list read from aStream <gettableStream> in the Reg. Ex. format: hh:mm:ss(.ss*)?.  Signal an error if not in specified format."

	| hh mm ss pos |
	#DtTmX.	"2001/07/18 Harmon, R. Added for DateAndTimeExtra support."
	pos := aStream position.
	hh := Integer readFrom: aStream radix: 10.
	pos + 2 = aStream position ifFalse: [self errorInvalidFormat].
	(aStream peekFor: $:) ifFalse: [self errorInvalidFormat].
	pos := aStream position.
	mm := Integer readFrom: aStream radix: 10.
	pos + 2 = aStream position ifFalse: [self errorInvalidFormat].
	(aStream peekFor: $:)
		ifFalse:
			[secondsRequired
				ifTrue: [self errorInvalidFormat]
				ifFalse:
					[^Array
						with: hh
						with: mm
						with: 0]].
	ss := Number readFrom: aStream.
	^Array
		with: hh
		with: mm
		with: ss!

readOffsetFrom: aStream
	"Answers a new instance offset of the receiver read from aStream in the Reg. Ex. format: [-+]HH:MM:SS(.SS*)?."

	| negative newDuration aHMS |
	#DtTmX.	"2001/07/18 Harmon, R. Added for <DurationExtra factory>."
	negative := aStream peekFor: $-.
	negative ifFalse: [aStream peekFor: $+].
	aHMS := self readHMSFrom: aStream secondsRequired: false.
	newDuration := Duration
		days: 0
		hours: (aHMS at: 1)
		minutes: (aHMS at: 2)
		seconds: (aHMS at: 3).
	negative ifFalse: [^newDuration].
	^newDuration negated!

seconds: seconds
	"Answer a <Duration> which is <number> seconds in length
	If seconds is negative, answer a <Duration> that is abs (seconds) less 
	than <Duration factory> #zero.
	(idb) All numbers converted to a Fraction, Floats are rounded to 6 decimal places."

	^self new setSeconds: seconds asRestrictedFraction!

zero
	"Answer a <Duration> representing a length of no time."

	^self seconds: 0! !
!Duration class categoriesFor: #days:!instance creation!public! !
!Duration class categoriesFor: #days:hours:minutes:seconds:!instance creation!public! !
!Duration class categoriesFor: #errorInvalidFormat!exceptions!public! !
!Duration class categoriesFor: #fromString:!instance creation!public! !
!Duration class categoriesFor: #hours:!instance creation!public! !
!Duration class categoriesFor: #minutes:!instance creation!public! !
!Duration class categoriesFor: #readFrom:!instance creation!public! !
!Duration class categoriesFor: #readHMSFrom:secondsRequired:!helpers!public! !
!Duration class categoriesFor: #readOffsetFrom:!instance creation!public! !
!Duration class categoriesFor: #seconds:!instance creation!public! !
!Duration class categoriesFor: #zero!instance creation!public! !

!Duration methodsFor!

- operand
	"Answer a <Duration> whose value is the result of 
	subtracting the <Duration> operand from the receiver"

	^self class seconds: seconds - operand asSeconds!

* operand
	"Answer a <Duration> whose value is the result of 
	multiplying the <number> operand by the receiver"

	^self class seconds: seconds * operand!

/ operand
	"If operand is a <number> answer a new <Duration> whose value is the result of 
	dividing the receiver by operand.  If operand is a <Duration> answer a <number> 
	whose value is the result of dividing  the receiver by operand. 	If operand equals zero
	or <Duration factory> #zero the ZeroDivide exception is signaled"

	^operand divideIntoDuration: self!

+ operand
	"Answer a <Duration> whose value is the result of 
	adding the <Duration> operand to the receiver"

	^self class seconds: seconds + operand asSeconds!

< operand
	"Answer true if operand represents a <Duration> that is larger than the receiver"

	^seconds < operand asSeconds!

= comparand
	"Answer true if the comparand is a <Duration> representing the 
	same length of time as the receiver"

	^self species == comparand species and: [seconds = comparand asSeconds]!

> operand
	"Answer true if operand represents a <Duration> that is smaller than the receiver"

	^seconds > operand asSeconds!

abs
	"If the receiver is greater than or equal to <Duration Factory> #zero answer 
	a <Duration> which is equal to the receiver. Otherwise answer a <Duration> 
	which has the same magnitude as the receiver but the opposite sign"

	^self class seconds: seconds abs!

asSeconds
	"Answer the total number of seconds in the length of time represented by the receiver
	including any fractional part of a second.  If the receiver is less than <Duration factory>
	#zero then the result will be less than 0
	(idb) Always answers a Fraction or an Integer"

	^seconds!

days
	"Answer the the <integer> number of whole days represented by the receiver.
	The answer may be negative for negative durations.
	(idb) see comment in #hours"

	^seconds quo: ##(24 * 60 * 60)!

divideIntoDuration: aDuration
	"Part of a double dispatch for <Duration> division.  Answers a <number>"

	^aDuration asSeconds / seconds!

hash
	"Answer the SmallInteger hash value for the receiver."

	^seconds hash!

hours
	"Answer an <integer> beteen -23 and 23, inclusive, which is the number 
	of whole hours represented by the receiver after complete days have been 
	removed.
	(idb) Use rem and quo rather than \\ and // to preserve sign on negative values
	-7200 \\ ##(24 * 60 * 60) --> 79200 ... wrong
	-7200 rem: ##(24 * 60 * 60) --> -7200

	(-7201 rem: ##(24 * 60 * 60)) // ##(60 * 60) --> -3 ... wrong
	(-7201 rem: ##(24 * 60 * 60)) quo: ##(60 * 60) --> -2"

	^(seconds rem: ##(24 * 60 * 60)) quo: ##(60 * 60)!

microseconds
	"Answer the number of microseconds in the fractional part of the receiver"

	^(seconds fractionPart * 1000000) rounded!

milliseconds
	"Answer the number of milliseconds in the fractional part of the receiver"

	^(seconds fractionPart * 1000) rounded!

minutes
	"Answer an <integer> beteen -59 and 59, inclusive, which is the number 
	of whole minutes represented by the receiver after complete days and hours
	have been removed.
	(idb) see comment in #hours"

	^(seconds rem: ##(60 * 60)) quo: 60!

negated
	"Answer a <Duration> of the opposite sign as the receiver."

	^self class seconds: seconds negated!

negative
	"Answer whether the receiver is negative."

	^seconds < 0!

positive
	"Answer whether the receiver is positive or zero."

	^seconds >= 0!

printOn: target
	"Append a default string representation of the receiver to the <readableStream>,
	target. The result will be of the format: [-]D:HH:MM:SS[.S]
	(idb) Any fractional part is displayed as a Float with a maximum of 6 decimal places"

	self negative ifTrue: [target nextPut: $-].
	target
		print: self days abs;
		nextPutAll: (':%02d' sprintfWith: self hours abs);
		nextPutAll: (':%02d' sprintfWith: self minutes abs).
	target nextPut: $:.
	self seconds abs < 10 ifTrue: [target nextPut: $0].
	self seconds fractionPart isZero
		ifTrue: [target print: self seconds abs]
		ifFalse:
			[| s |
			s := String writeStream.
			self seconds abs asFloat printOn: s decimalPlaces: 6.
			target nextPutAll: s contents trimZeros]!

seconds
	"Answer a <number> in the range -60 < s < 60, which is the number 
	of seconds, including any fraction part, represented by the receiver after 
	complete days, hours and minutes have been removed.
	(idb) see comment in #hours"

	^seconds rem: 60!

setSeconds: aNumber
	"Set the <number> of seconds that the receiver represents
	(idb) This will always be an Integer or Fraction - never a Float"

	seconds := aNumber!

subtractFromDateAndTime: aDateAndTime
	"Part of a double dispatch for <DateAndTime> subtraction. Answers a 
	<DateAndTime> representing the receiver subtracted from the argument"

	^DateAndTime seconds: aDateAndTime asSeconds - seconds offset: aDateAndTime offset! !
!Duration categoriesFor: #-!arithmetic!public! !
!Duration categoriesFor: #*!arithmetic!public! !
!Duration categoriesFor: #/!arithmetic!public! !
!Duration categoriesFor: #+!arithmetic!public! !
!Duration categoriesFor: #<!comparing!public! !
!Duration categoriesFor: #=!comparing!public! !
!Duration categoriesFor: #>!comparing!public! !
!Duration categoriesFor: #abs!arithmetic!public! !
!Duration categoriesFor: #asSeconds!converting!public! !
!Duration categoriesFor: #days!accessing!public! !
!Duration categoriesFor: #divideIntoDuration:!arithmetic!double dispatch!public! !
!Duration categoriesFor: #hash!comparing!public! !
!Duration categoriesFor: #hours!accessing!public! !
!Duration categoriesFor: #microseconds!accessing!public! !
!Duration categoriesFor: #milliseconds!accessing!public! !
!Duration categoriesFor: #minutes!accessing!public! !
!Duration categoriesFor: #negated!arithmetic!public! !
!Duration categoriesFor: #negative!public!testing! !
!Duration categoriesFor: #positive!public!testing! !
!Duration categoriesFor: #printOn:!printing!public! !
!Duration categoriesFor: #seconds!accessing!public! !
!Duration categoriesFor: #setSeconds:!instance creation!public! !
!Duration categoriesFor: #subtractFromDateAndTime:!arithmetic!double dispatch!idb goodies!public! !

!Time class methodsFor!

fromDateAndTime: aDateAndTime
	"Answer an instance of Time initialized from aDateAndTime's local time
	i.e. Any time zone offset in aDateAndTime is ignored"

	#idbAdded.
	^self
		fromSeconds:
			(aDateAndTime hour * 60 + aDateAndTime minute) * 60 + aDateAndTime second rounded!

fromDuration: aDuration
	"Answer an instance of Time initialized from aDuration.  
	NB: 
		Any day value in aDuration is ignored
		Negative values for aDuration produce backward Times i.e.
			Time fromDuration: (Duration days: 0 hours: -1 minutes: -2 seconds: -3) answers 22:57:57"

	#idbAdded.
	^self
		fromMilliseconds:
			(((aDuration hours * 60 + aDuration minutes) * 60 + aDuration seconds) * 1000) rounded!

fromString: aString
	"Answer an instance of the receiver constructed from the string,
	aString, using the default conversion format."

	| stream answer |
	stream := aString readStream.
	answer := self readFrom: stream.
	stream atEnd ifFalse: [^self errorInvalidFormat].
	^answer
! !
!Time class categoriesFor: #fromDateAndTime:!idb goodies!instance creation!public! !
!Time class categoriesFor: #fromDuration:!idb goodies!instance creation!public! !
!Time class categoriesFor: #fromString:!instance creation!public! !

!TimeStamp class methodsFor!

fromDateAndTime: aDateAndTime
	"Answer an instance of TimeStamp initialized from aDateAndTime's local time
	i.e. Any time zone offset in aDateAndTime is ignored"

	#idbAdded.
	^self
		date: (Date fromDateAndTime: aDateAndTime)
		time: (Time fromDateAndTime: aDateAndTime)! !
!TimeStamp class categoriesFor: #fromDateAndTime:!idb goodies!instance creation!public! !

!Number class methodsFor!

errorInvalidFormat
	"Private - Raise an error that some attempt to create an instance of the receiver failed
	because the some input was in the wrong format."

	^InvalidFormat signalWith: self!

fromString: aString 
	"Instantiate a new instance of the receiver from the <readableString> argument."

	| stream answer |
	#todo.	"Should be separate fromDisplayString: version which converts from locale specific format (this method from Smalltalk format)"
	stream := aString readStream.
	answer := self readFrom: stream.
	stream atEnd ifFalse: [^self errorInvalidFormat].
	^answer! !
!Number class categoriesFor: #errorInvalidFormat!exceptions!private! !
!Number class categoriesFor: #fromString:!instance creation!public! !

!Number methodsFor!

asPercentageOf: aNumber
	"Answer the receiver as a percentage"

	#idbAdded.
	^(self / aNumber * 100.0) rounded!

asRestrictedFraction
	"Answer the receiver as a Fraction.  Subclasses can override to restrict 
	the conversion to a value that is an accurate representetion of the receiver"

	#idbAdded.
	^self asFraction!

divideIntoDuration: aDuration
	"Private - Answer a new <Duration> which represents the the value in 
	seconds of aDuration divided by the receiver"

	#idbAdded.
	^Duration seconds: aDuration asSeconds / self! !
!Number categoriesFor: #asPercentageOf:!converting!idb goodies!public! !
!Number categoriesFor: #asRestrictedFraction!converting!idb goodies!public! !
!Number categoriesFor: #divideIntoDuration:!double dispatch!idb goodies!public! !

!Float methodsFor!

asRestrictedFraction
	"Overridden to restrict the answered Fraction to the equivalent of six decimal
	places in the receiver. This allows any precision lost in the conversion to be ignored"

	#idbAdded.
	^(self fractionPart * 1000000) rounded / 1000000 + self integerPart asInteger! !
!Float categoriesFor: #asRestrictedFraction!converting!idb goodies!public! !

!Integer methodsFor!

digitLength
	"Answer the number of significant base-256 digits in the receiver."

	^self subclassResponsibility!

digitSize
	#deprecated.
	^self digitLength! !
!Integer categoriesFor: #digitLength!accessing!public! !
!Integer categoriesFor: #digitSize!accessing!public! !

!LargeInteger methodsFor!

digitLength
	"Answer the number of significant radix-256 digits necessary to
	represent the absolute magnitude of the receiver."

	| size signByte abs |
	abs := self abs.
	size := abs basicSize.
	signByte := 0.
	[(abs basicAt: size) == signByte and: [size > 0]] whileTrue: [size := size - 1].
	^size! !
!LargeInteger categoriesFor: #digitLength!accessing!public! !

!SmallInteger methodsFor!

digitLength
	"Answer the number of significant radix-256 digits in the receiver.
	This implementation is rather horrid, but faster than a loop"

	| value |
	value := self abs.
	value < 16r100 ifTrue: [^1].
	value < 16r10000 ifTrue: [^2].
	value < 16r1000000 ifTrue: [^3].
	^4! !
!SmallInteger categoriesFor: #digitLength!accessing!public! !

!CommandMenuItem methodsFor!

snoopDescription
	"Answer a description of the receiver for the snoop tree"

	#idbAdded.
	^self snoopDescription: self command printString!

snoopSecond
	"Answer any items (name and value) that snoop should disply for the receiver"

	#idbAdded.
	^(super snoopSecond)
		add: 'Text' -> self text;
		add:
				'Flags'
						->
							(Win32Constants
								snoopFlags: self flags
								from:
									#(#MF_BYPOSITION #MFS_CHECKED #MFS_DISABLED #MFT_MENUBARBREAK #MFT_MENUBREAK #MF_POPUP #MFT_SEPARATOR #MFS_ENABLED #MFT_STRING #MFT_RADIOCHECK #MFS_UNCHECKED #MFS_DEFAULT));
		yourself! !
!CommandMenuItem categoriesFor: #snoopDescription!displaying!idb goodies!public! !
!CommandMenuItem categoriesFor: #snoopSecond!accessing!idb goodies!public! !

ChunkBrowserModel comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ChunkBrowserModel methodsFor!

chunkCount
	^chunks size!

decodeChunkFromText: aString
	| chunkClass |
	chunkClass := ChunkBrowserChunk chunkClasses
		detect: [:each | each isChunkClassFor: aString]
		ifNone: [ChunkBrowserOtherChunk].
	^chunkClass fromText: aString!

fileInChunkSeriesFrom: aChunkSourceFiler after: aChunk
	| chunk chunkSeries |
	chunkSeries := OrderedCollection new.
	chunk := aChunkSourceFiler nextChunk.
	[chunk isEmpty]
		whileFalse:
			[chunkSeries add: (aChunk seriesChunk: chunk).
			chunk := aChunkSourceFiler nextChunk].
	^chunkSeries!

fileInChunksFrom: aStream
	| chunksLoaded sourceFiler |
	chunksLoaded := OrderedCollection new.
	sourceFiler := ChunkSourceFiler on: aStream.
	[aStream atEnd]
		whileFalse:
			[| chunkSource |
			chunkSource := sourceFiler nextChunk.
			chunkSource isEmpty
				ifFalse:
					[| chunk |
					chunk := self decodeChunkFromText: chunkSource.
					chunk isChunkSeriesStart
						ifTrue:
							[chunksLoaded addAll: (self fileInChunkSeriesFrom: sourceFiler after: chunk)]
						ifFalse: [chunksLoaded add: chunk]]].
	chunksLoaded keysAndValuesDo: [:index :each | each index: index].
	^chunksLoaded!

fileOpen: aString
	| stream |
	stream := FileStream read: aString.
	[chunks := self fileInChunksFrom: stream] ensure: [stream close]!

fileOpenPatch: aString
	"Dolphin LiveUpdate file.
	Assumes 6 chunks, the first 5 contain information about the patch and
	the sixth contains all the new sorce code"

	| stream |
	stream := FileStream read: aString.
	[| loadedChunks sourceChunks |
	loadedChunks := self fileInChunksFrom: stream.
	self assert: [loadedChunks size = 6].
	sourceChunks := self fileInChunksFrom: (loadedChunks at: 6) rawText readStream.
	sourceChunks do: [:each | each index: each index + 5].
	chunks := (loadedChunks copyFrom: 1 to: 5) , sourceChunks] ensure: [stream close]!

hasAnyChunksPicked
	^chunks anySatisfy: [:each | each picked]!

hasChunks
	^chunks isEmpty not!

indexOfLastImageSave
	| imageSaveChunks |
	imageSaveChunks := chunks select: [:each | each isImageSave].
	imageSaveChunks isEmpty ifTrue: [^1].
	^imageSaveChunks inject: 1 into: [:max :each | each index max: max]!

initialize
	super initialize.
	chunks := OrderedCollection new!

pickedChunks
	^chunks select: [:each | each picked]!

selectChunks: aSet missing: missingBool match: matchBool differ: differBool range: aRange last: lastBool
	| visibleChunks lastSet |
	visibleChunks := OrderedCollection new.
	lastSet := Set new.
	chunks
		do:
			[:each | 
			each
				filter: visibleChunks
				types: aSet
				missing: missingBool
				match: matchBool
				differ: differBool
				range: aRange
				last: lastBool
				lastSet: lastSet].
	lastBool ifTrue: [visibleChunks := lastSet asSortedCollection asOrderedCollection].
	^visibleChunks!

unpickAll
	chunks do: [:each | each picked: false]! !
!ChunkBrowserModel categoriesFor: #chunkCount!helpers!public! !
!ChunkBrowserModel categoriesFor: #decodeChunkFromText:!operations!public! !
!ChunkBrowserModel categoriesFor: #fileInChunkSeriesFrom:after:!operations!public! !
!ChunkBrowserModel categoriesFor: #fileInChunksFrom:!operations!public! !
!ChunkBrowserModel categoriesFor: #fileOpen:!operations!public! !
!ChunkBrowserModel categoriesFor: #fileOpenPatch:!operations!public! !
!ChunkBrowserModel categoriesFor: #hasAnyChunksPicked!public!testing! !
!ChunkBrowserModel categoriesFor: #hasChunks!public!testing! !
!ChunkBrowserModel categoriesFor: #indexOfLastImageSave!helpers!public! !
!ChunkBrowserModel categoriesFor: #initialize!initializing!public! !
!ChunkBrowserModel categoriesFor: #pickedChunks!accessing!public! !
!ChunkBrowserModel categoriesFor: #selectChunks:missing:match:differ:range:last:!operations!public! !
!ChunkBrowserModel categoriesFor: #unpickAll!operations!public! !

!ImageStripper class methodsFor!

initialize
	"Private - Initialize the receiver's class variables.
		self initialize
	"

	ClearGuidsMask := 16r1.
	FoldStringsMask := 16r2.
	PreserveAspectsMask := 16r4. 
	RetainInstVarNamesMask := 16r8.
	StripClassesMask := 16r10.
	StripClassInfoMask := 16r20.
	StripMethodsMask := 16r40.
	StripResourcesMask := 16r80.
	CompileStructsMask := 16r100.
	FoldMethodDictsMask := 16r200.
	WriteLogMask := 16r400.
	EmptyMethodDictsMask := 16r800.
	FoldBytecodesMask := 16r1000.
	LogReferencesMask := 16r2000.
	StripClassBuilderMask := 16r4000.
	StripShouldNotImplMask := 16r8000.
	StripDeprecatedMask := 16r10000.
	StripPackagesMask := 16r20000.
	LogPrerequisitesMask := 16r40000.
	IgnoreViewReferencesMask := 16r80000.
	ToGoMask := 16r100000.
	RetainSubclassRespMask := 16r800000!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	"N.B. This method must be in the 'must strip' category so that it is removed before
	package pre-requisites are calculated otherwise the Development System remains
	a pre-req. of the ADK due to the references to development classes herein."

	^(super publishedAspectsOfInstances)
		add: (Aspect boolean: #stripClassGuids);
		add: (Aspect boolean: #stripDuplicateStrings);
		add: (Aspect boolean: #preserveAspectSetters);
		add: (Aspect boolean: #retainInstVarNames);
		add: (Aspect boolean: #stripRedundantClasses);
		add: (Aspect boolean: #stripClassInfo);
		add: (Aspect boolean: #stripClassBuilder);
		add: (Aspect boolean: #stripRedundantMethods);
		add: (Aspect boolean: #stripDeprecatedMethods);
		add: (Aspect boolean: #stripShouldNotImplement);
		add: (Aspect boolean: #stripSubclassResponsibility);
		add: (Aspect boolean: #stripRedundantResources);
		add: (Aspect boolean: #stripRedundantPackages);
		add: (Aspect boolean: #compileExternalStructures);
		add: (Aspect boolean: #stripEmptyMethodDictionaries);
		add: (Aspect boolean: #writeLogFile);
		add: (Aspect boolean: #stripDuplicateBytecodes);
		add: (Aspect boolean: #logReferencesToClasses);
		add: (Aspect choice: #runtimeSessionManagerClass
					from: (SessionManager allSubclasses select: [:e | e isRuntime]));
		add: ((Aspect fileSave: #executableName)
					isNullable: false;
					yourself);
		add: (Aspect multilineString: #preStripScript);
		add: (Aspect name: #versionResource);
		add: (Aspect boolean: #isToGo);
		add: (Aspect fileOpen: #stubFilePath);
		yourself! !
!ImageStripper class categoriesFor: #initialize!initializing!private! !
!ImageStripper class categoriesFor: #publishedAspectsOfInstances!constants!development!must strip!public! !

!ImageStripper methodsFor!

checkedStubFilePath
	"Private - Answer the full path to the stub file. 
	Check that it exists, and if not raise an error."

	| stubFile |
	stubFile := self stubFilePath.
	^(File exists: stubFile) 
		ifTrue: [stubFile]
		ifFalse: [self error: 'Stub file not found: ''' , stubFile , '''']!

developmentMethodCategoryNames
	"Answer a <collection> of the names of <MethodCategory>s containing only
	development methods which must therefore be stripped from the image when it is deployed."

	| names |
	names := Set 
				withAll: #('development' 'categories-accessing' 'categories-adding' 'categories-removing').
	self stripSubclassResponsibility 
		ifTrue: 
			["It should be safe to remove these methods in a properly tested application as they are errors
		 intended for the developer."
			names add: 'subclass responsibility'].
	self stripShouldNotImplement 
		ifTrue: 
			["Ditto"
			names add: 'should not implement'].
	^names!

initialTidy
	"Private - Discard methods of the receiver that are no longer required now that early processing is finished
	and the runtime session manager has been installed."

	"We have have done the resource updating."

	versionResource := nil.
	self 
		finishedWithAll: #(#copyAndUpdateStub:to: #stripNotRequiredMethodsNotifying: #notRequiredMethodCategories #actualRequiredPackages #buildPreservedMessages #buildRootClasses #canDeploy #closeAllDevelopmentTools #closeChangeLog #developmentClasses #developmentMethods #developmentMethodCategoryNames #disableDevelopmentSystem #executableName #executableName: #executablePath #exeFileExtension #initialize #installRuntimeSessionManager #notifyClassesOfStrip #openLogFile #logFileExtension #logFileName #logReferencesToClasses: #logRemainingPackages #logPreservedClasses #logPreservedMessages #prepareToStrip #preStripScript #preStripScript: #requiredClasses #requiredMethodCategories #requiredPackageNames #resizeStubFile: #retainInstVarNames: #rootClasses: #rootPackage #rootPackage: #runPreStripScript #runtimeSessionManagerClass #runtimeSessionManagerClass: #stripAndSave #stripAndSaveWithProgress #stripShouldNotImplement #stripRedundantPackages #stripRedundantPackagesNotifying: #stubFile #checkedStubFilePath #vmReferencedClasses #writeLogFile #initialTidy)!

isToGo: aBoolean 
	"Set whether the resulting executable is to be deployed standalone (that is without
	a separate VM DLL)."

	"Ensure path nilled if using default"

	self stubFilePath: self stubFilePath.
	flags := flags mask: ToGoMask set: aBoolean!

stripAndSaveNotifying: notifier 
	"Strips the image and saves an executable file according to the configuration held by the 
	receiver. Notification messages are sent to notifier in the form of #status: messages.
	N.B. This method is in the 'must not strip' category to prevent the receiver pulling the rug
	out from under its own feet!!"

	| stubFile developmentMethods path |
	
	["Check stub file exists before we get too far"
	stubFile := self checkedStubFilePath.
	path := self executablePath.
	stubFile := self copyAndUpdateStub: stubFile to: path.
	developmentClasses := self developmentClasses.
	developmentMethods := self developmentMethods.
	self
		closeAllDevelopmentTools;
		runPreStripScript.
	self
		notifyClassesOfStrip;
		collectGarbage.

	"Before closing the change log, ensure all external structures have been sized in case they are referenced from methods
	 in the change log."
	self defineExternalStructuresNotifying: notifier.
	self closeChangeLog.

	"These methods must be stripped BEFORE redundant packages, as they may cause pre-requisites we don't want
	 in the deployed application"
	self stripNotRequiredMethodsNotifying: notifier.
	self stripRedundantPackagesNotifying: notifier.
	self logRemainingPackages.

	"... and make sure we've garnered all the info we require from development structures
	 to allow these to be removed immediately. This must be done before we disable the
	 package manager."
	self logPreservedClasses.
	self logPreservedMessages.
	self disableDevelopmentSystem.
	self installRuntimeSessionManager.
	self assert: [SessionManager current isRuntime].

	"#finishedWith: doesn't remove methods unless a run-time session manager is installed so we
	 can only start throwing stuff away now"
	self initialTidy.

	"Before we can remove any classes, we must ensure isChanged properties are removed"
	self clearChangedProperties.
	self disableClassChangeFlagging.
	self prepareExternalStructuresNotifying: notifier.
	self stripDevelopmentSystemNotifying: notifier.
	self finishedWith: #stripDevelopmentSystemNotifying:.

	"Empty the receiver's class' method dictionary"
	self class class methodDictionary: MethodDictionary new.
	self stripRedundantClassesMethodsAndResources: false notifying: notifier.
	self stripDuplicatesNotifying: notifier.
	self finishedWith: #stripDuplicatesNotifying:.
	self stripDevelopmentClassesAndMethods: developmentMethods notifying: notifier.
	self finishedWith: #stripDevelopmentClassesAndMethods:notifying:.
	developmentMethods := nil.

	"Have another go at finding redundant stuff now dev. classes out of the picture, but
	 this time strip resources too"
	self stripRedundantClassesMethodsAndResources: self stripRedundantResources
		notifying: notifier.
	self destroyAndRemoveProgressNotifying: notifier.

	"Some of the libraries may no longer be required."
	self closeExternalLibraries.

	"Necessary to clear these before other class meta-info in order to allow GUID to be stripped by
	before the ClassBuilder is removed."
	self stripClassGuidsNotifying: notifier.

	"One last go with the progress dialog removed"
	self stripRedundantClassesMethodsAndResources: self stripRedundantResources
		notifying: notifier.

	"Class removal will no longer be possible after the next message is sent. This is the point to insert any 
	debug trace to determine why a class remains in the image"
	self stripClassBuilderNotifying: notifier.
	self stripClassInfoNotifying: notifier.

	"And one final go at the methods that might be hanging around because of class stripping code"
	self 
		finishedWithAll: #(#stripClassBuilderNotifying: #stripRedundantResources #stripRedundantClassesMethodsAndResources:notifying: #addClassesReferencedByClass:andResources:to: #stripClassInfoNotifying:).
	self stripRedundantMethodsNotifying: notifier.
	self foldEmptyMethodDictionariesNotifying: notifier.
	self finishedWith: #foldEmptyMethodDictionariesNotifying:.
	self stripSystemDictionaryNotifying: notifier.

	"Remove as much as we can of the remainder of ImageStripper in case it hangs around"
	self finishedWithStripping.
	self shrinkHashedCollections.
	self shrinkSymbolTable] 
			on: Error
			do: 
				[:x | 
				"Trap all errors"
				self notify: notifier status: x description.
				self onError: x]
			on: Notification
			do: 
				[:n | 
				"Route all notifications to the notifier"
				self notify: notifier status: n description.
				n resume].
	SessionManager current inputState queueDeferredAction: (MessageSend 
				receiver: self
				selector: #saveExecutable:
				arguments: (Array with: path)).
	self finishedWithAll: #(#onError: #stripAndSaveNotifying:)!

stripSubclassResponsibility
	"Answer true if the stripping process will remove those methods which consist of a 'self
	subclassResponsibility' error report. It should be safe to remove such methods in a properly
	tested application, since they are intended as an indication of a logic error for the
	developer."

	^flags noMask: RetainSubclassRespMask!

stripSubclassResponsibility: aBoolean 
	"Set/reset the option to remove those methods which consist of a 'self
	subclassResponsibility' error report, depending on the <Boolean> argument. It should be safe
	to remove such methods in a properly tested application, since they are intended as an
	indication of a logic error for the developer."

	flags := flags mask: RetainSubclassRespMask set: aBoolean not!

stubFilePath
	"Answer the full path to the stub file. "

	^stubFilePath isNil 
		ifTrue: [self defaultStubFilePath]
		ifFalse: [FileLocator imageRelative localFileSpecFor: stubFilePath]!

versionResource
	"Answer the <VersionResource> describing the version resource to be built into	
	the deployed application/dll."

	| originalFilename |
	versionResource isNil 
		ifTrue: [versionResource := VersionResource forPath: self checkedStubFilePath].
	originalFilename := File splitFilenameFrom: self executableName.
	versionResource stringTables do: 
			[:each | 
			(each includesKey: 'OriginalFilename') 
				ifTrue: [each at: 'OriginalFilename' put: originalFilename]].
	^versionResource! !
!ImageStripper categoriesFor: #checkedStubFilePath!accessing!private! !
!ImageStripper categoriesFor: #developmentMethodCategoryNames!constants!public! !
!ImageStripper categoriesFor: #initialTidy!helpers!private! !
!ImageStripper categoriesFor: #isToGo:!accessing!public! !
!ImageStripper categoriesFor: #stripAndSaveNotifying:!must not strip!operations!public! !
!ImageStripper categoriesFor: #stripSubclassResponsibility!accessing!public!testing! !
!ImageStripper categoriesFor: #stripSubclassResponsibility:!accessing!public!testing! !
!ImageStripper categoriesFor: #stubFilePath!accessing!public! !
!ImageStripper categoriesFor: #versionResource!accessing!private! !

!SmalltalkSystem class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	| answer |
	answer := super publishedAspectsOfInstances.
	answer
		add: (Aspect boolean: #autoFormatMethodSource);
		add: (Aspect font: #defaultFont);
		add: (Aspect name: #hierarchyBrowserClass);
		add: (Aspect name: #debuggerClass);
		add: (Aspect name: #methodBrowserClass);
		add: (Aspect name: #packageBrowserClass);
		add: (Aspect name: #protocolBrowserClass);
		add: (Aspect name: #resourceBrowserClass);
		add: (Aspect name: #tipOfTheDayClass);
		add: (Aspect name: #viewComposerClass);
		add: (Aspect name: #workspaceClass);
		add: (Aspect name: #classChooserClass);
		add: (Aspect name: #resourceIdentifierDialogClass);
		add: (Aspect boolean: #backupOnImageSave);
		add: (Aspect name: #defaultInspectorClass);
		add: (Aspect boolean: #preferAlternateInspectors);
		add: (Aspect choice: #formatterClass
					from: (ClassCategory name: 'System-Compiler-Formatters') contents).
	(self respondsTo: #systemBrowserClass) 
		ifTrue: [answer add: (Aspect name: #systemBrowserClass)].
	^answer!

publishedEventsOfInstances
	"Answer a <Set> of <Symbol>s, being the names of all events published 
	by instances of the receiver."

	^(super publishedEventsOfInstances)
		add: #methodAdded:;
		add: #methodUpdated:;
		add: #methodRemoved:;
		add: #methodCategorized:;
		add: #classAdded:;
		add: #classUpdated:;
		add: #classRemoved:;
		add: #classCategorized:;
		add: #classCommented:;
		add: #globalRenamed:from:;
		add: #globalRemoved:;
		add: #protocolUpdated:;
		add: #protocolRemoved:;
		yourself! !
!SmalltalkSystem class categoriesFor: #publishedAspectsOfInstances!constants!development!public! !
!SmalltalkSystem class categoriesFor: #publishedEventsOfInstances!development!events!public! !

!SmalltalkSystem methodsFor!

defaultInspectorClass
	"Answer the class of inspector (a <SmalltalkToolShell>) to be used by default in 
	the development environment."

	defaultInspectorClass isNil 
		ifTrue: [defaultInspectorClass := self environment at: #FlipperInspector].
	^defaultInspectorClass!

defaultInspectorClass: toolClass 
	defaultInspectorClass := toolClass!

deleteClassHierarchy: aClass 
	"Removes aClass from the system, and any subclasses, regardless of whether they
	are still referenced. Answer whether the class was removed."

	| subclasses prompt caption removedGlobals references oldClassName |
	oldClassName := aClass name asString.
	subclasses := aClass allSubclasses.
	subclasses isEmpty 
		ifTrue: 
			[prompt := 'Are you sure you want to delete %1?' formatWith: oldClassName.
			caption := 'Delete Class ...']
		ifFalse: 
			[prompt := 'Are you sure you want to delete %1 and its %2!!d!! subclass(es)?' 
						formatWith: oldClassName
						with: subclasses size.
			caption := 'Delete Class Hierarchy...'].
	(MessageBox confirm: prompt caption: caption) ifFalse: [^false].
	[self verifyNoResourcesReferencingHierarchyOf: aClass] on: OperationAborted do: [:ex | ^false].
	removedGlobals := OrderedCollection new.
	
	[aClass allSubclassesEndOrderDo: 
			[:c | 
			removedGlobals add: (self globalVariable: c).
			c removeFromSystem].
	references := self referencesTo: (self globalVariable: aClass).
	aClass removeFromSystem] 
			on: ClassBuilder invalidRemoveError
			do: 
				[:e | 
				MessageBox errorMsg: e description.
				^false].
	removedGlobals do: [:g | references addAll: (self referencesTo: g)].
	references notEmpty 
		ifTrue: 
			[self 
				browseMethods: references
				caption: 'Class ' , oldClassName , ' deleted'
				findString: oldClassName
				filter: [:m | false]].
	^true!

methodFileOut: aCompiledMethod
	"Save the source and category for aCompiledMethod in chunk format..  Prompt for
	a file/path name but suggest a default"

	| filename |
	#idbAdded.
	filename := (FileSaveDialog new)
		caption: 'File Out ' , aCompiledMethod printString;
		fileTypes:
				(Array with: #('Smalltalk Files (*.st)' '*.st') with: FileDialog allFilesType);
		defaultExtension: 'st';
		value: aCompiledMethod fileOutName;
		showModal.
	filename notNil ifTrue: [aCompiledMethod fileOutTo: filename]!

onClassCommented: aClass
	"The comment associated with the specified <Class> has been updated."

	self classChanged: aClass.
	self trigger: #classCommented: with: aClass!

publishedAspects
	"Answer a <LookupTable> of the <Aspect>s published by the receiver."

	| browserClasses |
	browserClasses := Array with: self hierarchyBrowserClass.
	(self respondsTo: #systemBrowserClass) 
		ifTrue: [browserClasses := browserClasses copyWith: self systemBrowserClass].
	^(super publishedAspects)
		add: (Aspect choice: #defaultBrowserClass from: browserClasses);
		yourself!

registerSystemEvents
	"Private - Register interest with the 'standard' development environment. 
	Many of the receiver's events are just forwarding those from the SystemDictionary.
		SmalltalkSystem current registerSystemEvents
	"

	(self environment)
		removeEventsTriggeredFor: self;
		when: #methodAdded:
			send: #onMethodAdded:
			to: self;
		when: #methodUpdated:
			send: #onMethodUpdated:
			to: self;
		when: #methodRemoved:
			send: #onMethodRemoved:
			to: self;
		when: #methodCategorized:
			send: #onMethodCategorized:
			to: self;
		when: #classAdded:
			send: #onClassAdded:
			to: self;
		when: #classUpdated:
			send: #onClassUpdated:
			to: self;
		when: #classCategorized:
			send: #onClassCategorized:
			to: self;
		when: #classCommented:
			send: #onClassCommented:
			to: self;
		when: #classRemoved:
			send: #onClassRemoved:
			to: self;
		when: #protocolUpdated:
			send: #onProtocolUpdated:
			to: self;
		when: #protocolRemoved:
			send: #onProtocolRemoved:
			to: self;
		when: #globalRemoved:
			send: #onGlobalRemoved:
			to: self;
		when: #globalRenamed:from:
			send: #onGlobalRenamed:from:
			to: self!

verifyNoResourcesReferencingHierarchyOf: aClass 
	| references classes stream maxList response abort |
	references := SortedCollection new.
	classes := aClass withAllSubclasses.
	self sessionManager resourceManager allResourceIdentifiers do: 
			[:each | 
			(classes includes: each owningClass) 
				ifFalse: 
					[| referenced |
					referenced := each resource hiddenClassReferences.
					(classes intersection: referenced) notEmpty ifTrue: [references add: each]]].
	references isEmpty ifTrue: [^self].
	stream := String writeStream.
	stream
		nextPutAll: 'The following resources either contain instances of ';
		print: aClass;
		nextPutAll: ' or a subclass, or have some other reference to the class or a subclass:';
		cr.
	maxList := 15.
	references 
		from: 1
		to: (references size min: maxList)
		do: 
			[:each | 
			stream
				crtab;
				display: each].
	references size > maxList 
		ifTrue: 
			[stream
				crtab;
				nextPutAll: '...etc...'].
	stream
		cr;
		cr;
		nextPutAll: 'If ';
		print: aClass;
		nextPutAll: ' is removed then these resources will be in invalid and will no longer load. This will prevent the package system from being able to trace prerequisites, and may make the image unstable or even inoperable. Consequently the class cannot be removed safely without first modifying or removing these resources.';
		cr;
		cr;
		nextPutAll: 'Press Cancel to abort the operation (recommended), or Ok to delete the class anyway (NOT recommended).'.
	response := (MessageBox new)
				caption: ('Unable to delete %1...' formatWith: aClass name);
				okCancel;
				defaultButton: 2;
				warning: stream contents.
	abort := (OperationAborted new)
				messageText: (' Deletion of class %1 aborted' formatWith: aClass name);
				yourself.
	response == #ok ifFalse: [^abort signal].
	((MessageBox new)
		caption: 'Continue at your own risk!!';
		yesNo;
		warning: ('Are you absolutely sure you want to delete %1 even though it is referenced from resources?' 
					formatWith: aClass name)) 
			== #no ifTrue: [^abort signal]! !
!SmalltalkSystem categoriesFor: #defaultInspectorClass!options!public! !
!SmalltalkSystem categoriesFor: #defaultInspectorClass:!options!public! !
!SmalltalkSystem categoriesFor: #deleteClassHierarchy:!operations!public! !
!SmalltalkSystem categoriesFor: #methodFileOut:!idb goodies!public!source filing! !
!SmalltalkSystem categoriesFor: #onClassCommented:!event handling!public! !
!SmalltalkSystem categoriesFor: #publishedAspects!constants!public! !
!SmalltalkSystem categoriesFor: #registerSystemEvents!initializing!private! !
!SmalltalkSystem categoriesFor: #verifyNoResourcesReferencingHierarchyOf:!helpers!private! !

!TreeModelAbstract methodsFor!

includes: anObject 
	"Answer whether the argument, anObject, is one of the elements of the receiver. Uses
	the receiver's search policy for comparison."

	"Subclasses may wish to override to provide a more efficient implementation."

	| roots comparer |
	roots := self roots.
	comparer := self searchPolicy.
	self do: [:each | (comparer compare: anObject with: each) ifTrue: [^true]].
	^false!

withAllParents: anObject 
	"Answer a new <OrderedCollection> containing the <Object> argument (which must be in the
	tree represented by the receiver) and all of the parents of that object in this tree."

	^(self allParentsOf: anObject)
		addLast: anObject;
		yourself! !
!TreeModelAbstract categoriesFor: #includes:!hierarchy!public!searching! !
!TreeModelAbstract categoriesFor: #withAllParents:!hierarchy!public! !

!VirtualTreeModel methodsFor!

includes: anObject 
	"Answer whether the <Object> argument is one of the elements of the receiver. Uses
	the receiver's search policy for comparison."

	"Implementation Note: An <Object> is considered to be a member of a virtual tree if it
	passes the filter and its ultimate root is in the tree."

	^(filter value: anObject) and: 
			[| comparer progenitor |
			comparer := self searchPolicy.
			progenitor := (self withAllParents: anObject) first.
			self roots anySatisfy: [:each | comparer compare: progenitor with: each]]! !
!VirtualTreeModel categoriesFor: #includes:!hierarchy!public!searching! !

!ExpandingTreeModel methodsFor!

size
	"Answer the number of elements in the receiver."

	"Implementation Note: We must override back to the superclass implementation in order to
	count the number of nodes in the tree when fully expanded."

	^self countElements! !
!ExpandingTreeModel categoriesFor: #size!accessing!public! !

!AspectAccessor methodsFor!

aspectDisplayOn: aStream
  	"Private - Append a single-line textual representatin of the receiver to the <puttableStream>
  	argument in a form that a user viewing the receiver as the value of a published aspect would 
  	like to see it. In this case we want to display the accessort itself, and not its subject, as otherwise
	 we could get into an infinite loop in some circumstances such as inspecting the main UI process
	(an AspectAccessor in use in the inspector could be on the stack)."
  
  	self basicPrintOn: aStream! !
!AspectAccessor categoriesFor: #aspectDisplayOn:!development!private! !

ValueBuffer comment:
'A ValueBuffer can be used to buffer changes to a subject <valueModel>. It presents the same <value> protocol as its subject but, when the value is changed, the change is not immediately passed to the subject. This only happens when the ValueBuffer receives an #apply message to indicate that any changes should flushed.

Instance Variables:
	subject		<valueModel> being buffered.
	modified		<boolean> indicating whether the subject has been modified.
	gate		<valueModel> which, when set true will apply changes back to the subject.'!
!Chat methodsFor!

disconnect
	"Disconnect from any other chat window and wait for new calls"

	self closeConnection.
	self acceptCalls.
	self isOpen 
		ifTrue: 
			["Various user interface elements may need re-enabling"
			self validateUserInterface.
			calleeAddress setFocus]! !
!Chat categoriesFor: #disconnect!commands!public! !

DiffPresenter comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!DiffPresenter methodsFor!

compare
	| upperString lowerString |
	upperString := upper view plainText.
	lowerString := lower view plainText.
	upperString isEmpty | lowerString isEmpty ifTrue: [^self].
	self diff: (self parse: upperString) and: (self parse: lowerString)!

createComponents
	super createComponents.
	upper := self add: RichTextPresenter new name: 'upperText'.
	upperId := self add: RichTextPresenter new name: 'upperId'.
	lower := self add: RichTextPresenter new name: 'lowerText'.
	lowerId := self add: RichTextPresenter new name: 'lowerId'!

diff: upperItems and: lowerItems
	| match |
	match := (upperItems collect: [:each | each key])
		longestCommonSubsequenceInInterval: (1 to: upperItems size)
		withCollection: (lowerItems collect: [:each | each key])
		inInterval: (1 to: lowerItems size).
	self
		display: match
		items: upperItems
		presenter: upper.
	self
		display: (lowerItems inverseMatchVector: match)
		items: lowerItems
		presenter: lower!

display: match items: items presenter: presenter
	(presenter view)
		selectionRange: (1 to: -1);
		selectionColor: nil;
		beNonBold.
	(self reduce: match)
		do:
			[:each | 
			| range |
			range := (items at: each first) value first to: (items at: each last) value last.
			(presenter view)
				selectionRange: range;
				selectionColor: Color red;
				beBold].
	presenter view selectionRange: (1 to: 0)!

isMode: aSymbol
	^mode == aSymbol!

isVertical
	^self view layoutManager isVertical!

lowerText: textString id: idString
	lower value: textString.
	lowerId value: idString.
	self compare!

mode: aSymbol
	mode := aSymbol.
	self compare!

onViewOpened
	super onViewOpened.
	upper view setFont: SmalltalkWorkspace actualFont.
	lower view setFont: SmalltalkWorkspace actualFont.
	mode := #word!

parse: aString
	| items positions begin |
	mode == #character
		ifTrue: [items := aString asOrderedCollection collect: [:each | each asString]].
	mode == #word ifTrue: [items := self parseWordsFrom: aString].
	mode == #line ifTrue: [items := aString lines].
	positions := OrderedCollection new.
	begin := 1.
	items
		do:
			[:each | 
			begin := aString indexOfSubCollection: each startingAt: begin.
			positions add: each -> (begin to: begin + each size - 1).
			begin := begin + each size].
	positions := positions select: [:each | each key notEmpty].
	^positions!

parseWordsFrom: aString
	"Split into words and then split off any extra bracketing characters that are wrapping the word. 
	This prevents something like -
	aaa bbb ccc   diffWith->  (aaa bbb ccc) reddening all of (aaa and ccc)"

	| words |
	words := OrderedCollection new.
	aString subStrings
		do:
			[:each | 
			| word temp |
			word := each.
			[word size >= 2 and: ['([{<"''|' includes: word first]]
				whileTrue:
					[words add: word first asString.
					word := word copyFrom: 2].
			temp := OrderedCollection new.
			[word size >= 2 and: [')]}>"''|.;' includes: word last]]
				whileTrue:
					[temp addFirst: word last asString.
					word := word copyFrom: 1 to: word size - 1].
			words add: word.
			words addAll: temp].
	^words!

reduce: anArray
	| ranges stream |
	ranges := OrderedCollection new.
	stream := anArray readStream.
	[stream atEnd]
		whileFalse:
			[| start |
			(stream skipTo: nil)
				ifTrue:
					[start := stream position.
					stream skipWhile: [:each | each isNil].
					ranges add: (start to: stream position)]].
	^ranges!

upperText: textString id: idString
	upper value: textString.
	upperId value: idString.
	self compare!

vertical: aBoolean
	self view layoutManager isVertical: aBoolean.
	self view layout! !
!DiffPresenter categoriesFor: #compare!operations!public! !
!DiffPresenter categoriesFor: #createComponents!initializing!public! !
!DiffPresenter categoriesFor: #diff:and:!operations!public! !
!DiffPresenter categoriesFor: #display:items:presenter:!operations!public! !
!DiffPresenter categoriesFor: #isMode:!public!testing! !
!DiffPresenter categoriesFor: #isVertical!accessing!public!testing! !
!DiffPresenter categoriesFor: #lowerText:id:!accessing!public! !
!DiffPresenter categoriesFor: #mode:!accessing!public! !
!DiffPresenter categoriesFor: #onViewOpened!event handling!public! !
!DiffPresenter categoriesFor: #parse:!operations!public! !
!DiffPresenter categoriesFor: #parseWordsFrom:!operations!public! !
!DiffPresenter categoriesFor: #reduce:!helpers!public! !
!DiffPresenter categoriesFor: #upperText:id:!accessing!public! !
!DiffPresenter categoriesFor: #vertical:!accessing!public! !

ILColorSelectorPresenter comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ILColorSelectorPresenter methodsFor!

createComponents
	"The other two components are accesed as views - see onViewOpened"

	super createComponents.
	selectedColorText := self add: TextPresenter new name: 'selectedColorText'!

defaultColor
	"Answer the colour selected by default when the view is opened"

	^RGB red!

displayOn: aStream
	aStream
		space;
		print: (colorSelectorView indexOfRGB: selectedRGB);
		nextPutAll: '  (';
		print: selectedRGB red;
		nextPut: $,;
		print: selectedRGB green;
		nextPut: $,;
		print: selectedRGB blue;
		nextPutAll: ')'!

onViewOpened
	"We have to se the views here as they use no presenters"

	super onViewOpened.
	colorSelectorView := self view viewNamed: 'colorSelector'.
	selectedColorView := self view viewNamed: 'selectedColor'.
	colorSelectorView when: #selectRGB: sendTo: self.
	self selectRGB: self defaultColor!

selectedRGB
	^selectedRGB!

selectRGB: anRGB
	selectedRGB := anRGB.
	selectedColorView backcolor: anRGB.
	selectedColorText value: self displayString! !
!ILColorSelectorPresenter categoriesFor: #createComponents!initializing!public! !
!ILColorSelectorPresenter categoriesFor: #defaultColor!constants!public! !
!ILColorSelectorPresenter categoriesFor: #displayOn:!accessing!displaying!public! !
!ILColorSelectorPresenter categoriesFor: #onViewOpened!event handling!public! !
!ILColorSelectorPresenter categoriesFor: #selectedRGB!accessing!public! !
!ILColorSelectorPresenter categoriesFor: #selectRGB:!accessing!public! !

ILEditorWorkspacePresenter comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ILEditorWorkspacePresenter class methodsFor!

defaultModel
	^ILImage extent: 16 @ 16! !
!ILEditorWorkspacePresenter class categoriesFor: #defaultModel!models!public! !

!ILEditorWorkspacePresenter methodsFor!

backcolor: anRGB
	self view backcolor: anRGB!

canDraw
	^self view isZoomed & self view hasZone!

canEdit
	^self view isZoomed!

canFillAll
	^self view isZoomed!

defaultBackcolor
	^RGB white!

defaultZoom
	^16!

locationDescription
	^self view locationDescription!

onViewOpened
	super onViewOpened.
	self zoom: self defaultZoom.
	self backcolor: self defaultBackcolor!

zoneDescription
	^self view zoneDescription!

zoneRectangle
	^self view zoneRectangle!

zoom: anInteger
	self view zoom: anInteger!

zoomBy: anInteger
	self view zoomBy: anInteger!

zoomDescription
	^self view zoomDescription! !
!ILEditorWorkspacePresenter categoriesFor: #backcolor:!accessing!public! !
!ILEditorWorkspacePresenter categoriesFor: #canDraw!public!testing! !
!ILEditorWorkspacePresenter categoriesFor: #canEdit!public!testing! !
!ILEditorWorkspacePresenter categoriesFor: #canFillAll!public!testing! !
!ILEditorWorkspacePresenter categoriesFor: #defaultBackcolor!constants!event handling!public! !
!ILEditorWorkspacePresenter categoriesFor: #defaultZoom!constants!event handling!public! !
!ILEditorWorkspacePresenter categoriesFor: #locationDescription!accessing!public! !
!ILEditorWorkspacePresenter categoriesFor: #onViewOpened!event handling!public! !
!ILEditorWorkspacePresenter categoriesFor: #zoneDescription!accessing!public! !
!ILEditorWorkspacePresenter categoriesFor: #zoneRectangle!accessing!public! !
!ILEditorWorkspacePresenter categoriesFor: #zoom:!accessing!public! !
!ILEditorWorkspacePresenter categoriesFor: #zoomBy:!accessing!public! !
!ILEditorWorkspacePresenter categoriesFor: #zoomDescription!accessing!public! !

ILLibraryWorkspacePresenter comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!PackagePrerequisites methodsFor!

initialize
	super initialize.
	packages := #()! !
!PackagePrerequisites categoriesFor: #initialize!initializing!private! !

ProfilerPresenter comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ProfilerPresenter class methodsFor!

defaultModel
	"Answer a default model to be used when the presenter is initialized"

	^ProfilerSampleSet name: 'None'! !
!ProfilerPresenter class categoriesFor: #defaultModel!models!public! !

!ProfilerPresenter methodsFor!

filter: anObject
	"Answer true if all the filters agree that anObject should be displayed"

	^(percentageFilter value: anObject)
		and: [(dolphinFilter value: anObject) and: [selectorFilter value: anObject]]!

filterChanged
	"One of the filters has changed so update the models"

	self update!

filterDolphin: aBoolean
	"Answers true if the item is not in the Dolphin package (so it should be displayed)"

	self subclassResponsibility!

filterPercentage: aFloat
	"Set the filterBlock to answer true if any of the fileds ar > aFloat%"

	self subclassResponsibility!

filterSelector: aCompiledCodeOrNil
	"Answer true if this node shold be displayed for the selector filter"

	self subclassResponsibility!

initialize
	"Initialize the reciver"

	super initialize.
	percentageFilter := [:o | true].
	dolphinFilter := [:o | true].
	selectorFilter := [:o | true].
	^self!

model: aProfilerSampleSet
	"Set the model for the receiver"

	super model: aProfilerSampleSet.
	self filterChanged! !
!ProfilerPresenter categoriesFor: #filter:!filtering!public! !
!ProfilerPresenter categoriesFor: #filterChanged!filtering!public! !
!ProfilerPresenter categoriesFor: #filterDolphin:!filtering!public! !
!ProfilerPresenter categoriesFor: #filterPercentage:!filtering!public! !
!ProfilerPresenter categoriesFor: #filterSelector:!filtering!public! !
!ProfilerPresenter categoriesFor: #initialize!initializing!public! !
!ProfilerPresenter categoriesFor: #model:!accessing!public! !

ProfilerSamplesPresenter comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ProfilerSamplesPresenter class methodsFor!

defaultModel
	^ProfilerSampleSet name: 'None'! !
!ProfilerSamplesPresenter class categoriesFor: #defaultModel!models!public! !

!ProfilerSamplesPresenter methodsFor!

createComponents
	"Create the presenters contained by the receiver"

	super createComponents.
	self add: TextPresenter new name: 'sampleIndicator'.
	self add: NumberPresenter new name: 'sampleSelector'.
	self add: ListPresenter new name: 'frames'.
	self add: SmalltalkWorkspace new name: 'workspace'!

createSchematicWiring
	"Create the trigger wiring for the receiver"

	super createSchematicWiring.
	(self presenterNamed: 'frames')
		when: #selectionChanged
		send: #onFrameSelectionChanged
		to: self.
	(self presenterNamed: 'sampleSelector')
		when: #valueChanged
		send: #onSampleIndexChanged
		to: self!

filterNext
	"Find the next sample that answer true to the selectorFilter, starting at the current index.
	Beep if no more can be found and leave the selection at the current value"

	self model samplesSize ~= 0
		ifTrue:
			[index := (index + 1 to: self model samplesSize)
				detect: [:each | selectorFilter value: (self model sampleAt: each)]
				ifNone:
					[Sound beep.
					index]].
	self filterStopped!

filterPrevious
	"Find the previous sample that answer true to the selectorFilter, starting at the current index.
	Beep if no more can be found and leave the selection at the current value"

	self model samplesSize ~= 0
		ifTrue:
			[index := (index - 1 to: 1 by: -1)
				detect: [:each | selectorFilter value: (self model sampleAt: each)]
				ifNone:
					[Sound beep.
					index]].
	self filterStopped!

filterSelector: aCompiledCodeOrNil
	"Set the filterSelector up to look for any sample that contains a frame that matches
	the class/selector of aCompiledMethod. Move to the start and find the first match.
	If the argument is nil then the filter just steps one sample at a time"

	selectorFilter := aCompiledCodeOrNil isNil
		ifTrue: [[:o | true]]
		ifFalse:
			[(aCompiledCodeOrNil isKindOf: CompiledMethod)
				ifTrue: [[:o | o isChildOfFrameFor: aCompiledCodeOrNil]]
				ifFalse: [[:o | false]]].
	filterTarget := aCompiledCodeOrNil.
	index := 0.
	self filterNext!

filterStopped
	"The filter has selected sample index as the one to display. If either the filterTarget was 
	nil (filter turned off) or the target cannot be found in the frame then set frame to  nil which
	means the active frame will be selected, otherwise select the first frame that matches"

	frame := filterTarget isNil
		ifFalse:
			[(self model sampleAt: index) frames
				detect: [:each | each doClassAndSelectorMatch: filterTarget]
				ifNone: []].
	self showSample!

initialize
	"Initialize the reciver"

	super initialize.
	selectorFilter := [:o | true].
	index := 0.
	^self!

model: aProfilerSampleSet
	"Set the model for the receiver. The test is needed to ensure that the sub views are all
	updated when the model is changed but prevent a walkback the first time the model is set, as
	part of the window creation procedure. The walkback occurs because the scroll bar subview
	is not ready, at that stage, to have its range set (also see #onViewOpened)"

	super model: aProfilerSampleSet.
	((self presenterNamed: 'sampleSelector') view isKindOf: DeafObject)
		ifFalse: [self setSampleRange]!

onFrameSelectionChanged
	"The frame selection has changed so update the source view accordingly"

	| selection text selectionRange |
	selection := (self presenterNamed: 'frames') selectionOrNil.
	selection isNil
		ifTrue:
			[text := String new asRichText.
			selectionRange := 0 to: 0]
		ifFalse:
			[text := selection coloredSource.
			selectionRange := selection selectionRange].
	(self presenterNamed: 'workspace')
		text: text;
		selectionRange: selectionRange!

onSampleIndexChanged
	"The sample index has changed, the slider has been moved. Set the sample index and 
	show the sample"

	index := (self presenterNamed: 'sampleSelector') value.
	self showSample!

onViewOpened
	"When the view has been opened, and the sub views created, we can set the selection range. On
	subsequent model changes (therefore range changes) we have to use the #model: method as this
	method is never used again"

	super onViewOpened.
	self setSampleRange!

sampleIndicator: anInteger
	"Answer a String describing the position of the current sample in its world"

	^(String writeStream)
		nextPutAll: 'Sample ';
		print: anInteger;
		nextPutAll: ' out of ';
		print: self model samplesSize;
		contents!

setSampleRange
	"Set the range and initial index of the sampleSelector, the values reflecting the model"

	index := self model samplesSize = 0 ifTrue: [0] ifFalse: [1].
	((self presenterNamed: 'sampleSelector') view)
		range: (index to: self model samplesSize);
		pageSize: self model samplesSize // 10.
	self showSample!

showSample
	"The sample selected has changed. If index is 0 it means thare are no
	samples available (no sample set selected or an empty set) so just clear all
	the sub views. If it is a valid sample index the find and display the frames for
	the sample. Select either the frame set in frame "

	(self presenterNamed: 'sampleIndicator') value: (self sampleIndicator: index).
	(self presenterNamed: 'sampleSelector') view scrollPosition: index.
	index = 0
		ifTrue:
			[(self presenterNamed: 'frames') list: OrderedCollection new.
			self onFrameSelectionChanged]
		ifFalse:
			[| frames |
			frames := (self model sampleAt: index) frames.
			frame isNil ifTrue: [frame := frames first].
			(self presenterNamed: 'frames')
				list: frames;
				selection: frame	"reverse"].
	(self presenterNamed: 'frames') view layout.
	frame := nil! !
!ProfilerSamplesPresenter categoriesFor: #createComponents!initializing!public! !
!ProfilerSamplesPresenter categoriesFor: #createSchematicWiring!initializing!public! !
!ProfilerSamplesPresenter categoriesFor: #filterNext!filtering!public! !
!ProfilerSamplesPresenter categoriesFor: #filterPrevious!filtering!public! !
!ProfilerSamplesPresenter categoriesFor: #filterSelector:!filtering!public! !
!ProfilerSamplesPresenter categoriesFor: #filterStopped!filtering!public! !
!ProfilerSamplesPresenter categoriesFor: #initialize!initializing!public! !
!ProfilerSamplesPresenter categoriesFor: #model:!accessing!public! !
!ProfilerSamplesPresenter categoriesFor: #onFrameSelectionChanged!event handling!public! !
!ProfilerSamplesPresenter categoriesFor: #onSampleIndexChanged!event handling!public! !
!ProfilerSamplesPresenter categoriesFor: #onViewOpened!event handling!public! !
!ProfilerSamplesPresenter categoriesFor: #sampleIndicator:!private helpers!public! !
!ProfilerSamplesPresenter categoriesFor: #setSampleRange!private helpers!public! !
!ProfilerSamplesPresenter categoriesFor: #showSample!private helpers!public! !

RadioButtonGroup comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!RadioButtonGroup class methodsFor!

publishedEventsOfInstances
	"Answer a Set of Symbols that describe the published events triggered
    	by instances of the receiver."

	^(super publishedEventsOfInstances)
		add: #radioButtonSelection:;
		yourself! !
!RadioButtonGroup class categoriesFor: #publishedEventsOfInstances!events!public! !

!RadioButtonGroup methodsFor!

createSchematicWiring
	"Create the trigger wiring for the receiver"

	super createSchematicWiring.
	self ownedRadioButtons
		do:
			[:each | 
			each
				when: #actionPerformed
				send: #onRadioButtonSelection:
				to: self
				with: each]!

deselectRadioButtonNamed: aString
	"Deselect the button named aString but do nothing if the button does not exist. This should 
	be used with care as the group may now have no button selected. Note that no group event is 
	triggered by this method"

	(self radioButtonNamed: aString) ifNotNil: [:arg | arg value: false]!

disable: aString
	"Set the state of the RadioButton named aString to disabled.
	Care should be taken when disabling buttons. If the currently selected button is disabled you
	can easily end up with a situation where two buttons in a group are selected at the same time.
	A check should be made by the application so that it can deselect the button before disabling
	it. This cannot be done automatically as disabling and re-enabling a selected button may be 
	the required behaviour"

	(self radioButtonNamed: aString) ifNotNil: [:arg | arg disable]!

disableAllOf: aCollection
	"Set the state of all the RadioButtons named in aCollection to disabled"

	aCollection do: [:each | self disable: each]!

enable: aString
	"Set the state of the RadioButton named aString to enabled"

	(self radioButtonNamed: aString) ifNotNil: [:arg | arg enable]!

enableAllOf: aCollection
	"Set the state of all the RadioButtons named in aCollection to enabled"

	aCollection do: [:each | self enable: each]!

onRadioButtonSelection: aRadioButton
	"aRadioButton has been selected so fire the trigger to let any interested parties know. 
	The initial isNil test is because of the fact that Windows (or maybe Dolphin?)  triggers a
	selection event when the view is opened and there is no default button selected (no RadioButtons
	value aspect was set in the ViewComposer).However, the button specified in this initial selection
	is not actually selected in the view, so the easiest way is just to ignore it"

	aRadioButton value ifTrue: [self trigger: #radioButtonSelection: with: aRadioButton name]!

ownedRadioButtons
	"Answer a collection of the _immediate sub views of the reciever that admit to being RadioButtons.
	As only the immediate sub views are checked this allows nesting of RadioButtonGroups. Cache
	the buttons for a bit of a performance gain as they won't be changing.
	Fix for D5 so that we ensure that isGroupStop is false for all the buttons"

	ownedRadioButtons
		ifNil:
			[ownedRadioButtons := self view subViews select: [:each | each isKindOf: RadioButton].
			ownedRadioButtons do: [:each | each isGroupStop: false]].
	^ownedRadioButtons!

radioButtonNamed: aString
	"Answer the RadioButton that is named aString or nil if no button can be found"

	^self ownedRadioButtons detect: [:each | each name = aString] ifNone: []!

selectedRadioButton
	"Answer the (first?) RadioButton which is selected or nil if there are no selections. The 
	models should always match the visual indications (and therefore there should only be 
	no or one button selected) but it _is possible to get in a state with two buttons selected"

	^self ownedRadioButtons detect: [:each | each value] ifNone: []!

selectedRadioButtonName
	"Answers the name of the currently selected RadioButton or an empty String if there is 
	no selection"

	^self selectedRadioButton ifNil: [String new] ifNotNil: [:arg | arg name]!

selectRadioButtonNamed: aString
	"Select the button named aString but do nothing if either the button does not exist or it is 
	already the currently selected button. Note that the final action is to trigger an event as if
	the button had been selected in the normal (UI) way. This may not be the desired behaviour
	in every case so another method, that does not trigger the event, may be needed"

	| current select |
	(select := self radioButtonNamed: aString) ifNil: [^self].
	(current := self selectedRadioButton) == select ifTrue: [^self].	"This will cause the individual views to update"
	current ifNotNil: [:arg | current value: false].
	select value: true.	"Simulate a normal selection event by firing the trigger"
	self onRadioButtonSelection: select! !
!RadioButtonGroup categoriesFor: #createSchematicWiring!initializing!public! !
!RadioButtonGroup categoriesFor: #deselectRadioButtonNamed:!public!states!states-changing! !
!RadioButtonGroup categoriesFor: #disable:!public!states-changing! !
!RadioButtonGroup categoriesFor: #disableAllOf:!public!states-changing! !
!RadioButtonGroup categoriesFor: #enable:!public!states-changing! !
!RadioButtonGroup categoriesFor: #enableAllOf:!public!states-changing! !
!RadioButtonGroup categoriesFor: #onRadioButtonSelection:!event handling!public! !
!RadioButtonGroup categoriesFor: #ownedRadioButtons!accessing!public! !
!RadioButtonGroup categoriesFor: #radioButtonNamed:!enquiries!public! !
!RadioButtonGroup categoriesFor: #selectedRadioButton!enquiries!public! !
!RadioButtonGroup categoriesFor: #selectedRadioButtonName!enquiries!public! !
!RadioButtonGroup categoriesFor: #selectRadioButtonNamed:!public!states-changing! !

!SmalltalkWorkspace methodsFor!

showUndefined: aCollection
	#idbAdded.
	(self errorModel notNil and: [self errorModel value isNil])
		ifTrue:
			[| stream |
			stream := String writeStream.
			stream
				nextPutAll: ' undefined selector';
				nextPutAll: (aCollection size > 1 ifTrue: ['s:'] ifFalse: [':']);
				space.
			aCollection
				do:
					[:each | 
					stream
						print: each;
						space].
			self errorModel value: (Warning new messageText: stream contents).
			Sound errorBeep]! !
!SmalltalkWorkspace categoriesFor: #showUndefined:!idb goodies!operations!public! !

ProfilerListsPresenter comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ProfilerListsPresenter methodsFor!

createComponents
	"Create the presenters contained by the receiver"

	super createComponents.
	self add: ListPresenter new name: 'items'!

filterPercentage: aFloat
	"Set the filterBlock to answer true if any of the fileds ar > aFloat%"

	percentageFilter := [:o | o isAbove: aFloat].
	super filterChanged!

filterSelector: aCompiledCodeOrNil
	"Answer true if this node shold be displayed for the selector filter.
	Answers true if
		aCompiledCodeOrNil is nil - the filter is off so show all.
		ACompiledCodeOrNil matches the class/selector for this node"

	self shouldNotImplement!

hasSelection
	"Answers true if the item list has a selection"

	^self selectionOrNil notNil!

items
	"Answers a collection of the items to go in the list"

	self subclassResponsibility!

reportIdentityOf: aProfilerListItem to: aStream
	"Add the identity of the receiver to aStream"

	self subclassResponsibility!

reportItems
	"Answer the items in the correct order for the report"

	self subclassResponsibility!

reportTitleTo: aStream
	"Add a title for the receiver to aStream"

	self subclassResponsibility!

reportTo: aStream
	"Generate a report for the receiver on aStream"

	self reportTitleTo: aStream.
	self reportItems
		do:
			[:each | 
			self reportIdentityOf: each to: aStream.
			each reportOn: aStream]!

selectionOrNil
	"Answer the item (an ProfilerListItem) selected in the list or nil if there is no selection"

	^(self presenterNamed: 'items') selectionOrNil!

update
	"Select the items from the model that should be displayed in the list. Only
	display those that answer true to the current filterBlock"

	(self presenterNamed: 'items') list: (self items select: [:each | self filter: each]).
	(self presenterNamed: 'items') view layout! !
!ProfilerListsPresenter categoriesFor: #createComponents!initializing!public! !
!ProfilerListsPresenter categoriesFor: #filterPercentage:!filtering!public! !
!ProfilerListsPresenter categoriesFor: #filterSelector:!filtering!public! !
!ProfilerListsPresenter categoriesFor: #hasSelection!public!testing! !
!ProfilerListsPresenter categoriesFor: #items!accessing!public! !
!ProfilerListsPresenter categoriesFor: #reportIdentityOf:to:!public!reporting! !
!ProfilerListsPresenter categoriesFor: #reportItems!public!reporting! !
!ProfilerListsPresenter categoriesFor: #reportTitleTo:!public!reporting! !
!ProfilerListsPresenter categoriesFor: #reportTo:!public!reporting! !
!ProfilerListsPresenter categoriesFor: #selectionOrNil!accessing!public! !
!ProfilerListsPresenter categoriesFor: #update!public!updating! !

ProfilerTreesPresenter comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ProfilerTreesPresenter methodsFor!

collapse
	"Collapse the tree one level starting at the current node"

	| presenter |
	presenter := self presenterNamed: 'tree'.
	presenter hasSelection ifTrue: [presenter collapse: presenter selection]!

createComponents
	"Create the presenters contained by the receiver"

	super createComponents.
	self
		add: (TreePresenter new model: (VirtualTreeModel withRoots: OrderedCollection new))
		name: 'tree'.
	self add: SmalltalkWorkspace new name: 'workspace'.
	self add: SmalltalkWorkspace new name: 'disassembly'!

createSchematicWiring
	"Create the trigger wiring for the receiver"

	super createSchematicWiring.
	(self presenterNamed: 'tree')
		when: #selectionChanged
		send: #onSelectionChanged
		to: self!

expand
	"Expand the tree one level starting at the current node"

	| presenter |
	presenter := self presenterNamed: 'tree'.
	presenter hasSelection ifTrue: [presenter expand: presenter selection]!

filterDolphin: aBoolean
	"Answers true if the filter is on and the node is not part of a branch that
	only contains nodes in the Dolphin package"

	dolphinFilter := [:o | (aBoolean and: [o isDolphinBranch]) not].
	super filterChanged!

filterPercentage: aFloat
	"Set the percentage figure for the tree"

	percentageFilter := [:o | (self treeValueFor: o) > (aFloat / 100.0 * self total) truncated].
	super filterChanged!

filterSelector: aCompiledCodeOrNil
	"Answer true if this node shold be displayed for the selector filter.
	Answers true if
		aCompiledCodeOrNil is nil - the filter is off so show all.
		ACompiledCodeOrNil matches the class/selector for this node"

	selectorFilter := aCompiledCodeOrNil isNil
		ifTrue: [[:o | true]]
		ifFalse:
			[(aCompiledCodeOrNil isKindOf: CompiledMethod)
				ifTrue: [[:o | o isParentOfFrameFor: aCompiledCodeOrNil]]
				ifFalse: [[:o | false]]].
	super filterChanged!

onSelectionChanged
	"The frame selection has changed so update the source view accordingly"

	| sourceText sourceSelectionRange disassemblyText disassemblySelectionLine |
	(self presenterNamed: 'tree') selectionOrNil
		ifNil:
			[sourceText := String new asRichText.
			sourceSelectionRange := 0 to: 0.
			disassemblyText := String new asRichText.
			disassemblySelectionLine := 0]
		ifNotNil:
			[:arg | 
			sourceText := arg object coloredSource.
			sourceSelectionRange := arg object selectionRange.
			disassemblyText := arg object disassemblySource.
			disassemblySelectionLine := arg object disassemblySelectionLine].
	(self presenterNamed: 'workspace')
		text: sourceText;
		selectionRange: sourceSelectionRange.
	(self presenterNamed: 'disassembly')
		text: disassemblyText;
		selectLine: disassemblySelectionLine!

onViewOpened
	"Set the getImageBlock and getTExtBlocks for the receiver. These are done here, rather
	than in the ViewComposer as normal, as two types of tree use the same view and we need to
	discriminate between them in the getTextBlock"

	super onViewOpened.
	((self presenterNamed: 'tree') view)
		getImageBlock: [:o | o object icon imageIndex];
		getTextBlock:
				[:o | 
					| stream count |
					count := self treeValueFor: o.
					stream := String writeStream.
					ProfileBrowser showCounts
						ifTrue:
							[stream
								print: count;
								space].
					stream
						nextPut: $(;
						print: (count asPercentageOf: self total);
						nextPutAll: '%)';
						space.
					o hasChildren
						ifTrue: [stream print: o firstChild object]
						ifFalse:
							[stream
								nextPutAll: 'Primitive in ';
								print: o object].
					stream contents]!

total
	"Answer the total number of items for this type of tree"

	self subclassResponsibility!

treeValueFor: aProfilerTreeNode
	"Answers the value of the field for the receivers type of tree"

	self subclassResponsibility!

update
	"One of the filters has changed so redraw the tree taking the new filter into account. 
	Try to retain the current selection if possible"

	| presenter selection |
	selection := (presenter := self presenterNamed: 'tree') selectionOrNil.
	(presenter model)
		roots: self model rootNodes;
		filter: [:o | self filter: o].
	selection notNil ifTrue: [presenter selection: selection ifAbsent: []]! !
!ProfilerTreesPresenter categoriesFor: #collapse!commands!public! !
!ProfilerTreesPresenter categoriesFor: #createComponents!initializing!public! !
!ProfilerTreesPresenter categoriesFor: #createSchematicWiring!initializing!public! !
!ProfilerTreesPresenter categoriesFor: #expand!commands!public! !
!ProfilerTreesPresenter categoriesFor: #filterDolphin:!filtering!public! !
!ProfilerTreesPresenter categoriesFor: #filterPercentage:!filtering!public! !
!ProfilerTreesPresenter categoriesFor: #filterSelector:!filtering!public! !
!ProfilerTreesPresenter categoriesFor: #onSelectionChanged!event handling!public! !
!ProfilerTreesPresenter categoriesFor: #onViewOpened!event handling!public! !
!ProfilerTreesPresenter categoriesFor: #total!accessing!public! !
!ProfilerTreesPresenter categoriesFor: #treeValueFor:!accessing!public! !
!ProfilerTreesPresenter categoriesFor: #update!public!updating! !

ProfilerClassListPresenter comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ProfilerClassListPresenter methodsFor!

filterDolphin: aBoolean
	"Answers true if the item is not in the Dolphin package (so it should be displayed)"

	dolphinFilter := [:o | 
	| item |
	(aBoolean
		and: [(item := o object instanceClass owningPackage) notNil and: [item isSystemPackage]])
		not].
	super filterChanged!

items
	"Answers a collection of the items needed for the list"

	^self model samplesClasses!

reportIdentityOf: aProfilerListItem to: aStream
	"Add the identity of the receiver to aStream"

	| string |
	string := aProfilerListItem object printString.
	aStream nextPutAll: ('%-32s' sprintfWith: (string copyFrom: 1 to: (32 min: string size)))!

reportItems
	"Answer the items in the correct order for the report"

	^self items asSortedCollection: [:a :b | a object <= b object]!

reportTitleTo: aStream
	"Put a title and column headings for the report on aStream"

	aStream
		cr;
		cr;
		nextPutAll: 'Classes used';
		cr;
		cr;
		nextPutAll: ('%-32s' sprintfWith: 'Class');
		nextPutAll: ('%-10s' sprintfWith: 'Tally All');
		nextPutAll: ('%-10s' sprintfWith: 'Tally Act');
		nextPutAll: ('%-10s' sprintfWith: 'Time All');
		nextPutAll: ('%-10s' sprintfWith: 'Time Act');
		cr! !
!ProfilerClassListPresenter categoriesFor: #filterDolphin:!filtering!public! !
!ProfilerClassListPresenter categoriesFor: #items!accessing!public! !
!ProfilerClassListPresenter categoriesFor: #reportIdentityOf:to:!public!reporting! !
!ProfilerClassListPresenter categoriesFor: #reportItems!public!reporting! !
!ProfilerClassListPresenter categoriesFor: #reportTitleTo:!public!reporting! !

ProfilerSelectorListPresenter comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ProfilerSelectorListPresenter methodsFor!

createComponents
	"Create the presenters contained by the receiver"

	super createComponents.
	self add: SmalltalkWorkspace new name: 'workspace'!

createSchematicWiring
	"Create the trigger wiring for the receiver"

	super createSchematicWiring.
	(self presenterNamed: 'items')
		when: #selectionChanged
		send: #onSelectionChanged
		to: self!

filterDolphin: aBoolean
	"Answers true if the item is not in the Dolphin package (so it should be displayed)"

	dolphinFilter := [:o | 
	| item |
	(aBoolean
		and:
			[((item := o object) isKindOf: CompiledMethod)
				and: [(item := item owningPackage) notNil and: [item isSystemPackage]]]) not].
	super filterChanged!

items
	"Answer a copy of the initial list, leaving the percentage figures alone but replacing the
	Association (class -> methodName) with the appropriate compiledMethod. This makes
	the list etc much easier to handle. Don't copy the UndefinedObjects"

	^(self model samplesSelectors
		select: [:each | each object key selectors includes: each object value])
		collect:
			[:each | 
			(each copy)
				object: (each object key compiledMethodAt: each object value);
				yourself]!

onSelectionChanged
	"The selector selection has changed so update the source view accordingly"

	(self presenterNamed: 'workspace')
		text:
			(self hasSelection
				ifTrue: [self selectionOrNil object getColoredSource]
				ifFalse: [String new asRichText]).
	self trigger: #onSelectionChanged!

reportIdentityOf: aProfilerListItem to: aStream
	"Add the identity of the receiver to aStream"

	| string |
	string := aProfilerListItem object selector.
	aStream nextPutAll: ('%-32s' sprintfWith: (string copyFrom: 1 to: (31 min: string size))).
	string := aProfilerListItem object methodClass printString.
	aStream nextPutAll: ('%-32s' sprintfWith: (string copyFrom: 1 to: (31 min: string size)))!

reportItems
	"Answer the items in the correct order for the report"

	^self items asSortedCollection: [:a :b | a object selector <= b object selector]!

reportTitleTo: aStream
	"Put a title and column headings for the report on aStream"

	aStream
		cr;
		cr;
		nextPutAll: 'Methods used';
		cr;
		cr;
		nextPutAll: ('%-32s' sprintfWith: 'Selector');
		nextPutAll: ('%-32s' sprintfWith: 'Class');
		nextPutAll: ('%-10s' sprintfWith: 'Tally All');
		nextPutAll: ('%-10s' sprintfWith: 'Tally Act');
		nextPutAll: ('%-10s' sprintfWith: 'Time All');
		nextPutAll: ('%-10s' sprintfWith: 'Time Act');
		cr!

update
	"Update the list but try to retain the selection if possible"

	| presenter selection |
	selection := (presenter := self presenterNamed: 'items') selectionOrNil.
	super update.
	selection notNil ifTrue: [presenter selection: selection ifAbsent: []].
	self onSelectionChanged! !
!ProfilerSelectorListPresenter categoriesFor: #createComponents!initializing!public! !
!ProfilerSelectorListPresenter categoriesFor: #createSchematicWiring!initializing!public! !
!ProfilerSelectorListPresenter categoriesFor: #filterDolphin:!filtering!public! !
!ProfilerSelectorListPresenter categoriesFor: #items!accessing!public! !
!ProfilerSelectorListPresenter categoriesFor: #onSelectionChanged!event handling!public! !
!ProfilerSelectorListPresenter categoriesFor: #reportIdentityOf:to:!public!reporting! !
!ProfilerSelectorListPresenter categoriesFor: #reportItems!public!reporting! !
!ProfilerSelectorListPresenter categoriesFor: #reportTitleTo:!public!reporting! !
!ProfilerSelectorListPresenter categoriesFor: #update!public!updating! !

ProfilerTallyTreePresenter comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ProfilerTallyTreePresenter methodsFor!

total
	"Answer the total number of items for this type of tree"

	^self model samplesSize!

treeValueFor: aProfilerTreeNode
	"Answers the value of the field for the receivers type of tree"

	^aProfilerTreeNode tally! !
!ProfilerTallyTreePresenter categoriesFor: #total!accessing!public! !
!ProfilerTallyTreePresenter categoriesFor: #treeValueFor:!accessing!public! !

ProfilerTimeTreePresenter comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ProfilerTimeTreePresenter methodsFor!

total
	"Answer the total number of items for this type of tree"

	^self model samplesElapsedTime!

treeValueFor: aProfilerTreeNode
	"Answers the value of the field for the receivers type of tree"

	^aProfilerTreeNode time! !
!ProfilerTimeTreePresenter categoriesFor: #total!accessing!public! !
!ProfilerTimeTreePresenter categoriesFor: #treeValueFor:!accessing!public! !

!ClassSelector methodsFor!

classPackage
	"Prompt for the user to repackage the selected class."

	| class newPkg oldPkg |
	class := self selection.
	oldPkg := class owningPackage.
	newPkg := PackagePrompter 
				showModalOn: oldPkg asValue
				caption: 'Package of ' , class name , '...'
				default: nil
				validationBlock: [:package | package notNil and: [class environment includesKey: class name]].
	(newPkg isNil or: [newPkg = oldPkg]) ifFalse: [self queryMoveClass: class toPackage: newPkg]! !
!ClassSelector categoriesFor: #classPackage!commands!public! !

!PackageSelector methodsFor!

createComponents
	"Create the presenters contained by the receiver"

	super createComponents.
	filterPresenter := self add: TreePresenter new name: 'filter'.
	packagesPresenter := self add: ListPresenter new name: 'packages'!

model: aPackageHierarchyModel 
	super model: aPackageHierarchyModel.
	filterPresenter model: aPackageHierarchyModel! !
!PackageSelector categoriesFor: #createComponents!initializing!public! !
!PackageSelector categoriesFor: #model:!public! !

!MethodBrowser class methodsFor!

defaultAdditionalAccelerators
	^#(#(#widenSourceSelection 'Ctrl+U'))!

initialize
	"Private - Initialize the receiver's class variables.
		self initialize
	"

	self wordWrap: true.
	self autoFormat: false! !
!MethodBrowser class categoriesFor: #defaultAdditionalAccelerators!initializing!private! !
!MethodBrowser class categoriesFor: #initialize!initializing!private! !

!MethodBrowser methodsFor!

browseContainingText
	"Prompt for a string and open a method browser displaying the methods containing that
	string."

	self systemModel browseContainingText!

browseMethodHistory
	"Open a browser on the history of the current method"

	#idbAdded.
	self hasMethodSelected ifFalse: [^self].
	MethodHistoryBrowser showOnClass: self method methodClass selector: self method selector!

methodPackage
	"Prompt for the user to repackage the selected method."

	| method oldPkg newPkg |
	method := self selection.
	oldPkg := method owningPackage.
	newPkg := PackagePrompter 
				showModalOn: oldPkg asValue
				caption: 'Package of ' , method displayString , '...'
				default: method methodClass owningPackage
				validationBlock: [:package | package notNil and: [method isUnbound not]].
	"We allow OK even if no change from existing package, so must check for that here"
	(newPkg notNil and: [newPkg ~= oldPkg]) ifFalse: [^self].
	Package manager addMethod: method to: newPkg.
	self model updateAtIndex: self selectionByIndex!

showUndefined: aSortedCollection
	#idbAdded.
	sourcePresenter showUndefined: aSortedCollection! !
!MethodBrowser categoriesFor: #browseContainingText!commands!public! !
!MethodBrowser categoriesFor: #browseMethodHistory!commands!idb goodies!public! !
!MethodBrowser categoriesFor: #methodPackage!commands!public! !
!MethodBrowser categoriesFor: #showUndefined:!idb goodies!operations!public! !

MultipleSelectionListPresenter comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!MultipleSelectionListPresenter methodsFor!

hasSingleSelection
	^self hasSelection and: [self selection size = 1]!

singleSelection
	^self selection first!

singleSelection: anObject
	self selection: (OrderedCollection with: anObject)!

singleSelectionIndex
	^self selectionByIndex first! !
!MultipleSelectionListPresenter categoriesFor: #hasSingleSelection!public!testing! !
!MultipleSelectionListPresenter categoriesFor: #singleSelection!public!selection! !
!MultipleSelectionListPresenter categoriesFor: #singleSelection:!public!selection! !
!MultipleSelectionListPresenter categoriesFor: #singleSelectionIndex!public!selection! !

!ResourceListPresenter methodsFor!

queryCommand: aCommandQuery 
	"Private - Enter details about a potential command for the receiver 
	into the <CommandQuery>, query."

	| selector |
	selector := aCommandQuery commandSymbol.
	(#(#clearSelection #deleteResource) identityIncludes: selector) 
		ifTrue: 
			[aCommandQuery isEnabled: self selections notEmpty.
			^true].
	#showResource == selector 
		ifTrue: 
			[| rid |
			rid := self resourceIdentifier.
			aCommandQuery isEnabled: (rid notNil and: [rid canShow]).
			^true].
	(#(#properties #resourcePackage #browseIt #editResource) identityIncludes: selector) 
		ifTrue: 
			[aCommandQuery isEnabled: self resourceIdentifier notNil.
			^true].
	(#(#browseHierarchy #browseSystem) identityIncludes: selector) 
		ifTrue: 
			[| name rid |
			rid := self resourceIdentifier.
			name := rid isNil ifTrue: ['Classes'] ifFalse: [rid owningClass name].
			aCommandQuery
				isEnabled: (rid notNil and: [self respondsTo: selector]);
				text: (aCommandQuery commandDescription menuText formatWith: name).
			^true].
	^super queryCommand: aCommandQuery! !
!ResourceListPresenter categoriesFor: #queryCommand:!commands!private! !

!DocumentShell methodsFor!

onPromptToSaveChanges: aBooleanValue 
	"Private - The receiver is about to lose its current contents (or is being closed)
	as the result of some user action. If the displayed document has been changed
	then prompt to see if those changes should be retained, giving the user the option 
	of (a) saving the changes now, (b) discarding the changes, or (c) retaining the 
	changes and aborting whatever operation brought us to this point. If the 
	operation is to be aborted, then the boolean <ValueHolder> argument is 
	set to false."

	self isModified 
		ifTrue: 
			[| docName |
			docName := self hasFilename ifTrue: [self filename] ifFalse: ['(untitled)'].
			(MessageBox new)
				owner: self view;
				confirm: ('Save changes to %1?' formatWith: docName)
					onYes: [aBooleanValue value: self fileSave]
					onNo: [self isModified: false]
					onCancel: [aBooleanValue value: false]].
	^aBooleanValue value! !
!DocumentShell categoriesFor: #onPromptToSaveChanges:!private!testing! !

SpinnerTest comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!SpinnerTest methodsFor!

createComponents
	super createComponents.
	spinner := self add: SpinnerPresenter new name: 'spinner'.
	report := self add: NumberPresenter new name: 'report'!

createSchematicWiring
	super createSchematicWiring.
	spinner
		when: #valueChanged
		send: #onSpinnerValueChanged
		to: self!

negative
	spinner value: -50!

onSpinnerValueChanged
	report value: spinner value!

positive
	spinner value: 50! !
!SpinnerTest categoriesFor: #createComponents!initializing!public! !
!SpinnerTest categoriesFor: #createSchematicWiring!initializing!public! !
!SpinnerTest categoriesFor: #negative!commands!public! !
!SpinnerTest categoriesFor: #onSpinnerValueChanged!event handling!public! !
!SpinnerTest categoriesFor: #positive!commands!public! !

!TranscriptShell methodsFor!

onViewRestored: aSizeEvent 
	"#149: In order to workaround the problem of a restored Transcript not displaying any output
	sent when it was closed, we have to perturb it a bit. This seems to be a bug in the RichEdit
	control , since this workaround is not necessary when using a multi-line text edit. Thanks
	to Mikael Svane for this fix."

	outputWindow
		sendMessage: EM_SCROLL wParam: SB_LINEUP;
		sendMessage: EM_SCROLL wParam: SB_LINEDOWN.
	^super onViewRestored: aSizeEvent!

stbSaveOn: anSTBOutFiler
	"Output the singleton receiver to anSTBOutFiler."

	anSTBOutFiler saveObject: self as: (STBSingletonProxy for: self class)! !
!TranscriptShell categoriesFor: #onViewRestored:!event handling!public! !
!TranscriptShell categoriesFor: #stbSaveOn:!binary filing!public! !

!CreateSubclassDialog methodsFor!

createSchematicWiring
	super createSchematicWiring.
	packagesPresenter 
		when: #selectionChanged
		send: #onPackageSelected
		to: self.
	usePackagePresenter 
		when: #valueChanged
		send: #toggleSetPackage
		to: self.
	superclassPresenter 
		when: #valueChanged
		send: #onSuperclassChanged
		to: self!

environment
	"Private - Answer the global environment for which we are defining a subclass."

	^self superclass isNil ifTrue: [Smalltalk] ifFalse: [self superclass environment]!

model: aSubjectModel 
	| aClassOrNil |
	super model: aSubjectModel.
	aClassOrNil := aSubjectModel value.
	package := Smalltalk developmentSystem defaultPackage.
	superclassPresenter model: aClassOrNil.
	namePresenter model: aClassOrNil name asValue.
	self onSuperclassChanged!

onSuperclassChanged
	superClass := self superclass.
	superClass isNil 
		ifTrue: [subclassesPresenter choices: Smalltalk allRoots]
		ifFalse: 
			[subclassesPresenter choices: superClass subclasses.
			package isNil ifTrue: [package := superClass owningPackage]]! !
!CreateSubclassDialog categoriesFor: #createSchematicWiring!initializing!public! !
!CreateSubclassDialog categoriesFor: #environment!constants!private! !
!CreateSubclassDialog categoriesFor: #model:!accessing!public! !
!CreateSubclassDialog categoriesFor: #onSuperclassChanged!event handling!private! !

ILExtentDialog comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ILExtentDialog class methodsFor!

defaultModel
	^16 @ 16! !
!ILExtentDialog class categoriesFor: #defaultModel!models!public! !

!ILExtentDialog methodsFor!

createComponents
	super createComponents.
	widthPresenter := self add: NumberPresenter new name: 'width'.
	heightPresenter := self add: NumberPresenter new name: 'height'.
	optionsPresenter := self add: ListPresenter new name: 'options'!

createSchematicWiring
	super createSchematicWiring.
	optionsPresenter
		when: #selectionChanged
		send: #onSelectionChanged
		to: self.
	optionsPresenter
		when: #actionPerformed
		send: #ok
		to: self!

model: aPoint
	super model: aPoint.
	widthPresenter model: (self model aspectValue: #x).
	heightPresenter model: (self model aspectValue: #y).
	optionsPresenter list: OrderedCollection new!

onSelectionChanged
	widthPresenter value: optionsPresenter selection x.
	heightPresenter value: optionsPresenter selection y!

options: aCollection
	optionsPresenter
		list: aCollection;
		selection: aCollection first! !
!ILExtentDialog categoriesFor: #createComponents!initializing!public! !
!ILExtentDialog categoriesFor: #createSchematicWiring!initializing!public! !
!ILExtentDialog categoriesFor: #model:!accessing!public! !
!ILExtentDialog categoriesFor: #onSelectionChanged!event handling!public! !
!ILExtentDialog categoriesFor: #options:!initializing!public! !

PoolItemDialog comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!PoolItemDialog class methodsFor!

defaultModel
	^Association new! !
!PoolItemDialog class categoriesFor: #defaultModel!constants!public! !

!PoolItemDialog methodsFor!

createComponents
	super createComponents.
	key := self add: TextPresenter new name: 'key'.
	value := self add: TextPresenter new name: 'value'!

isValid
	"Answers true if the key field contains a (not empty) String and the 
	value field contains a valid expression"

	| flag |
	(key value isNil or: [key value isEmpty]) ifTrue: [^false].
	[Compiler evaluate: value value logged: false.
	flag := true]
		on: CompilerErrorNotification , Error
		do:
			[:ex | 
			flag := false.
			ex return: nil].
	^flag!

model: anAssociation
	"Make sure we are working with two Strings"

	super model: anAssociation key -> anAssociation value printString.
	key model: (self model aspectValue: #key).
	value model: (self model aspectValue: #value)!

ok
	"Compile the value before applying.  We know it will compile correctly 
	because the OK key was enabled (see #isValid)"

	value value: (Compiler evaluate: value value logged: false).
	^super ok!

onViewOpened
	super onViewOpened.
	key value
		ifNotNil:
			[:arg | 
			[(self view viewNamed: 'value')
				setFocus;
				selectAll] postToInputQueue]!

queryCommand: aCommandQuery
	aCommandQuery command == #ok
		ifTrue:
			[aCommandQuery isEnabled: self isValid.
			^true].
	^super queryCommand: aCommandQuery! !
!PoolItemDialog categoriesFor: #createComponents!initializing!public! !
!PoolItemDialog categoriesFor: #isValid!public!testing! !
!PoolItemDialog categoriesFor: #model:!accessing!public! !
!PoolItemDialog categoriesFor: #ok!commands!public! !
!PoolItemDialog categoriesFor: #onViewOpened!event handling!public! !
!PoolItemDialog categoriesFor: #queryCommand:!commands!public! !

ProfilerSetupDialog comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ProfilerSetupDialog class methodsFor!

defaultModel
	"Answer a default model to be assigned to the receiver when it is initialized.
	We use true to obtain a useful return value when the dialog is closed"

	^true!

interval
	"Accessor for the Interval class variable"

	^ProfilingInterval!

isCollect
	"Accessor for the IsCollect class variable"

	^IsCollect!

isOn
	"Accessor for the IsOn class variable"

	^IsOn!

profiledBlock
	"Accessor for the ProfiledBlock class variable"

	^ProfiledBlock!

sampleSetName
	"Accessor for the SampleSetName class variable"

	^SampleSetName! !
!ProfilerSetupDialog class categoriesFor: #defaultModel!models!public! !
!ProfilerSetupDialog class categoriesFor: #interval!accessing!public! !
!ProfilerSetupDialog class categoriesFor: #isCollect!accessing!public! !
!ProfilerSetupDialog class categoriesFor: #isOn!accessing!public! !
!ProfilerSetupDialog class categoriesFor: #profiledBlock!accessing!public! !
!ProfilerSetupDialog class categoriesFor: #sampleSetName!accessing!public! !

!ProfilerSetupDialog methodsFor!

apply
	"The dialog has been closed with OK and the responses are acceptable
	so copy the results into the class variables"

	IsCollect := (self presenterNamed: 'collect') value.
	IsOn := (self presenterNamed: 'profilingOn') value.
	SampleSetName := (self presenterNamed: 'set') view text.
	ProfilingInterval := (self presenterNamed: 'interval') value.
	ProfiledText := (self presenterNamed: 'source') text.
	super apply!

createComponents
	"Create the presenters contained by the receiver"

	super createComponents.
	self
		add: BooleanPresenter new name: 'collect';
		add: BooleanPresenter new name: 'profilingOn';
		add: ListPresenter new name: 'set';
		add: NumberPresenter new name: 'interval';
		add: SmalltalkWorkspace new name: 'source'!

isAcceptable
	"Check all the response fields to make sure thay are acceptable. This also involves 
	compiling and checking the source code.
	Answer true if the dialog is acceptable"

	| sourcePresenter text |
	(self presenterNamed: 'set') view text isEmpty
		| (self presenterNamed: 'interval') value isNil
		ifTrue:
			[MessageBox warning: 'Both the Set and Interval must be given'.
			^false].
	(self presenterNamed: 'interval') value >= 1
		ifFalse:
			[MessageBox warning: 'The Interval must be greater than, or equal to, 1mS'.
			^false].
	(sourcePresenter := self presenterNamed: 'source') selection isEmpty
		ifTrue: [sourcePresenter view selectAll].
	text := sourcePresenter selection trimBlanks.
	(text isEmpty or: [text first ~= $[ | (text last ~= $])])
		ifTrue: [sourcePresenter replaceSelection: '[' , text , ']'].
	(ProfiledBlock := sourcePresenter evaluateItIfFail: []) isNil
		ifTrue:
			[MessageBox warning: 'The evaluation block failed to compile'.
			^false].
	^true!

ok
	"Only continue if the responses are acceptable. A bad response will have already
	given an error message so we can just abandon"

	self isAcceptable ifFalse: [^self].
	super ok!

onViewOpened
	"When the view has been opened we need to initialize the fields from the class vars.
	If they haven't been used before, are not initialized (IsCollect == nil) then just do a reset"

	super onViewOpened.
	IsCollect isNil ifTrue: [self reset] ifFalse: [self setFields]!

reset
	"Reset all the class inst vars to their defaul values"

	IsCollect := false.
	IsOn := true.
	SampleSetName := ProfilerSampleSetManager defaultSetName.
	ProfilingInterval := 1.
	ProfiledText := '["Enter the code to profile"
        ]' asRichText.
	self setFields!

setFields
	"Set the field with the appropriate values, either from the class inst vars oe external singletons"

	| sampleSetNames |
	sampleSetNames := ProfilerSampleSetManager default sampleSetNames.
	(sampleSetNames includes: ProfilerSampleSetManager defaultSetName)
		ifFalse: [sampleSetNames add: ProfilerSampleSetManager defaultSetName].
	(self presenterNamed: 'collect') value: IsCollect.
	(self presenterNamed: 'profilingOn') value: IsOn.
	(self presenterNamed: 'set') list: sampleSetNames.
	(self presenterNamed: 'interval') value: ProfilingInterval.
	(self presenterNamed: 'source') text: ProfiledText.
	(self presenterNamed: 'set') view text: SampleSetName! !
!ProfilerSetupDialog categoriesFor: #apply!commands!public! !
!ProfilerSetupDialog categoriesFor: #createComponents!initializing!public! !
!ProfilerSetupDialog categoriesFor: #isAcceptable!public!testing! !
!ProfilerSetupDialog categoriesFor: #ok!commands!public! !
!ProfilerSetupDialog categoriesFor: #onViewOpened!event handling!public! !
!ProfilerSetupDialog categoriesFor: #reset!commands!public! !
!ProfilerSetupDialog categoriesFor: #setFields!initializing!public! !

ILBitmapExtentDialog comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ILBitmapExtentDialog methodsFor!

bitmapExtent: aPoint
	bitmapExtent := aPoint.
	self
		options:
			((1 to: aPoint x)
				select: [:each | aPoint x \\ each = 0]
				thenCollect:
					[:each | 
					(String writeStream)
						print: aPoint x // each;
						nextPutAll: ' bitmap';
						nextPutAll: (aPoint x // each = 1 ifTrue: [' '] ifFalse: ['s ']);
						nextPutAll: 'sized ';
						print: each;
						nextPutAll: ' x ';
						print: aPoint y;
						contents])!

onSelectionChanged
	| parts |
	parts := optionsPresenter selection subStrings.
	widthPresenter value: (Number fromString: (parts at: 4)).
	heightPresenter value: (Number fromString: (parts at: 6))! !
!ILBitmapExtentDialog categoriesFor: #bitmapExtent:!accessing!initializing!public! !
!ILBitmapExtentDialog categoriesFor: #onSelectionChanged!event handling!public! !

!PackagePrompter class methodsFor!

defaultValidationBlock
	^[:package | package notNil]!

showModalOn: aModel caption: aString default: aPackage 
	"Creates an instance of the receiver with a default view and connected to aModel and the
	specified caption <String>. The view is displayed modal to the current active window.
	Answers the result of dialog if confirmed or nil cancelled. The OK button in the dialog will
	only be enabled if there is a package selected other than the initial value."

	^self 
		showModalOn: aModel
		caption: aString
		default: aPackage
		validationBlock: self defaultValidationBlock!

showModalOn: aModel caption: aString default: aPackage validationBlock: aBlock 
	"Creates an instance of the receiver with a default view and connected to aModel and the
	specified caption <String>. The view is displayed modal to the current active window.
	Answers the result of dialog if confirmed or nil cancelled. The OK button in the dialog will
	only be enabled when the <monadicValuable>, aBlock, evaluates to true when passed the
	current package selection."

	^(self createOn: aModel)
		defaultPackage: aPackage;
		caption: aString;
		validationBlock: aBlock;
		showModal! !
!PackagePrompter class categoriesFor: #defaultValidationBlock!constants!public! !
!PackagePrompter class categoriesFor: #showModalOn:caption:default:!instance creation!public! !
!PackagePrompter class categoriesFor: #showModalOn:caption:default:validationBlock:!instance creation!public! !

!PackagePrompter methodsFor!

initialize
	"Private - Initialize the receiver"

	super initialize.
	validationBlock := self class defaultValidationBlock!

queryCommand: query 
	"Private - Enters details about a potential command for the receiver into 
	the <CommandQuery>, query"

	| cmd |
	cmd := query commandSymbol.
	cmd == #ok 
		ifTrue: 
			[query isEnabled: (self validationBlock value: self value).
			^true].
	^super queryCommand: query!

validationBlock
	^validationBlock!

validationBlock: aBlock 
	"Set the <monadicValuable> used validate the current package selection. The valuable is
	passed the current package selection as its argument, and is expected to answer whether it
	is valid. The OK button is not enabled until the validationBlock answers true."

	validationBlock := aBlock! !
!PackagePrompter categoriesFor: #initialize!initializing!private! !
!PackagePrompter categoriesFor: #queryCommand:!commands!private! !
!PackagePrompter categoriesFor: #validationBlock!accessing!public! !
!PackagePrompter categoriesFor: #validationBlock:!accessing!public! !

MultipleFileOpenDialog comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!MultipleFileOpenDialog methodsFor!

defaultMaxFileCount
	"Answers the default number of selections that are expected  to fit into the buffer"

	^25!

defaultStyle
	"Answers the style for the receiver."

	^super defaultStyle bitOr: ##(OFN_ALLOWMULTISELECT | OFN_EXPLORER)!

extractResult: result
	"Extract the result from the buffer. The possible outcomes are
		result == false. 
			The user cancelled. Don't change the model.
		result == true.
			If the user made one selection then the buffer contains a full path.
			If the user made multiple selections then the first item in the buffer contains the
				 path (minus any filename) and the subsequent entries contain the selected 
				filenames.
			In both cases we construct a collection of full paths to  set the receivers value.
	Items are stored in the buffer separated by 0, the end of the buffer indicated by an empty
	entry (double 0)"

	result
		ifTrue:
			[| endIndex pathNames |
			endIndex := buffer
				indexOfSubCollection: ##(String with: Character null with: Character null).
			pathNames := (buffer copyFrom: 1 to: endIndex) subStrings: Character null.
			pathNames size > 1
				ifTrue:
					[pathNames := (pathNames copyFrom: 2)
						collect: [:each | File composePath: pathNames first subPath: each]].
			self value: pathNames.
			self apply]!

maxFileCount
	"Answers the maximum number of selections that can be expected to fit into the buffer.
	Maintain a minimum size of 10, just in case"

	maxFileCount isNil ifTrue: [^self defaultMaxFileCount].
	^maxFileCount max: 10!

maxFileCount: anInteger
	"Sets the maximum number of paths that can be expected to fit into the buffer"

	maxFileCount := anInteger!

prepareStruct
	"Prepare the structure expected by the dialog. The size of the buffer is set to the 
	maximum size of a Windows path (the buffer will only ever contain one path) plus
	maxFileCount instVar multiplied by 30 (i.e. 3 times the average file name size). 
	If the buffer specified is too small then the Dialog just answers nil, no error is raised.
	NB We keep a reference to the buffer in an instVar as we need to scan it later to 
	extract multiple Strings (see #extractResult). If we try to use the winStruct reference
	we can only recover the first String."

	| filename defext |
	buffer := String new: self maxFileCount * 30 + File maxPath.
	filename := self value.
	filename notNil
		ifTrue:
			[buffer
				replaceFrom: 1
				to: filename size
				with: filename].
	(self winStruct)
		fileTypes: (self fileTypesStringFromSpecs: self fileTypes);
		nMaxFile: buffer size;
		fileName: buffer;
		flags: self style! !
!MultipleFileOpenDialog categoriesFor: #defaultMaxFileCount!accessing!public! !
!MultipleFileOpenDialog categoriesFor: #defaultStyle!constants!public! !
!MultipleFileOpenDialog categoriesFor: #extractResult:!helpers!public! !
!MultipleFileOpenDialog categoriesFor: #maxFileCount!accessing!public! !
!MultipleFileOpenDialog categoriesFor: #maxFileCount:!accessing!public! !
!MultipleFileOpenDialog categoriesFor: #prepareStruct!public!realizing/unrealizing! !

!ClassBrowserAbstract methodsFor!

actualClassChain
	"Private - Answer the method search chain for the actual class selected in the receiver after taking account
	of instance or class mode and whether superclass searching is enabled."

	| actualClass |
	(actualClass := self actualClass) isNil ifTrue: [^#()].
	^self isShowInheritedMethods 
		ifTrue: 
			[| chain |
			chain := actualClass withAllSuperclasses.
			self isFilterObjectMethods 
				ifTrue: 
					[| objectClass |
					objectClass := self isInstanceMode ifTrue: [Object] ifFalse: [Object class].
					actualClass ~= objectClass ifTrue: [chain := chain upTo: objectClass]].
			chain]
		ifFalse: [Array with: actualClass]!

browseMethodHistory
	"Open a browser on the history of methods in the current class"

	#idbAdded.
	methodBrowserPresenter browseMethodHistory!

browseMethodHistoryForClass
	"Open a browser on the history of methods in the current class"

	#idbAdded.
	ClassHistoryBrowser showOnClass: self actualClass!

checkForUndefined
	#idbAdded.
	self method
		ifNotNil:
			[:method | 
			| selectors |
			(selectors := method undefinedSelectors) isEmpty
				ifFalse: [methodBrowserPresenter showUndefined: selectors]]!

classesPresenter
	#idbAdded.
	^classesPresenter!

createSchematicWiring
	"Create the trigger wiring for the receiver"

	super createSchematicWiring.
	classesPresenter
		when: #modeChanged
			send: #onClassModeChanged
			to: self;
		when: #selectionChanged
			send: #onClassSelected
			to: self;
		when: #selectionChanging:
			send: #onClassSelectionChanging:
			to: self.
	categoriesPresenter
		when: #selectionChanged
			send: #onCategorySelected
			to: self;
		when: #selectionChanging:
			send: #onFilterSelectionChanging:
			to: self;
		when: #drag:
			send: #onDragCategory:
			to: self;
		when: #dragCut:
			send: #onDragMethodsCut:
			to: self;
		when: #dragOver:
			send: #onDragOverCategory:
			to: self;
		when: #drop:
			send: #onDropOverCategory:
			to: self.
	modePresenter
		when: #selectionChanged
			send: #onModeSelectionChanged
			to: self;
		when: #selectionChanging:
			send: #onFilterSelectionChanging:
			to: self;
		when: #dragOver:
			send: #onDragOverMode:
			to: self;
		when: #drop:
			send: #onDropOverMode:
			to: self.
	methodBrowserPresenter
		when: #methodChanged
			send: #onMethodSelected
			to: self;
		when: #dragOver:
			send: #onDragOverMethod:
			to: self;
		when: #drop:
			send: #onDropOverMethods:
			to: self.
	self 
		when: #closeRequested:
		send: #onCloseRequested:
		to: self.
	(self model)
		when: #methodCategorized:
			send: #onMethodCategorized:
			to: self;
		when: #methodAdded:
			send: #onMethodAdded:
			to: self;
		when: #methodRemoved:
			send: #onMethodRemoved:
			to: self;
		when: #classUpdated:
			send: #onClassUpdated:
			to: self;
		when: #classCommented:
			send: #onClassCommented:
			to: self;
		when: #classCategorized:
			send: #onClassCategorized:
			to: self;
		when: #protocolUpdated:
			send: #onProtocolUpdated:
			to: self;
		when: #protocolRemoved:
			send: #onProtocolRemoved:
			to: self.
	(self packageManager)
		when: #methodRepackaged:from:to:
			send: #onMethodRepackaged:from:to:
			to: self;
		when: #classRepackaged:from:to:
			send: #onClassRepackaged:from:to:
			to: self.
	protocolsPresenter
		when: #selectionChanged
			send: #onProtocolSelected
			to: self;
		when: #selectionChanging:
			send: #onFilterSelectionChanging:
			to: self;
		when: #actionPerformed
			send: #browseMethodProtocol
			to: self;
		when: #drag:
			send: #onDragProtocol:
			to: self;
		when: #dragCut:
			send: #onDragMethodsCut:
			to: self;
		when: #dragOver:
			send: #onDragOverProtocol:
			to: self model;
		when: #drop:
			send: #onDropOverProtocol:
			to: self model;
		when: #labelOf:editedTo:accept:
			send: #onRenameMethodProtocol:to:accept:
			to: self.
	variablesPresenter
		when: #drag:
			send: #onDragVariableRefs:
			to: self;
		when: #dragCut:
			send: #onDragMethodsCut:
			to: self;
		when: #selectionChanged
			send: #onVariableSelected
			to: self;
		when: #selectionChanging:
			send: #onFilterSelectionChanging:
			to: self;
		when: #labelOf:editedTo:accept:
			send: #onRenameInstVar:to:accept:
			to: self!

fileOutMethod
	"File out, after asking for filename, the currenly selected method"

	#idbAdded.
	self systemModel methodFileOut: self method!

isMethodFiltrate: aCompiledMethod 
	"Private - Answer whether the <CompiledMethod> argument passes through the current method filter.
	It is assumed that the method is from the currently displayed hierarchy."

	self isFilterObjectMethods ifFalse: [^true].
	^((self isInstanceMode ifTrue: [Object] ifFalse: [Object class]) 
		includesBehavior: aCompiledMethod methodClass) not!

isMethodVisible: aCompiledMethod 
	| actualClass |
	actualClass := self actualClass.
	^aCompiledMethod methodClass == actualClass or: 
			[self isShowInheritedMethods and: 
					[(actualClass lookupMethod: aCompiledMethod selector) == aCompiledMethod 
						and: [self isMethodFiltrate: aCompiledMethod]]]!

methodBrowserPresenter
	#idbAdded.
	^methodBrowserPresenter!

onClassCommented: aClass 
	"Private - The comment of a class within the receiver has been changed. 
	Refresh the comment pane if it is the selected class."

	| class |
	class := self actualClass.
	(class isNil or: [class instanceClass ~~ aClass instanceClass]) ifTrue: [^self].
	self 
		updateClass: 'comment'
		presenter: commentPresenter
		source: aClass comment!

onClassUpdated: aClass 
	"Private - A class within the receiver has changed. Refresh the definition pane if it is the
	selected class, and refresh the variables and caption if it is the actual class/metaclass
	being displayed."

	| class |
	class := self actualClass.
	(class isNil or: [(class instanceClass includesBehavior: aClass instanceClass) not]) 
		ifTrue: [^self].
	class instanceClass == aClass instanceClass 
		ifTrue: 
			[self 
				updateClass: 'definition'
				presenter: definitionPresenter
				source: aClass instanceClass coloredDefinition].

	"If displaying the actual class or a superclass, then may need to refresh variables"
	(class includesBehavior: aClass) ifFalse: [^self].
	self updateVariables.
	self updateCaption!

onMethodRemoved: aCompiledMethod 
	"Private - The development system has removed aCompiledMethod."

	"Implementation Note: Some complexity arises if in 'show inherited methods'
	mode as the method may have been hiding a superclass implementation which
	we now need to add into the browser."

	| actualClass methodClass |
	self isShowInheritedMethods ifFalse: [^self].
	methodClass := aCompiledMethod methodClass.
	actualClass := self actualClass.
	(actualClass includesBehavior: methodClass) ifFalse: [^self].

	"A method has been removed in the selected class' inheritance chain - this may possibly
	 have exposed a method higher up the chain."
	(actualClass lookupMethod: aCompiledMethod selector) ifNotNil: 
			[:visibleMethod | 
			((methodClass inheritsFrom: visibleMethod methodClass) 
				and: [self isMethodFiltrate: visibleMethod]) 
					ifTrue: 
						[methodBrowserPresenter model add: visibleMethod.
						self addCategoriesOfMethod: visibleMethod]]!

runCommand
	| target answer |
	#idbAdded.
	target := self selectedClass new.
	answer := target run.
	answer = target ifFalse: [answer inspect]!

updateClass: aspectString presenter: aSmalltalkWorkspace source: sourceString 
	| class event |
	class := self actualClass.
	event := (SelectionChangingEvent forSource: self)
				oldSelection: class;
				newSelection: class;
				yourself.
	(aSmalltalkWorkspace prompt: aspectString toSaveChanges: event) 
		ifTrue: [aSmalltalkWorkspace text: sourceString]! !
!ClassBrowserAbstract categoriesFor: #actualClassChain!accessing!private! !
!ClassBrowserAbstract categoriesFor: #browseMethodHistory!commands!idb goodies!public! !
!ClassBrowserAbstract categoriesFor: #browseMethodHistoryForClass!commands!idb goodies!public! !
!ClassBrowserAbstract categoriesFor: #checkForUndefined!idb goodies!operations!public! !
!ClassBrowserAbstract categoriesFor: #classesPresenter!accessing!idb goodies!public! !
!ClassBrowserAbstract categoriesFor: #createSchematicWiring!initializing!public! !
!ClassBrowserAbstract categoriesFor: #fileOutMethod!idb goodies!public!source filing! !
!ClassBrowserAbstract categoriesFor: #isMethodFiltrate:!private!testing! !
!ClassBrowserAbstract categoriesFor: #isMethodVisible:!private!testing! !
!ClassBrowserAbstract categoriesFor: #methodBrowserPresenter!accessing!idb goodies!public! !
!ClassBrowserAbstract categoriesFor: #onClassCommented:!event handling!private! !
!ClassBrowserAbstract categoriesFor: #onClassUpdated:!event handling!private! !
!ClassBrowserAbstract categoriesFor: #onMethodRemoved:!event handling!private! !
!ClassBrowserAbstract categoriesFor: #runCommand!commands!idb goodies!public! !
!ClassBrowserAbstract categoriesFor: #updateClass:presenter:source:!helpers!private! !

!Debugger methodsFor!

populateStackModel
	"Private - Create and set the stack model list from the first 'depth' frames
	below the current topFrame of the current process."

	"Suppress selection reset event caused by refreshing the list"

	stackPresenter 
		noEventsDo: [stackPresenter list: (process stackFramesFrom: topFrame depth: depth)].
	stackPresenter selectionOrNil: topFrame!

process: aProcess topFrame: aStackFrame
	"Private - Sets the process being debugged and the top stack frame (of interest).
	The stack frame list is populated."

	topFrame := aStackFrame.
	self isMain: aProcess isMain.
	process := aProcess.
	process debugger: self.
	self populateStackModel.
	tempsPresenter selectionByIndex: 1 ifAbsent: []!

queryCommand: aCommandQuery 
	"Private - Enter details about a potential command for the receiver into the 
	<CommandQuery>."

	| selector running runnable animating frame |
	selector := aCommandQuery commandSymbol.
	animating := self isAnimating.
	running := self isRunning or: [animating].
	runnable := running not and: [self isResumable].
	frame := self frame.
	#nilVariable == selector 
		ifTrue: 
			[aCommandQuery isEnabled: tempsPresenter selectionByIndex > 1.
			^true].
	#accept == selector 
		ifTrue: 
			[inspectorPresenter hasFocus 
				ifTrue: [aCommandQuery isEnabled: tempsPresenter selectionByIndex > 1]
				ifFalse: [aCommandQuery isEnabled: self canSaveMethod].
			^true].
	#browseVariableClass == selector 
		ifTrue: 
			[aCommandQuery isEnabled: tempsPresenter selectionByIndex > 0.
			^true].
	(#(#acceptNoRestart #reformatAccept #reformatSource) identityIncludes: selector) 
		ifTrue: 
			[aCommandQuery isEnabled: self canSaveMethod.
			^true].
	selector == #userBreak 
		ifTrue: 
			[aCommandQuery isEnabled: (running and: [animating not]).
			^true].
	selector == #stepInto 
		ifTrue: 
			["Can only step-into in the top stack frame"
			aCommandQuery isEnabled: (runnable and: [frame = topFrame]).
			^true].
	selector == #runToCursor 
		ifTrue: 
			["Can run to cursor if not in disassembly view"
			aCommandQuery isEnabled: (runnable and: [frame notNil and: [self isDisassembled not]]).
			^true].
	(#(#resumeProcess #runProcess) identityIncludes: selector) 
		ifTrue: 
			[aCommandQuery isEnabled: runnable.
			^true].
	(#(#stepOver #stepOut) identityIncludes: selector) 
		ifTrue: 
			[aCommandQuery isEnabled: (runnable and: [frame notNil]).
			^true].
	selector == #returnFromMessage 
		ifTrue: 
			[aCommandQuery isEnabled: (running not and: [frame notNil and: [frame sender notNil]]).
			^true].
	selector == #restartFrame 
		ifTrue: 
			[aCommandQuery isEnabled: (running not and: [frame notNil and: [frame isRestartable]]).
			^true].
	selector == #toggleDisassembly 
		ifTrue: 
			[aCommandQuery
				isEnabled: frame notNil;
				isChecked: self isDisassembled.
			^true].
	selector == #toggleAnimation 
		ifTrue: 
			[aCommandQuery
				isEnabled: (runnable or: [animating]);
				isChecked: animating.
			^true].
	(selector == #moreFrames or: [selector == #allFrames]) 
		ifTrue: 
			[aCommandQuery isEnabled: (running not and: [self depth <= self frames size]).
			^true].
	#showNextStatement == selector 
		ifTrue: 
			[aCommandQuery isEnabled: running not.
			^true].
	"Note that the implement menu is not just for DNUs any more, but any message which is not directly
	 implemented by its receiver."
	selector == #implementDNUMenu 
		ifTrue: 
			[aCommandQuery isEnabled: (running not 
						and: [frame notNil and: [self class enableDynamicMenus and: [self canImplementMessage]]]).
			^true].
	#browseMethodInheritanceChain == selector 
		ifTrue: 
			[aCommandQuery isEnabled: (self method notNil and: [self method isOverride]).
			^true].
	(#(#definitionsMenu #referencesMenu #localDefinitionsMenu #localReferencesMenu) 
		identityIncludes: selector) 
			ifTrue: 
				[aCommandQuery isEnabled: (self class enableDynamicMenus and: [self method notNil]).
				^true].
	^super queryCommand: aCommandQuery!

setVariablesList: anOrderedCollection 
	"Private - Set the temporary variables list to an <OrderedCollection> of name-value pairs.
	Attempt to maintain any existing temporary selection by name, failing that select the first
	entry (self). If there is no selection, then maintain that state."

	| oldSelection newSelection |
	oldSelection := tempsPresenter selectionByIndex.
	newSelection := oldSelection > 1 
				ifTrue: 
					[| varName index |
					varName := (tempsPresenter list at: oldSelection) first.
					index := anOrderedCollection findFirst: [:each | each first = varName].
					index = 0 ifTrue: [1] ifFalse: [index]]
				ifFalse: [oldSelection].
	tempsPresenter list: anOrderedCollection.
	tempsPresenter selectionByIndex: newSelection! !
!Debugger categoriesFor: #populateStackModel!private!updating! !
!Debugger categoriesFor: #process:topFrame:!initializing!private! !
!Debugger categoriesFor: #queryCommand:!commands!private! !
!Debugger categoriesFor: #setVariablesList:!private!updating! !

IdbShell comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!IdbShell class methodsFor!

defaultIconName
	^self idbDefaultIconName! !
!IdbShell class categoriesFor: #defaultIconName!constants!public! !

!IdbShell methodsFor!

about: aString
	(Splash
		bitmap: (Bitmap fromFile: SessionManager current idbResourcesFolder , '\about.bmp')
		overlayWith:
			[:canvas | 
			Processor sleep: 1000.
			canvas
				setBkMode: TRANSPARENT;
				forecolor: Color blue;
				font: (Font name: 'Arial' pointSize: 11) beBold;
				formatText: aString
					in: ((0 @ 0 extent: 250 @ 180) insetBy: 8 @ 8)
					flags: DT_CENTER]) show!

idbHelp
	"Open up the index page for help on idb tools"

	ShellLibrary default
		shellOpen:
			(File composePath: SessionManager current idbDocumentationFolder subPath: 'index.html')! !
!IdbShell categoriesFor: #about:!commands!public! !
!IdbShell categoriesFor: #idbHelp!commands!public! !

!LiveUpdate class methodsFor!

backupFile: aString forPatchLevel: anInteger 
	| dir backupName |
	dir := File splitPathFrom: aString.
	backupName := File change: aString
				extension: ('PrePL<1p>.<2s>' expandMacrosWith: anInteger with: (File splitExtensionFrom: aString)).
	File copy: aString to: backupName.
	^dir!

buildOfBinary: path 
	| build lib |
	lib := ExternalLibrary open: path.
	build := VMLibrary default versionInfo fixedInfo dwFileVersionLS lowWord.
	lib close.
	^build!

dolphinExePath
	^ExternalLibrary moduleFileName: nil!

installPathOfSystemComponent: progIdString 
	| clsid classesRoot |
	classesRoot := RegKey classesRoot: #read.
	clsid := ((classesRoot at: progIdString) at: 'CLSID') value.
	^((RegKey classesRoot: #read) at: ('CLSID\<1s>\InProcServer32' expandMacrosWith: clsid)) value
!

renameOnReboot: fromPath to: toPath 
	KernelLibrary default 
		moveFileEx: fromPath
		lpNewFileName: toPath
		dwFlags: 5!

updateSharedBinary: progIdString forLevel: anInteger withBytes: aByteArray 
	| tempPath dir prompt exePath exeDir dllName formatString lib verinfo path imageBase |
	path := self installPathOfSystemComponent: progIdString.
	(self buildOfBinary: path) >= anInteger ifTrue: [^self].
	dir := self backupFile: path forPatchLevel: anInteger.
	exePath := self dolphinExePath.
	exeDir := File splitPathFrom: exePath.
	imageBase := SessionManager current imageBase.
	dllName := File splitFilenameFrom: path.
	tempPath := File change: path extension: 'bin'.
	(FileStream write: tempPath text: false)
		nextPutAll: aByteArray;
		close.
	formatString := OSVERSIONINFO current isWin9X 
				ifTrue: 
					['<n>A new binary (<3s>, version  <4s>), has been placed into your Dolphin installation directory to replace:<n><t><2s><n> If you wish to use this version (recommended) you must exit Dolphin, delete the old binary and rename the following file to replace it:<n><t><1s><n>']
				ifFalse: 
					[self renameOnReboot: tempPath to: path.
					'<n>A new binary (<3s>, version  <4s>), has been placed into your Dolphin installation directory to replace:<n><t><2s><n>To complete installation of this binary you must reboot your machine.<n>'].
	lib := ExternalLibrary open: tempPath.
	verinfo := lib versionInfo.
	prompt := formatString 
				expandMacrosWith: tempPath
				with: path
				with: verinfo fileDescription
				with: verinfo fileVersionString.
	lib close.
	[Notification signal: prompt] postToInputQueue! !
!LiveUpdate class categoriesFor: #backupFile:forPatchLevel:!operations!private! !
!LiveUpdate class categoriesFor: #buildOfBinary:!operations!private! !
!LiveUpdate class categoriesFor: #dolphinExePath!helpers!private! !
!LiveUpdate class categoriesFor: #installPathOfSystemComponent:!helpers!private! !
!LiveUpdate class categoriesFor: #renameOnReboot:to:!operations!private! !
!LiveUpdate class categoriesFor: #updateSharedBinary:forLevel:withBytes:!operations!private! !

!MethodBrowserShell methodsFor!

fileOutMethod
	"File out, after asking for filename, the currenly selected method"

	#idbAdded.
	self systemModel methodFileOut: self browser method!

hasMethodSelected
	"Needed to duplicate ClassBrowserAbstract functionality"

	#idbAdded.
	^self browser hasMethodSelected! !
!MethodBrowserShell categoriesFor: #fileOutMethod!idb goodies!public!source filing! !
!MethodBrowserShell categoriesFor: #hasMethodSelected!idb goodies!public!testing! !

!PackageBrowserShell methodsFor!

browseAllMethods
	#idbAdded.
	SmalltalkSystem current
		browseMethods: methodsPresenter list
		caption: 'Loose methods in selected package(s)'
		findString: nil
		filter: [:m | self packages includes: m owningPackage]!

hasMethods
	#idbAdded.
	^methodsPresenter model notEmpty!

onDropDown: aToolbarButton 
	"Private - The receiver's toolbar has sent a notification that a button's drop-down arrow
	has been pressed. Generate and pop-up the appropriate menu."

	| popup |
	aToolbarButton command asSymbol == #viewModeSelect ifFalse: [^nil].
	popup := classesPresenter view buildViewsPopup.
	popup queryAllFromView: self view.
	popup showIn: self position: aToolbarButton screenRectangle bottomLeft.
	^0!

onViewOpened
	"Received when the receiver's view is been connected. "

	| statusItem toolbar |
	super onViewOpened.
	statusItem := self view viewNamed: 'errors' ifNone: [].
	statusItem notNil 
		ifTrue: 
			[statusModel := ValueHolder new.
			statusItem model: statusModel.
			scriptTextPresenter errorModel: statusModel].

	"Enable view mode pulldown"
	toolbar := self view viewNamed: 'viewTools'.
	toolbar presenterConnectionPoint 
		when: #dropDown:
		send: #onDropDown:
		to: self.

	"Really a CardContainer view, but we treat as if a presenter"
	cardsPresenter := self view viewNamed: 'ownedCards'.
	cardsPresenter 
		when: #currentCardChanged
		send: #onCardChanged
		to: self.	";
		when: #currentCardChanging: send: #onSelectionChanging: to: self"
	self applyOptions.

	"Make sure the classes tab is visble"
	commentPresenter ensureVisible.
	self packageManager youShouldBeProcessingEvents.! !
!PackageBrowserShell categoriesFor: #browseAllMethods!commands!idb goodies!public! !
!PackageBrowserShell categoriesFor: #hasMethods!idb goodies!public!testing! !
!PackageBrowserShell categoriesFor: #onDropDown:!event handling!private! !
!PackageBrowserShell categoriesFor: #onViewOpened!event handling!public! !

!ViewComposer class methodsFor!

defaultAdditionalAccelerators
	^super defaultAdditionalAccelerators , #(#(#widenSelection 'Ctrl+U'))! !
!ViewComposer class categoriesFor: #defaultAdditionalAccelerators!constants!private! !

!ViewComposer methodsFor!

decreaseHeight
	#idbAdded.
	self resizeBy: 0 @ -1!

decreaseWidth
	#idbAdded.
	self resizeBy: -1 @ 0!

increaseHeight
	#idbAdded.
	self resizeBy: 0 @ 1!

increaseWidth
	#idbAdded.
	self resizeBy: 1 @ 0!

moveBy: aPoint
	#idbAdded.
	self selections do: [:each | each position: each position + aPoint]!

moveDown
	#idbAdded.
	self moveBy: 0 @ 1!

moveLeft
	#idbAdded.
	self moveBy: -1 @ 0!

moveRight
	#idbAdded.
	self moveBy: 1 @ 0!

moveUp
	#idbAdded.
	self moveBy: 0 @ -1!

mutate
	"Mutate the primary selection to a user's choice of view"

	| viewClasses excluded |
	excluded := Set new.
	#(#DesktopView #WinAsyncSocket #BrowserView) 
		do: [:each | Smalltalk at: each ifPresent: [:viewClass | excluded add: viewClass]].
	excluded 
		addAll: (self class owningPackage classes select: [:each | each inheritsFrom: View]).
	viewClasses := View allSubclasses 
				reject: [:each | (excluded includes: each) or: [each isAbstract]].
	(ChoicePrompter choices: viewClasses asSortedCollection caption: 'Mutate to') 
		ifNotNil: [:viewClass | self mutateTo: viewClass]!

mutateTo: aViewClass 
	"Mutate the primary selection to an instance of aViewClass."

	| selectedView newView |
	selectedView := self primarySelection.
	newView := selectedView parentView addSubView: aViewClass new.
	self copyAspectsFrom: selectedView to: newView.
	selectedView subViews copy inject: nil
		into: 
			[:prev :each | 
			| name |
			name := each name.
			each
				parentView: newView;
				recreate;
				name: name;
				zOrderAfter: prev;
				yourself].
	self pastedView: newView context: newView parentView.
	self removeView: selectedView.
	"Ensure any refs to old view (such as from a layout manager) are now to
	the new view"
	selectedView oneWayBecome: newView!

queryCommand: aCommandQuery 
	"Private - Enter details about a potential command for the receiver into the 
	<CommandQuery> argument."

	| command |
	command := aCommandQuery commandSymbol.
	(#(#copySelection #cutSelection #clearSelection #mutate #toggleGroupStop #toggleTabStop) 
		identityIncludes: command) 
			ifTrue: 
				[aCommandQuery isEnabled: self hasSelection.
				^true].
	#viewSave == command 
		ifTrue: 
			[aCommandQuery isEnabled: (self hasComposingView 
						and: [self hasResource and: [resourceIdentifier canSave]]).
			^true].
	#viewRevert == command 
		ifTrue: 
			[aCommandQuery isEnabled: (self hasComposingView and: [self hasResource]).
			^true].
	(#(#referenceViewMenu #dereference #editReference) identityIncludes: command) 
		ifTrue: 
			[aCommandQuery isEnabled: (self primarySelection isKindOf: ReferenceView).
			^true].
	(#(#viewExport #viewSaveAs #viewClose #viewTest) includes: command) 
		ifTrue: 
			[aCommandQuery isEnabled: self hasComposingView.
			^true].
	(#(#zFront #zForward #zBackward #zBack) identityIncludes: command) 
		ifTrue: 
			[aCommandQuery isEnabled: self primarySelection notNil.
			^true].
	#widenSelection == command 
		ifTrue: 
			[| selected |
			selected := self primarySelection.
			aCommandQuery isEnabled: (selected notNil and: [selected parentView ~~ arena]).
			^true].
	(#(#matchWidths #matchHeights #matchFonts #matchForegroundColors #matchBackgroundColors #alignLefts #alignMiddles #alignRights #alignTops #alignCenters #alignBottoms) 
		identityIncludes: command) 
			ifTrue: 
				[aCommandQuery isEnabled: self selections size > 1.
				^true].
	command == #editMenuBar 
		ifTrue: 
			[aCommandQuery isEnabled: (self composingView class conformsToProtocol: #topView).
			^true].
	command == #editContextMenu 
		ifTrue: 
			[aCommandQuery isEnabled: self primarySelection notNil.
			^true].
	command == #toggleTabStop 
		ifTrue: 
			[self hasSelection 
				ifTrue: 
					[aCommandQuery
						isEnabled: true;
						isChecked: (self selections detect: [:v | v isTabStop not] ifNone: []) isNil].
			^true].
	command == #toggleGroupStop 
		ifTrue: 
			[self hasSelection 
				ifTrue: 
					[aCommandQuery
						isEnabled: true;
						isChecked: self primarySelection isGroupStop].
			^true].
	command == #pasteClipboard 
		ifTrue: 
			[aCommandQuery isEnabled: self canPaste.
			^true].
	^super queryCommand: aCommandQuery!

resizeBy: aPoint
	#idbAdded.
	self selections do: [:each | each extent: each extent + aPoint]!

widenSelection
	"Widen the selection to encompass the parent of the current primary selection."

	self selection: self primarySelection parentView! !
!ViewComposer categoriesFor: #decreaseHeight!commands!idb goodies!public! !
!ViewComposer categoriesFor: #decreaseWidth!commands!idb goodies!public! !
!ViewComposer categoriesFor: #increaseHeight!commands!idb goodies!public! !
!ViewComposer categoriesFor: #increaseWidth!commands!idb goodies!public! !
!ViewComposer categoriesFor: #moveBy:!idb goodies!operations!public! !
!ViewComposer categoriesFor: #moveDown!commands!idb goodies!public! !
!ViewComposer categoriesFor: #moveLeft!commands!idb goodies!public! !
!ViewComposer categoriesFor: #moveRight!commands!idb goodies!public! !
!ViewComposer categoriesFor: #moveUp!commands!idb goodies!public! !
!ViewComposer categoriesFor: #mutate!commands!public! !
!ViewComposer categoriesFor: #mutateTo:!operations!public! !
!ViewComposer categoriesFor: #queryCommand:!commands!private! !
!ViewComposer categoriesFor: #resizeBy:!idb goodies!operations!public! !
!ViewComposer categoriesFor: #widenSelection!commands!public! !

!ClassBrowserShell methodsFor!

saveNewMethod: aString
	"Added to intercept save operation and perform undefined test"

	#idbAdded.
	super saveNewMethod: aString.
	self checkForUndefined! !
!ClassBrowserShell categoriesFor: #saveNewMethod:!idb goodies!operations!public! !

!SystemBrowserShell methodsFor!

saveNewMethod: aString
	"Added to intercept save operation and perform undefined test"

	#idbAdded.
	super saveNewMethod: aString.
	self checkForUndefined! !
!SystemBrowserShell categoriesFor: #saveNewMethod:!idb goodies!operations!public! !

ClassHistoryBrowser comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ClassHistoryBrowser class methodsFor!

showOnClass: aClass
	^self show initializeFor: aClass! !
!ClassHistoryBrowser class categoriesFor: #showOnClass:!instance creation!public! !

!ClassHistoryBrowser methodsFor!

browseHistory
	"Private - Open up a MethodHistoryBrowser on the selected method to allow
	a previous version to be located and, optionally restored"

	MethodHistoryBrowser showOnClass: class selector: (list selection at: 1)!

browseMethod
	"Private - Open up a ClassBrowser on the selected method"

	(class includesSelector: (list selection at: 1))
		ifTrue: [(class compiledMethodAt: (list selection at: 1)) browse]!

createComponents
	super createComponents.
	list := self add: ListPresenter new name: 'list'!

createSchematicWiring
	super createSchematicWiring.
	list
		when: #actionPerformed
		send: #browseHistory
		to: self.
	(SmalltalkSystem current)
		when: #methodAdded:
			send: #onImageChanged:
			to: self;
		when: #methodRemoved:
			send: #onImageChanged:
			to: self!

initializeFor: aClass
	"Private - Initialize the list. This is used the first time the browser is opened and
	also whenever a method in the selected class is edivted/deleted"

	| selectors methodHistory |
	class := aClass.
	self caption: 'Method History for ' , class printString.
	selectors := SourceManager default historyOfClass: aClass.
	methodHistory := OrderedCollection new.
	((selectors at: 1) , (selectors at: 2)) asSet asSortedCollection
		do:
			[:each | 
			| status |
			methodHistory
				add:
					((Array new: 4)
						at: 1 put: each;
						at: 2
							put:
								(self
										statusOf: each
										source: (selectors at: 1)
										change: (selectors at: 2));
						at: 3 put: ((selectors at: 1) occurrencesOf: each);
						at: 4 put: ((selectors at: 2) occurrencesOf: each);
						yourself)].
	list list: methodHistory!

onImageChanged: aCompiledMethod
	"Private - THe image has changed. If it is a method in the class we are displaying
	then reinitialize to catch the changes"

	| currentSelection |
	aCompiledMethod methodClass == class ifFalse: [^self].
	list hasSelection ifTrue: [currentSelection := list selection at: 1].
	self initializeFor: class.
	currentSelection isNil ifTrue: [^self].
	list selection: (list list detect: [:each | (each at: 1) == currentSelection])!

onViewClosed
	"Private - This is needed to prevent events trying to access this shell
	after it is closed but before it is garbage collected"

	super onViewClosed.
	SmalltalkSystem current removeEventsTriggeredFor: self!

queryCommand: aCommandQuery
	aCommandQuery command = #browseHistory
		ifTrue:
			[aCommandQuery isEnabled: list hasSelection.
			^true].
	aCommandQuery command = #browseMethod
		ifTrue:
			[aCommandQuery
				isEnabled: (list hasSelection and: [class includesSelector: (list selection at: 1)]).
			^true].
	^super queryCommand: aCommandQuery!

statusOf: aSymbol source: sourceCollection change: changeCollection
	"Answers a textual description of the methods status. This is a bit
	arbitrary and is mainly to allow sorting of the list"

	(class includesSelector: aSymbol) ifFalse: [^'deleted'].
	(sourceCollection includes: aSymbol) & (changeCollection includes: aSymbol)
		ifTrue: [^'modified'].
	(sourceCollection includes: aSymbol) not & (changeCollection includes: aSymbol)
		ifTrue: [^'added'].
	^'original'! !
!ClassHistoryBrowser categoriesFor: #browseHistory!commands!public! !
!ClassHistoryBrowser categoriesFor: #browseMethod!commands!public! !
!ClassHistoryBrowser categoriesFor: #createComponents!initializing!public! !
!ClassHistoryBrowser categoriesFor: #createSchematicWiring!initializing!public! !
!ClassHistoryBrowser categoriesFor: #initializeFor:!initializing!public! !
!ClassHistoryBrowser categoriesFor: #onImageChanged:!event handling!public! !
!ClassHistoryBrowser categoriesFor: #onViewClosed!event handling!public! !
!ClassHistoryBrowser categoriesFor: #queryCommand:!commands!public! !
!ClassHistoryBrowser categoriesFor: #statusOf:source:change:!helpers!public! !

IdbToolShell comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!IdbToolShell class methodsFor!

initializeAfterLoad
	self == ##(self)
		ifFalse:
			[(Smalltalk developmentSystem)
				addAdditionalToolsFolderIcon: self toolsFolderIcon;
				registerTool: self].
	super initializeAfterLoad!

uninitializeBeforeRemove
	self == ##(self)
		ifFalse:
			[(Smalltalk developmentSystem)
				removeSystemFolderIcon: self toolsFolderIcon;
				unregisterTool: self].
	super uninitializeBeforeRemove! !
!IdbToolShell class categoriesFor: #initializeAfterLoad!initializing!public! !
!IdbToolShell class categoriesFor: #uninitializeBeforeRemove!initializing!public! !

!IdbToolShell methodsFor!

addToCommandRoute: route
	super addToCommandRoute: route.
	route appendTarget: Smalltalk developmentSystem! !
!IdbToolShell categoriesFor: #addToCommandRoute:!commands!public! !

ILEditorShell comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ILEditorShell class methodsFor!

defaultModel
	^ILImage extent: 16 @ 16!

icon
	^##(self) instanceClass defaultIcon! !
!ILEditorShell class categoriesFor: #defaultModel!models!public! !
!ILEditorShell class categoriesFor: #icon!constants!public! !

!ILEditorShell methodsFor!

about
	"Display the about view"

	self
		about:
			'
Image Editor
for
Dolphin Smalltalk 5.x

Version 5d
 1997-2004 Ian Bartholomew
http://www.idb.me.uk'!

addImage
	"Tell the library, or whatever, to add the image and then restart the editor"

	self model beNotModified.
	self trigger: #addImage: with: (backupImage := self model libraryImage)!

backcolor: anRGB
	"Set the colour to be used as the backcolor for the editorWorkspace"

	editorWorkspace backcolor: anRGB!

createComponents
	super createComponents.
	editorWorkspace := self add: ILEditorWorkspacePresenter new name: 'editorWorkspace'.
	colorSelector := self add: ILColorSelectorPresenter new name: 'colorSelector'.
	imageStatus := self add: TextPresenter new name: 'imageStatus'.
	locationStatus := self add: TextPresenter new name: 'locationStatus'.
	zoneStatus := self add: TextPresenter new name: 'zoneStatus'.
	zoomStatus := self add: TextPresenter new name: 'zoomStatus'.
	modifiedStatus := self add: TextPresenter new name: 'modifiedStatus'!

createSchematicWiring
	super createSchematicWiring.
	self
		when: #closeRequested:
		send: #onCloseRequested:
		to: self.
	editorWorkspace
		when: #selectRGB:
			send: #selectRGB:
			to: colorSelector;
		when: #plot:
			send: #onPlot:
			to: self;
		when: #zoneDescriptionChanged
			send: #onToolbarChanged
			to: self!

drawEllipse
	self model ellipse: editorWorkspace zoneRectangle with: colorSelector selectedRGB!

drawFill
	self model fill: editorWorkspace zoneRectangle with: colorSelector selectedRGB!

drawLineTlBr
	self model lineTlBr: editorWorkspace zoneRectangle with: colorSelector selectedRGB!

drawLineTrBl
	self model lineTrBl: editorWorkspace zoneRectangle with: colorSelector selectedRGB!

drawPlot: aPoint
	self model plot: aPoint with: colorSelector selectedRGB!

drawRectangle
	self model rectangle: editorWorkspace zoneRectangle with: colorSelector selectedRGB!

drawText
	| text |
	((text := Prompter prompt: 'Enter the text' caption: 'Image Editor Text') isNil
		or: [text isEmpty]) ifTrue: [^self].
	Cursor wait
		showWhile:
			[self model
				text: editorWorkspace zoneRectangle
				with: colorSelector selectedRGB
				displaying: text]!

editCopy
	self model editCopy: editorWorkspace zoneRectangle!

editCut
	self model editCut: editorWorkspace zoneRectangle with: colorSelector selectedRGB!

editPaste
	self model editPaste: editorWorkspace zoneRectangle!

editRedo
	self model editRedo!

editUndo
	self model editUndo!

fillAll: aSymbol
	"A symbol must be the selector of a method in the RGB hierarchy"

	| color |
	color := aSymbol isNil
		ifTrue: [colorSelector selectedRGB]
		ifFalse: [RGB perform: aSymbol].
	self model fill: self model rectangle with: color!

model: anILImage
	"We keep the ILImage passed to here as a backup and use a duplicate for all the editing"

	backupImage := anILImage.
	super model: anILImage editingImage.
	editorWorkspace model: self model.
	self model beNotModified.
	self model
		when: #toolbarChanged
		send: #onToolbarChanged
		to: self.
	imageStatus
		model:
			((self model aspectValue: #imageDescription) aspectTriggers: #imageDescriptionChanged).
	locationStatus
		model:
			((editorWorkspace aspectValue: #locationDescription)
				aspectTriggers: #locationDescriptionChanged).
	zoneStatus
		model:
			((editorWorkspace aspectValue: #zoneDescription) aspectTriggers: #zoneDescriptionChanged).
	zoomStatus
		model:
			((editorWorkspace aspectValue: #zoomDescription) aspectTriggers: #zoomDescriptionChanged).
	modifiedStatus
		model:
			((self model aspectValue: #modifiedDescription)
				aspectTriggers: #modifiedDescriptionChanged)!

onCloseRequested: aValueHolder
	"Only allow the loss of a modified image after confirming"

	self model isModified ifFalse: [^self].
	aValueHolder
		value: (MessageBox confirm: 'This image has been modified. Continue without saving?')!

onPlot: aPoint
	"The only command generated by the editorWorkspace - draw a single pixel"

	self drawPlot: aPoint!

onToolbarChanged
	"Something has changed redarding the edit status (enable/disable cut/copy/paste/undo/redo)
	so we need to ensure that the toolbar reflects this"

	self view invalidateUserInterface!

queryCommand: aCommandQuery
	(#(#drawEllipse #drawFill #drawLineTlBr #drawLineTrBl #drawRectangle #drawText)
		includes: aCommandQuery commandSymbol)
		ifTrue:
			[aCommandQuery isEnabled: editorWorkspace canDraw.
			^true].
	(#(#editCut #editCopy) includes: aCommandQuery commandSymbol)
		ifTrue:
			[aCommandQuery isEnabled: editorWorkspace canDraw.
			^true].
	aCommandQuery commandSymbol = #editPaste
		ifTrue:
			[aCommandQuery isEnabled: self model canPaste & editorWorkspace canDraw.
			^true].
	aCommandQuery commandSymbol == #fillAll:
		ifTrue:
			[aCommandQuery isEnabled: editorWorkspace canFillAll.
			^true].
	aCommandQuery command == #editUndo
		ifTrue:
			[aCommandQuery isEnabled: self model canUndo & editorWorkspace canEdit.
			^true].
	aCommandQuery command == #editRedo
		ifTrue:
			[aCommandQuery isEnabled: self model canRedo & editorWorkspace canEdit.
			^true].
	(#(#reloadImage #replaceImage) includes: aCommandQuery command)
		ifTrue:
			[aCommandQuery isEnabled: self model isModified.
			^true].
	^super queryCommand: aCommandQuery!

reloadImage
	"Reload from the backup we kept of the original image"

	self model: backupImage!

replaceImage
	"Tell the library, or whatever, to replace the image and then restart the editor"

	self model beNotModified.
	self trigger: #replaceImage: with: (backupImage := self model libraryImage)!

selectToolbarGray
	"Select the grey colour used for the toolbar"

	colorSelector selectRGB: RGB toolbarGray!

selectTransparent
	"Select the colour that the ILImage recognises as transparent"

	colorSelector selectRGB: self model transparentColor!

zoom: anInteger
	editorWorkspace zoom: anInteger!

zoomBy: anInteger
	editorWorkspace zoomBy: anInteger! !
!ILEditorShell categoriesFor: #about!commands!public! !
!ILEditorShell categoriesFor: #addImage!commands!public! !
!ILEditorShell categoriesFor: #backcolor:!accessing!public! !
!ILEditorShell categoriesFor: #createComponents!initializing!public! !
!ILEditorShell categoriesFor: #createSchematicWiring!initializing!public! !
!ILEditorShell categoriesFor: #drawEllipse!commands!public! !
!ILEditorShell categoriesFor: #drawFill!commands!public! !
!ILEditorShell categoriesFor: #drawLineTlBr!commands!public! !
!ILEditorShell categoriesFor: #drawLineTrBl!commands!public! !
!ILEditorShell categoriesFor: #drawPlot:!commands!public! !
!ILEditorShell categoriesFor: #drawRectangle!commands!public! !
!ILEditorShell categoriesFor: #drawText!commands!public! !
!ILEditorShell categoriesFor: #editCopy!commands!public! !
!ILEditorShell categoriesFor: #editCut!commands!public! !
!ILEditorShell categoriesFor: #editPaste!commands!public! !
!ILEditorShell categoriesFor: #editRedo!commands!public! !
!ILEditorShell categoriesFor: #editUndo!commands!public! !
!ILEditorShell categoriesFor: #fillAll:!commands!public! !
!ILEditorShell categoriesFor: #model:!accessing!public! !
!ILEditorShell categoriesFor: #onCloseRequested:!event handling!public! !
!ILEditorShell categoriesFor: #onPlot:!event handling!public! !
!ILEditorShell categoriesFor: #onToolbarChanged!event handling!public! !
!ILEditorShell categoriesFor: #queryCommand:!commands!public! !
!ILEditorShell categoriesFor: #reloadImage!commands!public! !
!ILEditorShell categoriesFor: #replaceImage!commands!public! !
!ILEditorShell categoriesFor: #selectToolbarGray!commands!public! !
!ILEditorShell categoriesFor: #selectTransparent!commands!public! !
!ILEditorShell categoriesFor: #zoom:!commands!public! !
!ILEditorShell categoriesFor: #zoomBy:!commands!public! !

MethodHistoryBrowser comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!MethodHistoryBrowser class methodsFor!

showOnClass: aClass selector: aSymbol
	^self show initializeFor: aClass selector: aSymbol! !
!MethodHistoryBrowser class categoriesFor: #showOnClass:selector:!instance creation!public! !

!MethodHistoryBrowser methodsFor!

canPrint
	^(Smalltalk includesKey: #IdePrinter) and: [super canPrint]!

createComponents
	super createComponents.
	selection := self add: NumberPresenter new name: 'selection'.
	source := self add: RichTextPresenter new name: 'source'!

createSchematicWiring
	super createSchematicWiring.
	selection
		when: #valueChanged
		send: #onSelectionChanged
		to: self.
	(SmalltalkSystem current)
		when: #methodAdded:
			send: #onImageChanged:
			to: self;
		when: #methodRemoved:
			send: #onImageChanged:
			to: self!

diff
	DiffBrowser
		compare: (history at: selection value)
		id: 'Version #' , selection value printString
		and: (history at: history size)
		id: 'Current image'!

history: aCollection
	"The historic list is being set for the first time or the method has been edited
	Update the caption and slider then reset the selection to the newest method"

	history := aCollection.
	self
		caption:
			((String writeStream)
				nextPutAll: 'MethodHistory - ';
				nextPutAll: class name;
				nextPutAll: '>>';
				nextPutAll: selector asString;
				nextPutAll: ' (';
				print: history size;
				nextPutAll: ' chunk';
				nextPutAll: (history size > 1 ifTrue: ['s '] ifFalse: [' ']);
				nextPutAll: 'found)';
				contents).
	history size > 1
		ifTrue:
			[(selection view)
				enable;
				range: (1 to: history size);
				ticks: (1 to: history size) asArray]
		ifFalse: [selection view disable].
	selection value: history size!

initializeFor: aClass selector: aSymbol
	"Initialze the list by locating the source for all the historical methods for the
	selected class/selector.
	In addition to the initial opening of the browser this method is called whenever
	the existing method in the image is modified or deleted"

	class := aClass.
	selector := aSymbol.
	self history: (SourceManager default historyOfClass: aClass selector: aSymbol)!

newest
	"Display the newest method definition"

	selection value: history size!

oldest
	"Display the oldest method definition"

	selection value: 1!

onImageChanged: aCompiledMethod
	aCompiledMethod methodClass == class & (aCompiledMethod selector == selector)
		ifTrue: [self initializeFor: class selector: selector]!

onSelectionChanged
	"Private - The selection has been changed so update the source to display the correct method.

	NB  Get the selection value from the model to prevent a problem with Dolphin's 
	#value: event sequence that prevents the value being changed"

	source
		value: (Compiler syntaxColorOfMethod: (history at: selection model value) in: class)!

onViewClosed
	"Private - This is needed to prevent events trying to access this shell
	after it is closed but before it is garbage collected"

	super onViewClosed.
	SmalltalkSystem current removeEventsTriggeredFor: self!

printableView
	^source view!

queryCommand: aCommandQuery
	"Don't allow pointless restore of newest source"

	(#(#newest #oldest) identityIncludes: aCommandQuery commandSymbol)
		ifTrue:
			[aCommandQuery isEnabled: history size > 1.
			^true].
	aCommandQuery command == #print
		ifTrue:
			[aCommandQuery
				isEnabled: self canPrint;
				receiver: self.
			^true].
	aCommandQuery commandSymbol == #diff
		ifTrue:
			[aCommandQuery isEnabled: selection value ~= history size.
			^true].
	^super queryCommand: aCommandQuery!

restoreMethod
	"Restore the selected method. Check for a compilation failure - although it 
	should be obvious, the displayed  method will be in red , we don't want to 
	let this go without a warning. The history browser will be updated by the 
	normal event mechanism"

	(class compile: (history at: selection value)) isNil
		ifTrue: [^MessageBox warning: 'Restore failed']! !
!MethodHistoryBrowser categoriesFor: #canPrint!printing!public!testing! !
!MethodHistoryBrowser categoriesFor: #createComponents!initializing!public! !
!MethodHistoryBrowser categoriesFor: #createSchematicWiring!initializing!public! !
!MethodHistoryBrowser categoriesFor: #diff!commands!public! !
!MethodHistoryBrowser categoriesFor: #history:!operations!public! !
!MethodHistoryBrowser categoriesFor: #initializeFor:selector:!accessing!public! !
!MethodHistoryBrowser categoriesFor: #newest!commands!public! !
!MethodHistoryBrowser categoriesFor: #oldest!commands!public! !
!MethodHistoryBrowser categoriesFor: #onImageChanged:!event handling!public! !
!MethodHistoryBrowser categoriesFor: #onSelectionChanged!event handling!public! !
!MethodHistoryBrowser categoriesFor: #onViewClosed!event handling!public! !
!MethodHistoryBrowser categoriesFor: #printableView!accessing!printing!public! !
!MethodHistoryBrowser categoriesFor: #queryCommand:!commands!public! !
!MethodHistoryBrowser categoriesFor: #restoreMethod!commands!public! !

SerialChat comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!SerialChat class methodsFor!

icon
	^##(self) instanceClass defaultIcon!

initialize
	Smalltalk developmentSystem
		addSamplesFolderIconFor: self
		description: self sampleDescription!

sampleDescription
	^'Serial Chat'!

uninitialize
	Smalltalk developmentSystem removeSystemFolderIconNamed: self sampleDescription! !
!SerialChat class categoriesFor: #icon!constants!public! !
!SerialChat class categoriesFor: #initialize!initializing!public! !
!SerialChat class categoriesFor: #sampleDescription!constants!development!public! !
!SerialChat class categoriesFor: #uninitialize!initializing!public! !

!SerialChat methodsFor!

about
	"Display the about view"

	self
		about:
			'
Serial Chat
for
Dolphin Smalltalk 5.x

Version 5d
 1999-2004 Ian Bartholomew
http://www.idb.me.uk'!

appendText: aString
	display
		value:
			((String writeStream)
				nextPutAll: display value;
				cr;
				nextPutAll: '--\/--';
				cr;
				nextPutAll: aString;
				cr;
				nextPutAll: '--/\--';
				cr;
				contents).
	entry value: String new.
	display view scrollToEnd.
	entry view setFocus!

comPorts
	^#('COM1' 'COM2' 'COM3' 'COM4')!

connect
	serialIO := SerialIO connectTo: comPort selection.
	status
		value:
			((String writeStream)
				nextPutAll: '  Connected to ';
				nextPutAll: comPort selection;
				nextPutAll: ' at ';
				print: Time now;
				nextPutAll: '  (';
				nextPutAll: serialIO connectionParameters;
				nextPut: $);
				contents).
	process := [[| text |
	Processor sleep: 250.
	(text := serialIO read: 50) notEmpty
		ifTrue:
			[display value: display value , text asString.
			display view scrollToEnd]] repeat] fork!

createComponents
	super createComponents.
	comPort := self add: ListPresenter new name: 'comPort'.
	entry := self add: TextPresenter new name: 'entry'.
	display := self add: TextPresenter new name: 'display'!

disconnect
	process notNil
		ifTrue:
			[process terminate.
			process := nil].
	serialIO notNil
		ifTrue:
			[serialIO disconnect.
			serialIO := nil].
	status value: '  Not connected'!

finalize
	self disconnect!

isConnected
	^serialIO notNil!

onViewClosed
	super onViewClosed.
	self disconnect!

onViewOpened
	super onViewOpened.
	self beFinalizable.
	(self view viewNamed: 'status') model: (status := '  Not connected' asValue).
	comPort
		list: self comPorts;
		selection: self comPorts first!

queryCommand: aCommandQuery
	aCommandQuery command == #connect
		ifTrue:
			[aCommandQuery isEnabled: self isConnected not.
			^true].
	(#(#disconnect #send #sendWithCr) identityIncludes: aCommandQuery command)
		ifTrue:
			[aCommandQuery isEnabled: self isConnected.
			^true].
	^super queryCommand: aCommandQuery!

send
	serialIO write: entry value.
	self appendText: entry value!

sendWithCr
	serialIO write: entry value , String lineDelimiter.
	self appendText: entry value! !
!SerialChat categoriesFor: #about!commands!public! !
!SerialChat categoriesFor: #appendText:!helpers!operations!public! !
!SerialChat categoriesFor: #comPorts!constants!public! !
!SerialChat categoriesFor: #connect!commands!public! !
!SerialChat categoriesFor: #createComponents!initializing!public! !
!SerialChat categoriesFor: #disconnect!commands!public! !
!SerialChat categoriesFor: #finalize!finalizing!public! !
!SerialChat categoriesFor: #isConnected!public!testing! !
!SerialChat categoriesFor: #onViewClosed!event handling!public! !
!SerialChat categoriesFor: #onViewOpened!event handling!public! !
!SerialChat categoriesFor: #queryCommand:!commands!public! !
!SerialChat categoriesFor: #send!commands!public! !
!SerialChat categoriesFor: #sendWithCr!commands!public! !

ChunkBrowser comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ChunkBrowser class methodsFor!

chunkTypeSelection
	ChunkTypeSelection ifNil: [ChunkTypeSelection := self defaultChunkTypeSelection].
	^ChunkTypeSelection!

chunkTypeSelection: aLookupTable
	ChunkTypeSelection := aLookupTable!

compareMethodsUsingParser
	CompareMethodsUsingParser
		ifNil: [CompareMethodsUsingParser := self defaultCompareMethodsUsingParser].
	^CompareMethodsUsingParser!

compareMethodsUsingParser: aBoolean
	CompareMethodsUsingParser := aBoolean!

comparisonSelection
	ComparisonSelection ifNil: [ComparisonSelection := self defaultComparisonSelection].
	^ComparisonSelection!

comparisonSelection: aLookupTable
	ComparisonSelection := aLookupTable!

defaultChunkTypeSelection
	^(LookupTable new)
		at: #'Class Category' put: false;
		at: #'Class Define' put: true;
		at: #'Class Delete' put: true;
		at: #'Class Comment' put: false;
		at: #'Class GUID' put: false;
		at: #'Class Protocol' put: false;
		at: #'Class Resource' put: true;
		at: #'Method Category' put: false;
		at: #'Method Define' put: true;
		at: #'Method Delete' put: true;
		at: #'Resource Define' put: true;
		at: #'Resource Delete' put: true;
		at: #System put: true;
		at: #Other put: false;
		yourself!

defaultCompareMethodsUsingParser
	^true!

defaultComparisonSelection
	^(LookupTable new)
		at: #Match put: true;
		at: #Differ put: true;
		at: #Missing put: true;
		yourself!

defaultModel
	^ChunkBrowserModel new!

displayOn: aStream
	aStream nextPutAll: 'Chunk Browser'!

fileTypes
	"Answer an Array of file types that can be associated with this
	class of document."

	^(OrderedCollection new)
		add: #('Change Files (*.chg)' '*.chg');
		add: #('Class Files (*.cls)' '*.cls');
		add: #('Smalltalk Files (*.st)' '*.st');
		add: #('Package Files (*.pac)' '*.pac');
		add: #('Multi-File Package Files (*.pax)' '*.pax');
		add: #('Image Source Files (*.sml)' '*.sml');
		add: #('All Files (*.*)' '*.*');
		yourself!

icon
	"Answers an Icon that can be used to represent this class"

	^##(self) instanceClass defaultIcon!

publishedAspects
	^(super publishedAspects)
		add: (Aspect dictionary: #chunkTypeSelection);
		add: (Aspect dictionary: #comparisonSelection);
		add: (Aspect boolean: #compareMethodsUsingParser);
		yourself! !
!ChunkBrowser class categoriesFor: #chunkTypeSelection!accessing!public! !
!ChunkBrowser class categoriesFor: #chunkTypeSelection:!accessing!public! !
!ChunkBrowser class categoriesFor: #compareMethodsUsingParser!accessing!public! !
!ChunkBrowser class categoriesFor: #compareMethodsUsingParser:!accessing!public! !
!ChunkBrowser class categoriesFor: #comparisonSelection!accessing!public! !
!ChunkBrowser class categoriesFor: #comparisonSelection:!accessing!public! !
!ChunkBrowser class categoriesFor: #defaultChunkTypeSelection!constants!public! !
!ChunkBrowser class categoriesFor: #defaultCompareMethodsUsingParser!constants!public! !
!ChunkBrowser class categoriesFor: #defaultComparisonSelection!constants!public! !
!ChunkBrowser class categoriesFor: #defaultModel!constants!public! !
!ChunkBrowser class categoriesFor: #displayOn:!operations!public! !
!ChunkBrowser class categoriesFor: #fileTypes!constants!public! !
!ChunkBrowser class categoriesFor: #icon!constants!public! !
!ChunkBrowser class categoriesFor: #publishedAspects!constants!public! !

!ChunkBrowser methodsFor!

about
	"Display the about view"

	self
		about:
			'
Chunk Browser
for
Dolphin Smalltalk 5.x

Version 5l
 1997-2004 Ian Bartholomew
http://www.idb.me.uk'!

browseChunk
	chunkList singleSelection browse!

canBrowse
	^chunkList hasSingleSelection and: [chunkList singleSelection canBrowse]!

canPrint
	^(Smalltalk includesKey: #IdePrinter) and: [super canPrint]!

canShowDifferences
	^(chunkList hasSingleSelection and: [chunkList singleSelection canShowDifferences])
		or: [chunkList selection size = 2]!

clearStatusReport
	(self presenterNamed: 'statusReport') value: String new!

copyText
	Clipboard current
		setText:
			(chunkText hasSelection
				ifTrue: [chunkText view selectionRichText]
				ifFalse: [chunkText view text])
		format: #RichText!

createComponents
	super createComponents.
	chunkList := self add: MultipleSelectionListPresenter new name: 'chunkList'.
	chunkText := self add: RichTextPresenter new name: 'chunkText'.
	self add: TextPresenter new name: 'statusCount'.
	self add: TextPresenter new name: 'statusRange'.
	self add: TextPresenter new name: 'statusFinal'.
	self add: TextPresenter new name: 'statusReport'!

createSchematicWiring
	super createSchematicWiring.
	chunkList
		when: #selectionChanged
			send: #onSelectionChanged
			to: self;
		when: #actionPerformed
			send: #onActionPerformed
			to: self!

differences
	chunkList hasSingleSelection
		ifTrue:
			[DiffBrowser
				compare: chunkList singleSelection sourceText
				id: 'Current image'
				and: chunkList singleSelection chunkText
				id: 'Chunk #' , chunkList singleSelection index printString]
		ifFalse:
			[DiffBrowser
				compare: chunkList selection first chunkText
				id: 'Chunk #' , chunkList selection first index printString
				and: chunkList selection last chunkText
				id: 'Chunk #' , chunkList selection last index printString]!

fileOpen
	| dialog |
	pathname ifNil: [pathname := SourceManager default changesFileName].
	dialog := FileOpenDialog on: pathname.
	(dialog
		fileTypes: self class fileTypes;
		defaultExtension: (File splitExtensionFrom: pathname);
		showModal) ifNil: [^self] ifNotNil: [:arg | pathname := arg].
	Cursor wait
		showWhile:
			[self model fileOpen: pathname.
			chunkList selectionOrNil: nil.
			self updateChunkList].
	self caption: 'ChunkBrowser - ' , (File splitFilenameFrom: pathname)!

fileOpenPatch
	| dialog |
	dialog := FileOpenDialog on: '*.st'.
	(dialog
		fileTypes:
				(OrderedCollection
						with: #('Smalltalk Files (*.st)' '*.st')
						with: #('All Files (*.*)' '*.*'));
		defaultExtension: 'st';
		showModal) ifNil: [^self] ifNotNil: [:arg | pathname := arg].
	Cursor wait
		showWhile:
			[self model fileOpenPatch: pathname.
			chunkList selectionOrNil: nil.
			self updateChunkList].
	self caption: 'ChunkBrowser - ' , (File splitFilenameFrom: pathname)!

lastOnly
	lastOnly := lastOnly not.
	self updateChunkList!

onActionPerformed
	chunkList selection do: [:each | each picked: each picked not].
	self onRefreshNeeded!

onRefreshNeeded
	chunkList view updateAll.
	chunkList hasSingleSelection
		ifTrue: [chunkText value: chunkList singleSelection chunkText]!

onSelectionChanged
	compareSource
		ifTrue:
			[chunkText view backcolor: Color dolphinWorkspace.
			compareSource := false].
	chunkText
		value:
			(chunkList hasSingleSelection
				ifTrue: [chunkList singleSelection chunkText]
				ifFalse: [String new]).
	self clearStatusReport!

onTipTextRequired: aToolbarButton
	| command |
	command := aToolbarButton command asSymbol.
	command = #toggleInclusionOfChunkType:
		ifTrue:
			[| argument |
			argument := aToolbarButton command arguments first.
			^(chunkTypeSelection at: argument)
				ifTrue: ['Hide ' , argument]
				ifFalse: ['Show ' , argument]].
	command = #toggleComparison:
		ifTrue:
			[| argument |
			argument := aToolbarButton command arguments first.
			^(comparisonSelection at: argument)
				ifTrue: ['Hide ' , argument]
				ifFalse: ['Show ' , argument]].
	command = #selectRange
		ifTrue:
			[chunkRange ifNotNil: [:arg | ^'Remove range limitation'].
			chunkList hasSelection ifFalse: [^'Set range limit - last image save to final chunk'].
			chunkList hasSingleSelection
				ifTrue: [^'Set range limit - selected chunk to final chunk'].
			^'Set range limit - earliest to latest selected chunk'].
	command = #selectAllOrDefault
		ifTrue:
			[self shouldSelectAll ifTrue: [^'Select all chunk types'].
			^'Select default chunk types'].
	command = #lastOnly
		ifTrue:
			[^lastOnly ifTrue: ['Remove last chunk limitation'] ifFalse: ['Limit to final chunk only']].
	command = #differences
		ifTrue:
			[self canShowDifferences ifFalse: [^'Show differences'].
			^chunkList hasSingleSelection
				ifTrue: ['Show differences between image and selected chunk']
				ifFalse: ['Show differences between selected chunks']].
	^super onTipTextRequired: aToolbarButton!

onViewClosed
	super onViewClosed.
	SmalltalkSystem current removeEventsTriggeredFor: self.
	SessionManager current resourceManager removeEventsTriggeredFor: self!

onViewOpened
	super onViewOpened.
	self setDefault.
	SmalltalkSystem publishedEventsOfInstances
		do:
			[:each | 
			SmalltalkSystem current
				when: each
				send: #onRefreshNeeded
				to: self].
	ResourceManager publishedEventsOfInstances
		do:
			[:each | 
			SessionManager current resourceManager
				when: each
				send: #onRefreshNeeded
				to: self]!

pickSelection
	chunkList selectionByIndex
		do:
			[:index | 
			(chunkList model at: index) picked
				ifFalse:
					[(chunkList model at: index) picked: true.
					chunkList model updateAtIndex: index]]!

printableView
	^chunkText view!

queryCommand: aCommandQuery
	aCommandQuery commandSymbol == #toggleInclusionOfChunkType:
		ifTrue:
			[| argument |
			aCommandQuery isEnabled: true.
			argument := aCommandQuery commandDescription command arguments first.
			aCommandQuery isChecked: (chunkTypeSelection at: argument).
			^true].
	aCommandQuery commandSymbol == #toggleComparison:
		ifTrue:
			[| argument |
			aCommandQuery isEnabled: true.
			argument := aCommandQuery commandDescription command arguments first.
			aCommandQuery isChecked: (comparisonSelection at: argument).
			^true].
	aCommandQuery commandSymbol == #selectAllOrDefault
		ifTrue:
			[aCommandQuery
				isEnabled: true;
				text: (self shouldSelectAll ifTrue: ['&Select all'] ifFalse: ['&Select default']).
			^true].
	aCommandQuery commandSymbol == #differences
		ifTrue:
			[aCommandQuery isEnabled: self canShowDifferences.
			^true].
	aCommandQuery commandSymbol == #selectRange
		ifTrue:
			[aCommandQuery
				isEnabled: self model hasChunks;
				isChecked: chunkRange notNil.
			^true].
	aCommandQuery commandSymbol == #lastOnly
		ifTrue:
			[aCommandQuery
				isEnabled: self model hasChunks;
				isChecked: lastOnly.
			^true].
	aCommandQuery commandSymbol == #copyText
		ifTrue:
			[aCommandQuery isEnabled: chunkList hasSingleSelection.
			^true].
	aCommandQuery commandSymbol == #browseChunk
		ifTrue:
			[aCommandQuery isEnabled: self canBrowse.
			^true].
	(#(#print #printPreview) identityIncludes: aCommandQuery command)
		ifTrue:
			[aCommandQuery isEnabled: self canPrint.
			^true].
	(#(#pickSelection #unpickSelection #restoreSelection)
		identityIncludes: aCommandQuery command)
		ifTrue:
			[aCommandQuery isEnabled: chunkList hasSelection.
			^true].
	aCommandQuery commandSymbol == #restorePicked
		ifTrue:
			[aCommandQuery isEnabled: self model hasAnyChunksPicked.
			^true].
	^super queryCommand: aCommandQuery!

restore: aCollection 
	| failures stream |
	failures := OrderedCollection new.
	aCollection do: [:each | each restore ifNotNil: [:arg | failures add: arg]].
	stream := String writeStream.
	(self presenterNamed: 'statusReport') value: (failures isEmpty 
				ifTrue: ['  Restore suceeded']
				ifFalse: ['  Restore may have failed']).
	failures isEmpty 
		ifFalse: 
			[stream
				nextPutAll: 'The following chunks may have failed to restore:';
				cr;
				cr.
			(failures copyFrom: 1 to: (10 min: failures size)) do: 
					[:each | 
					stream
						print: each key;
						space;
						nextPutAll: each value;
						cr].
			failures size > 10 
				ifTrue: 
					[stream
						nextPutAll: '.... and ';
						print: failures size - 10;
						nextPutAll: ' more'].
			MessageBox notify: stream contents caption: 'Restore may have failed']!

restorePicked
	self restore: self model pickedChunks!

restoreSelection
	self restore: chunkList selection!

selectAllOrDefault
	"Leave all other settings alone"

	self shouldSelectAll
		ifTrue:
			[chunkTypeSelection := self class chunkTypeSelection copy.
			chunkTypeSelection keysDo: [:each | chunkTypeSelection at: each put: true]]
		ifFalse: [chunkTypeSelection := self class chunkTypeSelection copy].
	self updateChunkList!

selectNone
	"Leave all other settings alone"

	chunkTypeSelection atAll: chunkTypeSelection keys put: false.
	self updateChunkList!

selectRange
	chunkRange := chunkRange
		ifNil:
			[| first last |
			chunkList hasSelection
				ifTrue:
					[first := 99999999.
					last := 0.
					chunkList selection
						do:
							[:each | 
							first := first min: each index.
							last := last max: each index]]
				ifFalse: [first := last := self model indexOfLastImageSave].
			first = last ifTrue: [last := self model chunkCount].
			chunkList selectionOrNil: nil.
			first to: last]
		ifNotNil: [:arg | ].
	self updateChunkList!

setDefault
	chunkTypeSelection := self class chunkTypeSelection copy.
	comparisonSelection := self class comparisonSelection copy.
	chunkRange := nil.
	lastOnly := false.
	compareSource := false!

shouldSelectAll
	| default |
	default := self class chunkTypeSelection.
	^chunkTypeSelection keys
		allSatisfy: [:each | (chunkTypeSelection at: each) = (default at: each)]!

toggleComparison: aSymbol
	comparisonSelection at: aSymbol put: (comparisonSelection at: aSymbol) not.
	self updateChunkList!

toggleInclusionOfChunkType: aSymbol
	chunkTypeSelection at: aSymbol put: (chunkTypeSelection at: aSymbol) not.
	self updateChunkList!

unpickAll
	chunkList model
		keysAndValuesDo:
			[:index :each | 
			each picked
				ifTrue:
					[each picked: false.
					chunkList model updateAtIndex: index]]!

unpickSelection
	chunkList selectionByIndex
		do:
			[:index | 
			(chunkList model at: index) picked
				ifTrue:
					[(chunkList model at: index) picked: false.
					chunkList model updateAtIndex: index]]!

updateChunkList
	| currentSelection |
	currentSelection := chunkList selectionOrNil.
	chunkList
		list:
			(self model
				selectChunks:
					(chunkTypeSelection keys select: [:each | chunkTypeSelection at: each]) asSet
				missing: (comparisonSelection at: #Missing)
				match: (comparisonSelection at: #Match)
				differ: (comparisonSelection at: #Differ)
				range: chunkRange
				last: lastOnly).
	currentSelection
		ifNotNil:
			[:arg | 
			chunkList selectionOrNil: (arg select: [:each | chunkList list identityIncludes: each]).
			chunkList view ensureSelectionVisible].
	self onSelectionChanged.
	self updateStatus!

updateStatus
	(self presenterNamed: 'statusCount')
		value:
			((String writeStream)
				nextPutAll: '  Showing: ';
				print: chunkList list size;
				nextPutAll: ' of ';
				print:
						(chunkRange ifNil: [model chunkCount] ifNotNil: [:arg | arg last - arg first + 1]);
				contents).
	(self presenterNamed: 'statusRange')
		value:
			(chunkRange
				ifNil: [String new]
				ifNotNil:
					[:arg | 
					(String writeStream)
						nextPutAll: '  Range: ';
						print: arg first;
						nextPutAll: ' to ';
						print: arg last;
						contents]).
	(self presenterNamed: 'statusFinal')
		value: (lastOnly ifTrue: [' Final'] ifFalse: [String new]).
	self clearStatusReport! !
!ChunkBrowser categoriesFor: #about!commands!enquiries!public! !
!ChunkBrowser categoriesFor: #browseChunk!commands!public!testing! !
!ChunkBrowser categoriesFor: #canBrowse!public!testing! !
!ChunkBrowser categoriesFor: #canPrint!printing!public!testing! !
!ChunkBrowser categoriesFor: #canShowDifferences!public!testing! !
!ChunkBrowser categoriesFor: #clearStatusReport!helpers!public! !
!ChunkBrowser categoriesFor: #copyText!commands!public! !
!ChunkBrowser categoriesFor: #createComponents!initializing!public! !
!ChunkBrowser categoriesFor: #createSchematicWiring!initializing!public! !
!ChunkBrowser categoriesFor: #differences!commands!public! !
!ChunkBrowser categoriesFor: #fileOpen!commands!public! !
!ChunkBrowser categoriesFor: #fileOpenPatch!commands!public! !
!ChunkBrowser categoriesFor: #lastOnly!commands!public! !
!ChunkBrowser categoriesFor: #onActionPerformed!event handling!public! !
!ChunkBrowser categoriesFor: #onRefreshNeeded!event handling!public! !
!ChunkBrowser categoriesFor: #onSelectionChanged!event handling!public! !
!ChunkBrowser categoriesFor: #onTipTextRequired:!event handling!public! !
!ChunkBrowser categoriesFor: #onViewClosed!event handling!public! !
!ChunkBrowser categoriesFor: #onViewOpened!event handling!public! !
!ChunkBrowser categoriesFor: #pickSelection!commands!public! !
!ChunkBrowser categoriesFor: #printableView!accessing!printing!public! !
!ChunkBrowser categoriesFor: #queryCommand:!commands!public! !
!ChunkBrowser categoriesFor: #restore:!commands!public! !
!ChunkBrowser categoriesFor: #restorePicked!commands!public! !
!ChunkBrowser categoriesFor: #restoreSelection!commands!public! !
!ChunkBrowser categoriesFor: #selectAllOrDefault!commands!public! !
!ChunkBrowser categoriesFor: #selectNone!commands!public! !
!ChunkBrowser categoriesFor: #selectRange!commands!public! !
!ChunkBrowser categoriesFor: #setDefault!helpers!public! !
!ChunkBrowser categoriesFor: #shouldSelectAll!public!testing! !
!ChunkBrowser categoriesFor: #toggleComparison:!commands!public! !
!ChunkBrowser categoriesFor: #toggleInclusionOfChunkType:!commands!public! !
!ChunkBrowser categoriesFor: #unpickAll!commands!public! !
!ChunkBrowser categoriesFor: #unpickSelection!commands!public! !
!ChunkBrowser categoriesFor: #updateChunkList!operations!public! !
!ChunkBrowser categoriesFor: #updateStatus!helpers!public! !

DiffBrowser comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!DiffBrowser class methodsFor!

compare: upperText id: upperId and: lowerText id: lowerId
	self show
		compare: upperText
		id: upperId
		and: lowerText
		id: lowerId!

displayOn: aStream
	aStream nextPutAll: 'Difference Browser'!

icon
	"Answers an Icon that can be used to represent this class"

	^##(self) instanceClass defaultIcon! !
!DiffBrowser class categoriesFor: #compare:id:and:id:!instance creation!public! !
!DiffBrowser class categoriesFor: #displayOn:!operations!public! !
!DiffBrowser class categoriesFor: #icon!constants!public! !

!DiffBrowser methodsFor!

about
	"Display the about view"

	self
		about:
			'
Difference Browser
for
Dolphin Smalltalk 5.x

Version 5e
 2002-2004 Ian Bartholomew
http://www.idb.me.uk'!

character
	diffP mode: #character!

compare: upperString id: upperIdString and: lowerString id: lowerIdString
	diffP
		upperText: upperString asString id: upperIdString;
		lowerText: lowerString asString id: lowerIdString!

createComponents
	super createComponents.
	diffP := self add: DiffPresenter new name: 'diff'!

horizontal
	diffP vertical: false!

line
	diffP mode: #line!

queryCommand: aCommandQuery
	(#(#character #word #line) identityIncludes: aCommandQuery command)
		ifTrue:
			[aCommandQuery
				isEnabled: true;
				isChecked: (diffP isMode: aCommandQuery command).
			^true].
	(#(#vertical #horizontal) identityIncludes: aCommandQuery command)
		ifTrue:
			[aCommandQuery
				isEnabled: true;
				isChecked:
						(aCommandQuery command == #vertical
								ifTrue: [diffP isVertical]
								ifFalse: [diffP isVertical not]).
			^true].
	^super queryCommand: aCommandQuery!

readTextFrom: filename
	| stream |
	stream := FileStream read: filename.
	[^stream contents] ensure: [stream close]!

selectLower
	FileOpenDialog showModal
		ifNotNil: [:arg | diffP lowerText: (self readTextFrom: arg) id: arg]!

selectUpper
	FileOpenDialog showModal
		ifNotNil: [:arg | diffP upperText: (self readTextFrom: arg) id: arg]!

vertical
	diffP vertical: true!

word
	diffP mode: #word! !
!DiffBrowser categoriesFor: #about!commands!public! !
!DiffBrowser categoriesFor: #character!commands!public! !
!DiffBrowser categoriesFor: #compare:id:and:id:!operations!public! !
!DiffBrowser categoriesFor: #createComponents!initializing!public! !
!DiffBrowser categoriesFor: #horizontal!commands!public! !
!DiffBrowser categoriesFor: #line!commands!public! !
!DiffBrowser categoriesFor: #queryCommand:!commands!public! !
!DiffBrowser categoriesFor: #readTextFrom:!helpers!public! !
!DiffBrowser categoriesFor: #selectLower!commands!public! !
!DiffBrowser categoriesFor: #selectUpper!commands!public! !
!DiffBrowser categoriesFor: #vertical!commands!public! !
!DiffBrowser categoriesFor: #word!commands!public! !

FileBrowser comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!FileBrowser class methodsFor!

defaultFolder
	^SessionManager current imageBase!

displayOn: aStream
	aStream nextPutAll: 'File Browser'!

hexEnabled
	"Answer whether the hex display is enabled"

	HexEnabled isNil ifTrue: [^false].
	^HexEnabled!

hexEnabled: aBoolean
	"Set whether the hex display is enabled"

	HexEnabled := aBoolean!

hexFont
	"Answer the font used for the hex view"

	HexFont isNil ifTrue: [^Font name: 'Courier New' pointSize: 10].
	^HexFont!

hexFont: aFont
	"Set the font used for the hex view"

	HexFont := aFont!

icon
	"Answers an Icon that can be used to represent this class"

	^##(self) instanceClass defaultIcon!

publishedAspects
	"Answer a Set of the aspects published by  instances of the receiver"

	| aspects |
	aspects := super publishedAspects.
	aspects
		add: (Aspect font: #textFont);
		add: (Aspect font: #hexFont);
		add: (Aspect folder: #rootFolder);
		add: (Aspect boolean: #hexEnabled);
		add: (Aspect boolean: #removeCr);
		add: (Aspect boolean: #warnings).
	^aspects!

removeCr
	"Answer whether we reove Crs before saving"

	RemoveCr isNil ifTrue: [^false].
	^RemoveCr!

removeCr: aBoolean
	"Set whether we remove Crs when saving"

	RemoveCr := aBoolean!

rootFolder
	"Answer the name of the root folder in the tree"

	RootFolder isNil ifTrue: [^self defaultFolder].
	^RootFolder!

rootFolder: aString
	"Set the name of the root folder in the tree"

	RootFolder := aString!

textFont
	"Answer the font used for the text view"

	TextFont isNil ifTrue: [^Font name: 'Times New Roman' pointSize: 12].
	^TextFont!

textFont: aFont
	"Set the font used for the text view"

	TextFont := aFont!

warnings
	"Answer whether warnings are enabled"

	Warnings isNil ifTrue: [^true].
	^Warnings!

warnings: aBoolean
	"Set whether warnings are enabled"

	Warnings := aBoolean! !
!FileBrowser class categoriesFor: #defaultFolder!accessing!public! !
!FileBrowser class categoriesFor: #displayOn:!operations!public! !
!FileBrowser class categoriesFor: #hexEnabled!accessing!public! !
!FileBrowser class categoriesFor: #hexEnabled:!accessing!public! !
!FileBrowser class categoriesFor: #hexFont!accessing!public! !
!FileBrowser class categoriesFor: #hexFont:!accessing!public! !
!FileBrowser class categoriesFor: #icon!constants!public! !
!FileBrowser class categoriesFor: #publishedAspects!initializing!public! !
!FileBrowser class categoriesFor: #removeCr!accessing!public! !
!FileBrowser class categoriesFor: #removeCr:!accessing!public! !
!FileBrowser class categoriesFor: #rootFolder!accessing!public! !
!FileBrowser class categoriesFor: #rootFolder:!accessing!public! !
!FileBrowser class categoriesFor: #textFont!accessing!public! !
!FileBrowser class categoriesFor: #textFont:!accessing!public! !
!FileBrowser class categoriesFor: #warnings!accessing!public! !
!FileBrowser class categoriesFor: #warnings:!accessing!public! !

!FileBrowser methodsFor!

about
	"Display the about view"

	self
		about:
			'
File Browser
for
Dolphin Smalltalk 5.x

Version 5d
 1999-2004 Ian Bartholomew
http://www.idb.me.uk'!

askAboutHex: anInteger
	"Give the chance to turn off hex if the option is on and the file size greater than 50000"

	anInteger < 50000 ifTrue: [^true].
	(MessageBox
		confirm:
			'The hex option is on and the selected file is ' , (anInteger // 1024) printString
				,
					' KB in size.
This may take a little time to render.
Do you want to turn the hex option off before continuing?') ifTrue: [hexEnabled := false].
	^hexEnabled!

canFileIn
	"Answers true if a file is selected and it's extension is st or cls"

	^files hasSelection and: [files selection isChunkFile]!

canPrint
	^(Smalltalk includesKey: #IdePrinter)
		and:
			[(text view == self printableView or: [hex view == self printableView])
				and: [super canPrint]]!

clearTabs
	"Empty all the tab pages"

	text text: String new.
	hex text: String new.
	image value: nil.
	html value: 'about:blank'!

createComponents
	"Private - Create the presenters contained by the receiver"

	super createComponents.
	folders := self add: TreePresenter new name: 'folders'.
	files := self add: ListPresenter new name: 'files'.
	text := self add: SmalltalkWorkspace new name: 'text'.
	hex := self add: SmalltalkWorkspace new name: 'hex'.
	image := self add: ImagePresenter new name: 'image'.
	html := self add: URLPresenter new name: 'html'!

createSchematicWiring
	"Private - Create the trigger wiring for the receiver"

	super createSchematicWiring.
	self
		when: #closeRequested:
		send: #onCloseRequested:
		to: self.
	folders
		when: #selectionChanged
		send: #onFolderSelectionChanged
		to: self.
	folders
		when: #selectionChanging:
		send: #onSelectionChanging:
		to: self.
	files
		when: #selectionChanged
		send: #onFileSelectionChanged
		to: self.
	files
		when: #selectionChanging:
		send: #onSelectionChanging:
		to: self.
	text
		when: #keyEvent:
		send: #onKeyEvent:
		to: self.
	SessionManager current
		when: #sessionStarted
		send: #onSessionStarted
		to: self!

enableHex
	"Enable the creation of the Hex text. This can be quite slow for larger files"

	hexEnabled := hexEnabled not.
	self updateFilesKeepingSelection!

fileDelete
	"Delete the selected file. If warnings are enable we have to confirm this operation"

	files hasSelection ifFalse: [^self].
	self class warnings
		ifTrue:
			[(MessageBox
				confirm:
					files selection path
						,
							' will be deleted.
OK to continue?') ifFalse: [^self]].
	File delete: files selection path.
	self onFolderSelectionChanged!

fileIn
	"Only enabled for chunk (st and cls) files. Loads the file into the image"

	self class sourceManager fileIn: files selection path!

fileNew
	"Just clear any selected file and make sure the text views are cleared 
	to allow a new file to be created. Check for a modified text view first"

	self promptForChanges ifTrue: [^self].
	files selectionOrNil: nil.
	self clearTabs!

fileOpen
	"Change the root folder displayed in the tree - nothing to do with files really.
	Check for modified files first as if we allow the normal check on a folder changing
	the tree seems to get confused. It's best to do it before the folder dialog anyway.
	Make the root folder sticky across image saves"

	| root rootName |
	self promptForChanges ifTrue: [^self].
	(rootName := BrowseFolderDialog showModal) isNil ifTrue: [^self].	"Can't just add this as the path may already end in \ e.g. c:\"
	rootName last = $\ ifFalse: [rootName := rootName , '\'].
	folders model roots: (Array with: (root := FileBrowserFolder name: rootName parent: nil)).
	folders selection: root.
	currentRootFolder := rootName!

fileSave
	"Save any changes to the file"

	files hasSelection ifFalse: [^self fileSaveAs].
	self saveFile: files selection path.
	self updateFilesKeepingSelection!

fileSaveAs
	"Save any changes to the text view in a new file"

	| pathname |
	pathname := folders hasSelection
		ifTrue: [FileSaveDialog showModalOn: folders selection searchPath]
		ifFalse: [FileSaveDialog showModal].
	pathname isNil ifTrue: [^self].
	self saveFile: pathname.
	self updateFilesKeepingSelection!

macroPlayback
	"Playback the last recorded keyboard macro. This appears to work, and is part of
	the Windows API, but I remain unconvinced it will work in all circumstances.
	Control key combinations and Function keys are known not to work, there may be others?"

	macro
		do:
			[:each | 
			| flag |
			flag := each isExtended ifTrue: [1] ifFalse: [0].
			each isAlreadyDown
				ifTrue:
					["i.e. auto repeat so signal a key up first"
					UserLibrary default
						keybdEvent: each code
						bScan: each scanCode
						dwFlags: (flag bitOr: 2)
						dwExtraInfo: 0].
			UserLibrary default
				keybdEvent: each code
				bScan: each scanCode
				dwFlags: (flag bitOr: (each isBeingReleased ifTrue: [2] ifFalse: [0]))
				dwExtraInfo: 0]!

macroStartRecord
	"Set the flag to indicate we are now recording a macro"

	macro := OrderedCollection new.
	isMacroRecording := true.
	lastMacroKey := nil!

macroStopRecord
	"Finished recording a macro so reset the flag"

	isMacroRecording := false!

onCloseRequested: aValueHolder
	"The shell is about to be closed. Check for any changes before allowing this"

	self promptForChanges
		ifFalse:
			[SessionManager current removeEventsTriggeredFor: self.
			^self].
	aValueHolder value: false!

onFileSelectionChanged
	"The file selection has changed so update the text views and the caption"

	| newCaption rawText |
	files hasSelection
		ifTrue:
			[| fileStream |
			fileStream := FileStream read: files selection path.
			[rawText := fileStream contents] ensure: [fileStream close].
			text text: rawText.
			self setImage: files selection.
			self setHTML: files selection.
			newCaption := files selection path]
		ifFalse:
			[self clearTabs.
			newCaption := String new].
	(hexEnabled and: [rawText notNil and: [rawText notEmpty]])
		ifTrue:
			[(self askAboutHex: rawText size)
				ifTrue: [Cursor wait showWhile: [hex text: rawText asHexText]]
				ifFalse: [hex text: String new]]
		ifFalse: [hex text: String new].
	self caption: 'File Browser - ' , newCaption!

onFolderSelectionChanged
	"The folder selection has changed so update the file list. We have to make sure that
	the text views are cleared as well as the #onFileSelectionChanged method is not 
	automatically called"

	files
		list:
			(folders hasSelection ifTrue: [folders selection files] ifFalse: [OrderedCollection new]).
	files view layout.
	self clearTabs!

onKeyEvent: aKeyEvent
	"Comes here whenever a key is pressed in the text view.
	 If we are recording a macro then remember the keypress"

	isMacroRecording ifFalse: [^self].	"If the last key was a control down and this is another key being released
	then assume that there was a key depression that was missed and insert it"
	(lastMacroKey notNil and: [lastMacroKey == VK_CONTROL])
		ifTrue:
			[aKeyEvent isBeingReleased
				ifTrue:
					[macro
						addLast:
							(KeyEvent
								message: aKeyEvent message
								handle: aKeyEvent hwnd
								wParam: aKeyEvent wParam
								lParam: (aKeyEvent lParam bitAnd: 2147483647))]].
	lastMacroKey := aKeyEvent code.	"Swap F4 for F3 so that find next can be used (with F4)"
	lastMacroKey == VK_F4
		ifTrue:
			[| scanCode |
			scanCode := (Keyboard vKeyToScanCode: VK_F3) bitShift: 16.
			macro
				addLast:
					(KeyEvent
						message: aKeyEvent message
						handle: aKeyEvent hwnd
						wParam: VK_F3
						lParam: ((aKeyEvent lParam bitAnd: 4278255615) bitOr: scanCode))]
		ifFalse: [macro addLast: aKeyEvent]!

onSelectionChanging: aValueHolder
	"A selection, either the folder or the file, is changing so check to see if there have been any 
	modifications to the text view before allowing the change"

	self promptForChanges ifFalse: [^self].
	aValueHolder value: false!

onSessionStarted
	"A new session has been started with the FileBrowser open so make sure it is consistent"

	isMacroRecording := false.
	macro := OrderedCollection new.
	currentRootFolder isNil ifTrue: [currentRootFolder := self class rootFolder].
	(File exists: currentRootFolder) ifFalse: [currentRootFolder := self class defaultFolder].
	folders
		model:
			(VirtualTreeModel
				withRoots: (Array with: (FileBrowserFolder name: currentRootFolder parent: nil)))!

onViewOpened
	"The view has opened. Get the initial values from the class variables. These can be
	set in the DolphinOptions folder"

	super onViewOpened.
	isMacroRecording := false.
	macro := OrderedCollection new.
	hexEnabled := self class hexEnabled.
	removeCr := self class removeCr.
	text view font: self class textFont.
	hex view font: self class hexFont.
	folders
		model:
			(VirtualTreeModel
				withRoots: (Array with: (FileBrowserFolder name: self class rootFolder parent: nil))).
	showImageAs := #scaleToFit!

printableView
	^(self view viewNamed: 'cards') currentCard view!

promptForChanges
	"If warnings are enabled and if the text view has been modified ask for confirmation.
	Answer false if we can continue, possibly losing changed text or true if we want to allow
	the text to be saved. We have to reset the isModified flag to prevent multiple prompts and
	we might as well clear the text pane to prevent confusion"

	| answer |
	self class warnings ifFalse: [^false].
	text isModified ifFalse: [^false].
	(answer := MessageBox
		confirm:
			'There are unsaved changes.
Do you want to retain them?')
		ifFalse:
			[text
				text: String new;
				isModified: false].
	^answer!

queryCommand: aCommandQuery
	"Enters details about a potential command for the receiver into aCommandQuery"

	(#(#fileSave #fileDelete) includes: aCommandQuery command)
		ifTrue:
			[aCommandQuery isEnabled: files hasSelection.
			^true].
	#enableHex == aCommandQuery command
		ifTrue:
			[aCommandQuery
				isEnabled: true;
				isChecked: hexEnabled.
			^true].
	#removeCr == aCommandQuery command
		ifTrue:
			[aCommandQuery
				isEnabled: true;
				isChecked: removeCr.
			^true].
	#fileIn == aCommandQuery command
		ifTrue:
			[aCommandQuery isEnabled: self canFileIn.
			^true].
	#macroStopRecord == aCommandQuery command
		ifTrue:
			[aCommandQuery isEnabled: isMacroRecording.
			^true].
	#macroStartRecord == aCommandQuery command
		ifTrue:
			[aCommandQuery isEnabled: isMacroRecording not.
			^true].
	#macroPlayback == aCommandQuery command
		ifTrue:
			[aCommandQuery isEnabled: isMacroRecording not & macro notEmpty.
			^true].
	(#(#print #printPreview) identityIncludes: aCommandQuery command)
		ifTrue:
			[aCommandQuery isEnabled: self canPrint.
			^true].
	^super queryCommand: aCommandQuery!

removeCr
	"Toggle whether we remove Crs on saving"

	removeCr := removeCr not!

saveFile: pathname
	"Save the file after stripping crs if required"

	| fileStream rawText |
	rawText := text plainText.
	removeCr ifTrue: [rawText := rawText copyWithout: Character cr].
	fileStream := FileStream write: pathname.
	[fileStream nextPutAll: rawText] ensure: [fileStream close].
	text isModified: false!

setHTML: aFileBrowserFile
	"If the selected file is a html file then diplay it on the html tab"

	aFileBrowserFile isHTMLFile ifFalse: [^html value: 'about:blank'].
	html value: aFileBrowserFile path!

setImage: aFileBrowserFile
	"If the selected file is an image file then diplay it on the image tab"

	aFileBrowserFile isImageFile ifFalse: [^image value: nil].
	image value: (OLEPicture fromFile: aFileBrowserFile path).
	(image view)
		viewMode: showImageAs;
		layout!

showImageAs: aSymbol
	showImageAs := aSymbol.
	files hasSelection ifTrue: [self setImage: files selection]!

updateFilesKeepingSelection
	"Update the files list but keep the current selection. We can't just use the same selection
	as the actual items in the list will have been recreated so the actual old selection will have
	gone. We have to reselect the item representing the same file"

	| selection |
	files hasSelection ifTrue: [selection := files selection name].
	self onFolderSelectionChanged.
	selection notNil
		ifTrue:
			[files selectionOrNil: (files list detect: [:each | each name = selection] ifNone: [])]! !
!FileBrowser categoriesFor: #about!commands!public! !
!FileBrowser categoriesFor: #askAboutHex:!helpers!public! !
!FileBrowser categoriesFor: #canFileIn!commands!public!testing! !
!FileBrowser categoriesFor: #canPrint!printing!public!testing! !
!FileBrowser categoriesFor: #clearTabs!helpers!public! !
!FileBrowser categoriesFor: #createComponents!initializing!public! !
!FileBrowser categoriesFor: #createSchematicWiring!initializing!public! !
!FileBrowser categoriesFor: #enableHex!commands!public! !
!FileBrowser categoriesFor: #fileDelete!commands!public! !
!FileBrowser categoriesFor: #fileIn!commands!public! !
!FileBrowser categoriesFor: #fileNew!commands!public! !
!FileBrowser categoriesFor: #fileOpen!commands!public! !
!FileBrowser categoriesFor: #fileSave!commands!public! !
!FileBrowser categoriesFor: #fileSaveAs!commands!public! !
!FileBrowser categoriesFor: #macroPlayback!commands!public! !
!FileBrowser categoriesFor: #macroStartRecord!commands!public! !
!FileBrowser categoriesFor: #macroStopRecord!commands!public! !
!FileBrowser categoriesFor: #onCloseRequested:!event handling!public! !
!FileBrowser categoriesFor: #onFileSelectionChanged!event handling!public! !
!FileBrowser categoriesFor: #onFolderSelectionChanged!event handling!public! !
!FileBrowser categoriesFor: #onKeyEvent:!event handling!public! !
!FileBrowser categoriesFor: #onSelectionChanging:!event handling!public! !
!FileBrowser categoriesFor: #onSessionStarted!event handling!public! !
!FileBrowser categoriesFor: #onViewOpened!event handling!public! !
!FileBrowser categoriesFor: #printableView!accessing!printing!public! !
!FileBrowser categoriesFor: #promptForChanges!helpers!public! !
!FileBrowser categoriesFor: #queryCommand:!commands!public! !
!FileBrowser categoriesFor: #removeCr!commands!public! !
!FileBrowser categoriesFor: #saveFile:!helpers!public! !
!FileBrowser categoriesFor: #setHTML:!helpers!public! !
!FileBrowser categoriesFor: #setImage:!helpers!public! !
!FileBrowser categoriesFor: #showImageAs:!commands!public! !
!FileBrowser categoriesFor: #updateFilesKeepingSelection!helpers!public! !

ILLibraryShell comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ILLibraryShell class methodsFor!

allFileTypes
	^#(#('All files (*.*)' '*.*') #('Bitmap files (*.bmp)' '*.bmp') #('Icon files (*.ico)' '*.ico') #('Cursor files (*.cur)' '*.cur') #('Library Files (*.lib)' '*.lib') #('Application Files (*.exe)' '*.exe'))!

bitmapFileExtension
	^'bmp'!

bitmapFileTypes
	^#(#('Bitmap files (*.bmp)' '*.bmp') #('All files (*.*)' '*.*'))!

cursorFileExtension
	^'cur'!

cursorFileTypes
	^#(#('Cursor files (*.cur)' '*.cur') #('All files (*.*)' '*.*'))!

defaultModel
	^ILLibrary new!

displayOn: aStream
	aStream nextPutAll: 'Image Library'!

exeFileTypes
	^#(#('Application files (*.exe)' '*.exe') #('All files (*.*)' '*.*'))!

icon
	^##(self) instanceClass defaultIcon!

iconFileExtension
	^'ico'!

iconFileTypes
	^#(#('Icon files (*.ico)' '*.ico') #('All files (*.*)' '*.*'))!

libraryFileExtension
	^'lib'!

libraryFileTypes
	^#(#('Library Files (*.lib)' '*.lib') #('All Files (*.*)' '*.*'))! !
!ILLibraryShell class categoriesFor: #allFileTypes!constants!public! !
!ILLibraryShell class categoriesFor: #bitmapFileExtension!constants!public! !
!ILLibraryShell class categoriesFor: #bitmapFileTypes!constants!public! !
!ILLibraryShell class categoriesFor: #cursorFileExtension!constants!public! !
!ILLibraryShell class categoriesFor: #cursorFileTypes!constants!public! !
!ILLibraryShell class categoriesFor: #defaultModel!models!public! !
!ILLibraryShell class categoriesFor: #displayOn:!operations!public! !
!ILLibraryShell class categoriesFor: #exeFileTypes!constants!public! !
!ILLibraryShell class categoriesFor: #icon!constants!public! !
!ILLibraryShell class categoriesFor: #iconFileExtension!constants!public! !
!ILLibraryShell class categoriesFor: #iconFileTypes!constants!public! !
!ILLibraryShell class categoriesFor: #libraryFileExtension!constants!public! !
!ILLibraryShell class categoriesFor: #libraryFileTypes!constants!public! !

!ILLibraryShell methodsFor!

about
	"Display the about view"

	self
		about:
			'
Image Library and Editor
for
Dolphin Smalltalk 5.x

Version 5d
 1997-2004 Ian Bartholomew
http://www.idb.me.uk'!

addImage
	| imageExtent |
	imageExtent := (ILExtentDialog create)
		options: self model imageSizes;
		showModal.
	imageExtent isNil ifTrue: [^self].
	self model addImage: imageExtent!

allowLoss
	^self model isModified not
		or: [MessageBox confirm: 'Continue and lose all changes made to the library?']!

checkMarker: aFileStream
	(aFileStream next: 3) = 'LIB' asByteArray ifTrue: [^true].
	MessageBox notify: 'Not a valid library'.
	^false!

createComponents
	super createComponents.
	libraryWorkspace := self add: ILLibraryWorkspacePresenter new name: 'libraryWorkspace'.
	libraryStatus := self add: TextPresenter new name: 'libraryStatus'.
	imageStatus := self add: TextPresenter new name: 'imageStatus'.
	modifiedStatus := self add: TextPresenter new name: 'modifiedStatus'!

createSchematicWiring
	super createSchematicWiring.
	self
		when: #closeRequested:
		send: #onCloseRequested:
		to: self.
	self
		when: #viewOpened
		send: #onLibraryChanged
		to: self.
	libraryWorkspace
		when: #mouseOver:
		send: #onMouseOver:
		to: self.
	libraryWorkspace
		when: #editImage
		send: #onEditImage
		to: self!

deleteImage
	(MessageBox confirm: 'This will permanately delete the selected image(s). Continue?')
		ifFalse: [^self].
	self model deleteImage!

editImage
	self model editImageWithBackcolor: libraryWorkspace view backcolor!

exportBitmap
	| filename fileStream |
	filename := (FileSaveDialog new)
		fileTypes: self class bitmapFileTypes;
		defaultExtension: self class bitmapFileExtension;
		showModal.
	filename isNil ifTrue: [^self].
	Cursor wait
		showWhile:
			[fileStream := FileStream write: filename text: false.
			[self model exportBitmapTo: fileStream] ensure: [fileStream close]]!

exportCursor
	| filename fileStream |
	filename := (FileSaveDialog new)
		fileTypes: self class cursorFileTypes;
		defaultExtension: self class cursorFileExtension;
		showModal.
	filename isNil ifTrue: [^self].
	Cursor wait
		showWhile:
			[fileStream := FileStream write: filename text: false.
			[self model exportCursorTo: fileStream] ensure: [fileStream close]]!

exportExe
	| filename fileStream |
	filename := (FileOpenDialog new)
		fileTypes: self class exeFileTypes;
		showModal.
	filename isNil ifTrue: [^self].
	Cursor wait
		showWhile:
			[fileStream := (FileStream readWrite: filename) beBinary.
			[self model exportExeTo: fileStream] ensure: [fileStream close]]!

exportIcon
	| filename fileStream |
	filename := (FileSaveDialog new)
		fileTypes: self class iconFileTypes;
		defaultExtension: self class iconFileExtension;
		showModal.
	filename isNil ifTrue: [^self].
	Cursor wait
		showWhile:
			[fileStream := FileStream write: filename text: false.
			[self model exportIconTo: fileStream] ensure: [fileStream close]]!

import
	| filenames fileStream |
	filenames := (MultipleFileOpenDialog new)
		fileTypes: self class allFileTypes;
		showModal.
	filenames isNil ifTrue: [^self].
	Cursor wait
		showWhile:
			[filenames
				do:
					[:each | 
					fileStream := FileStream read: each text: false.
					[self model import: fileStream] ensure: [fileStream close]]].
	self model resetAfterImport!

insertMarker: aFileStream
	aFileStream nextPutAll: 'LIB' asByteArray!

model: anILLibrary
	super model: anILLibrary.
	libraryWorkspace model: self model.	"Lose the argument as we don't need it"
	self model
		when: #libraryChanged:
		send: #onLibraryChanged
		to: self!

moveDown
	self model moveDown!

moveToEnd
	self model moveToEnd!

moveToStart
	self model moveToStart!

moveUp
	self model moveUp!

newLibrary
	self allowLoss ifFalse: [^self].
	self model: ILLibrary new.
	libraryFilename := nil.
	self model resetAfterLoad!

onCloseRequested: aValueHolder
	aValueHolder value: self allowLoss!

onEditImage
	self model hasSingleSelection ifTrue: [self editImage]!

onLibraryChanged
	self
		caption:
			'IDB Image Library - '
				,
					(libraryFilename isNil
						ifTrue: ['Unsaved Library']
						ifFalse: [File splitFilenameFrom: libraryFilename]).
	libraryStatus
		value:
			((String writeStream)
				space;
				nextPutAll: ' Images: ';
				print: self model imageCount;
				contents).
	modifiedStatus value: (self model isModified ifTrue: [' modified'] ifFalse: [String new])!

onMouseOver: anILImageOrNil
	imageStatus
		value:
			(anILImageOrNil isNil ifTrue: [String new] ifFalse: [anILImageOrNil imageDescription])!

openLibrary
	| filename fileStream |
	self allowLoss ifFalse: [^self].
	filename := (FileOpenDialog new)
		fileTypes: self class libraryFileTypes;
		showModal.
	filename isNil ifTrue: [^self].	"The deferred action is needed because (I think) Windows starts a redraw when the dialog 
	closes, using the original model. We interrupt it with the actions below, replacing the model
	and forcing a redraw. Windows then trys to restart the interruped original paint and, as
	the model has now changed, has problems"
	[libraryFilename := filename.
	Cursor wait
		showWhile:
			[fileStream := FileStream read: filename text: false.
			[(self checkMarker: fileStream)
				ifTrue: [self model: (Object binaryReadFrom: fileStream)]] ensure: [fileStream close]].
	self model resetAfterLoad] postToInputQueue!

queryCommand: aCommandQuery
	(#(#deleteImage #exportBitmap #exportCursor #exportIcon #exportExe)
		includes: aCommandQuery command)
		ifTrue:
			[aCommandQuery isEnabled: self model hasSelection.
			^true].
	(#(#moveToStart #moveToEnd #moveUp #moveDown) includes: aCommandQuery command)
		ifTrue:
			[aCommandQuery isEnabled: self model hasMultipleImages & self model hasSelection.
			^true].
	aCommandQuery command == #editImage
		ifTrue:
			[aCommandQuery isEnabled: self model hasSingleSelection.
			^true].
	(#(#saveLibrary #saveLibraryAs) includes: aCommandQuery command)
		ifTrue:
			[aCommandQuery isEnabled: self model hasImages.
			^true].
	^super queryCommand: aCommandQuery!

save
	| fileStream |
	self model resetBeforeSave.
	fileStream := FileStream write: libraryFilename text: false.
	Cursor wait
		showWhile:
			[[self insertMarker: fileStream.
			self model binaryStoreOn: fileStream] ensure: [fileStream close]].
	self model resetAfterSave: libraryWorkspace view backcolor!

saveLibrary
	libraryFilename isNil ifTrue: [self saveLibraryAs] ifFalse: [self save]!

saveLibraryAs
	| filename dialog |
	dialog := FileSaveDialog new.
	filename := dialog
		style: (dialog style bitOr: OFN_OVERWRITEPROMPT);
		fileTypes: self class libraryFileTypes;
		defaultExtension: self class libraryFileExtension;
		showModal.
	filename isNil ifTrue: [^self].
	libraryFilename := filename.
	self save!

setBackgroundColor: aSymbol
	| color |
	libraryWorkspace view backcolor: (RGB perform: aSymbol).
	ILImage transparentRGB: libraryWorkspace view backcolor.
	self model clearBitmapCache! !
!ILLibraryShell categoriesFor: #about!commands!public! !
!ILLibraryShell categoriesFor: #addImage!commands!public! !
!ILLibraryShell categoriesFor: #allowLoss!helpers!public! !
!ILLibraryShell categoriesFor: #checkMarker:!helpers!public! !
!ILLibraryShell categoriesFor: #createComponents!initializing!public! !
!ILLibraryShell categoriesFor: #createSchematicWiring!initializing!public! !
!ILLibraryShell categoriesFor: #deleteImage!commands!public! !
!ILLibraryShell categoriesFor: #editImage!commands!public! !
!ILLibraryShell categoriesFor: #exportBitmap!commands!public! !
!ILLibraryShell categoriesFor: #exportCursor!commands!public! !
!ILLibraryShell categoriesFor: #exportExe!commands!public! !
!ILLibraryShell categoriesFor: #exportIcon!commands!public! !
!ILLibraryShell categoriesFor: #import!commands!public! !
!ILLibraryShell categoriesFor: #insertMarker:!helpers!public! !
!ILLibraryShell categoriesFor: #model:!models!public! !
!ILLibraryShell categoriesFor: #moveDown!commands!public! !
!ILLibraryShell categoriesFor: #moveToEnd!commands!public! !
!ILLibraryShell categoriesFor: #moveToStart!commands!public! !
!ILLibraryShell categoriesFor: #moveUp!commands!public! !
!ILLibraryShell categoriesFor: #newLibrary!commands!public! !
!ILLibraryShell categoriesFor: #onCloseRequested:!event handling!public! !
!ILLibraryShell categoriesFor: #onEditImage!event handling!public! !
!ILLibraryShell categoriesFor: #onLibraryChanged!event handling!public! !
!ILLibraryShell categoriesFor: #onMouseOver:!event handling!public! !
!ILLibraryShell categoriesFor: #openLibrary!commands!public! !
!ILLibraryShell categoriesFor: #queryCommand:!commands!public! !
!ILLibraryShell categoriesFor: #save!commands!public! !
!ILLibraryShell categoriesFor: #saveLibrary!commands!public! !
!ILLibraryShell categoriesFor: #saveLibraryAs!commands!public! !
!ILLibraryShell categoriesFor: #setBackgroundColor:!commands!public! !

NewsArchiveBrowser comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!NewsArchiveBrowser class methodsFor!

archiveFolder
	ArchiveFolder isNil ifTrue: [ArchiveFolder := self defaultArchiveFolder].
	^ArchiveFolder!

archiveFolder: aStringOrNil
	ArchiveFolder := aStringOrNil!

defaultArchiveFolder
	^File
		composePath: SessionManager current idbPackageFolder
		subPath: 'News Archive Browser\Archive'!

defaultModel
	^NewsArchive new!

defaultTextFont
	^SmalltalkWorkspaceDocument defaultFont!

displayOn: aStream
	aStream nextPutAll: 'News Archive Browser'!

icon
	"Answers an Icon that can be used to represent this class"

	^##(self) instanceClass defaultIcon!

publishedAspects
	^(super publishedAspects)
		add: (Aspect folder: #archiveFolder);
		add: (Aspect font: #textFont);
		yourself!

textFont
	TextFont isNil ifTrue: [TextFont := self defaultTextFont].
	^TextFont!

textFont: aFontOrNil
	TextFont := aFontOrNil! !
!NewsArchiveBrowser class categoriesFor: #archiveFolder!accessing!public! !
!NewsArchiveBrowser class categoriesFor: #archiveFolder:!accessing!public! !
!NewsArchiveBrowser class categoriesFor: #defaultArchiveFolder!constants!public! !
!NewsArchiveBrowser class categoriesFor: #defaultModel!constants!public! !
!NewsArchiveBrowser class categoriesFor: #defaultTextFont!constants!public! !
!NewsArchiveBrowser class categoriesFor: #displayOn:!operations!public! !
!NewsArchiveBrowser class categoriesFor: #icon!constants!public! !
!NewsArchiveBrowser class categoriesFor: #publishedAspects!accessing!public! !
!NewsArchiveBrowser class categoriesFor: #textFont!accessing!public! !
!NewsArchiveBrowser class categoriesFor: #textFont:!accessing!public! !

!NewsArchiveBrowser methodsFor!

about
	"Display the about view"

	self
		about:
			'
News Archive Browser
for
Dolphin Smalltalk 5.x

Version 5d
 2000-2004 Ian Bartholomew
http://www.idb.me.uk'!

canPrint
	^(Smalltalk includesKey: #IdePrinter) and: [super canPrint]!

copySelected
	| selected stream |
	stream := String writeStream.
	Cursor wait showWhile: [self model copySelectedTo: stream].
	stream contents copyToClipboard!

createComponents
	list := self add: ListPresenter new name: 'list'.
	text := self add: TextPresenter new name: 'text'.
	status := self add: TextPresenter new name: 'status'.
	percentageLoaded := self add: NumberPresenter new name: 'percentageLoaded'!

createSchematicWiring
	super createSchematicWiring.
	list
		when: #selectionChanged
		send: #onSelectionChanged
		to: self.
	list
		when: #actionPerformed
		send: #onActionPerformed
		to: self.
	self model
		when: #percentageLoaded:
		send: #onPercentageLoaded:
		to: self!

onActionPerformed
	list selection toggleSelection.
	list model updateAtIndex: list selectionByIndex!

onPercentageLoaded: aNumber
	percentageLoaded value: aNumber rounded!

onSelectionChanged
	text value: (list hasSelection ifTrue: [list selection text] ifFalse: [String new])!

onViewOpened
	| time |
	super onViewOpened.
	text view font: self class textFont.
	self caption: 'Archive:  ' , self class archiveFolder.
	["Lots of objects created so get this done first"
	MemoryManager current collectGarbage.
	time := Time millisecondsToRun: [self showAll].
	percentageLoaded view hide.
	[status value: time printString , ' milliseconds'.
	Processor sleep: 750.
	self setStatus] fork] postToInputQueue!

printableView
	^text view!

queryCommand: aCommandQuery
	(#(#selectAll #unSelectAll #copySelected #showSelected #searchFrom #searchSubject #searchText)
		includes: aCommandQuery command)
		ifTrue:
			[aCommandQuery isEnabled: (list list notNil and: [list list notEmpty]).
			^true].
	(#(#copySelection #showConversation) includes: aCommandQuery command)
		ifTrue:
			[aCommandQuery isEnabled: list hasSelection.
			^true].
	(#(#copySelected #showSelected #unSelectAll) includes: aCommandQuery command)
		ifTrue:
			[aCommandQuery isEnabled: self model hasAnySelected.
			^true].
	(#(#print #printPreview) identityIncludes: aCommandQuery command)
		ifTrue:
			[aCommandQuery
				isEnabled: self canPrint;
				receiver: self.
			^true].
	^super queryCommand: aCommandQuery!

searchAllFrom
	self showAll.
	self searchFrom!

searchAllSubject
	self showAll.
	self searchSubject!

searchAllText
	self showAll.
	self searchText!

searchCaption: aString selector: aSymbol
	| target newList |
	target := Prompter prompt: aString.
	(target isNil or: [target isEmpty]) ifTrue: [^self].
	Cursor wait
		showWhile:
			[newList := list list select: [:each | each perform: aSymbol with: target asLowercase]].
	self setList: newList!

searchFrom
	self searchCaption: 'Search From field for - ' selector: #searchFromFor:!

searchSubject
	self searchCaption: 'Search Subject field for - ' selector: #searchSubjectFor:!

searchText
	self searchCaption: 'Search Text field for - ' selector: #searchTextFor:!

selectAll
	Cursor wait showWhile: [list list do: [:each | each select]].
	list view refreshContents!

setList: aCollection
	| selection |
	selection := list selectionOrNil.
	list list: aCollection.
	(selection notNil and: [aCollection includes: selection])
		ifTrue: [list selection: selection]
		ifFalse: [text value: String new].	"This stops a horizontal scroll bar appearing"
	list view layout.
	self setStatus!

setStatus
	status
		value:
			((String writeStream)
				nextPutAll: ' Showing ';
				print: list model size;
				nextPutAll: ' of ';
				print: self model countArticles;
				contents)!

showAll
	self setList: self model articles!

showConversation
	Cursor wait
		showWhile: [self setList: (self model articlesInConversation: list selection)]!

showSelected
	Cursor wait showWhile: [self setList: self model allSelected]!

unSelectAll
	Cursor wait showWhile: [list list do: [:each | each unSelect]].
	list view refreshContents! !
!NewsArchiveBrowser categoriesFor: #about!commands!public! !
!NewsArchiveBrowser categoriesFor: #canPrint!printing!public!testing! !
!NewsArchiveBrowser categoriesFor: #copySelected!commands!public! !
!NewsArchiveBrowser categoriesFor: #createComponents!initializing!public! !
!NewsArchiveBrowser categoriesFor: #createSchematicWiring!initializing!public! !
!NewsArchiveBrowser categoriesFor: #onActionPerformed!event handling!public! !
!NewsArchiveBrowser categoriesFor: #onPercentageLoaded:!event handling!public! !
!NewsArchiveBrowser categoriesFor: #onSelectionChanged!event handling!public! !
!NewsArchiveBrowser categoriesFor: #onViewOpened!event handling!public! !
!NewsArchiveBrowser categoriesFor: #printableView!accessing!printing!public! !
!NewsArchiveBrowser categoriesFor: #queryCommand:!commands!public! !
!NewsArchiveBrowser categoriesFor: #searchAllFrom!commands!public! !
!NewsArchiveBrowser categoriesFor: #searchAllSubject!commands!public! !
!NewsArchiveBrowser categoriesFor: #searchAllText!commands!public! !
!NewsArchiveBrowser categoriesFor: #searchCaption:selector:!commands!public! !
!NewsArchiveBrowser categoriesFor: #searchFrom!commands!public! !
!NewsArchiveBrowser categoriesFor: #searchSubject!commands!public! !
!NewsArchiveBrowser categoriesFor: #searchText!commands!public! !
!NewsArchiveBrowser categoriesFor: #selectAll!commands!public! !
!NewsArchiveBrowser categoriesFor: #setList:!helpers!public! !
!NewsArchiveBrowser categoriesFor: #setStatus!helpers!public! !
!NewsArchiveBrowser categoriesFor: #showAll!commands!public! !
!NewsArchiveBrowser categoriesFor: #showConversation!commands!public! !
!NewsArchiveBrowser categoriesFor: #showSelected!commands!public! !
!NewsArchiveBrowser categoriesFor: #unSelectAll!commands!public! !

PoolDictionaryBrowser comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!PoolDictionaryBrowser class methodsFor!

displayOn: aStream
	aStream nextPutAll: 'PoolDictionary Browser'!

initializeAfterLoad
	(Smalltalk developmentSystem)
		addAdditionalToolsFolderIcon: self toolsFolderIcon;
		registerTool: self.
	super initializeAfterLoad!

uninitializeBeforeRemove
	(Smalltalk developmentSystem)
		removeSystemFolderIcon: self toolsFolderIcon;
		unregisterTool: self.
	super uninitializeBeforeRemove! !
!PoolDictionaryBrowser class categoriesFor: #displayOn:!accessing!public! !
!PoolDictionaryBrowser class categoriesFor: #initializeAfterLoad!initializing!public! !
!PoolDictionaryBrowser class categoriesFor: #uninitializeBeforeRemove!public!uninitializing! !

!PoolDictionaryBrowser methodsFor!

about
	"Display the about view"

	self
		about:
			'
Pool Dictionary Browser
for
Dolphin Smalltalk 5.x

Version 5d
 2003-2004 Ian Bartholomew
http://www.idb.me.uk'!

addItem: anAssociation
	(poolList selection)
		add: anAssociation;
		isChanged: true.
	self updateItemList.
	itemList selection: (itemList list detect: [:each | each = anAssociation]).
	self updatePoolListSelection!

canDelete
	^MessageBox
		confirm:
			'Completely delete the PoolConstantsDictionary named ' , poolList selection name
				,
					'
Are you sure?'
		caption: 'Delete PoolConstantsDictionary'!

canDeleteIfReferenced
	(self environment allClasses
		select: [:class | class sharedPools includes: poolList selection]) notEmpty
		ifTrue:
			[^MessageBox
				confirm:
					'There are classes that still include ' , poolList selection name
						,
							' as a Pool.
Continue and delete the PoolConstantsDictionary?'
				caption: 'PoolConstantsDictionary still in use'].
	^true!

canOverwrite: aString
	(self environment includesKey: aString)
		ifTrue:
			[^MessageBox
				confirm:
					'A PoolConstantsDictionary named ' , aString
						,
							' already exists. 
Do you want to overwrite it?'
				caption: 'Duplicate PoolConstantsDictionary'].
	^true!

canRenameIfReferenced
	| references |
	(references := self environment allClasses
		select: [:class | class sharedPools includes: poolList selection]) notEmpty
		ifTrue:
			[| stream |
			stream := String writeStream.
			stream
				nextPutAll: 'The PoolConstantsDictionary ';
				nextPutAll: poolList selection name;
				nextPutAll: ' is included in the following class definition(s)';
				cr;
				nextPutAll:
						'After renaming these classes (and any subclasses) may not compile unless the Pool reference is updated.';
				cr;
				nextPutAll: 'Are you sure you want to rename this PoolConstantsDictionary?';
				cr;
				cr.
			references
				do:
					[:each | 
					stream
						nextPutAll: each name;
						space;
						space].
			^MessageBox confirm: stream contents caption: 'PoolConstantsDictionary Rename'].
	^true!

createComponents
	super createComponents.
	poolList := self add: ListPresenter new name: 'poolList'.
	itemList := self add: ListPresenter new name: 'itemList'!

createSchematicWiring
	super createSchematicWiring.
	poolList
		when: #selectionChanged
		send: #onPoolSelectionChanged
		to: self.
	itemList
		when: #actionPerformed
		send: #editItem
		to: self!

deleteItem
	| index |
	(poolList selection)
		removeKey: itemList selection key;
		isChanged: true.
	index := itemList selectionByIndex.
	self updateItemList.
	itemList selectionByIndex: (index min: itemList list size) ifAbsent: [].
	self updatePoolListSelection!

deletePool
	| index |
	self canDelete ifFalse: [^self].
	self canDeleteIfReferenced ifFalse: [^self].
	index := poolList selectionByIndex.
	self environment removeKey: poolList selection name.
	self updatePoolList.
	poolList selectionByIndex: (index min: poolList list size) ifAbsent: []!

editItem
	(PoolItemDialog showModalOn: itemList selection)
		ifNotNil:
			[:arg | 
			itemList selection = arg ifTrue: [^self].
			itemList selection key = arg key
				ifFalse: [poolList selection removeKey: itemList selection key].
			self addItem: arg]!

environment
	^Smalltalk!

fileInPool
	| filename difference |
	filename := (FileOpenDialog new)
		caption: 'File In PoolConstantsDictionary ';
		fileTypes:
				(Array with: #('Smalltalk Files (*.st)' '*.st') with: FileDialog allFilesType);
		defaultExtension: 'st';
		showModal.
	filename ifNil: [^self].
	SourceManager default fileIn: filename.	"Hmmm, think about this next bit"
	difference := SmalltalkSystem current availablePools difference: poolList list.
	(difference detect: [:each | each class == PoolConstantsDictionary] ifNone: [])
		ifNotNil:
			[:arg | 
			self updatePoolList.
			poolList selection: arg]!

fileOutPool
	| filename |
	filename := (FileSaveDialog new)
		caption: 'File Out PoolConstantsDictionary ' , poolList selection name;
		fileTypes:
				(Array with: #('Smalltalk Files (*.st)' '*.st') with: FileDialog allFilesType);
		defaultExtension: 'st';
		value: poolList selection fileOutName;
		showModal.
	filename ifNil: [^self].
	SourceManager default fileOut: poolList selection to: filename.
	self updatePoolListSelection!

findItemKey
	| title target lowercaseTarget found stream pools |
	title := 'Find Item Key'.
	target := Prompter prompt: 'Enter the required key text (case ignored)' caption: title.
	target ifNil: [^self].
	lowercaseTarget := target asLowercase.
	found := OrderedCollection new.
	poolList list
		do:
			[:eachPool | 
			(eachPool keys
				select: [:eachKey | (eachKey asLowercase indexOfSubCollection: lowercaseTarget) ~= 0])
				do: [:eachKey | found add: eachPool -> eachKey]].
	found isEmpty
		ifTrue:
			[(MessageBox new)
				text: target , ' has no matching keys';
				caption: title;
				prompt;
				ok;
				open.
			^self].
	pools := (found collect: [:each | each key name]) asSet asSortedCollection.
	stream := String writeStream.
	stream
		nextPutAll: 'The following pools contained keys whichec matched ';
		nextPutAll: target;
		cr;
		cr.
	pools
		do:
			[:each | 
			stream
				nextPutAll: each;
				space].
	stream
		cr;
		cr.
	(found
		asSortedCollection:
			[:a :b | a key = b key ifTrue: [a value < b value] ifFalse: [a key name < b key name]])
		keysAndValuesDo:
			[:index :each | 
			index < 26
				ifTrue:
					[stream
						nextPutAll: each key name;
						nextPutAll: ' .... ';
						nextPutAll: each value;
						nextPutAll: ' .... ';
						print: (each key at: each value);
						cr]
				ifFalse:
					[index = 26
						ifTrue:
							[stream
								nextPutAll: '(and ';
								print: found size - 25;
								nextPutAll: ' more)';
								cr]]].
	(MessageBox new)
		text: stream contents;
		caption: title;
		prompt;
		ok;
		open!

getNewPoolName
	"Answers a name or nil"

	^self
		validatePoolName:
			(Prompter
				prompt: 'Name of new PoolConstantsDictionary'
				caption: 'Add PoolConstantsDictionary')!

getRenamePoolName
	"Answers the name or nil "

	^self
		validatePoolName:
			(Prompter
				prompt: 'New name for the PoolConstantsDictionary ' , poolList selection name
				caption: 'Rename PoolConstantsDictionary')!

newItem
	PoolItemDialog showModal ifNotNil: [:arg | self addItem: arg]!

newPool
	| poolName newPool |
	(poolName := self getNewPoolName) ifNil: [^self].
	(self canOverwrite: poolName) ifFalse: [^self].
	self environment at: poolName put: (newPool := PoolConstantsDictionary named: poolName).
	self updatePoolList.
	poolList selection: newPool!

onPoolSelectionChanged
	poolList hasSelection
		ifTrue: [self updateItemList]
		ifFalse: [itemList list: OrderedCollection new]!

onViewOpened
	super onViewOpened.
	self updatePoolList.
	[self validatePools] postToInputQueue!

packagePool
	| currentPackage newPackage currentIndex |
	currentPackage := poolList selection owningPackage.
	newPackage := PackagePrompter
		showModalOn: currentPackage asValue
		caption: 'Package of ' , poolList selection name
		default: currentPackage.
	(newPackage isNil or: [newPackage = currentPackage]) ifTrue: [^self].
	poolList selection owningPackage: newPackage.
	self updatePoolListSelection!

queryCommand: aCommandQuery
	(#(#deletePool #packagePool #newItem #refreshItems #referencesToPool #renamePool)
		identityIncludes: aCommandQuery command)
		ifTrue:
			[aCommandQuery isEnabled: poolList hasSelection.
			^true].
	(#(#deleteItem #editItem #referencesToItem) identityIncludes: aCommandQuery command)
		ifTrue:
			[aCommandQuery isEnabled: itemList hasSelection.
			^true].
	aCommandQuery command == #fileOutPool
		ifTrue:
			[aCommandQuery isEnabled: (poolList hasSelection and: [poolList selection canFileOut]).
			^true].
	^super queryCommand: aCommandQuery!

referencesToItem
	| references target title |
	references := OrderedCollection new.
	target := itemList selection key.
	(self environment allClasses
		select: [:class | class allSharedPools includes: poolList selection])
		do:
			[:class | 
			class methodDictionary
				do: [:method | (method containsSource: target) ifTrue: [references add: method]].
			class class methodDictionary
				do: [:method | (method containsSource: target) ifTrue: [references add: method]]].
	title := 'References to ' , target , ' in ' , poolList selection name.
	references isEmpty
		ifTrue:
			[(MessageBox new)
				text: target , ' has no references';
				caption: title;
				prompt;
				ok;
				open.
			^self].
	SmalltalkSystem current
		browseMethods: references
		caption: title
		findString: target
		filter: [:m | false]!

referencesToPool
	| references stream |
	stream := String writeStream.
	(references := self environment allClasses
		select: [:class | class sharedPools includes: poolList selection]) isEmpty
		ifTrue:
			[stream
				nextPutAll:
					'The PoolConstantsDictionary ' , poolList selection name , ' has no references']
		ifFalse:
			[stream
				nextPutAll: 'The PoolConstantsDictionary ';
				nextPutAll: poolList selection name;
				nextPutAll:
						' is included in the following class definition(s) and is also available in any subclasses';
				cr;
				cr.
			(references asSortedCollection: [:a :b | a name < b name])
				do:
					[:each | 
					stream
						nextPutAll: each name;
						space;
						space]].
	(MessageBox new)
		text: stream contents;
		caption: 'PoolConstantsDictionary References';
		prompt;
		ok;
		open!

refreshItems
	self updateItemList.
	itemList selectionOrNil: nil!

refreshPools
	self updatePoolList.
	poolList selectionOrNil: nil!

renamePool
	| poolName newPool |
	self canRenameIfReferenced ifFalse: [^self].
	(poolName := self getRenamePoolName) ifNil: [^self].
	(self canOverwrite: poolName) ifFalse: [^self].
	self environment at: poolName put: (newPool := PoolConstantsDictionary named: poolName).
	poolList selection keysAndValuesDo: [:key :value | newPool at: key put: value].
	poolList selection owningPackage ifNotNil: [:arg | newPool owningPackage: arg].
	self environment removeKey: poolList selection name.
	self updatePoolList.
	poolList selection: newPool!

updateItemList
	itemList
		list: (poolList selection associations asSortedCollection: [:a :b | a key < b key])!

updatePoolList
	poolList
		list:
			(SmalltalkSystem current availablePools asSortedCollection: [:a :b | a name < b name])!

updatePoolListSelection
	poolList model updateAtIndex: poolList selectionByIndex!

validatePoolName: aStringOrNil
	(aStringOrNil isNil or: [aStringOrNil isEmpty]) ifTrue: [^nil].
	aStringOrNil first isLetter
		ifFalse:
			[(MessageBox new)
				text: 'Pool name should start with an uppercase letter';
				caption: 'PoolConstantsDictionary Name';
				prompt;
				ok;
				open.
			^nil].
	aStringOrNil first isUppercase
		ifFalse:
			[(MessageBox
				confirm:
					'Pool name should start with an uppercase letter.
Change new pool name to ' , aStringOrNil capitalized , ' ?'
				caption: 'PoolConstantsDictionary Name') ifTrue: [^aStringOrNil capitalized]].
	^aStringOrNil!

validatePools
	poolList list
		do:
			[:each | 
			((self environment includesKey: each name) and: [(self environment at: each name) == each])
				ifFalse:
					[| stream reply |
					stream := String writeStream.
					stream
						nextPutAll: 'The PoolConstantsDictionary with the global name of ';
						nextPutAll: (self environment keyAtValue: each);
						nextPutAll: ' has the internal name ';
						nextPutAll: each name;
						cr;
						nextPutAll:
								'Do you want to change the internal name to match the global name (recommended)'.
					reply := ((MessageBox new)
						text: stream contents;
						caption: 'PoolConstantsDictionary Name Mismatch';
						warning;
						yesNo;
						open) == #yes.
					reply
						ifTrue:
							[each name: (self environment keyAtValue: each).
							self updatePoolList]]]! !
!PoolDictionaryBrowser categoriesFor: #about!commands!public! !
!PoolDictionaryBrowser categoriesFor: #addItem:!items!operations!public! !
!PoolDictionaryBrowser categoriesFor: #canDelete!public!testing! !
!PoolDictionaryBrowser categoriesFor: #canDeleteIfReferenced!public!testing! !
!PoolDictionaryBrowser categoriesFor: #canOverwrite:!public!testing! !
!PoolDictionaryBrowser categoriesFor: #canRenameIfReferenced!public!testing! !
!PoolDictionaryBrowser categoriesFor: #createComponents!initializing!public! !
!PoolDictionaryBrowser categoriesFor: #createSchematicWiring!initializing!public! !
!PoolDictionaryBrowser categoriesFor: #deleteItem!commands!items!public! !
!PoolDictionaryBrowser categoriesFor: #deletePool!commands!pools!public! !
!PoolDictionaryBrowser categoriesFor: #editItem!commands!items!public! !
!PoolDictionaryBrowser categoriesFor: #environment!constants!public! !
!PoolDictionaryBrowser categoriesFor: #fileInPool!commands!pools!public! !
!PoolDictionaryBrowser categoriesFor: #fileOutPool!commands!pools!public! !
!PoolDictionaryBrowser categoriesFor: #findItemKey!commands!public! !
!PoolDictionaryBrowser categoriesFor: #getNewPoolName!commands!pools!public! !
!PoolDictionaryBrowser categoriesFor: #getRenamePoolName!commands!pools!public! !
!PoolDictionaryBrowser categoriesFor: #newItem!commands!items!public! !
!PoolDictionaryBrowser categoriesFor: #newPool!commands!pools!public! !
!PoolDictionaryBrowser categoriesFor: #onPoolSelectionChanged!event handling!public! !
!PoolDictionaryBrowser categoriesFor: #onViewOpened!event handling!public! !
!PoolDictionaryBrowser categoriesFor: #packagePool!commands!pools!public! !
!PoolDictionaryBrowser categoriesFor: #queryCommand:!commands!public! !
!PoolDictionaryBrowser categoriesFor: #referencesToItem!commands!items!public! !
!PoolDictionaryBrowser categoriesFor: #referencesToPool!commands!pools!public! !
!PoolDictionaryBrowser categoriesFor: #refreshItems!commands!items!public! !
!PoolDictionaryBrowser categoriesFor: #refreshPools!commands!items!public! !
!PoolDictionaryBrowser categoriesFor: #renamePool!commands!pools!public! !
!PoolDictionaryBrowser categoriesFor: #updateItemList!helpers!items!public! !
!PoolDictionaryBrowser categoriesFor: #updatePoolList!helpers!pools!public! !
!PoolDictionaryBrowser categoriesFor: #updatePoolListSelection!helpers!pools!public! !
!PoolDictionaryBrowser categoriesFor: #validatePoolName:!commands!operations!pools!public! !
!PoolDictionaryBrowser categoriesFor: #validatePools!helpers!operations!pools!public! !

ProfileBrowser comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ProfileBrowser class methodsFor!

defaultShowCounts
	^false!

displayOn: aStream
	aStream nextPutAll: 'Profile Browser'!

icon
	"Answers an Icon that can be used to represent this class"

	^##(self) instanceClass defaultIcon!

publishedAspects
	^(super publishedAspects)
		add: (Aspect boolean: #showCounts);
		yourself!

showCounts
	^ShowCounts ifNil: [self defaultShowCounts] ifNotNil: [:arg | ShowCounts]!

showCounts: aBooleanOrNil
	ShowCounts := aBooleanOrNil! !
!ProfileBrowser class categoriesFor: #defaultShowCounts!constants!public! !
!ProfileBrowser class categoriesFor: #displayOn:!operations!public! !
!ProfileBrowser class categoriesFor: #icon!constants!public! !
!ProfileBrowser class categoriesFor: #publishedAspects!constants!public! !
!ProfileBrowser class categoriesFor: #showCounts!accessing!public! !
!ProfileBrowser class categoriesFor: #showCounts:!accessing!public! !

!ProfileBrowser methodsFor!

about
	"Display the about view"

	self
		about:
			'
Profiler
for
Dolphin Smalltalk 5.x

Version 5c
 1999-2004 Ian Bartholomew
http://www.idb.me.uk'!

createComponents
	"Create the presenters for the sub views in the shell"

	super createComponents.
	self
		add: ListPresenter new name: 'sampleSets';
		add: ProfilerSamplesPresenter new name: 'samples';
		add: ProfilerClassListPresenter new name: 'classes';
		add: ProfilerSelectorListPresenter new name: 'selectors';
		add: ProfilerTallyTreePresenter new name: 'tally';
		add: ProfilerTimeTreePresenter new name: 'time';
		add: NumberPresenter new name: 'progressBar'!

createSchematicWiring
	"Create the trigger wiring for the receiver and link up
	to the sample sets model (a ListModel)"

	super createSchematicWiring.
	(self presenterNamed: 'sampleSets')
		when: #selectionChanged
		send: #onSampleSetSelectionChanged
		to: self.
	(self presenterNamed: 'selectors')
		when: #onSelectionChanged
		send: #onSelectorSelectionChanged
		to: self.
	(self presenterNamed: 'sampleSets') model: ProfilerSampleSetManager default sampleSets.
	((self presenterNamed: 'sampleSets') model)
		when: #itemUpdatedAtIndex:
			send: #onSampleSetUpdated:
			to: self;
		when: #itemRemovedAtIndex:
			send: #onSampleSetUpdated:
			to: self!

deleteAllSampleSets
	"Delete all the sample sets"

	ProfilerSampleSetManager default removeAll!

deleteSampleSet
	"Delete the currently selected sample set"

	ProfilerSampleSetManager default
		removeSampleSetNamed: (self presenterNamed: 'sampleSets') selection name!

filterDolphinXXX
	"Toggle the filter for displaying the Dolphin package classes and tell the tabs"

	"Temporarily removed until I decide what to do with it"

	filterDolphin := filterDolphin not.
	#('classes' 'selectors' 'tally' 'time')
		do: [:each | (self presenterNamed: each) filterDolphin: filterDolphin]!

filterPercentage: aFloat symbol: aSymbol
	"Tell the tree presenters the mimimum percentage value for items to be displayed
	and remember the current command (aSymbol)"

	filterPercentSymbol == aSymbol
		ifFalse:
			[filterPercentSymbol := aSymbol.
			#('classes' 'selectors' 'tally' 'time')
				do: [:each | (self presenterNamed: each) filterPercentage: aFloat]]!

filterSelector
	"Tell the tabs to filter out samples or tree branches that do not include the currently 
	selected method (if there is one)"

	filterSelector := filterSelector not.
	self onSelectorSelectionChanged!

isSampleSetSelected
	"Answer true if there is a sample set selected in the list"

	^(self presenterNamed: 'sampleSets') selectionOrNil notNil!

onSampleSetSelectionChanged
	"The sample set selection has been changed so refresh all the other cards"

	| sampleSet |
	(sampleSet := (self presenterNamed: 'sampleSets') selectionOrNil) isNil ifTrue: [^self].
	sampleSet
		when: #updateIndicator:of:
		send: #onUpdateIndicator:of:
		to: self.
	Cursor wait
		showWhile:
			[(self presenterNamed: 'progressBar') view
				range: (1 to: ((sampleSet samplesSize max: 1) min: self updateIndicatorLimit)).
			self refreshTabsFor: sampleSet.
			(self presenterNamed: 'progressBar') value: 0].
	sampleSet removeEventsTriggeredFor: self.
	self resetSelectorFilter.
	self caption: 'Profiler Browser - ' , sampleSet name!

onSampleSetUpdated: anInteger
	"This is the target for a triggered event that says that one of the current sample sets
	has been changed in some way. We just update the complete sample set list.
	anInteger is the index of the sample set that changed but we don't need to use it here"

	self sampleSetUpdated!

onSelectorSelectionChanged
	"The method selected in the selector tab list has changed. Depending on the
	whether filetering is active and a method is selected we send nil or a compiledcode"

	| selection |
	selection := (filterSelector and: [(self presenterNamed: 'selectors') hasSelection])
		ifTrue: [(self presenterNamed: 'selectors') selectionOrNil object].
	#('samples' 'tally' 'time')
		do: [:each | (self presenterNamed: each) filterSelector: selection]!

onUpdateIndicator: anInteger of: maximumInteger
	"The sample set is being scanned and has asked, via a trigger, for the visual display 
	showing its progress to be updated. Fiddle a bit as the maximum vale for the display
	is 65536 so we must start scaling if we will go above that"

	| position |
	position := maximumInteger > self updateIndicatorLimit
		ifTrue: [(self updateIndicatorLimit * (anInteger / maximumInteger)) truncated]
		ifFalse: [anInteger].
	(self presenterNamed: 'progressBar') value: position!

onViewOpened
	"Initialize the sub presenters and views"

	| sampleSetView |
	super onViewOpened.
	filterDolphin := false.
	filterSelector := false.
	filterPercentSymbol := #filter0.
	self caption: 'Profiler Browser - '!

queryCommand: aCommandQuery
	"Enters details about a potential command for the receiver into aCommandQuery"

	#filterPercentage:symbol: == aCommandQuery commandSymbol
		ifTrue:
			[aCommandQuery
				beEnabled;
				isChecked: filterPercentSymbol == aCommandQuery command arguments last.
			^true].	"#filterDolphin == aCommandQuery commandSymbol 
		ifTrue: 
			[aCommandQuery
				beEnabled;
				isChecked: filterDolphin.
			^true]."
	#filterSelector == aCommandQuery commandSymbol
		ifTrue:
			[aCommandQuery
				beEnabled;
				isChecked: filterSelector.
			^true].
	(#(#deleteSampleSet #report) includes: aCommandQuery commandSymbol)
		ifTrue:
			[aCommandQuery isEnabled: self isSampleSetSelected.
			^true].
	^super queryCommand: aCommandQuery!

refreshSampleSets
	"Refresh the sample sets list. This can be useful if you want to set all the
	tabs back to their default values - It leaves no sample set selected"

	self sampleSetUpdated!

refreshTabsFor: aSampleSet
	"A new sample set has been selected so set all the tabs to reflect its contents. aSampleSet may
	be the dummy (named 'None') if we just want to cleaer all the tabs"

	#('samples' 'classes' 'selectors' 'tally' 'time')
		do: [:each | (self presenterNamed: each) model: aSampleSet]!

report
	"Generate a text report for the selected sample set and open a SmalltalkWorkspaceDocument on it"

	| stream document |
	stream := String writeStream.
	(self presenterNamed: 'sampleSets') selection reportTo: stream.
	(self presenterNamed: 'classes') reportTo: stream.
	(self presenterNamed: 'selectors') reportTo: stream.
	document := SmalltalkWorkspaceDocument show.
	document workspace view font: (Font name: 'Courier').
	document setDocumentData: stream contents!

resetSelectorFilter
	"For some reason, probably the sample set has been updated/changed we need to make sure
	the selector filter is inacive. It it is currently active, turn it off"

	filterSelector
		ifTrue:
			[filterSelector := false.
			#('samples' 'tally' 'time')
				do: [:each | (self presenterNamed: each) filterSelector: nil]]!

sampleSetUpdated
	"One of the sample sets has been changed in some way. Set the selection to nil and
	use a dummy model to refresh all the tabs"

	self refreshTabsFor: (ProfilerSampleSet name: 'None').
	(self presenterNamed: 'sampleSets') selectionOrNil: nil.
	self resetSelectorFilter.
	self caption: 'Profiler Browser - '!

startProfiler
	"If the profiler dialog is correctly completed and dismissed with OK then profile
	the the block that was entered with the requested parameters"

	ProfilerSetupDialog showModal isNil ifTrue: [^self].
	Profiler
		samplingInterval: ProfilerSetupDialog interval;
		profile: ProfilerSetupDialog profiledBlock
			inSetNamed: ProfilerSetupDialog sampleSetName
			collect: ProfilerSetupDialog isCollect
			on: ProfilerSetupDialog isOn!

updateIndicatorLimit
	"Answer the limit for the indicator, above which we have to satrt 
	scaling (see #onUpdateIndicator:of:"

	^65000! !
!ProfileBrowser categoriesFor: #about!commands!public! !
!ProfileBrowser categoriesFor: #createComponents!initializing!public! !
!ProfileBrowser categoriesFor: #createSchematicWiring!initializing!public! !
!ProfileBrowser categoriesFor: #deleteAllSampleSets!commands!public! !
!ProfileBrowser categoriesFor: #deleteSampleSet!commands!public! !
!ProfileBrowser categoriesFor: #filterDolphinXXX!commands!public! !
!ProfileBrowser categoriesFor: #filterPercentage:symbol:!private helpers!public! !
!ProfileBrowser categoriesFor: #filterSelector!commands!public! !
!ProfileBrowser categoriesFor: #isSampleSetSelected!public!testing! !
!ProfileBrowser categoriesFor: #onSampleSetSelectionChanged!event handling!public! !
!ProfileBrowser categoriesFor: #onSampleSetUpdated:!event handling!public! !
!ProfileBrowser categoriesFor: #onSelectorSelectionChanged!event handling!public! !
!ProfileBrowser categoriesFor: #onUpdateIndicator:of:!event handling!public! !
!ProfileBrowser categoriesFor: #onViewOpened!event handling!public! !
!ProfileBrowser categoriesFor: #queryCommand:!commands!public! !
!ProfileBrowser categoriesFor: #refreshSampleSets!commands!public! !
!ProfileBrowser categoriesFor: #refreshTabsFor:!private helpers!public! !
!ProfileBrowser categoriesFor: #report!commands!public! !
!ProfileBrowser categoriesFor: #resetSelectorFilter!private helpers!public! !
!ProfileBrowser categoriesFor: #sampleSetUpdated!private helpers!public! !
!ProfileBrowser categoriesFor: #startProfiler!commands!public! !
!ProfileBrowser categoriesFor: #updateIndicatorLimit!constants!public! !

Snoop comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!Snoop class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^##(self) instanceClass defaultIcon! !
!Snoop class categoriesFor: #icon!constants!public! !

!Snoop methodsFor!

about
	"Display the about view"

	self
		about:
			'
Snoop
for
Dolphin Smalltalk 5.x

Version 5b
 1998-2004 Ian Bartholomew
http://www.idb.me.uk'!

closeSnoopee
	"If there is a shell being snooped then close it down as well"

	snoopedShell isNil
		ifFalse:
			[snoopedShell removeEventsTriggeredFor: self view.
			snoopedShell topShell hasView ifTrue: [snoopedShell topShell view close].
			snoopedShell := nil]!

collapse
	"Collapse one level of the tree starting at the selected node"

	| tree |
	tree := self currentTreePresenter.
	tree hasSelection ifTrue: [tree collapse: tree selection]!

createComponents
	"Create the presenters contained by the receiver"

	super createComponents.
	viewTree := self add: TreePresenter new name: 'viewTree'.
	viewList := self add: ListPresenter new name: 'viewList'.
	presenterTree := self add: TreePresenter new name: 'presenterTree'.
	presenterList := self add: ListPresenter new name: 'presenterList'.
	status := self add: TextPresenter new name: 'status'!

createSchematicWiring
	"Create the trigger wiring for the receiver"

	super createSchematicWiring.
	viewTree
		when: #selectionChanged
		send: #onTreeSelectionChanged
		to: self.
	viewList
		when: #actionPerformed
		send: #onListActionPerformed
		to: self.
	presenterTree
		when: #selectionChanged
		send: #onTreeSelectionChanged
		to: self.
	presenterList
		when: #actionPerformed
		send: #onListActionPerformed
		to: self.
	(self view viewNamed: 'cards') layoutManager
		when: #currentCardChanged
		send: #onTreeSelectionChanged
		to: self!

currentListPresenter
	"Answer the current list presenter ('view' or 'presenter')"

	^self isViewTab ifTrue: [viewList] ifFalse: [presenterList]!

currentTreePresenter
	"Answer the current tree presenter ('view' or 'presenter')"

	^self isViewTab ifTrue: [viewTree] ifFalse: [presenterTree]!

expand
	"Expand one level of the tree starting at the selected node"

	| tree |
	tree := self currentTreePresenter.
	tree hasSelection ifTrue: [tree expand: tree selection]!

hideSnoopee
	snoopedShell topShell hide.
	isHidden := true.
	self updateStatus!

inspectItem
	"Same as double clicking an item"

	self onListActionPerformed!

isViewTab
	"Answer true if the view tab is selected. If it's not the view it must be the presenter"

	^(self view viewNamed: 'cards') currentCard name = 'view'!

onListActionPerformed
	"A list item was double clicked so simply open a standard inspector on it"

	| list |
	list := self currentListPresenter.
	list hasSelection ifTrue: [list selection value inspect]!

onTreeSelectionChanged
	"The tree selection has changed so update the items list"

	| tree list |
	tree := self currentTreePresenter.
	list := self currentListPresenter.
	tree hasSelection
		ifTrue: [list list: tree selection snoopAspects]
		ifFalse: [list list: OrderedCollection new].
	list view layout!

onViewClosed
	super onViewClosed.
	self closeSnoopee!

queryCommand: aCommandQuery
	| command |
	super queryCommand: aCommandQuery.
	command := aCommandQuery command.
	(#(#report #collapse #expand #refreshTree) includes: command)
		ifTrue: [aCommandQuery isEnabled: snoopedShell notNil].
	command == #hideSnoopee
		ifTrue: [aCommandQuery enabled: (snoopedShell notNil and: [isHidden not])].
	command == #showSnoopee
		ifTrue: [aCommandQuery enabled: (snoopedShell notNil and: [isHidden])].
	(#(#inspectItem #refreshItem) includes: command)
		ifTrue: [aCommandQuery isEnabled: viewList hasSelection | presenterList hasSelection]!

refreshItem
	"Force a refresh the items currently selected in the tree"

	| list selectionIndex |
	list := self currentListPresenter.
	selectionIndex := list selectionByIndex.
	self onTreeSelectionChanged.
	list selectionByIndex: selectionIndex!

refreshTree
	"Set the tree presenters model for the first time or after it has changed. Expand and
	select the 	top level when the tree is displayed as will only have a small number of 
	nodes and it also looks better.
	It would be nice to be able to reselect the currently selected item here but ... to do
	this the parent block (see SnoopHierarchy) needs to work but ... a number of items
	that we put in the tree don't know who their parent (or even top view) is !! (menus 
	for example) and finding out would not be an easy task. Seems easier to ignore it"

	viewTree model: (self treeModelFor: snoopedShell view).
	viewTree
		expand: snoopedShell view;
		selection: snoopedShell view.
	presenterTree model: (self treeModelFor: snoopedShell).
	presenterTree
		expand: snoopedShell;
		selection: snoopedShell.
	self updateStatus!

report
	"Opens up a SmalltalkWorkspaceDocument containing the same information
	as the tree but in a text form that can be saved or printed"

	| stream report |
	stream := String writeStream.
	self
		report: snoopedShell view
		on: stream
		indent: 0.
	report := SmalltalkWorkspaceDocument show.
	report caption: 'Snoop Report on ' , snoopedShell printString.
	report workspace view font: (Font name: 'Courier New' pointSize: 11).
	report workspace text: stream contents!

report: aView on: aStream indent: anInteger
	"Recursively duplicate the information held in the snoop tree onto aStream"

	| indent |
	indent := (String new: anInteger) atAllPut: $ .
	aStream
		nextPutAll: indent;
		nextPutAll: aView snoopDescription;
		cr.
	indent := indent , ' o '.
	((aView snoopAspects)
		removeFirst;
		yourself)
		do:
			[:each | 
			aStream
				nextPutAll: indent;
				nextPutAll: ('%-24s ' sprintfWith: each key);
				nextPutAll: each value printString;
				cr].
	aView snoopChildren
		do:
			[:each | 
			self
				report: each
				on: aStream
				indent: anInteger + 4]!

showSnoopee
	snoopedShell topShell show.
	isHidden := false.
	self updateStatus.
	self topShell setFocus!

snoopee
	"Start up Snoop on an open instance of the selected class. Ensure that any shell
	currently being snooped is closed down first"

	| classList snoopeeClass snoopee |
	classList := CompositePresenter allSubclasses.	"CommonDialog can only be opened modal so we can't snoop on them"
	classList := classList reject: [:each | each includesBehavior: CommonDialog].	"Causes problems as it expects to be updated"
	classList := classList reject: [:each | each includesBehavior: ProgressDialog].
	snoopeeClass := ChoicePrompter
		choices: classList asSortedCollection
		caption: 'Select a Class to Snoop on'.
	snoopeeClass isNil ifTrue: [^self].
	[snoopee := snoopeeClass show]
		on: Error
		do: [:e | ^MessageBox notify: 'Unable to snoop on ' , snoopeeClass name].
	self snoopOn: snoopee.
	self topShell setFocus!

snoopOn: aShell
	"Keep a reference to the shell, so it can be refreshed again later"

	self closeSnoopee.
	snoopedShell := aShell.
	snoopedShell
		when: #viewClosed
		send: #close
		to: self view.
	isHidden := false.
	self refreshTree!

treeModelFor: anObject
	"Answer a new tree model suitable for either of the trees used"

	^(VirtualTreeModel new)
		getChildrenBlock: [:each | each snoopChildren];
		getParentBlock: [:each | self error: 'Should never get here'];
		hasChildrenBlock: [:each | each snoopChildren notEmpty];
		roots: (Array with: anObject);
		yourself!

updateStatus
	status
		value:
			((String writeStream)
				nextPutAll: '  Snooping - ';
				print: snoopedShell;
				nextPutAll: (isHidden ifTrue: [' (Hidden)'] ifFalse: ['']);
				contents)! !
!Snoop categoriesFor: #about!commands!public! !
!Snoop categoriesFor: #closeSnoopee!helpers!initializing!public! !
!Snoop categoriesFor: #collapse!commands!public! !
!Snoop categoriesFor: #createComponents!initializing!public! !
!Snoop categoriesFor: #createSchematicWiring!initializing!public! !
!Snoop categoriesFor: #currentListPresenter!helpers!public! !
!Snoop categoriesFor: #currentTreePresenter!helpers!public! !
!Snoop categoriesFor: #expand!commands!public! !
!Snoop categoriesFor: #hideSnoopee!commands!public! !
!Snoop categoriesFor: #inspectItem!commands!public! !
!Snoop categoriesFor: #isViewTab!public!testing! !
!Snoop categoriesFor: #onListActionPerformed!event handling!public! !
!Snoop categoriesFor: #onTreeSelectionChanged!event handling!public! !
!Snoop categoriesFor: #onViewClosed!event handling!public! !
!Snoop categoriesFor: #queryCommand:!commands!public! !
!Snoop categoriesFor: #refreshItem!commands!public! !
!Snoop categoriesFor: #refreshTree!commands!public! !
!Snoop categoriesFor: #report!commands!public! !
!Snoop categoriesFor: #report:on:indent:!helpers!public! !
!Snoop categoriesFor: #showSnoopee!commands!public! !
!Snoop categoriesFor: #snoopee!commands!public! !
!Snoop categoriesFor: #snoopOn:!initializing!public! !
!Snoop categoriesFor: #treeModelFor:!commands!public! !
!Snoop categoriesFor: #updateStatus!helpers!public! !

!BasicInspector methodsFor!

queryCommand: query 
	"Private - Enter details about a potential command for the receiver into the 
	<CommandQuery>, query."

	| cmd hasSel |
	super queryCommand: query.
	cmd := query commandSymbol.
	hasSel := variableNamesPresenter hasSelection.
	(#(#inspectReferences #basicInspectIt) includes: cmd) 
		ifTrue: 
			[query isEnabled: hasSel.
			^true].
	#inspectIt == cmd 
		ifTrue: 
			[query
				isEnabled: hasSel;
				isDefault: hasSel.
			^true].
	(#(#accept #nilVariable) includes: cmd) 
		ifTrue: 
			[query isEnabled: (hasSel and: [self variableIndex > self headerSize]).
			^true].
	(#(#browseHierarchy #browseSystem #browseClass) identityIncludes: cmd) 
		ifTrue: 
			[| class |
			[hasSel ifTrue: [class := self variable class]] on: Error do: [:e | ].
			class isNil 
				ifFalse: 
					[query
						isEnabled: (self respondsTo: cmd);
						text: 'Browse ' , class name.
					^true]
				ifTrue: 
					[query
						isEnabled: false;
						text: query commandDescription menuText]].
	cmd == #undo 
		ifTrue: 
			[query
				beDisabled;
				text: (query commandDescription menuText formatWith: '').
			^true].
	^false! !
!BasicInspector categoriesFor: #queryCommand:!commands!private! !

!DictionaryPresenter class methodsFor!

defaultModel
	"Answer a default model to be assigned to the receiver when it
	is initialized."

	^Dictionary new asValue! !
!DictionaryPresenter class categoriesFor: #defaultModel!models!public! !

SpinnerPresenter comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!SpinnerPresenter class methodsFor!

icon
	^Spinner icon! !
!SpinnerPresenter class categoriesFor: #icon!constants!public! !

!SpinnerPresenter methodsFor!

createComponents
	super createComponents.
	numberPresenter := self add: NumberPresenter new name: 'number'.
	spinPresenter := self add: NumberPresenter new name: 'spin'!

createSchematicWiring
	super createSchematicWiring.
	numberPresenter
		when: #valueChanged
		send: #onNumberValueChanged
		to: self.
	spinPresenter
		when: #valueChanged
		send: #onSpinValueChanged
		to: self!

onNumberValueChanged
	spinPresenter view udmSetPos32: numberPresenter value!

onSpinValueChanged
	numberPresenter value: spinPresenter view udmGetPos32!

onViewOpened
	super onViewOpened.
	spinPresenter view range: (16r7FFFFFFF to: -16r7FFFFFFF).	"The numberPresenter shares our model.  The spinPresenter has it's own model which 
	we ignore, other than using it's trigger mechanism.  If we need to set/get the value of the 
	spinner we go straight to the Windows api"
	numberPresenter
		model: self model;
		onValueChanged! !
!SpinnerPresenter categoriesFor: #createComponents!initializing!public! !
!SpinnerPresenter categoriesFor: #createSchematicWiring!initializing!public! !
!SpinnerPresenter categoriesFor: #onNumberValueChanged!event handling!public! !
!SpinnerPresenter categoriesFor: #onSpinValueChanged!event handling!public! !
!SpinnerPresenter categoriesFor: #onViewOpened!event handling!public! !

!GUISessionManager methodsFor!

showSplash
	"Show a splash screen for this session. Can be overidden in subclasses to bring up
	an appropriate splash." 

	^false
!

tertiaryStartup
	"Perform GUI  system tertiary startup"

	| splashShown |
	"Pop-up the splash screen before the windows are restored"
	splashShown := (self cmdLineFlags includes: 'nosplash') not and: [self showSplash ~~ false].
	super tertiaryStartup.
	splashShown ifFalse: [self trigger: #sessionReady]! !
!GUISessionManager categoriesFor: #showSplash!operations!public! !
!GUISessionManager categoriesFor: #tertiaryStartup!operations-startup!public! !

!CommandLineCalculator methodsFor!

main
	"Implement the main body of the command line version of the Calculator application."

	| expr |
	(self stdout)
		nextPutAll: 'Dolphin Smalltalk Console Calculator Sample';
		cr;
		nextPutAll: 'Copyright (c) Object Arts Ltd, 2001-2004.';
		cr.
	
	[(self stdout)
		cr;
		nextPutAll: '> ';
		flush.
	expr := self stdin nextLine.
	expr isEmpty and: [self stdin atEnd]] 
			whileFalse: 
				[| result |
				
				[(self stdout)
					display: (Compiler evaluate: expr logged: false);
					cr;
					flush] 
						on: CompilerErrorNotification , Error
						do: 
							[:x | 
							(self stderr)
								display: x;
								cr;
								flush]]! !
!CommandLineCalculator categoriesFor: #main!operations-startup!public! !

!DevelopmentSessionManager methodsFor!

initializeFromSessionManager: oldSessionManager 
	"Private - The receiver has taken take over as the current session
	manager from oldSessionManager. This is an opportunity to transfer
	state information from the replaced manager."

	super initializeFromSessionManager: oldSessionManager.
	self productDetails: oldSessionManager productDetails.
	self 
		when: #queryEndSession:
		send: #onQueryEndSession:
		to: self.
	self 
		when: #sessionReady
		send: #onSessionReady
		to: self!

onQueryEndSession: aBooleanValue 
	"The user has initiated the end of the session, either by shutting down (or logging off of)
	Window, or by closing the system launcher window. Prompt the user to save the image, and
	give them the opportunity to abort the shutdown."

	self isEmbedded ifTrue: [^self].
	(MessageBox new)
		taskModal;
		confirm: 'You are about to exit Dolphin Smalltalk.
Do you wish to save the image?'
			onYes: [self saveImage]
			onNo: []
			onCancel: [aBooleanValue value: false]!

onSessionReady
	"The Session is ready, the splash screen (if any) having closed."

	Smalltalk developmentSystem tipOfTheDayAtStartup!

retire
	"This SessionManager instance is stepping down in favour of a new boy. Perform any
	uninitialisation that might be required; because the session manager instances are swapped
	with become, we must make sure to remove any unwanted event subscriptions as these will be
	transferred to the new session manager."

	self removeEventsTriggeredFor: self!

showSplash
	"Show a splash screen for this session."

	^self splashShellClass 
		ifNil: [false]
		ifNotNil: 
			[:splashClass | 
			(splashClass new)
				when: #viewClosed
					send: #trigger:
					to: self
					with: #sessionReady;
				showTimed.
			true]! !
!DevelopmentSessionManager categoriesFor: #initializeFromSessionManager:!initializing!private! !
!DevelopmentSessionManager categoriesFor: #onQueryEndSession:!public! !
!DevelopmentSessionManager categoriesFor: #onSessionReady!event handling!public! !
!DevelopmentSessionManager categoriesFor: #retire!public! !
!DevelopmentSessionManager categoriesFor: #showSplash!operations!public! !

!ProtectedProductSessionManager methodsFor!

cipherMethod: aCompiledMethod with: aPC1Cipher 
	"Private - Encrypts aCompiledMethod using aPC1Cipher"

	| cipheredBytecodes |
	aPC1Cipher reset.
	cipheredBytecodes := aCompiledMethod byteCodes collect: [:each | aPC1Cipher cipher: each].
	aCompiledMethod byteCodes: cipheredBytecodes! !
!ProtectedProductSessionManager categoriesFor: #cipherMethod:with:!operations!private! !

!ChunkSourceFiler methodsFor!

fileOutBinaryGlobal: anAssociation 
	"File out the text representation of the non-<sourceObject> which is the value of the
	<Association>, anAssociation, onto the receiver's source stream. The key of the association
	is the global name. If the global is just an alias to a class, then we don't need to binary
	file it at all."

	| glob |
	glob := anAssociation value.
	(glob class isMeta and: [anAssociation key ~= glob name]) 
		ifTrue: 
			[stream
				nextPutAll: anAssociation key;
				nextPutAll: ' := ';
				print: anAssociation value;
				nextPut: $!!;
				cr.
			^self].
	stream
		nextPutAll: anAssociation key;
		nextPutAll: ' := ';
		print: Object;
		space;
		display: #fromBinaryStoreBytes:;
		space;
		cr.
	glob binaryStoreBytes base64StoreOn: stream.
	stream
		nextPut: $!!;
		cr!

fileOutPoolDictionary: aPoolDictionary 
	"Append a definition of the <PoolDictionary> (or <PoolConstantsDictionary>, aPoolDictionary,
	to the <puttableStream>, aWriteStream. The definition should be sufficient to recreate a
	copy of the dictionary."

	| poolName value env |
	env := aPoolDictionary environment.
	poolName := aPoolDictionary name.
	stream
		nextPutAll: (env keyAtValue: env);
		nextPutAll: ' at: ';
		print: poolName;
		nextPutAll: ' put: (';
		nextPutAll: aPoolDictionary class name;
		nextPutAll: ' named: ';
		print: aPoolDictionary name.
	self emitChunk: ')'.
	aPoolDictionary associations asSortedCollection do: 
			[:a | 
			stream
				nextPutAll: poolName;
				nextPutAll: ' at: ';
				print: a key;
				nextPutAll: ' put: '.
			value := a value.
			value isLiteral 
				ifTrue: 
					[self emitChunk: (value isInteger ifTrue: [value printStringRadix: 16] ifFalse: [value printString])]
				ifFalse: 
					[stream
						nextPut: $(;
						print: Object;
						space;
						display: #fromBinaryStoreBytes:;
						space;
						cr.
					value binaryStoreBytes base64StoreOn: stream.
					self emitChunk: ')']].
	self emitChunk: poolName , ' shrink'!

fileOutResource: aResourceIdentifier 
	"Append a definition of the resource identified by the <ResourceIdentifier>,
	aResourceIdentifer, to the <puttableStream>, aWriteStream. The definition should be
	sufficient to recreate a copy of the resource."

	stream
		nextPut: $(;
		print: aResourceIdentifier class;
		nextPutAll: ' class: ';
		print: aResourceIdentifier owningClass;
		nextPutAll: ' name: ';
		print: aResourceIdentifier name;
		nextPutAll: ') assign: (';
		print: Object;
		space;
		display: #fromBinaryStoreBytes:;
		cr.
	aResourceIdentifier resource asInternalResource binaryStoreBytes base64StoreOn: stream.
	self emitChunk: ')'! !
!ChunkSourceFiler categoriesFor: #fileOutBinaryGlobal:!public!source filing! !
!ChunkSourceFiler categoriesFor: #fileOutPoolDictionary:!public!source filing! !
!ChunkSourceFiler categoriesFor: #fileOutResource:!public!source filing! !

!BlockFrame methodsFor!

argsOffset
	^(self tempsBeforeIp: self block initialIP - 1) size! !
!BlockFrame categoriesFor: #argsOffset!accessing!private! !

!StatusBarItem methodsFor!

snoopSecond
	"Answer any items (name and value) that snoop should display for the receiver"

	#idbAdded.
	^(super snoopSecond)
		add: 'Value' -> (self model ifNotNil: [:arg | arg value]);
		add: 'Get Text Block' -> self getTextBlock;
		add: 'Get Image Block' -> self getImageBlock;
		add: 'Image Manager' -> self imageManager;
		yourself! !
!StatusBarItem categoriesFor: #snoopSecond!accessing!idb goodies!public! !

!STBInFiler methodsFor!

readInteger
	"Answer the next 32-bit integer in the stream."

	^stream nextSDWORD!

readObjectOfClass: aClass 
	^aClass stbReadFrom: self format: (converters at: aClass ifAbsent: []).
	"^self readObjectOfClass: aClass format: (converters at: aClass ifAbsent: [])"!

readObjectOfClass: aClass format: anSTBClassConversion 
	"Private - Read the stream for the data to create an instance of aClass."

	"First, read the basicSize (number of indexed variables)."

	| basicSize fullSize newObject |
	basicSize := stream nextSDWORD.
	"Create a new object of sufficient size to hold the stored data."
	anSTBClassConversion isNil 
		ifTrue: 
			["The object is of the current format.
			Create an instance of the appropriate class."
			fullSize := aClass instSize + basicSize.
			newObject := aClass isVariable ifTrue: [aClass basicNew: basicSize] ifFalse: [aClass basicNew]]
		ifFalse: 
			["The object is of an old format.
			Create an Array or ByteArray to hold the stored data. This is
			passed to the converter block which answers an instance of the
			real class initialised from it."
			fullSize := anSTBClassConversion instSize + basicSize.
			newObject := (anSTBClassConversion isBytes ifTrue: [ByteArray] ifFalse: [Array]) basicNew: fullSize].
	self register: newObject.

	"Read the object's instance data."
	aClass isBytes 
		ifTrue: 
			["Many of these objects will be Strings, so some optimization may be possible"
			1 to: fullSize do: [:i | newObject basicAt: i put: stream next]]
		ifFalse: [1 to: fullSize do: [:i | newObject instVarAt: i put: self basicNext]].
	anSTBClassConversion notNil 
		ifTrue: 
			["Initialise a new instance from the old format object data and become it."
			newObject become: (anSTBClassConversion converterBlock value: newObject)].
	^newObject! !
!STBInFiler categoriesFor: #readInteger!helpers!public! !
!STBInFiler categoriesFor: #readObjectOfClass:!accessing!private! !
!STBInFiler categoriesFor: #readObjectOfClass:format:!operations!private! !

!STBOutFiler methodsFor!

writePreambleFor: anObject 
	self
		writeClass: anObject class withPrefix: STBPrefix forData;
		register: anObject! !
!STBOutFiler categoriesFor: #writePreambleFor:!binary filing!public! !

!RBConfigurableFormatter class methodsFor!

initialize
	"
		self initialize
	"

	FormatCommentWithStatements := true.
	IndentsForKeywords := 1.
	IndentString := String with: Character tab.
	LineUpBlockBrackets := false.
	MaxLineLength := 90.
	MethodSignatureOnMultipleLines := false.
	MinimumNewLinesBetweenStatements := 1.
	NewLineAfterCascade := true.
	NewLineBeforeFirstCascade := true.
	NewLineBeforeFirstKeyword := true.	

	"One blank line after method comment"
	NewLinesAfterMethodComment := 2.
	NewLinesAfterMethodPattern := 1.
	NewLinesAfterTemporaries := 1.
	NumberOfArgumentsForMultiLine := 3.
	PeriodsAtEndOfBlock := PeriodsAtEndOfMethod := false.
	RetainBlankLinesBetweenStatements := false.
	StringFollowingReturn := ''.
	StringInsideBlocks := ''.
	StringInsideParentheses := ''.
	TraditionalBinaryPrecedence := #(#($| $& $?) #($= $~ $< $>) #($- $+) #($* $/ $% $\) #($@)).
	UseTraditionalBinaryPrecedenceForParentheses := true!

periodsAsTerminators
	^PeriodsAtEndOfBlock and: [PeriodsAtEndOfMethod]!

periodsAsTerminators: aBoolean 
	PeriodsAtEndOfBlock := aBoolean.
	PeriodsAtEndOfMethod := aBoolean!

periodsAtEndOfBlock
	^PeriodsAtEndOfBlock!

periodsAtEndOfBlock: aBoolean 
	PeriodsAtEndOfBlock := aBoolean!

periodsAtEndOfMethod
	^PeriodsAtEndOfMethod!

periodsAtEndOfMethod: aBoolean 
	PeriodsAtEndOfMethod := aBoolean! !
!RBConfigurableFormatter class categoriesFor: #initialize!initializing!public! !
!RBConfigurableFormatter class categoriesFor: #periodsAsTerminators!public!settings! !
!RBConfigurableFormatter class categoriesFor: #periodsAsTerminators:!public!settings! !
!RBConfigurableFormatter class categoriesFor: #periodsAtEndOfBlock!public! !
!RBConfigurableFormatter class categoriesFor: #periodsAtEndOfBlock:!public! !
!RBConfigurableFormatter class categoriesFor: #periodsAtEndOfMethod!public! !
!RBConfigurableFormatter class categoriesFor: #periodsAtEndOfMethod:!public! !

!RBConfigurableFormatter methodsFor!

formatSequenceNodeStatementsFor: aSequenceNode 
	| statements |
	statements := aSequenceNode statements.
	statements isEmpty ifTrue: [^self].
	1 to: statements size
		do: 
			[:i | 
			self visitNode: (statements at: i).
			(i < statements size or: 
					[aSequenceNode parent 
						ifNil: [self class periodsAsTerminators]
						ifNotNil: 
							[:parent | 
							parent isBlock 
								ifTrue: [self class periodsAtEndOfBlock]
								ifFalse: [self class periodsAtEndOfMethod]]]) 
				ifTrue: [codeStream nextPut: $.].
			self formatStatementCommentsFor: (statements at: i).
			i < statements size 
				ifTrue: [self addNewLinesBeforeStatementStartingAt: (statements at: i + 1) start]]! !
!RBConfigurableFormatter categoriesFor: #formatSequenceNodeStatementsFor:!formatting!private! !

!RBFormatter class methodsFor!

initialize
	"
		self initialize
	"

	#rbFix.	"Added"
	self maximumLineWidth: 90.
	self maximumArgumentsPerLine: 2.
	self selectorsToLeaveOnLine: #(#to:do: #to:by: #to:by:do:).
	self 
		selectorsToStartOnNewLine: #(#ifTrue:ifFalse: #ifFalse:ifTrue: #ifTrue: #ifFalse: #ifNil: #ifNotNil: #ifNil:ifNotNil: #ifNotNil:ifNil:)! !
!RBFormatter class categoriesFor: #initialize!initializing!public! !

!StMethodNode methodsFor!

= anObject 
	self == anObject ifTrue: [^true].
	self class = anObject class ifFalse: [^false].
	(self selector = anObject selector and: [self body = anObject body]) ifFalse: [^false].
	1 to: self arguments size
		do: [:i | (self arguments at: i) = (anObject arguments at: i) ifFalse: [^false]].
	^self tag = anObject tag! !
!StMethodNode categoriesFor: #=!comparing!public! !

!StExternalCallNode methodsFor!

= anObject 
	self == anObject ifTrue: [^true].
	self class = anObject class ifFalse: [^false].
	#todo "Implement more efficiently".
	^self formattedCode = anObject formattedCode! !
!StExternalCallNode categoriesFor: #=!comparing!public! !

!StPrimitiveNode methodsFor!

= anObject 
	self == anObject ifTrue: [^true].
	self class = anObject class ifFalse: [^false].
	^self primitiveIndex = anObject primitiveIndex! !
!StPrimitiveNode categoriesFor: #=!comparing!public! !

!StLiteralArrayNode methodsFor!

equalTo: anObject withMapping: aDictionary 
	self class = anObject class ifFalse: [^false].
	self isForByteArray = anObject isForByteArray ifFalse: [^false].
	self contents size = anObject contents size ifFalse: [^false].
	1 to: self contents size
		do: 
			[:i | 
			((self contents at: i) equalTo: (anObject contents at: i) withMapping: aDictionary) 
				ifFalse: [^false]].
	^true! !
!StLiteralArrayNode categoriesFor: #equalTo:withMapping:!comparing!public! !

!SequencedStream methodsFor!

contents
	"Answer all of the objects in the collection accessed by the receiver.
	Generally the collection will be the same class as the one accessed by the receiver."

	^self subclassResponsibility
!

nextWord
	"Answer the next 'word' in the receiver's element stream, where a word is defined as a
	sequence of one or more elements delimited by an elements which answer true to #isSeparator,
	or nil if there are no more words in the receiver. Leading separators are skipped. The
	stream is left positioned after the first trailing separator."

	| wordStream element |
	self skipSeparators ifFalse: [^nil].
	wordStream := self contentsSpecies writeStream: 32.
	[self atEnd] whileFalse: 
			[element := self next.
			element isSeparator ifTrue: [^wordStream contents].
			wordStream nextPut: element].
	^wordStream contents! !
!SequencedStream categoriesFor: #contents!accessing!public! !
!SequencedStream categoriesFor: #nextWord!accessing!public! !

!PositionableStream methodsFor!

isEmpty
	"Answer whether the Stream is accessing an empty collection"

	^self size == 0!

positionsOf: aString oneOnly: aBoolean
	"Private - Go through the receiver and answer a collection of all the offsets 
	where aString  occurs. If aBoolean is true than bale out after the first is found"

	| positions |
	#idbAdded.
	positions := Set new.
	self reset.
	[self atEnd]
		whileFalse:
			[| startPosition bytes offset |
			self position > aString size ifTrue: [self position: self position - aString size].
			startPosition := self position.
			bytes := self nextAvailable: 500000.
			offset := 1.
			[offset = 0]
				whileFalse:
					[(offset := bytes indexOfSubCollection: aString startingAt: offset) = 0
						ifFalse:
							[positions add: startPosition + offset + aString size - 1.
							aBoolean ifTrue: [^positions].
							offset := offset + 1]]].
	^positions asSortedCollection!

reverseContents
	"Answer a copy of the receiver's contents in reverse order."

	| newCollection size |
	size := self size.
	newCollection := self contentsSpecies new: size.
	1 to: size do: [:i | newCollection at: i put: (collection at: size - i + 1)].
	^newCollection! !
!PositionableStream categoriesFor: #isEmpty!public!testing! !
!PositionableStream categoriesFor: #positionsOf:oneOnly:!idb goodies!public!searching! !
!PositionableStream categoriesFor: #reverseContents!accessing!public! !

!StdioFileStream methodsFor!

size
	"Answer the size of the file in bytes. Enquiring the size of streams connected
	to, for example, stdin is an error."

	| len |
	self flush.
	^(len := CRTLibrary default _filelength: self fileno) == -1 
		ifTrue: [CRTError signal]
		ifFalse: [len]! !
!StdioFileStream categoriesFor: #size!accessing!public! !

!ReadStream methodsFor!

next: count into: aSequenceableCollection startingAt: startAt
	"Destructively replace the elements of the argument, aSequenceableCollection,
	in the interval (startAt..startAt+count-1) with the next, count, elements of
	the receiver. Answer aSequenceableCollection."

	| stop |
	stop := self positionAfterNext: count.
	aSequenceableCollection
		replaceFrom: startAt
		to: startAt+count-1
		with: collection
		startingAt: position+1.
	self position: stop.
	^aSequenceableCollection! !
!ReadStream categoriesFor: #next:into:startingAt:!accessing!public! !

!ReadWriteStream methodsFor!

next: count into: aSequenceableCollection startingAt: startAt
	"Destructively replace the elements of the argument, aSequenceableCollection,
	in the interval (startAt..startAt+count-1) with the next, count, elements of
	the receiver. Answer aSequenceableCollection."

	| stop |
	stop := self positionAfterNext: count.
	aSequenceableCollection
		replaceFrom: startAt
		to: startAt+count-1
		with: collection
		startingAt: position+1.
	self position: stop.
	^aSequenceableCollection! !
!ReadWriteStream categoriesFor: #next:into:startingAt:!accessing!public! !

!FileStream methodsFor!

file
	"Answer the <File> instance over which the receiver is streaming."

	^file!

position: anInteger 
	"Move the receiver's logical position to absolute (zero-based) position anInteger."

	| pos |
	readLimit < position ifTrue: [readLimit := position].
	pos := anInteger + 1.
	(pos < pageBase or: [pos >= (pageBase + writeLimit)]) 
		ifTrue: 
			["anInteger is not within the current page.
			Write out any changes to the current page buffer and read the one required."
			self
				flush;
				readPageFor: anInteger].
	position := pos - pageBase! !
!FileStream categoriesFor: #file!accessing!public! !
!FileStream categoriesFor: #position:!accessing!positioning!public! !

!StLiteralToken methodsFor!

storeOn: aStream 
	(value isKindOf: Symbol) 
		ifTrue: 
			[aStream nextPut: $#.
			((SmalltalkScanner isSelector: value) and: [value ~~ #'||']) 
				ifTrue: [aStream nextPutAll: value]
				ifFalse: [value asString printOn: aStream].
			^self].
	value class == Character 
		ifTrue: 
			[aStream
				nextPut: $$;
				nextPut: value.
			^self].
	value storeOn: aStream! !
!StLiteralToken categoriesFor: #storeOn:!printing!public! !

!ToolbarButton methodsFor!

snoopDescription
	"Answer a description of the receiver for the snoop tree"

	#idbAdded.
	^self snoopDescription: self command printString!

snoopSecond
	"Answer any items (name and value) that snoop should disply for the receiver"

	#idbAdded.
	^(super snoopSecond)
		add: 'Parent' -> self parent;
		add: 'Bitmap' -> self bitmap;
		add: 'Bitmap Index' -> self bitmapIndex;
		add:
				'Style'
						->
							(ControlBarConstants
								snoopConstant: self style
								from:
									#(#BTNS_CHECK #BTNS_BUTTON #BTNS_CHECKGROUP #BTNS_GROUP #BTNS_SEP #BTNS_DROPDOWN));
		add: 'Enabled' -> self enabled;
		add: 'Checked' -> self checked;
		add: 'Pressed' -> self pressed;
		yourself! !
!ToolbarButton categoriesFor: #snoopDescription!displaying!idb goodies!public! !
!ToolbarButton categoriesFor: #snoopSecond!accessing!idb goodies!public! !

!ToolbarSeparator methodsFor!

snoopThird
	"Answer any items (name and value) that snoop should disply for the receiver"

	#idbAdded.
	^(super snoopThird)
		add:
				'Style'
						->
							(ControlBarConstants
								snoopConstant: self style
								from: #(#BTNS_CHECK #BTNS_BUTTON #BTNS_CHECKGROUP #BTNS_GROUP #BTNS_SEP));
		add: 'Width' -> self width;
		yourself! !
!ToolbarSeparator categoriesFor: #snoopThird!accessing!idb goodies!public! !

ProfilerTreeNode comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ProfilerTreeNode methodsFor!

addFrame: aStackFrame elapsedTime: anInteger
	"If aStackFrame is already present a child of the receiver then we just update its values
	(tally and time). If it is a new child then  we have to create an empty node and add it to 
	the tree first
	Answer the child node"

	| node |
	node := self children
		detect: [:eachChild | eachChild object isSameFrameAs: aStackFrame]
		ifNone: [self addChildNode: (ProfilerTreeNode for: (ProfilerFrame frame: aStackFrame))].
	node
		incrementTally;
		incrementTimeBy: anInteger.
	^node!

allClasses
	"Answer a Set of all the classes used by nodes between this node and the
	root of the tree. Cache the Set for improved performance (any subnodes doing
	the same thing will only need to go this far up the tree). The cache is cleared
	via clearCache when the tree is changed"

	classes isNil
		ifTrue:
			[classes := self parent notNil
				ifTrue:
					[(self parent allClasses copy)
						add: self object methodClass;
						yourself]
				ifFalse: [Set new]].
	^classes!

allParentFrames
	"Answer an OrderedCollection of all the frame objects between the receiver
	and the root node"

	| frames node |
	frames := OrderedCollection new.
	node := self.
	[node object isNil]
		whileFalse:
			[frames add: node object.
			node := node parent].
	^frames!

allSelectors
	"Answer a Set of all the methods (a description is an Association containging the method 
	class and the selector name) used by nodes between this node and the root of the tree. 
	Cache the Set for improved performance (any subnodes doingthe same thing will only 	need 
	to go this far up the tree). The cache is cleared via clearCache when the tree is changed"

	selectors isNil
		ifTrue:
			[selectors := self parent notNil
				ifTrue:
					[(self parent allSelectors copy)
						add: self object selectorDescription;
						yourself]
				ifFalse: [Set new]].
	^selectors!

children
	"Answers an SortedColletion of the child nodes of the receiver
	The profiler tree looks better if the children nodes are in ip order so
	that the execution flow goes through the nodes in sequence. Subclassing seems
	the only way to order the child nodes?"

	children isNil
		ifTrue: [^SortedCollection sortBlock: [:a :b | a object ip <= b object ip]].
	^children!

clearCache
	"The tree is either being reused or a new set of samples are about to be added
	to it. In either case we must clear all the cached values for this node and all of its kiddies"

	classes := nil.
	selectors := nil.
	self children do: [:each | each clearCache]!

firstChild
	^self hasChildren ifTrue: [self children first]!

hasChildren
	^self children notEmpty!

incrementTally
	"Advance the tally by one"

	tally := tally + 1!

incrementTimeBy: anInteger
	"Advance the time taken for this node by anInteger"

	time := time + anInteger!

isAbove: aFloat
	"Answers true if either of the fields isAbove aFloat (a percentage).
	This should really just check one filed, for the receivers type of tree, but this is much easier
	and should make little difference as the percentages are usually very similar"

	^tally > aFloat or: [time > aFloat]!

isChildOfFrameFor: aCompiledCode
	"Answer true if the frame represented by this node has the same class and selector
	as aCompiledCode. If not check the parent of this node etc etc"

	self object isNil ifTrue: [^false].
	(self object doClassAndSelectorMatch: aCompiledCode) ifTrue: [^true].
	^self parent isChildOfFrameFor: aCompiledCode!

isDolphinBranch
	"Answer true is this node, and all of its children, are in the Dolphin
	package. Used to filter out the Dolphin classes in the tree"

	self object isInSystemPackage ifFalse: [^false].
	^self children allSatisfy: [:each | each isDolphinBranch]!

isParentOfFrameFor: aCompiledCode
	"Answer true if the frame represented by this node has the same class and selector
	as aCompiledCode. If not check the children of this node etc etc. Only answers true
	if neither this node or any of its subnodes match aCompiledCode"

	(self object doClassAndSelectorMatch: aCompiledCode) ifTrue: [^true].
	^self children anySatisfy: [:each | each isParentOfFrameFor: aCompiledCode]!

object: aProfilerFrame
	"Set aFarame as the object for this node and initialize the tally and time counts"

	super object: aProfilerFrame.
	tally := 0.
	time := 0!

tally
	"Answer the value of the receiver's instance variable tally.
	This method was automatically generated, but may be modified."

	^tally!

time
	"Answer the value of the receiver's instance variable time.
	This method was automatically generated, but may be modified."

	^time! !
!ProfilerTreeNode categoriesFor: #addFrame:elapsedTime:!profiling!public! !
!ProfilerTreeNode categoriesFor: #allClasses!operations!public! !
!ProfilerTreeNode categoriesFor: #allParentFrames!operations!public! !
!ProfilerTreeNode categoriesFor: #allSelectors!operations!public! !
!ProfilerTreeNode categoriesFor: #children!accessing!public! !
!ProfilerTreeNode categoriesFor: #clearCache!operations!public! !
!ProfilerTreeNode categoriesFor: #firstChild!accessing!public! !
!ProfilerTreeNode categoriesFor: #hasChildren!public!testing! !
!ProfilerTreeNode categoriesFor: #incrementTally!operations!public! !
!ProfilerTreeNode categoriesFor: #incrementTimeBy:!operations!public! !
!ProfilerTreeNode categoriesFor: #isAbove:!public!testing! !
!ProfilerTreeNode categoriesFor: #isChildOfFrameFor:!public!testing! !
!ProfilerTreeNode categoriesFor: #isDolphinBranch!public!testing! !
!ProfilerTreeNode categoriesFor: #isParentOfFrameFor:!public!testing! !
!ProfilerTreeNode categoriesFor: #object:!accessing!public! !
!ProfilerTreeNode categoriesFor: #tally!accessing!public! !
!ProfilerTreeNode categoriesFor: #time!accessing!public! !

!AccelToHotKey class methodsFor!

hotKeyToAccelModifiers: hotKeyModMask
	"Private - Convert a hot key modifier mask to the equivalent accelerator table
	mask."

	| accelMask |
	accelMask := FVIRTKEY.
	ModifierMap do: [:a |
		(hotKeyModMask anyMask: a key)
			ifTrue: [accelMask := accelMask maskSet: a value]].
	^accelMask! !
!AccelToHotKey class categoriesFor: #hotKeyToAccelModifiers:!initializing!private! !

!PluggableTypeConverter class methodsFor!

leftToRight: leftMonadicValuable rightToLeft: rightMonadicValuable 
	"Answer a new instance of the receiver that converts between values 
	in the left domain to values in the the right domain by evaluating the 
	<monadicValuable>, leftMonadicValuable, and which converts in the 
	reverse direction by evaluating the <monadicValuable>, rightMonadicValuable."

	^(self new)
		setLeftToRightBlock: leftMonadicValuable rightToLeftBlock: rightMonadicValuable;
		yourself! !
!PluggableTypeConverter class categoriesFor: #leftToRight:rightToLeft:!instance creation!public! !

CurrencyToText comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!CurrencyToText class methodsFor!

publishedAspectsOfInstances
	"Answer a Set of AspectDescriptors that describe the aspects published
	by instances instances of the receiver"

	^(super publishedAspectsOfInstances)
		add: (Aspect boolean: #zeroFillInteger);
		add: (Aspect boolean: #commas);
		add: (Aspect boolean: #signBeforeCurrency);
		add: (Aspect integer: #integerLength);
		add: (Aspect integer: #fractionLength);
		add: (Aspect string: #currencySymbol);
		yourself! !
!CurrencyToText class categoriesFor: #publishedAspectsOfInstances!constants!must strip!public! !

!CurrencyToText methodsFor!

addCommasTo: aStream
	"Replace the contents of aStream with the original contents but with 
	commas added in the appropriate places"

	| groups |
	groups := OrderedCollection new.
	aStream reset.
	[aStream atEnd] whileFalse: [groups add: (aStream nextAvailable: 3)].
	aStream reset.
	(1 to: groups size - 1)
		do:
			[:index | 
			aStream nextPutAll: (groups at: index).
			(groups at: index) last isDigit & (groups at: index + 1) first isDigit
				ifTrue: [aStream nextPut: $,]].
	aStream nextPutAll: groups last!

commas
	"Add commas to the integer part"

	commas isNil ifTrue: [^self defaultCommas].
	^commas!

commas: aBoolean
	"Add commas to the integer part"

	commas := aBoolean!

currencySymbol
	"The <readableString> used for the currency"

	currencySymbol isNil ifTrue: [^self defaultCurrencySymbol].
	^currencySymbol!

currencySymbol: aString
	"The <readableString> used for the currency"

	currencySymbol := aString!

defaultCommas
	"True if commas should be added to the integer part"

	^true!

defaultCurrencySymbol
	"The <readableString> giving the currency symbol to use"

	^Locale default currency!

defaultFractionLength
	"The default mimimum length after the dp, padded with zeros if needed"

	^2!

defaultIntegerLength
	"The default mimimum length before the dp"

	^1!

defaultSignBeforeCurrency
	"True if the sign comes before the currenct symbol(s)"

	^false!

defaultZeroFillInteger
	"True if extra space to the left of the dp should be zero filled"

	^false!

fractionLength
	"Minimum length after the dp"

	fractionLength isNil ifTrue: [^self defaultFractionLength].
	^fractionLength max: 0!

fractionLength: anInteger
	"Minimum length after the dp"

	fractionLength := anInteger!

fractionSideStringFor: aFloat
	"Answer a String representing the right side of the dp"

	| stream |
	stream := String writeStream.
	aFloat abs fractionPart printOn: stream decimalPlaces: self fractionLength.
	^stream contents copyFrom: 2!

integerFiller
	"Answer the character used for the integer side filler"

	^self zeroFillInteger ifTrue: [$0] ifFalse: [$ ]!

integerLength
	"Minimum length before the dp"

	integerLength isNil ifTrue: [^self defaultIntegerLength].
	^integerLength max: 1!

integerLength: anInteger
	"Minimum length before the dp"

	integerLength := anInteger!

integerSideStringFor: aNumber
	"Answer a String representing the left side of the dp.
		Pad if needed, with the appropriate character
		Insert commas if needed
		Fiddle for negative values and sign after currency to give (with/without padding)
			       -12,345.00
			-0,000,012,345.00
			-123.00
			-1,234.00
		NB The integer field length calculation excludes commas or a sign character"

	| stream padLength |
	stream := ReadWriteStream with: String new.
	stream nextPutAll: aNumber truncated abs printString reverse.
	padLength := self integerLength - stream contents size.
	(aNumber negative and: [self zeroFillInteger not and: [self signBeforeCurrency not]])
		ifTrue: [stream nextPut: $-].
	padLength timesRepeat: [stream nextPut: self integerFiller].
	(aNumber negative and: [self zeroFillInteger and: [self signBeforeCurrency not]])
		ifTrue: [stream nextPut: $-].
	self commas ifTrue: [self addCommasTo: stream].
	^stream contents reverse!

isLeftExceptionalValue: aNumber
	"Don't allow nil or anything not a <number>"

	^(super isLeftExceptionalValue: aNumber)
		or: [(aNumber class conformsToProtocol: #number) not]!

isRightExceptionalValue: aString
	"Don't allow nil, an empty string or anything not a <readableString>
	Note - local test is first to avoid walkback"

	^(aString class conformsToProtocol: #readableString) not
		or: [super isRightExceptionalValue: aString]!

leftToRight: aNumber
	"Convert aNumber into a String.
	Prefix with the default locale currency character(s).
	Insert a sign (if aNumber is negative) either before or after (in #integerSideStringFor:) the currency symbol"

	| stream |
	stream := String writeStream.
	(self signBeforeCurrency and: [aNumber negative]) ifTrue: [stream nextPut: $-].
	stream
		nextPutAll: self currencySymbol;
		nextPutAll: (self integerSideStringFor: aNumber).
	self fractionLength > 0
		ifTrue: [stream nextPutAll: (self fractionSideStringFor: aNumber asFloat)].
	^stream contents!

rightToLeft: aString
	"Convert from aString to a Number. 
	Strip out first -
		currency character(s)
		commas
		spaces"

	| value |
	value := aString copy.
	value := value copyWithoutAll: ', ' , self currencySymbol.
	^Number fromString: value!

signBeforeCurrency
	"Does the sign come before or after the currency symbol"

	signBeforeCurrency isNil ifTrue: [^self defaultSignBeforeCurrency].
	^signBeforeCurrency!

signBeforeCurrency: aBoolean
	"Does the sign come before or after the currency symbol"

	signBeforeCurrency := aBoolean!

zeroFillInteger
	"Zero fill unused space before dp"

	zeroFillInteger isNil ifTrue: [^self defaultZeroFillInteger].
	^zeroFillInteger!

zeroFillInteger: aBoolean
	"Zero fill unused space before dp"

	zeroFillInteger := aBoolean! !
!CurrencyToText categoriesFor: #addCommasTo:!operations!public! !
!CurrencyToText categoriesFor: #commas!accessing!public! !
!CurrencyToText categoriesFor: #commas:!accessing!public! !
!CurrencyToText categoriesFor: #currencySymbol!accessing!public! !
!CurrencyToText categoriesFor: #currencySymbol:!accessing!public! !
!CurrencyToText categoriesFor: #defaultCommas!constants!public! !
!CurrencyToText categoriesFor: #defaultCurrencySymbol!constants!public! !
!CurrencyToText categoriesFor: #defaultFractionLength!constants!public! !
!CurrencyToText categoriesFor: #defaultIntegerLength!constants!public! !
!CurrencyToText categoriesFor: #defaultSignBeforeCurrency!constants!public! !
!CurrencyToText categoriesFor: #defaultZeroFillInteger!constants!public! !
!CurrencyToText categoriesFor: #fractionLength!accessing!public! !
!CurrencyToText categoriesFor: #fractionLength:!accessing!public! !
!CurrencyToText categoriesFor: #fractionSideStringFor:!operations!public! !
!CurrencyToText categoriesFor: #integerFiller!helpers!public! !
!CurrencyToText categoriesFor: #integerLength!accessing!public! !
!CurrencyToText categoriesFor: #integerLength:!accessing!public! !
!CurrencyToText categoriesFor: #integerSideStringFor:!operations!public! !
!CurrencyToText categoriesFor: #isLeftExceptionalValue:!public!testing! !
!CurrencyToText categoriesFor: #isRightExceptionalValue:!public!testing! !
!CurrencyToText categoriesFor: #leftToRight:!operations!public! !
!CurrencyToText categoriesFor: #rightToLeft:!operations!public! !
!CurrencyToText categoriesFor: #signBeforeCurrency!accessing!public! !
!CurrencyToText categoriesFor: #signBeforeCurrency:!accessing!public! !
!CurrencyToText categoriesFor: #zeroFillInteger!accessing!public! !
!CurrencyToText categoriesFor: #zeroFillInteger:!accessing!public! !

DurationToText comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!DurationToText methodsFor!

defaultFormat
	^'d:h:m:s'!

format
	format isNil ifTrue: [^self defaultFormat].
	^format!

format: aStringOrNil
	format := aStringOrNil!

formatDaysIn: aDuration onto: aStream using: aString
	| string |
	string := aDuration days printString.
	string size < aString size
		ifTrue: [string := ((String new: aString size - string size) atAllPut: $0) , string].
	aStream nextPutAll: string!

formatHoursIn: aDuration onto: aStream using: aString
	| hours string |
	hours := aString first isUppercase
		ifTrue:
			[self assert: [aStream position = 0].
			aDuration days * 24 + aDuration hours]
		ifFalse: [aDuration hours].
	string := hours printString.
	string size < aString size
		ifTrue: [string := ((String new: aString size - string size) atAllPut: $0) , string].
	aStream nextPutAll: string!

formatMinutesIn: aDuration onto: aStream using: aString
	| minutes string |
	minutes := aString first isUppercase
		ifTrue:
			[self assert: [aStream position = 0].
			(aDuration days * 24 + aDuration hours) * 60 + aDuration minutes]
		ifFalse: [aDuration minutes].
	string := minutes printString.
	string size < aString size
		ifTrue: [string := ((String new: aString size - string size) atAllPut: $0) , string].
	aStream nextPutAll: string!

formatSecondsIn: aDuration onto: aStream using: aString
	| string |
	string := aDuration seconds asFloat printString.
	string size < aString size
		ifTrue: [string := ((String new: aString size - string size) atAllPut: $0) , string].
	aStream nextPutAll: string!

formatSelectorFor: aString
	^##((LookupTable new)
			at: $d put: #formatDaysIn:onto:using:;
			at: $h put: #formatHoursIn:onto:using:;
			at: $m put: #formatMinutesIn:onto:using:;
			at: $s put: #formatSecondsIn:onto:using:;
			yourself) at: aString trimBlanks first asLowercase ifAbsent: [#formatError]!

leftToRight: aDuration
	| stream |
	stream := String writeStream.
	(self format subStrings: $:)
		do:
			[:each | 
			| formatString |
			formatString := each trimBlanks.
			self
				perform: (self formatSelectorFor: formatString)
				with: aDuration
				with: stream
				with: formatString]
		separatedBy: [stream nextPut: $:].
	^stream contents!

rightToLeft: aString
	"Convert aString into a Duration.  
		Expected format is day:hour:minute:seconds
			- any argument can have a sign
			- days hours and minutes are truncated to integers, seconds are not
			- arguments can be omitted from the left so 12:34 iseqivalent to 0:0:12:34
			- 0, more than 4 values , illegal characters answers nil"

	| values |
	(aString allSatisfy: [:each | '0123456789+-:.' includes: each])
		ifFalse: [^self leftNullValue].
	values := OrderedCollection new.
	(aString subStrings: $:) reverseDo: [:each | values add: (Number fromString: each)].
	values isEmpty | (values size > 4) ifTrue: [^self leftNullValue].
	[values size < 4] whileTrue: [values add: 0].
	^Duration
		days: (values at: 4) truncated
		hours: (values at: 3) truncated
		minutes: (values at: 2) truncated
		seconds: (values at: 1)! !
!DurationToText categoriesFor: #defaultFormat!accessing!public! !
!DurationToText categoriesFor: #format!accessing!public! !
!DurationToText categoriesFor: #format:!accessing!public! !
!DurationToText categoriesFor: #formatDaysIn:onto:using:!operations!public! !
!DurationToText categoriesFor: #formatHoursIn:onto:using:!operations!public! !
!DurationToText categoriesFor: #formatMinutesIn:onto:using:!operations!public! !
!DurationToText categoriesFor: #formatSecondsIn:onto:using:!operations!public! !
!DurationToText categoriesFor: #formatSelectorFor:!operations!public! !
!DurationToText categoriesFor: #leftToRight:!operations!public! !
!DurationToText categoriesFor: #rightToLeft:!operations!public! !

ILColorSelector comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ILColorSelector methodsFor!

colorsAcross
	^8!

colorsDown
	^self colorTable size / self colorsAcross!

colorsSize
	"The size of the square that displays each colour"

	^16!

colorTable
	"Lazily initialize the colour table that the images all use"

	colorTable isNil
		ifTrue:
			[colorTable := (DeviceIndependentBitmap colorTableForDepth: 8)
				collect: [:each | RGB fromRGBQUAD: each]].
	^colorTable!

indexOf: aPoint
	"Answers the number, 1..256, of the color in the colour table displayed at 
	position aPoint or nil if aPoint is outside the colour area"

	| location |
	location := (aPoint - self margin) // self colorsSize.
	(location x between: 0 and: self colorsAcross - 1)
		& (location y between: 0 and: self colorsDown - 1) ifFalse: [^nil].
	^location y * self colorsAcross + location x + 1!

indexOfRGB: anRGB
	"Answers the index in the colour table for anRGB (1..256)"

	^self colorTable indexOf: anRGB!

margin
	"The size of the margin surrounding the colour display"

	^4!

onLeftButtonPressed: aMouseEvent
	"Convert the mouse location into a colour and, if not nil, tell any interested parties"

	| index |
	(index := self indexOf: aMouseEvent position) isNil ifTrue: [^self].
	self trigger: #selectRGB: with: (self colorTable at: index)!

onPaintRequired: aPaintEvent
	"Paint the color table in the view. No point in any fancy caching of brushes as this will
	only need painting  when the editor's model changes or it is resized"

	| canvas colors |
	canvas := aPaintEvent canvas.
	0
		to: self colorsAcross - 1
		do:
			[:across | 
			0
				to: self colorsDown - 1
				do:
					[:down | 
					canvas
						fillRectangle:
							(across @ down * self colorsSize + self margin extent: self colorsSize)
						brush: (Brush color: (self colorTable at: down * self colorsAcross + across + 1))]]!

preferredExtent
	"Answer the preferred extent of the view. If this answers the correct size then 
	the parent view, a ScrollingContainer, will be able to layout the scroll bars correctly"

	^self colorsAcross @ self colorsDown * self colorsSize + (self margin * 2)! !
!ILColorSelector categoriesFor: #colorsAcross!constants!public! !
!ILColorSelector categoriesFor: #colorsDown!constants!public! !
!ILColorSelector categoriesFor: #colorsSize!constants!public! !
!ILColorSelector categoriesFor: #colorTable!accessing!public! !
!ILColorSelector categoriesFor: #indexOf:!helpers!public! !
!ILColorSelector categoriesFor: #indexOfRGB:!accessing!helpers!public! !
!ILColorSelector categoriesFor: #margin!constants!public! !
!ILColorSelector categoriesFor: #onLeftButtonPressed:!event handling!public! !
!ILColorSelector categoriesFor: #onPaintRequired:!event handling!public! !
!ILColorSelector categoriesFor: #preferredExtent!geometry!public! !

ILEditorWorkspace comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ILEditorWorkspace methodsFor!

clearZone
	"Invalidate the user interface to ensure the toolbar is updated"

	self hideZone.
	zone := nil.
	self presenter trigger: #zoneDescriptionChanged!

connectModel
	"Register for events triggered by the model"

	self model
		ifNotNil:
			[:arg | 
			arg
				when: #imageChanged:
				send: #onImageChanged:
				to: self]!

continueTrackingAt: aPoint from: aPreviousPoint
	"Part of the zone definition protocol called while the mouse is being tracked. Only
	update the zone if it's extent has changed to avoid excessive repainting"

	| pixel |
	pixel := self imagePixelFor: aPoint.
	(pixel notNil and: [pixel ~= zone corner])
		ifTrue:
			[self hideZone.
			zone corner: pixel.
			self showZone.
			self presenter trigger: #zoneDescriptionChanged.
			location := pixel.
			self presenter trigger: #locationDescriptionChanged].
	^aPoint!

cursor
	^Cursor
		fromFile:
			(File composePath: SessionManager current idbResourcesFolder subPath: 'ImageEditor.cur')!

drawImageOn: aCanvas in: aRectangle
	"Draw the complete image, pixel by pixel. This looks like it should be iimplemented in
	LImage but we need to calculate the screen rect for each pixel so this is the best place"

	| imageRectangle |
	aCanvas pen: Pen red.
	imageRectangle := self imageRectangleFor: (aRectangle expandedBy: zoom).
	imageRectangle left
		to: imageRectangle right
		do:
			[:across | 
			imageRectangle top
				to: imageRectangle bottom
				do:
					[:down | 
					self model
						draw: across @ down
						on: aCanvas
						in: (self viewRectangleForPoint: across @ down)]]!

drawZoneOn: aCanvas show: aBoolean
	"aBoolean indicates if the zone or the underlying image should be displayed. 
	true = show the zone, false = show the underlying image"

	self isZoomed & self hasZone ifFalse: [^self].
	aCanvas
		pen: Pen red;
		setBkMode: (aBoolean ifTrue: [TRANSPARENT] ifFalse: [OPAQUE]).
	self zonePerimeterPixels
		do:
			[:each | 
			| rectangle |
			rectangle := self viewRectangleForPoint: each.
			aBoolean
				ifFalse:
					[self model
						draw: each
						on: aCanvas
						in: rectangle]
				ifTrue:
					[aCanvas
						brush: (self zoneBrushes at: each x odd == each y odd);
						rectangle: rectangle]]!

endTrackingAt: aPoint
	"Part of the zone definition protocol called while the mouse tracking has ended. The zone
	has been redrawn while it was being tracked (see #continueTrackinAt:from:) so all
	we need to do here is check for a 0 extent zone - which means that no zone is wanted"

	self hasZone
		ifTrue:
			[zone := zone normalize.
			zone extent = Point zero ifTrue: [^self clearZone]].
	self model trigger: #zoneDescriptionChanged!

hasZone
	^zone notNil!

hideZone
	self drawZoneOn: self canvas show: false!

imagePixelFor: aPoint
	"aPoint represents a location in the view. This method answers the pixel in
	the image that is being displayed at that point or nil if it is outside"

	| pixel |
	pixel := (aPoint - self margin) // (zoom - 1) + 1.
	^(self model rectangle containsPointInclusive: pixel) ifTrue: [pixel]!

imageRectangleFor: aRectangle
	"aRectangle represents an area of the view. This method answers the smallest
	rectangle, in the models image co-ordinates, that will enclose the views rectangle
	but ignoring anything outside the perimiters of the image"

	| origin corner |
	origin := self imagePixelFor: aRectangle origin.
	origin isNil ifTrue: [origin := self model rectangle origin].
	corner := self imagePixelFor: aRectangle corner.
	corner isNil ifTrue: [corner := self model rectangle corner].
	^(origin corner: corner) intersect: self model rectangle!

initialize
	super initialize.
	self usePreferredExtent: true!

isZoomed
	^zoom > 1!

locationDescription
	"Answers a String describing the location for the editor status"

	^(String writeStream)
		nextPutAll: ' Loc: ';
		display: location;
		contents!

margin
	"Answer the size of the margin added to the outsides of the image display"

	^8!

onImageChanged: aRectangleOrNil
	"The model has changed one or more of the pixels contained within aRectangle.
	Refresh the screen but only within the bit that corresponds to the changed rectangle"

	self invalidateRect: (self viewRectangleForRectangle: aRectangleOrNil) erase: false!

onLeftButtonPressed: aMouseEvent
	"Trigger a left button event passing the appropriate arguments
	mouse only - draw a pixel in the current colour
	mouse + control - pick up the colur and make it current
	mouse + shift + control - set the hotSpot for a cursor"

	| pixel |
	self isZoomed ifFalse: [^self].
	(pixel := self imagePixelFor: aMouseEvent position) isNil ifTrue: [^self].
	aMouseEvent isCtrlDown
		ifTrue:
			[aMouseEvent isShiftDown
				ifTrue: [self model hotSpot: pixel]
				ifFalse: [^self onMiddleButtonPressed: aMouseEvent]]
		ifFalse: [self presenter trigger: #plot: with: pixel]!

onMiddleButtonPressed: aMouseEvent
	| pixel |
	(pixel := self imagePixelFor: aMouseEvent position) isNil ifTrue: [^self].
	self presenter trigger: #selectRGB: with: (self model getRGBAt: pixel)!

onMouseMoved: aMouseEvent
	"If the mouse has moved onto another pixel, ot moved out of the edit
	area, then simulate a button up/button down sequence"

	| pixel |
	self isZoomed ifFalse: [^self].
	pixel := self imagePixelFor: aMouseEvent position.
	pixel = location
		ifFalse:
			[location := pixel.
			self presenter trigger: #locationDescriptionChanged.
			aMouseEvent isLButtonDown ifTrue: [self onLeftButtonPressed: aMouseEvent]]!

onMouseWheel: aMouseEvent
	self parentView parentView
		scroll: aMouseEvent wheelDirection
		toNextIn: ((1 to: self model height) collect: [:each | each * (zoom - 1) + self margin])!

onPaintRequired: aPaintEvent
	"Redraw the receiver using the current model. If the image is not zoomed then 
	we just draw the bitmap that the model maintains, otherwise we have to paint 
	each pixel within in the specified screen rectangle, individually (with a border)"

	| canvas |
	self model isNil ifTrue: [^self].
	canvas := aPaintEvent canvas.
	self isZoomed
		ifTrue:
			[self drawImageOn: canvas in: aPaintEvent paintStruct rcPaint asRectangle.
			self drawZoneOn: canvas show: true]
		ifFalse: [self model drawBitmapOn: canvas at: self margin asPoint]!

onRightButtonPressed: aMouseEvent
	"Start tracking the mouse to define the zone"

	self isZoomed ifFalse: [^self].
	self clearZone.	"Right click outside to only clear the zone"
	(self imagePixelFor: aMouseEvent position) isNil ifTrue: [^self].
	(MouseTracker forPresenter: self presenter startingAt: aMouseEvent screenPosition)
		origin: aMouseEvent position;
		hysteresis: 0;
		dragButton: #right;
		startTracking: self!

preferredExtent
	"Answer the extent of the receiver allowing for the extent of the image, the zoom
	factor and the margin allowed around all four edges. If this answers the correct
	size the the parent view, a ScrollingDecorator can set it's scroll bars correctly"

	self model isNil ifTrue: [^10 @ 10].
	^self model extent * (zoom - 1) + (self margin * 2)!

showZone
	self drawZoneOn: self canvas show: true!

startTrackingAt: aPoint
	"Part of the zone definition protocol called while the mouse starts being tracked"

	zone := (self imagePixelFor: aPoint) extent: 0.
	self showZone.
	self presenter trigger: #zoneDescriptionChanged.
	^aPoint!

viewRectangleForPoint: aPoint
	"aPoint represents a pixel in the model (an ILImage). This method answers the
	rectangle in the view that defines the equivalent area"

	^(aPoint - 1) * (zoom - 1) + self margin asPoint extent: zoom!

viewRectangleForRectangle: aRectangle
	"aPoint represents a rectangle in the model (an ILImage). This method answers the
	rectangle in the view that defines the equivalent area"

	^(self viewRectangleForPoint: aRectangle origin)
		merge: (self viewRectangleForPoint: aRectangle corner)!

zoneBrushes
	"When painting the zone we use two alternating brush designs. Define and cache
	them here to avoid a bit of GDI Churn"

	zoneBrushes isNil
		ifTrue:
			[zoneBrushes := (LookupTable new: 2)
				at: true
					put:
						(Brush
								withStyle: BS_HATCHED
								color: Color red
								hatch: HS_DIAGCROSS);
				at: false
					put:
						(Brush
								withStyle: BS_HATCHED
								color: Color black
								hatch: HS_DIAGCROSS);
				yourself].
	^zoneBrushes!

zoneDescription
	"Answers a String describing the location for the editor status bar"

	^(String writeStream)
		nextPutAll: ' Zone: ';
		display: (zone isNil ifTrue: [String new] ifFalse: [zone normalize extent abs + 1]);
		contents!

zonePerimeterPixels
	"Answer the collection of pixels (in ILImage coordinates) that comprise the zone perimeter"

	| pixels rectangle |
	pixels := OrderedCollection new.
	rectangle := zone normalize.
	rectangle left
		to: rectangle right
		do:
			[:across | 
			pixels
				add: across @ zone top;
				add: across @ zone bottom].
	rectangle top + 1
		to: rectangle bottom - 1
		do:
			[:down | 
			pixels
				add: zone left @ down;
				add: zone right @ down].
	^pixels!

zoneRectangle
	^zone!

zoom: anInteger
	"Set the zoom factor - The number of pixels used for each side of an ILImage pixel.
	As this redraws everything we might as well check first to make sure it is actually changing.
	We need to force a full redraw and relayout as the scrollers might need to be updated"

	zoom = anInteger ifTrue: [^self].
	zoom := anInteger.
	(self parentView)
		invalidateLayout;
		invalidate.
	self presenter trigger: #zoomDescriptionChanged!

zoomBy: anInteger
	"Increase the zoom by anInteger. zoom just defines the number of screen pixels
	to be used for each size of an ILImage pixel"

	(zoom + anInteger between: 1 and: 40) ifFalse: [^self].
	self zoom: zoom + anInteger!

zoomDescription
	"Answers a String describing the amount of zoom"

	^(String writeStream)
		nextPutAll: ' Zoom: ';
		display: zoom;
		contents! !
!ILEditorWorkspace categoriesFor: #clearZone!event handling!public! !
!ILEditorWorkspace categoriesFor: #connectModel!models!public! !
!ILEditorWorkspace categoriesFor: #continueTrackingAt:from:!event handling!public! !
!ILEditorWorkspace categoriesFor: #cursor!constants!public! !
!ILEditorWorkspace categoriesFor: #drawImageOn:in:!drawing!public! !
!ILEditorWorkspace categoriesFor: #drawZoneOn:show:!event handling!public! !
!ILEditorWorkspace categoriesFor: #endTrackingAt:!event handling!public! !
!ILEditorWorkspace categoriesFor: #hasZone!public!testing! !
!ILEditorWorkspace categoriesFor: #hideZone!event handling!public! !
!ILEditorWorkspace categoriesFor: #imagePixelFor:!calculations!public! !
!ILEditorWorkspace categoriesFor: #imageRectangleFor:!calculations!public! !
!ILEditorWorkspace categoriesFor: #initialize!initializing!public! !
!ILEditorWorkspace categoriesFor: #isZoomed!public!testing! !
!ILEditorWorkspace categoriesFor: #locationDescription!displaying!public! !
!ILEditorWorkspace categoriesFor: #margin!constants!public! !
!ILEditorWorkspace categoriesFor: #onImageChanged:!event handling!public! !
!ILEditorWorkspace categoriesFor: #onLeftButtonPressed:!event handling!public! !
!ILEditorWorkspace categoriesFor: #onMiddleButtonPressed:!event handling!public! !
!ILEditorWorkspace categoriesFor: #onMouseMoved:!event handling!public! !
!ILEditorWorkspace categoriesFor: #onMouseWheel:!event handling!public! !
!ILEditorWorkspace categoriesFor: #onPaintRequired:!event handling!public! !
!ILEditorWorkspace categoriesFor: #onRightButtonPressed:!event handling!public! !
!ILEditorWorkspace categoriesFor: #preferredExtent!geometry!public! !
!ILEditorWorkspace categoriesFor: #showZone!event handling!public! !
!ILEditorWorkspace categoriesFor: #startTrackingAt:!event handling!public! !
!ILEditorWorkspace categoriesFor: #viewRectangleForPoint:!calculations!public! !
!ILEditorWorkspace categoriesFor: #viewRectangleForRectangle:!calculations!public! !
!ILEditorWorkspace categoriesFor: #zoneBrushes!event handling!public! !
!ILEditorWorkspace categoriesFor: #zoneDescription!displaying!public! !
!ILEditorWorkspace categoriesFor: #zonePerimeterPixels!event handling!public! !
!ILEditorWorkspace categoriesFor: #zoneRectangle!accessing!public! !
!ILEditorWorkspace categoriesFor: #zoom:!accessing!public! !
!ILEditorWorkspace categoriesFor: #zoomBy:!accessing!public! !
!ILEditorWorkspace categoriesFor: #zoomDescription!displaying!public! !

ILLibraryWorkspace comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!ILLibraryWorkspace methodsFor!

connectModel
	self model
		ifNotNil:
			[:arg | 
			arg
				when: #libraryChanged:
				send: #onLibraryChanged:
				to: self]!

imageLayout
	| lineRect |
	imageLayout isNil
		ifTrue:
			[imageLayout := LookupTable new.
			imageLayoutRect := Rectangle new.
			lineRect := imageLayoutRect copy.
			self model images
				do:
					[:each | 
					| imageRect |
					imageRect := lineRect topRight extent: each extent + (self margin * 2).
					imageRect right > (self parentView parentView width - 24)
						ifTrue:
							["allow for future scrollbar width"
							lineRect := imageLayoutRect bottomLeft extent: 0.
							imageRect := imageLayoutRect bottomLeft extent: each extent + (self margin * 2)].
					lineRect := lineRect merge: imageRect.
					imageLayoutRect := imageLayoutRect merge: lineRect.
					imageLayout at: each put: imageRect]].
	^imageLayout!

initialize
	super initialize.
	self usePreferredExtent: true!

margin
	^8!

onLeftButtonDoubleClicked: aMouseEvent
	self setCapture!

onLeftButtonPressed: aMouseEvent
	| rect image previousSelection |
	rect := self imageLayout
		detect: [:each | each containsPoint: aMouseEvent position]
		ifNone: [^self].
	self invalidateUserInterface.
	image := self imageLayout keyAtValue: rect.
	previousSelection := lastSelection.
	lastSelection := image.
	aMouseEvent isCtrlDown ifTrue: [^self model selectInvert: image].
	(aMouseEvent isShiftDown and: [previousSelection notNil])
		ifTrue: [^self model selectBetween: previousSelection and: image].
	self model selectOnly: image!

onLeftButtonReleased: aMouseEvent
	self hasCapture
		ifTrue:
			[self class releaseCapture.
			self presenter trigger: #editImage].
	^super onLeftButtonReleased: aMouseEvent!

onLibraryChanged: aCollectionOrNil
	"The arguent is either a Collection of images that have to be drawn or nil
	which indicates that the whole view (including it's scroll area) needs updating"

	| rect |
	aCollectionOrNil isNil
		ifTrue:
			[imageLayout := nil.	"x2 because of the reference view!!"
			self parentView parentView layout]
		ifFalse:
			[| images |
			images := aCollectionOrNil asOrderedCollection.
			rect := images
				inject: (self imageLayout at: images first)
				into: [:bigRect :each | bigRect merge: (self imageLayout at: each)]].
	self invalidateRect: rect!

onMouseMoved: aMouseEvent
	| rect image |
	rect := self imageLayout
		detect: [:each | each containsPoint: aMouseEvent position]
		ifNone: [].
	image := self imageLayout keyAtValue: rect.
	image == lastImage ifTrue: [^self].
	lastImage := image.
	self presenter trigger: #mouseOver: with: image!

onMouseWheel: aMouseEvent
	self parentView parentView
		scroll: aMouseEvent wheelDirection
		toNextIn:
			(self imageLayout collect: [:each | each top]) asSet asSortedCollection
				asOrderedCollection!

onPaintRequired: aPaintEvent
	| canvas paintRect |
	self model isNil ifTrue: [^self].
	canvas := aPaintEvent canvas.
	paintRect := aPaintEvent paintStruct rcPaint asRectangle.
	self model images
		do:
			[:each | 
			| imageRect |
			imageRect := self imageLayout at: each.
			(imageRect intersects: paintRect)
				ifTrue:
					[(self model isSelected: each)
						ifTrue:
							[canvas
								pen: Pen red;
								brush: Brush transparent;
								rectangle: (imageRect insetBy: 4)].
					each drawBitmapOn: canvas at: imageRect origin + self margin]]!

onPositionChanged: aPositionEvent
	aPositionEvent isResize
		ifTrue:
			[imageLayout := nil.
			self invalidate].
	^super onPositionChanged: aPositionEvent!

preferredExtent
	self model isNil ifTrue: [^10 @ 10].
	self imageLayout.
	^imageLayoutRect corner max: Point one! !
!ILLibraryWorkspace categoriesFor: #connectModel!models!public! !
!ILLibraryWorkspace categoriesFor: #imageLayout!geometry!public! !
!ILLibraryWorkspace categoriesFor: #initialize!initializing!public! !
!ILLibraryWorkspace categoriesFor: #margin!constants!public! !
!ILLibraryWorkspace categoriesFor: #onLeftButtonDoubleClicked:!event handling!public! !
!ILLibraryWorkspace categoriesFor: #onLeftButtonPressed:!event handling!public! !
!ILLibraryWorkspace categoriesFor: #onLeftButtonReleased:!event handling!public! !
!ILLibraryWorkspace categoriesFor: #onLibraryChanged:!event handling!public! !
!ILLibraryWorkspace categoriesFor: #onMouseMoved:!event handling!public! !
!ILLibraryWorkspace categoriesFor: #onMouseWheel:!event handling!public! !
!ILLibraryWorkspace categoriesFor: #onPaintRequired:!event handling!public! !
!ILLibraryWorkspace categoriesFor: #onPositionChanged:!event handling!public! !
!ILLibraryWorkspace categoriesFor: #preferredExtent!geometry!public! !

!MoenTreeView methodsFor!

calculateNodeExtents: aMoenTreeNode forCanvas: aCanvas 
	"Private - Generate the cached extent of each node in the tree including and below
	the <MoenTreeNode> argument using the <Canvas> argument as the hypothetical
	display medium."

	| getImage user dtf rect lead2 getText |
	getText := self getTextBlock.
	getImage := self getImageBlock ifNil: [[:each | nil]].
	user := UserLibrary default.
	rect := RECT new.
	dtf := (dtFlags maskSet: DT_CALCRECT) maskClear: DT_VCENTER.
	lead2 := (self leadingForCanvas: aCanvas) * 2.
	aMoenTreeNode visiblePreOrderDo: 
			[:each | 
			| elem nodeExtent |
			(elem := each object) isNil 
				ifTrue: [nodeExtent := 0 @ 0]
				ifFalse: 
					[| txt |
					rect right: maxTextExtent x.
					rect bottom: 0.
					txt := getText value: elem.
					aCanvas 
						formatText: (txt isEmpty ifTrue: ['.'] ifFalse: [txt])
						in: rect
						flags: dtf.
					nodeExtent := (rect right + lead2 x) @ (rect bottom + lead2 y + 1) min: maxTextExtent.
					(getImage value: elem) notNil 
						ifTrue: [nodeExtent := (iconExtent x + nodeExtent x + 1) @ (iconExtent y max: nodeExtent y)]].
			each extent: nodeExtent]! !
!MoenTreeView categoriesFor: #calculateNodeExtents:forCanvas:!geometry!private! !

!AbstractCardContainer methodsFor!

ensureSubViewVisible: aSubView
	"Ensures that aSubView is visible in the receiver. Show the appropriate card
	if it is not already visible"

	super ensureSubViewVisible: aSubView.
	self layoutManager showCard: aSubView! !
!AbstractCardContainer categoriesFor: #ensureSubViewVisible:!public!sub views! !

!ScrollingDecorator methodsFor!

continuousTracking
	#deprecated.
	^self isTrackingContinuous!

continuousTracking: aBoolean 
	#deprecated.
	self isTrackingContinuous: aBoolean!

scroll: aSymbol toNextIn: aCollection
	| range pageSize currentValue newValue |
	#idbAdded.
	range := self getScrollRange: SB_VERT.
	pageSize := (self getScrollPage: SB_VERT) max: 1.
	currentValue := self scrollOffset y.
	newValue := aSymbol == #forward
		ifTrue: [aCollection reverse detect: [:each | each < currentValue] ifNone: [0]]
		ifFalse: [aCollection detect: [:each | each > currentValue] ifNone: [999999]].
	newValue := newValue max: range start.
	newValue := newValue min: range stop - pageSize + 1.
	newValue ~= currentValue
		ifTrue:
			[self scrollOffset: self scrollOffset x @ newValue.
			self layoutManager positionViewsOf: self]! !
!ScrollingDecorator categoriesFor: #continuousTracking!modes!public! !
!ScrollingDecorator categoriesFor: #continuousTracking:!modes!public! !
!ScrollingDecorator categoriesFor: #scroll:toNextIn:!event handling!idb goodies!public! !

!ShellView methodsFor!

snoopSecond
	"Answer any extra items that should be displayed for the receiver"

	#idbAdded.
	^(super snoopSecond)
		add: 'Default Button Id' -> self defaultButtonId;
		yourself! !
!ShellView categoriesFor: #snoopSecond!accessing!idb goodies!public! !

!BasicListAbstract methodsFor!

basicAdd: anObject 
	"Private - Adds a string for the <Object> argument to the listbox control at the end of the
	list. Answers the argument."

	self 
		sendMessage: self addStringMessage
		wParam: 0
		lpParam: (getTextBlock value: anObject) displayString.
	^anObject!

basicAdd: anObject atIndex: anInteger 
	"Private - Adds a string for the <Object> argument to the listbox control at the specified
	1-based <integer> index. If anInteger is zero then the string is added to the end of the
	list. Answer anObject."

	self 
		sendMessage: self insertStringMessage
		wParam: anInteger - 1
		lpParam: (getTextBlock value: anObject) displayString.
	^anObject!

requestDragObjects: aDragDropSession 
	"This is where the receiver specifies which object(s) a <DragDropSession> is to drag.
	The objects are added to the session using DragDropSession>>addDragObject: 
	or DragDropSession>>dragObjects:"

	| selections |
	selections := self selections.
	"Dragging existing selection?"
	(selections includes: aDragDropSession suggestedSource) 
		ifTrue: [selections do: [:each | aDragDropSession addDragee: each]]
		ifFalse: [aDragDropSession addDragee: aDragDropSession suggestedSource].
	"But let any observers override with their own suggestion"
	super requestDragObjects: aDragDropSession! !
!BasicListAbstract categoriesFor: #basicAdd:!adding!private! !
!BasicListAbstract categoriesFor: #basicAdd:atIndex:!adding!private! !
!BasicListAbstract categoriesFor: #requestDragObjects:!drag & drop!public! !

!IconicListAbstract methodsFor!

requestDragObjects: aDragDropSession 
	"This is where the receiver specifies which object(s) a <DragDropSession> is to drag.
	The objects are added to the session using DragDropSession>>addDragObject: 
	or DragDropSession>>dragObjects:"

	| selections |
	selections := self selections.
	"Dragging existing selection?"
	(selections includes: aDragDropSession suggestedSource) 
		ifTrue: [selections do: [:each | aDragDropSession addDragee: each]]
		ifFalse: [aDragDropSession addDragee: aDragDropSession suggestedSource].
	"But let any observers override with their own suggestion"
	super requestDragObjects: aDragDropSession!

snoopSecond
	"Answer any extra items that should be displayed for the receiver"

	#idbAdded.
	^(super snoopSecond)
		add: 'Image Manager' -> self imageManager;
		add: 'State Image Manager' -> self stateImageManager;
		yourself! !
!IconicListAbstract categoriesFor: #requestDragObjects:!drag & drop!public! !
!IconicListAbstract categoriesFor: #snoopSecond!accessing!idb goodies!public! !

!PushButton class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^(super publishedAspectsOfInstances)
		add: (Aspect name: #commandDescription) beReadOnly;
		add: (Aspect boolean: #isDefault);
		add: (Aspect icon: #image);
		"#1191: Windows BUTTON control doesn't support changing the foreground colour"
		removeKey: #forecolor;
		yourself! !
!PushButton class categoriesFor: #publishedAspectsOfInstances!constants!development!public! !

!ValueConvertingControlView methodsFor!

updateModel
	"Private - The displayed value of the receiver has changed so set this
	back into the model after first running through the type converter"

	[self model value: (self typeconverter convertFromRightToLeft: self displayValue)] 
		on: InvalidFormat
		do: 
			[:exception | 
			exception beep.
			self
				value: self typeconverter leftNullValue;
				refreshContents	"Ensure that receiver displays null value even if model is unchanged"].
	self invalidateUserInterface! !
!ValueConvertingControlView categoriesFor: #updateModel!private!updating! !

!ComboBox class methodsFor!

publishedAspectsOfInstances
    	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."
    
    	^(super publishedAspectsOfInstances)
    		add: (Aspect integer: #droppedHeight);
    		add: (Aspect choice: #mode from: Modes);
    		add: (Aspect boolean: #canHScroll);
    		yourself! !
!ComboBox class categoriesFor: #publishedAspectsOfInstances!constants!development!public! !

!ComboBox methodsFor!

canHScroll
	"Answer whether the receiver's edit field is in horizontal scrolling mode."

	^self baseStyleAllMask: CBS_AUTOHSCROLL!

canHScroll: aBoolean 
	"Sets the receiver into horizontal scrolling mode if aBoolean is true. When this style is
	off the control limits the amount of text that can be entered to that which can be displayed
	in the box. When the style is on the user can enter more text than can be displayed (the
	caret remains at the right edge of the field and the text scrolls left to accomodate new
	input). This style is only relevant when the combobox has an associated edit field (i.e. not
	when in #dropDownList mode)."

	"Implementation Note: The control ignores changes to this style after creation, so we must
	accept the default action, which is to recreate the view."

	self baseStyleMask: CBS_AUTOHSCROLL set: aBoolean! !
!ComboBox categoriesFor: #canHScroll!accessing-styles!public! !
!ComboBox categoriesFor: #canHScroll:!accessing-styles!public! !

!MultipleSelectionListBox methodsFor!

onItemRemovedAtIndex: anIntegerIndex
	"Event received when an object has been removed from the receiver's
	model at anIntegerIndex. Remove the appropriate string from the listbox.
	We must also account for the fact that the selected item may have been
	removed."

	self basicRemoveAtIndex: anIntegerIndex.
	(lastSelIndices includes: anIntegerIndex) ifTrue: [self onSelChanged].
	self updateLastSel! !
!MultipleSelectionListBox categoriesFor: #onItemRemovedAtIndex:!event handling!public! !

!StatusBar methodsFor!

calculateEdges
	| edges right fixedWidth numResizable widths numParts borders rectBorder share |
	numParts := parts size.
	self assert: [numParts < 256].	"common control limitation"
	numParts < 1 ifTrue: [^SDWORDArray with: -1].
	numResizable := 0.
	fixedWidth := 0.
	widths := parts collect: 
					[:each | 
					| width |
					width := each width.
					width = -1 
						ifTrue: [numResizable := numResizable + 1]
						ifFalse: [fixedWidth := fixedWidth + width].
					width].
	borders := self sbGetBorders.
	right := borders at: 2.
	share := numResizable = 0 
				ifFalse: 
					[(self clientWidth - right - fixedWidth 
						- (UserLibrary default getSystemMetrics: SM_CXHTHUMB)) // numResizable].
	rectBorder := borders at: 3.
	edges := SDWORDArray new: numParts.
	widths keysAndValuesDo: 
			[:i :cx | 
			cx = -1 ifTrue: [cx := share].
			right := right + cx + rectBorder.
			edges at: i put: right].
	"Special case last resizable edge"
	widths last = -1 ifTrue: [edges at: numParts put: -1].
	^edges!

setRightEdges
	"Private - Inform the common control of the right edge for each of the receiver's parts."

	| edges |
	edges := self calculateEdges.
	(self 
		sendMessage: SB_SETPARTS
		wParam: edges size
		lpParam: edges) == 0 
		ifTrue: [^self errorInCommonControlCall]!

snoopChildren
	"Answer a collection containing any children of the receiver that should 
	appear in the snoop tree"

	#idbAdded.
	^super snoopChildren , self contents! !
!StatusBar categoriesFor: #calculateEdges!geometry!private! !
!StatusBar categoriesFor: #setRightEdges!helpers!private! !
!StatusBar categoriesFor: #snoopChildren!accessing!idb goodies!public! !

!Toolbar methodsFor!

changeButtonSize: aNiladicBlock 
	"Private - Apply an operation that affects the button geometry of the toolbar, requiring
	that it recalculates its layout. Due to a bug in the common controls DLL if we want to
	maintain a consistent border width (of zero) between flat and non-flat styles we must turn
	on the flat/transparent style for the duration of the resizing operation."

	| style |
	style := self getWindowStyle.
	(style allMask: TBSTYLE_FLAT) ifTrue: [^aNiladicBlock value].
	^
	[self setWindowStyle: (style bitOr: ##(TBSTYLE_FLAT | TBSTYLE_TRANSPARENT)).
	aNiladicBlock value] 
			ensure: [self setWindowStyle: style]!

onFullyCreated
	"The receiver window has been created (but is not yet visible). 
	Finish the job and install the known ToolbarItems"

	super onFullyCreated.
	bitmapsStart := LookupTable new.
	self changeButtonSize: [self tbSetBitmapSize: self bitmapSize].
	#todo.	"Store extended style in an inst. var (appear to be some unused?) and provide accessors/mode settings"
	self tbSetExtendedStyle: TBSTYLE_EX_DRAWDDARROWS.
	self clearIdMap.
	self basicAddItems: items!

snoopChildren
	"Answer a collection containing any children of the receiver that should 
	appear in the snoop tree"

	#idbAdded.
	^super snoopChildren , self items!

updateSize
	"Private - Update the toolbar button and bitmap sizes."

	self changeButtonSize: 
			[self buttonSize notNil ifTrue: [self tbSetButtonSize: self buttonSize].
			self tbSetBitmapSize: self bitmapSize].
	self tbAutoSize! !
!Toolbar categoriesFor: #changeButtonSize:!helpers!private! !
!Toolbar categoriesFor: #onFullyCreated!event handling!public! !
!Toolbar categoriesFor: #snoopChildren!accessing!idb goodies!public! !
!Toolbar categoriesFor: #updateSize!operations!private! !

!ListView methodsFor!

addColumn: newColumn atIndex: columnIndex 
	"Insert the <ListViewColumn>, newColumn, into the receiver
	at the <integer> index columnIndex, shifting the positions of all 
	subsequent columns up by one. Answers the inserted column."

	lastClickedColIndex notNil 
		ifTrue: [lastClickedColIndex >= columnIndex ifTrue: [lastClickedColIndex := lastClickedColIndex + 1]].
	columns add: newColumn beforeIndex: columnIndex.
	self basicAddColumn: newColumn atIndex: columnIndex.
	self invalidateLayout.
	self updateAll.
	^newColumn!

autoResizeColumns
	"Private - Attempt to share the available width in the receiver between all automagically resizeable
	columns. This only has a visible effect in #report mode."

	| autoCols remainingWidth fixedWidth clientWidth idealWidth idealAccum actualAccum |
	fixedWidth := 0.
	autoCols := OrderedCollection new.
	self allColumns keysAndValuesDo: 
			[:eachIndex :eachCol | 
			eachCol isAutoResize 
				ifTrue: [autoCols addLast: eachIndex - 1 -> eachCol]
				ifFalse: [fixedWidth := fixedWidth + eachCol width]].
	autoCols isEmpty ifTrue: [^self].
	clientWidth := self clientWidth.
	"#1063: ListView doesn't seem to report its actual client width correctly if it has a static edge
	but not one of the other border styles, hence we must 'adjust' it a little in this case."
	(self hasStaticEdge and: [(self hasClientEdge or: [self hasBorder]) not]) 
		ifTrue: [clientWidth := clientWidth - 2].
	remainingWidth := clientWidth - fixedWidth.
	remainingWidth <= 0 ifTrue: [^self].
	"Split the available width between the auto columns - note the use of fractional arithmetic to avoid accumulating a rounding error"
	idealWidth := remainingWidth / autoCols size.
	idealAccum := 0.
	actualAccum := 0.
	autoCols do: 
			[:each | 
			| thisWidth |
			idealAccum := idealAccum + idealWidth.
			thisWidth := (idealAccum - actualAccum) rounded.
			each value basicWidth: thisWidth.
			self lvmSetColumnWidth: each key to: thisWidth.
			actualAccum := actualAccum + thisWidth]!

beSorted: aBlockClosure 
	self list: (self list asSortedCollection: aBlockClosure)!

columnClicked: anInteger 
	| sel column |
	sel := self selectionOrNil.
	column := self columnAtIndex: anInteger.
	column isSortable 
		ifFalse: 
			[Sound warningBeep.
			^self].
	anInteger = lastClickedColIndex 
		ifTrue: [column toggleSortOrder]
		ifFalse: 
			[self forgetLastClickedColumn.
			lastClickedColIndex := anInteger].
	self setColumnIcon: (column headerIcon: true) atIndex: anInteger.
	self sortOnColumn: column.
	sel notNil ifTrue: [self selection: sel]!

lvnColumnClick: anNMHDR 
	"Private - Default handler for the LVN_COLUMNCLICK notification message.
	Attempts to maintain current selection and to keep it visible."

	| nmlv |
	nmlv := self notificationClass fromAddress: anNMHDR yourAddress.
	self columnClicked: nmlv iSubItem + 1.
	^0!

onDropDown: aToolbarButton 
	"Private - The receiver's toolbar has sent a notification that a button's drop-down arrow
	has been pressed. Generate and pop-up the appropriate menu."

	| popup |
	aToolbarButton command asSymbol == #viewModeSelect ifFalse: [^nil].
	popup := self buildViewsPopup.
	popup queryAllFromView: self.
	popup showIn: self position: aToolbarButton screenRectangle bottomLeft.
	^0!

setWidthOfColumn: colIndexInteger to: widthInteger
	"Set the width of the column identified by itemIndex to anInteger."

	self lvmSetColumnWidth: colIndexInteger-1 to: widthInteger.
	self invalidateLayout!

snoopChildren
	"Answer a collection containing any children of the receiver that should 
	appear in the snoop tree. ListViews are awkward as they hold the primary 
	column separate from the rest of the columns"

	#idbAdded.
	^(super snoopChildren)
		add: self primaryColumn;
		addAll: self columns;
		yourself!

viewMode: aSymbol 
	"Sets the view mode of the receiver to that named by the <Symbol> argument. See #viewMode
	for a list of the valid mode names."

	| style |
	viewMode == aSymbol ifTrue: [^self].
	viewMode := aSymbol.
	viewMode = #largeIcons ifTrue: [self largeIconExtent: Icon largeExtent].
	viewMode = #tileIcons ifTrue: [self largeIconExtent: Icon tileExtent].
	style := ViewModes at: aSymbol ifAbsent: [LVS_REPORT].
	self 
		baseStyle: style
		maskedBy: LVS_TYPEMASK
		recreateIfChanged: false.
	self isVirtual ifTrue: [self invalidate] ifFalse: [self updateAll].
	self trigger: #viewModeChanged! !
!ListView categoriesFor: #addColumn:atIndex:!adding!columns!public! !
!ListView categoriesFor: #autoResizeColumns!operations!private! !
!ListView categoriesFor: #beSorted:!public!sorting! !
!ListView categoriesFor: #columnClicked:!helpers!private! !
!ListView categoriesFor: #lvnColumnClick:!event handling-win32!private! !
!ListView categoriesFor: #onDropDown:!event handling!private! !
!ListView categoriesFor: #setWidthOfColumn:to:!columns!public! !
!ListView categoriesFor: #snoopChildren!accessing!idb goodies!public! !
!ListView categoriesFor: #viewMode:!accessing!public! !

!TreeView methodsFor!

addNonVirtualItems: aCollection insertStruct: aTVINSERTSTRUCT 
	| tvItem getText getImage |
	tvItem := aTVINSERTSTRUCT item.
	getText := self getTextBlock.
	getImage := self getImageBlock.
	"Add items with subclassing removed so don't receive TVM_INSERTITEMs"
	self withOldWndProc: 
			[aCollection do: 
					[:each | 
					| hItem |
					tvItem
						text: (getText value: each) displayString;
						children: (self model hasChildren: each) asParameter.
					getImage notNil 
						ifTrue: 
							[(getImage value: each) 
								ifNotNil: 
									[:index | 
									tvItem
										image: index - 1;
										selectedImage: index - 1]].
					hItem := self 
								sendMessage: TVM_INSERTITEM
								wParam: 0
								lpParam: aTVINSERTSTRUCT.
					hItem == 0 ifFalse: [handleObjectMap at: hItem put: each]]]!

addRoot: anObject 
	self 
		basicAddAll: (Array with: anObject)
		inHandle: TVGN_ROOT
		afterHandle: TVI_LAST.
	self hasLinesAtRoot ifFalse: [self expand: anObject]!

basicRefresh: anObject handle: hItem
	"Private - Update the text, image, and children flag of the specified element of the tree."

	| tvItem |
	tvItem := TVITEM new.
	tvItem hItem: hItem.
	self isVirtual 
		ifTrue: [tvItem allCallbacks]
		ifFalse: 
			[tvItem
				text: (self getTextBlock value: anObject) displayString;
				children: (self model hasChildren: anObject) asParameter.
			self getImageBlock ifNotNil: 
					[:getImage | 
					(getImage value: anObject) ifNotNil: 
							[:index | 
							tvItem
								image: index - 1;
								selectedImage: index - 1]]].
	self tvmSetItem: tvItem!

onItem: anObject addedInParent: aParentObject 
	"Event received when anObject has been added to the receiver's
	model within aParentObject."

	"Update parent if it has gained it's first child."

	| parentHandle parentTvItem siblings previousSiblingIndex previousSiblingHandle |
	aParentObject isNil 
		ifTrue: 
			["Adding a root object"
			self addRoot: anObject.
			^self].

	"Get the TVITEM structure for the parent"
	parentHandle := self handleFromObject: aParentObject ifAbsent: [^self].
	parentTvItem := self getItemState: parentHandle.
	"#348: When TVM_GETITEM is sent the control, if it has not previously been repainted, may send back a 
	children callback to request the number of children of the parent, to which the answer is now '1' (since that 
	is determined by asking the model). However the control does not display the expansion button in this case
	(a bug), so we must refresh it even if there is already one child just in case."
	parentTvItem cChildren <= 1 ifTrue: [self refreshHasChildren: parentHandle].
	parentTvItem isStateExpandedOnce ifFalse: [^self].
	siblings := self model childrenOf: aParentObject.
	previousSiblingIndex := (self model 
				keyOfNode: anObject
				in: siblings
				ifAbsent: [^siblings errorNotFound: anObject]) - 1.

	"The model may have added more than one sibling, so we have to locate the first of them that we know about currently"
	previousSiblingHandle := nil.
	
	[previousSiblingIndex > 0 and: 
			[(previousSiblingHandle := self handleFromObject: (siblings at: previousSiblingIndex)) 
				isNil]] 
			whileTrue: [previousSiblingIndex := previousSiblingIndex - 1].
	self 
		basicAddAll: (Array with: anObject)
		inHandle: parentHandle
		afterHandle: (previousSiblingHandle ifNil: [TVI_FIRST])!

onSelChanging: anExternalAddress 
	"Private - Selection is changing in the receiver as a direct result of user input. Details
	about the selection change are recorded in the <NMTREEVIEW> structure pointed at
	by the argument. A #selectionChanging: event is triggered to enquire as to whether the 
	selection change is permissible. If it is not then any observer that wishes to veto the change 
	must set the the value of the <SelectionChangingEvent> to false."

	"Implementation Note: The TreeView is unusual among Windows controls in that it sends selection 
	changing notifications for programmatic changes, as well as for user input, so we have to identify
	and ignore these."

	| nmtv action |
	self isStateRestoring 
		ifTrue: 
			["Selection changing notifications are not propagated during state restoral."
			^true].
	nmtv := NMTREEVIEW fromAddress: anExternalAddress.
	action := nmtv action.
	"The TreeView sends a notification with the undocumented action code 4096 when it wants to reset
	 selection to the root. It doesn't seem to be happy without a selection, and tries to select the root whenever
	 reactivated with no selection. Answering false for any unexpected action codes prevents unwanted selection 
	changes from occurring."
	action > TVC_BYKEYBOARD ifTrue: [^false].
	^action == TVC_UNKNOWN or: 
			[self 
				onSelChangingFrom: (self objectFromHandle: nmtv itemOld hItem ifAbsent: [])
				to: (self objectFromHandle: nmtv itemNew hItem ifAbsent: [])
				cause: (#(#mouse #keyboard) at: action)]!

onSelChangingFrom: oldSelection to: newSelection cause: aSymbol 
	| event |
	event := SelectionChangingEvent forSource: self.
	event
		newSelection: newSelection;
		oldSelection: oldSelection;
		cause: aSymbol.
	self presenter onSelectionChanging: event.
	^event value!

refreshContents
	"Repopulate the receiver with the elements of the receiver's model."

	| roots |
	self isOpen ifFalse: [^self].
	self basicClear.
	roots := self model roots.
	self 
		basicAddAll: roots
		inHandle: TVGN_ROOT
		afterHandle: TVI_LAST.
	"If there are no lines (and therefore expansion buttons) at the roots, then the roots ought
	to be expanded as there is otherwise no visual indication to the user that there might be
	subnodes)."
	self hasLinesAtRoot ifFalse: [roots reverseDo: [:each | self expand: each]]! !
!TreeView categoriesFor: #addNonVirtualItems:insertStruct:!adding!private! !
!TreeView categoriesFor: #addRoot:!adding!private! !
!TreeView categoriesFor: #basicRefresh:handle:!private!updating! !
!TreeView categoriesFor: #onItem:addedInParent:!event handling!public! !
!TreeView categoriesFor: #onSelChanging:!event handling!private! !
!TreeView categoriesFor: #onSelChangingFrom:to:cause:!event handling!helpers!private! !
!TreeView categoriesFor: #refreshContents!public!updating! !

!MultipleSelectionListView methodsFor!

selectionsByIndex: aCollectionOfIntegers 
	self basicSelectionsByIndex: aCollectionOfIntegers.
	self ensureSelectionVisible.
	self onSelChanged: nil! !
!MultipleSelectionListView categoriesFor: #selectionsByIndex:!public!selection! !

Spinner comment:
'See [DolphinImageFolder]/Ian Bartholomew/Documentation for details

(C) 2004 Ian Bartholomew
ian@idb.me.uk
Public Domain Freeware'!
!Spinner class methodsFor!

defaultIconName
	^self idbDefaultIconName!

icon
	"Answers an Icon that can be used to represent this class"

	^##(self) instanceClass defaultIcon!

initialize
	"Private - Initialise the map of UpDown notification codes to selector/parameter-class pairs.
		UpDown initialize
	"

	UdnMap := (Array new: 1)
		at: 1 put: #udnDeltaPos:;
		yourself!

publishedAspectsOfInstances
	"Answer a Set of the aspects published by  instances of the receiver"

	^(super publishedAspectsOfInstances)
		add: (Aspect name: #range) beImmutable;
		add: (Aspect boolean: #isWrap);
		add: (Aspect boolean: #isBuddyInt);
		add: (Aspect boolean: #isAlignLeft);
		add: (Aspect boolean: #isAlignRight);
		add: (Aspect boolean: #isAutoBuddy);
		add: (Aspect boolean: #hasArrowKeys);
		add: (Aspect boolean: #isHorizontal);
		add: (Aspect boolean: #hasNoThousands);
		add: (Aspect boolean: #isHotTrack);
		yourself!

winClassName
	"Answer the name of the Windows window class to use when realizing the receiver."

	^'msctls_updown32'! !
!Spinner class categoriesFor: #defaultIconName!constants!public! !
!Spinner class categoriesFor: #icon!constants!public! !
!Spinner class categoriesFor: #initialize!initializing!public! !
!Spinner class categoriesFor: #publishedAspectsOfInstances!accessing!must strip!public! !
!Spinner class categoriesFor: #winClassName!constants!public! !

!Spinner methodsFor!

displayValue
	"Answer the displayable contents of the receiver"

	^self udmGetPos32!

displayValue: anInteger
	"Set the displayable contents of the receiver"

	self udmSetPos32: anInteger!

hasArrowKeys
	"Answer whether the receiver uses the keyboard arrow keys"

	^self baseStyleAllMask: UDS_ARROWKEYS!

hasArrowKeys: aBoolean
	"Set whether the receiver uses the keyboard arrow keys"

	^self baseStyleMask: UDS_ARROWKEYS set: aBoolean!

hasNoThousands
	"Answer whether the receiver hides the thousands separators"

	^self baseStyleAllMask: UDS_NOTHOUSANDS!

hasNoThousands: aBoolean
	"Set whether the receiver hides the thousands separators"

	^self baseStyleMask: UDS_NOTHOUSANDS set: aBoolean!

initialize
	"Initialize the receiver"

	super initialize.
	self setModel: 0 asValue!

isAlignLeft
	"Answer whether the receiver is aligned to the left  hand side of the buddy window"

	^self baseStyleAllMask: UDS_ALIGNLEFT!

isAlignLeft: aBoolean
	"Set whether the receiver is aligned to the left  hand side of the buddy window"

	^self baseStyleMask: UDS_ALIGNLEFT set: aBoolean!

isAlignRight
	"Answer whether the receiver is aligned to the right hand side of the buddy window"

	^self baseStyleAllMask: UDS_ALIGNRIGHT!

isAlignRight: aBoolean
	"Set whether the receiver is aligned to the right hand side of the buddy window"

	^self baseStyleMask: UDS_ALIGNRIGHT set: aBoolean!

isAutoBuddy
	"Answer whether the receiver locates its buddy window by itself"

	^self baseStyleAllMask: UDS_AUTOBUDDY!

isAutoBuddy: aBoolean
	"Set whether the receiver locates its buddy window by itself"

	^self baseStyleMask: UDS_AUTOBUDDY set: aBoolean!

isBuddyInt
	"Answer whether the receiver updates its buddy when it changes"

	^self baseStyleAllMask: UDS_SETBUDDYINT!

isBuddyInt: aBoolean
	"Set whether the receiver updates its buddy when it changes"

	self baseStyleMask: UDS_SETBUDDYINT set: aBoolean!

isHorizontal
	"Answer whether the receivers display points left and right"

	^self baseStyleAllMask: UDS_HORZ!

isHorizontal: aBoolean
	"Set whether the receivers display points left and right"

	^self baseStyleMask: UDS_HORZ set: aBoolean!

isHotTrack
	"Answer whether the receiver uses Win98 hot tracking (the control highlights)"

	^self baseStyleAllMask: UDS_HOTTRACK!

isHotTrack: aBoolean
	"Set whether the receiver uses Win98 hot tracking (the control highlights)"

	^self baseStyleMask: UDS_HOTTRACK set: aBoolean!

isWrap
	"Answer whether the receiver wraps from max to min value"

	^self baseStyleAllMask: UDS_WRAP!

isWrap: aBoolean
	"Set whether the receiver wraps from max to min value"

	self baseStyleMask: UDS_WRAP set: aBoolean!

nmNotify: pNMHDR
	"Private - Handler for a redirected UpDown WM_NOTIFY message.
	Implementation Note: Rather than create the appropriate header structure
	object here, we delay that until the handler, because most of the time
	we don't need to look at the notification at all."

	| action |
	action := UdnMap
		at: UDN_FIRST - (pNMHDR sdwordAtOffset: 8)
		ifAbsent: [^super nmNotify: pNMHDR].
	^self perform: action with: pNMHDR!

onHScroll: aScrollEvent
	"The receiver has been changed make the model track it"

	self updateModel.
	^0!

onVScroll: aScrollEvent
	"The receiver has been changed make the model track it"

	self updateModel.
	^0!

range
	"Answer the receivers valis range as an Interval
	Note -
		the returend interval's start is the limit that is reached by pressing the up button
		the returend interval's stop is the limit reached for the down button"

	^self udmGetRange32!

range: anIntegerInterval
	"Set the receivers range to anIntegerInterval.
	Note -
		anIntegerInterval start is the limit that is reached by pressing the up button
		anIntegerInterval stop is the limit reached for the down button"

	self udmSetRange32: anIntegerInterval!

refreshContents
	"Update the receivers model with the value that Windows wants in the view"

	self model value: self udmGetPos32.
	super refreshContents!

state
	"Answer a MessageSequence which, when replayed, will restore the receiver 
	to its current state"

	^(super state)
		add:
				(MessageSend
						receiver: self
						selector: #range:
						argument: self range);
		yourself!

udmGetAccel
	"Answer the accelerators used by the receiver. Returns a collection
	containin Associations where the key is the UDACCEL nSec number
	and the value is the nInc"

	| accels count |
	accels := StructureArray length: 50 elementClass: UDACCEL.
	count := self
		sendMessage: UDM_GETACCEL
		wParam: 50
		lpParam: accels.
	^(1 to: count) collect: [:index | (accels at: index) nSec -> (accels at: index) nInc]!

udmGetBase
	"Answer the current radix base used by the receiver"

	^self sendMessage: UDM_GETBASE!

udmGetBuddy
	"Answer the handle of the buddy view associated with the receiver"

	^self sendMessage: UDM_GETBUDDY!

udmGetPos
	"Answer the current position of the receiver"

	^self sendMessage: UDM_GETPOS!

udmGetPos32
	"Answer the current 32 bit position of the receiver"

	^self sendMessage: UDM_GETPOS32!

udmGetRange
	"Answer the minimum and maximum values for the receiver"

	^self sendMessage: UDM_GETRANGE!

udmGetRange32
	"Answer the minimum and maximum values for the receiver"

	| low high |
	low := SDWORD new.
	high := SDWORD new.
	self
		sendMessage: UDM_GETRANGE32
		wpParam: low
		lpParam: high.
	^high asInteger to: low asInteger!

udmGetUnicodeFormat
	"Answer the UNICODE format flag for the receiver"

	self sendMessage: UDM_GETUNICODEFORMAT!

udmSetAccel: aCollection
	"Set the acceleration values for the receiver.
	aCollection is a series of Associations with the key giving the UDACCEL nSec
	number and the value the nInc number..
	Answers whether the operation succeeded"

	| count accels |
	count := aCollection size.
	accels := StructureArray length: count elementClass: UDACCEL.
	(aCollection asSortedCollection: [:a :b | a key < b key])
		keysAndValuesDo:
			[:index :each | 
			(accels at: index)
				nSec: each key;
				nInc: each value].
	^self
		sendMessage: UDM_SETACCEL
		wParam: count
		lpParam: accels!

udmSetBase: anInteger
	"Set the current radix base used by the receiver. Must be 10 or 16.
	Answers the previous base value or 0 if invalid"

	self assert: [anInteger = 10 | (anInteger = 16)].
	^self sendMessage: UDM_SETBASE wParam: anInteger!

udmSetBuddy: aHandle
	"Set the buddy view associated with the receiver"

	^self sendMessage: UDM_SETBUDDY wParam: aHandle!

udmSetPos: anInteger
	"Set the receivers position. Answers the previous position"

	^self
		sendMessage: UDM_SETPOS
		wParam: 0
		lParam: anInteger!

udmSetPos32: anInteger
	"Set the receivers 32 bit position. Answers the previous position"

	^self
		sendMessage: UDM_SETPOS32
		wParam: 0
		lParam: anInteger!

udmSetRange: anInteger
	"Set the receivers min and max range"

	self
		sendMessage: UDM_SETRANGE
		wParam: 0
		lParam: anInteger!

udmSetRange32: anIntegerInterval
	"Set the receivers min and max range"

	self
		sendMessage: UDM_SETRANGE32
		wParam: anIntegerInterval stop
		lParam: anIntegerInterval start!

udmSetUnicodeFormat: aBoolean
	"Set the UNICODE format flag for the receiver"

	self sendMessage: UDM_SETUNICODEFORMAT wParam: aBoolean asParameter!

udnDeltaPos: anNMHDR
	"Default handler for the UDN_DELTAPOS notification message.
	An NMUPDOWN is available from the header to inspect the proposed change.
	Answer false to allow the change, or true to prevent it."

	| nmUpDown |
	nmUpDown := NMUPDOWN fromAddress: anNMHDR yourAddress.
	^false! !
!Spinner categoriesFor: #displayValue!public!updating! !
!Spinner categoriesFor: #displayValue:!public!updating! !
!Spinner categoriesFor: #hasArrowKeys!accessing-styles!public!updating! !
!Spinner categoriesFor: #hasArrowKeys:!accessing-styles!public!updating! !
!Spinner categoriesFor: #hasNoThousands!accessing-styles!public!updating! !
!Spinner categoriesFor: #hasNoThousands:!accessing-styles!public!updating! !
!Spinner categoriesFor: #initialize!initializing!public! !
!Spinner categoriesFor: #isAlignLeft!accessing-styles!public!updating! !
!Spinner categoriesFor: #isAlignLeft:!accessing-styles!public!updating! !
!Spinner categoriesFor: #isAlignRight!accessing-styles!public!updating! !
!Spinner categoriesFor: #isAlignRight:!accessing-styles!public!updating! !
!Spinner categoriesFor: #isAutoBuddy!accessing-styles!public!updating! !
!Spinner categoriesFor: #isAutoBuddy:!accessing-styles!public!updating! !
!Spinner categoriesFor: #isBuddyInt!accessing-styles!public!updating! !
!Spinner categoriesFor: #isBuddyInt:!accessing-styles!public!updating! !
!Spinner categoriesFor: #isHorizontal!accessing-styles!public!updating! !
!Spinner categoriesFor: #isHorizontal:!accessing-styles!public!updating! !
!Spinner categoriesFor: #isHotTrack!accessing-styles!public!updating! !
!Spinner categoriesFor: #isHotTrack:!accessing-styles!public!updating! !
!Spinner categoriesFor: #isWrap!accessing-styles!public!updating! !
!Spinner categoriesFor: #isWrap:!accessing-styles!public!updating! !
!Spinner categoriesFor: #nmNotify:!event handling-win32!public! !
!Spinner categoriesFor: #onHScroll:!event handling!public! !
!Spinner categoriesFor: #onVScroll:!event handling!public! !
!Spinner categoriesFor: #range!accessing!public! !
!Spinner categoriesFor: #range:!accessing!public! !
!Spinner categoriesFor: #refreshContents!public!updating! !
!Spinner categoriesFor: #state!accessing!public! !
!Spinner categoriesFor: #udmGetAccel!accessing!public! !
!Spinner categoriesFor: #udmGetBase!accessing!public! !
!Spinner categoriesFor: #udmGetBuddy!accessing!public! !
!Spinner categoriesFor: #udmGetPos!accessing!public! !
!Spinner categoriesFor: #udmGetPos32!accessing!public! !
!Spinner categoriesFor: #udmGetRange!accessing!public! !
!Spinner categoriesFor: #udmGetRange32!accessing!public! !
!Spinner categoriesFor: #udmGetUnicodeFormat!accessing!public! !
!Spinner categoriesFor: #udmSetAccel:!accessing!public! !
!Spinner categoriesFor: #udmSetBase:!accessing!public! !
!Spinner categoriesFor: #udmSetBuddy:!accessing!public! !
!Spinner categoriesFor: #udmSetPos:!accessing!public! !
!Spinner categoriesFor: #udmSetPos32:!accessing!public! !
!Spinner categoriesFor: #udmSetRange:!accessing!public! !
!Spinner categoriesFor: #udmSetRange32:!accessing!public! !
!Spinner categoriesFor: #udmSetUnicodeFormat:!accessing!public! !
!Spinner categoriesFor: #udnDeltaPos:!event handling-win32!public! !

!TextEdit methodsFor!

enMaxText
	"Private - The receiver has hit its current text limit. Sensible responses might be to expand
	the text limit with EM_SETLIMITTEXT (the default is 32Kb), or to inform the user that they are
	trying to enter too much data."

	^self onTextOverflow!

textLimit
	"Answer the current text limit for the control (i.e. the amount of text it can hold)."

	^self sendMessage: EM_GETLIMITTEXT! !
!TextEdit categoriesFor: #enMaxText!event handling-win32!private! !
!TextEdit categoriesFor: #textLimit!accessing!public! !

!StaticText methodsFor!

calculateExtent
	"Private - Answer a calculated preferred extent for the receiver."

	| canvas extent |
	canvas := self canvas.
	canvas font: self actualFont.
	extent := self isSingleLine 
				ifTrue: [canvas textExtent: self text]
				ifFalse: 
					[canvas 
						textExtent: self text
						width: self width
						alignment: self alignment].
	canvas free.

	"Now adjust required client extent to window extent"
	^self calcExtentFromClientExtent: extent!

isSingleLine
	^self alignment == #leftNoWrap! !
!StaticText categoriesFor: #calculateExtent!geometry!private! !
!StaticText categoriesFor: #isSingleLine!private!testing! !

!StaticPath methodsFor!

isSingleLine
	^true! !
!StaticPath categoriesFor: #isSingleLine!private!testing! !

!RichTextEdit methodsFor!

displayValue: aRichString 
	"Private - Set the displayed contents or the receiver to the text argument,
	(either a RichText, or a String, or nil)."

	| newValue |
	newValue := aRichString ifNil: [''].
	self displayValue = newValue ifFalse: [self text: newValue]!

wmKeyDown: message wParam: wParam lParam: lParam
	"Added to have first go at all keypresses for the macro facility in the FileBrowser"

	#idbAdded.
	self presenter
		trigger: #keyEvent:
		with:
			(KeyEvent
				message: message
				handle: handle
				wParam: wParam
				lParam: lParam).
	^super
		wmKeyDown: message
		wParam: wParam
		lParam: lParam!

wmKeyUp: message wParam: wParam lParam: lParam
	"Added to have first go at all keypresses for the macro facility in the FileBrowser"

	#idbAdded.
	self presenter
		trigger: #keyEvent:
		with:
			(KeyEvent
				message: message
				handle: handle
				wParam: wParam
				lParam: lParam).
	^super
		wmKeyUp: message
		wParam: wParam
		lParam: lParam! !
!RichTextEdit categoriesFor: #displayValue:!private!updating! !
!RichTextEdit categoriesFor: #wmKeyDown:wParam:lParam:!event handling-win32!idb goodies!public! !
!RichTextEdit categoriesFor: #wmKeyUp:wParam:lParam:!event handling-win32!idb goodies!public! !

!ClassStub methodsFor!

printOn: aStream
	"Append, to aStream, a String whose characters are a description of the receiver."

	| name |
	 name := [self class name] on: Error do: [:ex | 'invalid ClassStub'].
	aStream 
		nextPutAll: (name first isVowel ifTrue: ['an '] ifFalse: ['a ']);
		nextPutAll: name;
		nextPut: $(;
		print: classLocator;
		nextPut: $)! !
!ClassStub categoriesFor: #printOn:!printing!public! !

"07:56:05, 07 August 2004: Compressed changes"!

"07:56:05, 07 August 2004: Image saved"!

"07:56:09, 07 August 2004: Image saved"!

"08:38:19, 23 August 2004: Dolphin Smalltalk Professional started"!

"10:20:10, 30 August 2004: Dolphin Smalltalk Professional started"!

"11:31:09, 30 August 2004: Dolphin Smalltalk Professional started"!

"11:48:28, 30 August 2004: Dolphin Smalltalk Professional started"!

"11:26:28, 12 October 2004: Dolphin Smalltalk Professional started"!

"19:01:54, 01 November 2004: Dolphin Smalltalk Professional started"!

"21:41:33, 01 November 2004: Dolphin Smalltalk Professional started"!

"10:37:46, 02 November 2004: Dolphin Smalltalk Professional started"!

"22:57:41, 17 November 2004: Dolphin Smalltalk Professional started"!

"22:57:51, 17 November 2004: Image saved to C:\Documents and Settings\Ted\Desktop\Mugpunters\Placepot\MP55.img"!

"22:57:57, 17 November 2004: Image saved"!

"22:58:01, 17 November 2004: Image saved"!

"22:58:05, 17 November 2004: Dolphin Smalltalk Professional started"!

"22:58:24, 17 November 2004: Loading package 'SSLSockets' from: C:\Documents and Settings\Ted\Desktop\Mugpunters\Placepot\Chris Double\SSLSockets.pac"!

"Class Definitions"!

Object subclass: #InternetSocketClient
	instanceVariableNames: 'socket'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

ExternalLibrary subclass: #SSLeay32Library
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Socket subclass: #SSLSocket
	instanceVariableNames: 'method ctx handle'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

"Global Aliases"!

"Loose Methods"!

"End of package definition"!

"Source Globals"!

"Classes"!

InternetSocketClient guid: (GUID fromString: '{D0C484E2-D5F9-11D4-B744-C124AD8A2402}')!

InternetSocketClient guid: (GUID fromString: '{D0C484E2-D5F9-11D4-B744-C124AD8A2402}')!
InternetSocketClient comment: 'A class that represents a Socket connection to some internet service. The socket to use for the connection is passed on creation. 

This class provides details to read and write lines to the Socket with correct line terminators and is intended to serve as a base class for protocols such as HTTP, POP3, etc.

Author: Chris Double
mailto: chris@double.co.nz
http://www.double.co.nz/smalltalk'!

InternetSocketClient comment:
'A class that represents a Socket connection to some internet service. The socket to use for the connection is passed on creation. 

This class provides details to read and write lines to the Socket with correct line terminators and is intended to serve as a base class for protocols such as HTTP, POP3, etc.

Author: Chris Double
mailto: chris@double.co.nz
http://www.double.co.nz/smalltalk'!
!InternetSocketClient categoriesForClass!Unclassified! !
!InternetSocketClient methodsFor!
close
	"Cleans up any connection details and closes the socket."

	socket close.! !
!InternetSocketClient categoriesFor: #close!public! !

!InternetSocketClient methodsFor!
connect
	"Causes #connect to be called on the attached Socket and any required
	initialization for the particular internet protocol is performed"

	socket connect.! !
!InternetSocketClient categoriesFor: #connect!public! !

!InternetSocketClient methodsFor!
finalize
	"Private - Sent when the object no longer has any strong references to it.
	Frees the external resources by closing the connection."

	self close! !
!InternetSocketClient categoriesFor: #finalize!public! !

!InternetSocketClient methodsFor!
flush
	"Send any buffered data on the connection back to the server"

	socket writeStream flush.! !
!InternetSocketClient categoriesFor: #flush!public! !

!InternetSocketClient methodsFor!
printOn: aStream
	"Append, to aStream, a String whose characters are a description
	of the receiver as a developer would want to see it."
	
	aStream 
		basicPrint: self;
		nextPut: $(;
		display: self socket descriptor;
		nextPut: $)! !
!InternetSocketClient categoriesFor: #printOn:!public! !

!InternetSocketClient methodsFor!
readLine
	"Reads a line up to a terminating carriage return/line feed. If no such
	terminator exists, read and return the entire contents of the stream."

	| stream eol1 eol2 readStream |
	eol1 := String lineDelimiter first asInteger.
	eol2 := String lineDelimiter last asInteger.	
	stream := WriteStream with: String new.
	readStream := socket readStream.

	(readStream upTo: eol1) do: [:e | stream nextPut: e asCharacter].
	[readStream atEnd or: [readStream peekFor: eol2]]
		whileFalse: [ 	stream nextPut: eol1 asCharacter. 
					(readStream upTo: eol1) do: [:e | stream nextPut: e asCharacter ]. ].
	^stream contents.


! !
!InternetSocketClient categoriesFor: #readLine!public! !

!InternetSocketClient methodsFor!
socket
	"Private - Answer the value of the receiver's ''socket'' instance variable."

	^socket! !
!InternetSocketClient categoriesFor: #socket!public! !

!InternetSocketClient methodsFor!
socket: anObject
	"Private - Set the value of the receiver's ''socket'' instance variable to the argument, anObject."

	socket := anObject! !
!InternetSocketClient categoriesFor: #socket:!public! !

!InternetSocketClient methodsFor!
writeLine: aString
	"Writes a line to the socket terminated by a carriage return/line feed"

	socket writeStream
		nextPutAll: aString;
		nextPutAll: String lineDelimiter.
	^aString.! !
!InternetSocketClient categoriesFor: #writeLine:!public! !

!InternetSocketClient categoriesFor: #close!public! !

!InternetSocketClient categoriesFor: #connect!public! !

!InternetSocketClient categoriesFor: #finalize!finalizing!private! !

!InternetSocketClient categoriesFor: #flush!public! !

!InternetSocketClient categoriesFor: #printOn:!public! !

!InternetSocketClient categoriesFor: #readLine!public! !

!InternetSocketClient categoriesFor: #socket!accessing!public! !

!InternetSocketClient categoriesFor: #socket:!accessing!private! !

!InternetSocketClient categoriesFor: #writeLine:!public! !

!InternetSocketClient class methodsFor!
example1
	"Examples of using the class."
	| client1 client2 |

	client1 := InternetSocketClient onSocket: (Socket port: 80 host: 'www.double.co.nz').
	client1 connect.
	client1 writeLine: 'GET / HTTP/1.0'.
	client1 writeLine: ''.
	client1 flush.
	client1 readLine.
	client1 readLine.	
	client1 close.

	"SSL Socket example"
	client2 := InternetSocketClient onSocket: (SSLSocket port: 443 host: 'www.elliottwave.com').
	client2 connect.
	client2 writeLine: 'GET / HTTP/1.1'.
	client2 writeLine: 'Host: www.elliottwave.com'.
	client2 writeLine: ''.
	client2 flush.
	client2 readLine.
	client2 readLine.
	client2 close.

	

	
	! !
!InternetSocketClient class categoriesFor: #example1!public! !

!InternetSocketClient class methodsFor!
onSocket: aSocket
	"Create an InternetSocketClient object attached to the given Socket. The Socket should be a subclass
	of AbstractSocket (eg. Socket or SSLSocket). It is assumed that the socket is already connected."

	| client |
	client := super new.
	client socket: aSocket.
	^client.
	! !
!InternetSocketClient class categoriesFor: #onSocket:!public! !

!InternetSocketClient class categoriesFor: #example1!examples!private! !

!InternetSocketClient class categoriesFor: #onSocket:!instance creation!public! !

SSLeay32Library guid: (GUID fromString: '{0708D344-D36A-11D4-B744-D05C3E1CAB01}')!

SSLeay32Library guid: (GUID fromString: '{0708D344-D36A-11D4-B744-D05C3E1CAB01}')!
SSLeay32Library comment: 'The OpenSSL dynamic link library.

Author: Chris Double
mailto: chris@double.co.nz
http://www.double.co.nz/smalltalk'!

SSLeay32Library comment:
'The OpenSSL dynamic link library.

Author: Chris Double
mailto: chris@double.co.nz
http://www.double.co.nz/smalltalk'!
!SSLeay32Library categoriesForClass!Unclassified! !
!SSLeay32Library methodsFor!
sslConnect: p1
	"int SSL_connect (
		void* ssl);"

	<stdcall: sdword SSL_connect lpvoid>
	^self invalidCall! !
!SSLeay32Library categoriesFor: #sslConnect:!public! !

!SSLeay32Library methodsFor!
sslCtxFree: p1
	"void SSL_CTX_free (
		void* ctx);"

	<stdcall: void SSL_CTX_free lpvoid>
	^self invalidCall
! !
!SSLeay32Library categoriesFor: #sslCtxFree:!public! !

!SSLeay32Library methodsFor!
sslCtxNew: p1
	"void* SSL_CTX_new (
		void* meth);"

	<stdcall: lpvoid SSL_CTX_new lpvoid>
	^self invalidCall! !
!SSLeay32Library categoriesFor: #sslCtxNew:!public! !

!SSLeay32Library methodsFor!
sslFree: p1
	"void SSL_free (
		void* ssl);"

	<stdcall: void SSL_free lpvoid>
	^self invalidCall! !
!SSLeay32Library categoriesFor: #sslFree:!public! !

!SSLeay32Library methodsFor!
sslGetError: p1 code: p2
	"int SSL_set_fd (
		void* s,
	     	int rc);"

	<stdcall: sdword SSL_get_error lpvoid sdword>
	^self invalidCall

! !
!SSLeay32Library categoriesFor: #sslGetError:code:!public! !

!SSLeay32Library methodsFor!
sslLibraryInit
	"int SSL_library_init(void);"

	<stdcall: sdword SSL_library_init>
	^self invalidCall! !
!SSLeay32Library categoriesFor: #sslLibraryInit!public! !

!SSLeay32Library methodsFor!
sslLoadErrorStrings
	"void SSL_load_error_strings(void);"

	<stdcall: void SSL_load_error_strings>
	^self invalidCall! !
!SSLeay32Library categoriesFor: #sslLoadErrorStrings!public! !

!SSLeay32Library methodsFor!
sslNew: p1
	"void* SSL_new (
		void* ctx);"

	<stdcall: lpvoid SSL_new lpvoid>
	^self invalidCall
! !
!SSLeay32Library categoriesFor: #sslNew:!public! !

!SSLeay32Library methodsFor!
sslRead: p1 buffer: p2 length: p3
	"int SSL_read (
		void* ssl,
                char* buffer,
		int length);"

	<stdcall: sdword SSL_read lpvoid lpvoid sdword>
	^self invalidCall! !
!SSLeay32Library categoriesFor: #sslRead:buffer:length:!public! !

!SSLeay32Library methodsFor!
sslSetFd: p1 descriptor: p2
	"int SSL_set_fd (
		void* s,
	     	int fd);"

	<stdcall: sdword SSL_set_fd lpvoid sdword>
	^self invalidCall

! !
!SSLeay32Library categoriesFor: #sslSetFd:descriptor:!public! !

!SSLeay32Library methodsFor!
sslShutdown: p1
	"int SSL_shutdown(void* s);"

	<stdcall: sdword SSL_shutdown lpvoid>
	^self invalidCall! !
!SSLeay32Library categoriesFor: #sslShutdown:!public! !

!SSLeay32Library methodsFor!
sslv23ClientMethod
	"void* SSLv23_client_method(void);"

	<stdcall: lpvoid SSLv23_client_method>
	^self invalidCall
! !
!SSLeay32Library categoriesFor: #sslv23ClientMethod!public! !

!SSLeay32Library methodsFor!
sslv2ClientMethod
	"void* SSLv2_client_method(void);"

	<stdcall: lpvoid SSLv2_client_method>
	^self invalidCall! !
!SSLeay32Library categoriesFor: #sslv2ClientMethod!public! !

!SSLeay32Library methodsFor!
sslv3ClientMethod
	"void* SSLv3_client_method(void);"

	<stdcall: lpvoid SSLv3_client_method>
	^self invalidCall
! !
!SSLeay32Library categoriesFor: #sslv3ClientMethod!public! !

!SSLeay32Library methodsFor!
sslWrite: p1 buffer: p2 length: p3
	"int SSL_write (
		void* ssl,
                char* buffer,
		int length);"

	<stdcall: sdword SSL_write lpvoid lpvoid sdword>
	^self invalidCall! !
!SSLeay32Library categoriesFor: #sslWrite:buffer:length:!public! !

!SSLeay32Library categoriesFor: #sslConnect:!public! !

!SSLeay32Library categoriesFor: #sslCtxFree:!public! !

!SSLeay32Library categoriesFor: #sslCtxNew:!public! !

!SSLeay32Library categoriesFor: #sslFree:!public! !

!SSLeay32Library categoriesFor: #sslGetError:code:!public! !

!SSLeay32Library categoriesFor: #sslLibraryInit!public! !

!SSLeay32Library categoriesFor: #sslLoadErrorStrings!public! !

!SSLeay32Library categoriesFor: #sslNew:!public! !

!SSLeay32Library categoriesFor: #sslRead:buffer:length:!public! !

!SSLeay32Library categoriesFor: #sslSetFd:descriptor:!public! !

!SSLeay32Library categoriesFor: #sslShutdown:!public! !

!SSLeay32Library categoriesFor: #sslv23ClientMethod!public! !

!SSLeay32Library categoriesFor: #sslv2ClientMethod!public! !

!SSLeay32Library categoriesFor: #sslv3ClientMethod!public! !

!SSLeay32Library categoriesFor: #sslWrite:buffer:length:!public! !

!SSLeay32Library class methodsFor!
fileName
	"Answer the host system file name of the external library which the 
	receiver represents"

	^'SSLEAY32'

! !
!SSLeay32Library class categoriesFor: #fileName!public! !

!SSLeay32Library class methodsFor!
onStartup2
	"Perform session startup processing for this library."

	self startSocketSystem! !
!SSLeay32Library class categoriesFor: #onStartup2!public! !

!SSLeay32Library class methodsFor!
startSocketSystem
	"Initialise the SSL system."

	self default sslLibraryInit.
	self default sslLoadErrorStrings.
! !
!SSLeay32Library class categoriesFor: #startSocketSystem!public! !

!SSLeay32Library class categoriesFor: #fileName!constants!public! !

!SSLeay32Library class categoriesFor: #onStartup2!event handling!public! !

!SSLeay32Library class categoriesFor: #startSocketSystem!initializing!public! !

SSLSocket guid: (GUID fromString: '{0708D345-D36A-11D4-B744-D05C3E1CAB01}')!

SSLSocket guid: (GUID fromString: '{0708D345-D36A-11D4-B744-D05C3E1CAB01}')!
SSLSocket comment: 'A subclass of Socket that can connect via the SSL protocol using the OpenSSL libraries.

Author: Chris Double
mailto: chris@double.co.nz
http://www.double.co.nz/smalltalk'!

SSLSocket comment:
'A subclass of Socket that can connect via the SSL protocol using the OpenSSL libraries.

Author: Chris Double
mailto: chris@double.co.nz
http://www.double.co.nz/smalltalk'!
!SSLSocket categoriesForClass!Unclassified! !
!SSLSocket methodsFor!
basicConnect
	"Private - Attempt a socket connection to a host."

	| aHOSTENT result socketAddress |

	self create.
	(socketAddress := SOCKADDR_IN new)
		sin_family: AF_INET;
		sin_port: (WSockLibrary default htons: self port);
		sin_addr: (IN_ADDR address: self address).
	
	result := WSockLibrary default
		connect: self asParameter
		name: socketAddress asParameter
		namelen: socketAddress byteSize.
	(result = 0) ifFalse: [
		"The call is overlapped, so any error that occurred will have been stored into the Process
		 by the overlapped call primitive"
		SocketError signalWith: Processor activeProcess lastError].

        method := SSLeay32Library default sslv23ClientMethod.
	ctx := SSLeay32Library default sslCtxNew: method.
	handle := SSLeay32Library default sslNew: ctx.
	
	SSLeay32Library default sslSetFd: handle descriptor: (self descriptor).
	SSLeay32Library default sslConnect: handle.

	self
		registerDescriptor;
		allowAsyncEvents.
! !
!SSLSocket categoriesFor: #basicConnect!public! !

!SSLSocket methodsFor!
basicReceiveByteArray: anInteger
	"Private - Reads anInteger bytes from the socket.
	Answers a ByteArray representing the bytes read."

	| bytesReceived byteArray |
	byteArray := ByteArray new: anInteger.
	bytesReceived := SSLeay32Library default
		sslRead: handle
		buffer: byteArray
		length: byteArray size.

	bytesReceived > 0 ifTrue:
		[ "Success."
		^byteArray copyFrom: 1 to: bytesReceived ].
	bytesReceived = 0 ifTrue:
		[ "Socket has been closed."
		SocketClosed signal ].
	"Some other error."
	self error.
! !
!SSLSocket categoriesFor: #basicReceiveByteArray:!public! !

!SSLSocket methodsFor!
basicSendByteArray: aByteArray
	"Private - Sends aByteArray through the socket."

	| result |
	result := SSLeay32Library default
		sslWrite: handle
		buffer: aByteArray
		length: aByteArray size.

	result = -1 ifTrue: [self error].
	^result
! !
!SSLSocket categoriesFor: #basicSendByteArray:!public! !

!SSLSocket methodsFor!
close
	"Close the socket."

        handle = nil ifFalse: [ SSLeay32Library default sslShutdown: handle ].
        super close.
	handle = nil ifFalse: [ SSLeay32Library default sslFree: handle ].
	handle = nil ifFalse: [ SSLeay32Library default sslCtxFree: ctx ].
	handle := nil.
	ctx := nil.
	method := nil.
! !
!SSLSocket categoriesFor: #close!public! !

!SSLSocket methodsFor!
initialize
	"Private - Initialize the receiver."

	super initialize.
        method := nil.
	ctx := nil.
	handle := nil.
! !
!SSLSocket categoriesFor: #initialize!public! !

!SSLSocket categoriesFor: #basicConnect!must not strip!private! !

!SSLSocket categoriesFor: #basicReceiveByteArray:!must not strip!private! !

!SSLSocket categoriesFor: #basicSendByteArray:!must not strip!private! !

!SSLSocket categoriesFor: #close!must not strip!public! !

!SSLSocket categoriesFor: #initialize!must not strip!private! !

"Binary Globals"!

"Resources"!

!

SSLeay32Library startSocketSystem.!

"22:58:24, 17 November 2004: Loading package 'SW String Utilities' from: C:\Documents and Settings\Ted\Desktop\Mugpunters\Placepot\Steve Waring\Utilities\Additions\SW String Utilities.pac"!

"Class Definitions"!

Object subclass: #SWSU
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

"Global Aliases"!

"Loose Methods"!

"End of package definition"!

"Source Globals"!

"Classes"!

SWSU guid: (GUID fromString: '{5BDD7790-C84E-4627-9055-1C9153583F37}')!

SWSU guid: (GUID fromString: '{5BDD7790-C84E-4627-9055-1C9153583F37}')!
SWSU comment: 'Loose method pain avoidence class'!

SWSU comment:
'Loose method pain avoidence class'!
!SWSU categoriesForClass!Kernel-Objects! !
!SWSU class methodsFor!
addPathSlash: aPath
	(aPath isNil or: [aPath isEmpty]) ifTrue: [^aPath].
	^aPath last = $\ ifTrue: [aPath] ifFalse: [aPath , '\']! !
!SWSU class categoriesFor: #addPathSlash:!public! !

!SWSU class methodsFor!
addUrlSlash: aUrlString
	(aUrlString isNil or: [aUrlString isEmpty]) ifTrue: [^aUrlString].
	^aUrlString last = $/ ifTrue: [aUrlString] ifFalse: [aUrlString , '/']! !
!SWSU class categoriesFor: #addUrlSlash:!public! !

!SWSU class methodsFor!
byteSizeStringFor: bytes
	bytes < 1024 ifTrue: [^bytes displayString , ' bytes'].
	bytes <= 1000000 ifTrue: [^(bytes / 1024 roundTo: 0.1) displayString , 'KB'].
	bytes <= (1024 * 1024 * 1023) 
		ifTrue: [^(bytes / 1024 / 1024 roundTo: 1.0e-002) displayString , 'MB'].
	^(bytes / 1024 / 1024 / 1024 roundTo: 1.0e-002) displayString , 'GB'! !
!SWSU class categoriesFor: #byteSizeStringFor:!public! !

!SWSU class methodsFor!
copy: aString expanding: aTable
	"Answer a copy of the receiver with the chartacters in aTable expanded to their value strings.
	-aTable must be a table keying characters to strings"

	| keys stream |
	keys := aTable keys asArray.
	stream := WriteStream on: (String new: aString size).
	aString do: 
			[:each | 
			(keys includes: each) 
				ifTrue: [stream nextPutAll: (aTable at: each)]
				ifFalse: [stream nextPut: each]].
	^stream contents! !
!SWSU class categoriesFor: #copy:expanding:!public! !

!SWSU class methodsFor!
copyCombiningSeparators: aString
	| inStream outStream isLastSeparator |
	inStream := aString readStream.
	outStream := (String new: aString size) writeStream.
	isLastSeparator := false.
	[inStream atEnd] whileFalse: 
			[| next |
			next := inStream next.
			next isSeparator 
				ifTrue: 
					[isLastSeparator 
						ifFalse: 
							[outStream space.
							isLastSeparator := true]]
				ifFalse: 
					[isLastSeparator := false.
					outStream nextPut: next]].
	^outStream contents! !
!SWSU class categoriesFor: #copyCombiningSeparators:!public! !

!SWSU class methodsFor!
copyReplacingLineDelimiters: aString
	^aString 
		collect: [:each | each isLinefeed | (each = Character cr) ifTrue: [Character space] ifFalse: [each]]! !
!SWSU class categoriesFor: #copyReplacingLineDelimiters:!public! !

!SWSU class methodsFor!
does: aString1 endWith: aString2
	aString2 size > aString1 size ifTrue: [^false].
	^(aString1 last: aString2 size) = aString2! !
!SWSU class categoriesFor: #does:endWith:!public! !

!SWSU class methodsFor!
extractHTMLFormatFragment: anHTMLFormatString
	| stream |
	stream := anHTMLFormatString readStream.
	(stream skipToAll: '<!!--StartFragment-->') 
		ifFalse: [self error: 'Could not find the StartFragment comment'].
	^stream upToAll: '<!!--EndFragment-->'! !
!SWSU class categoriesFor: #extractHTMLFormatFragment:!public! !

!SWSU class methodsFor!
extractHTMLFormatSourceURL: anHTMLFormatString
	| stream |
	stream := anHTMLFormatString readStream.
	(stream skipToAll: 'SourceURL:') 
		ifFalse: [self error: 'Could not find the SourceURL header'].
	^(stream swUpToWhile: [:c | (c = Character lf | (c = Character cr)) not]) trimBlanks! !
!SWSU class categoriesFor: #extractHTMLFormatSourceURL:!public! !

!SWSU class methodsFor!
makePathUnique: aPathAndFilename
	"Note: Windows functions for this only seem to be win2k+"

	| split newFilename fnSplit num |
	(File exists: aPathAndFilename) ifFalse: [^aPathAndFilename].
	split := File splitPath: aPathAndFilename.
	('*(*)' match: split third) 
		ifTrue: 
			[fnSplit := self split: split third atLast: $(.
			num := [Integer fromString: (fnSplit second copyFrom: 1 to: fnSplit second size - 1)] 
						on: Error
						do: [:e | 0].
			num := num + 1.
			newFilename := fnSplit first , '(' , num displayString , ')']
		ifFalse: [newFilename := split third , ' (1)'].
	^self makePathUnique: (File 
				composePath: split first , split second
				stem: newFilename
				extension: split fourth)! !
!SWSU class categoriesFor: #makePathUnique:!public! !

!SWSU class methodsFor!
numFilesIn: aPath
	| count |
	count := 0.
	File 
		for: '*.*'
		in: aPath
		do: [:each | each isDirectory ifFalse: [count := count + 1]].
	^count! !
!SWSU class categoriesFor: #numFilesIn:!public! !

!SWSU class methodsFor!
pad: aString with: aChar to: aNumber
	| newString |
	newString := (String new: aNumber) atAllPut: aChar.
	^aString 
		replaceBytesOf: newString
		from: 1
		to: (aString size min: aNumber - 2)
		startingAt: 1! !
!SWSU class categoriesFor: #pad:with:to:!public! !

!SWSU class methodsFor!
padLeft: aString with: aChar to: aNumber
	aString size >= aNumber ifTrue: [^aString].
	^(String new: aNumber - aString size withAll: aChar) , aString! !
!SWSU class categoriesFor: #padLeft:with:to:!public! !

!SWSU class methodsFor!
rootPathOf: path
	^(File splitPath: path) first asUppercase copyWith: File pathDelimiter! !
!SWSU class categoriesFor: #rootPathOf:!public! !

!SWSU class methodsFor!
split: aString atLast: aCharacter
	| charIndex |
	charIndex := aString findLast: [:c | c = aCharacter].
	^charIndex = 0 
		ifTrue: [Array with: aString with: nil]
		ifFalse: 
			[Array with: (aString copyFrom: 1 to: charIndex - 1)
				with: (aString copyFrom: charIndex + 1 to: aString size)]! !
!SWSU class categoriesFor: #split:atLast:!public! !

!SWSU class methodsFor!
truncate: aString to: anInteger
	"truncate to anInteger chars if needed.
	Note it puts a space between the truncation and elipses"

	^aString size > anInteger 
		ifTrue: [(aString leftString: anInteger - 4) , ' ...']
		ifFalse: [aString]! !
!SWSU class categoriesFor: #truncate:to:!public! !

!SWSU class methodsFor!
truncateStart: aString to: anInteger
	"truncate to anInteger chars if needed ... anInteger could be 4, but really??"

	anInteger < 5 ifTrue: [self error: 'Invalid truncatation argument'].
	^aString size > anInteger 
		ifTrue: ['...' , (aString rightString: anInteger - 3)]
		ifFalse: [aString]! !
!SWSU class categoriesFor: #truncateStart:to:!public! !

!SWSU class categoriesFor: #addPathSlash:!paths!public! !

!SWSU class categoriesFor: #addUrlSlash:!paths!public! !

!SWSU class categoriesFor: #byteSizeStringFor:!public!strings! !

!SWSU class categoriesFor: #copy:expanding:!public!strings! !

!SWSU class categoriesFor: #copyCombiningSeparators:!public!strings! !

!SWSU class categoriesFor: #copyReplacingLineDelimiters:!public!strings! !

!SWSU class categoriesFor: #does:endWith:!public!strings! !

!SWSU class categoriesFor: #extractHTMLFormatFragment:!html!public! !

!SWSU class categoriesFor: #extractHTMLFormatSourceURL:!html!public! !

!SWSU class categoriesFor: #makePathUnique:!paths!public! !

!SWSU class categoriesFor: #numFilesIn:!files!public! !

!SWSU class categoriesFor: #pad:with:to:!public!strings! !

!SWSU class categoriesFor: #padLeft:with:to:!public!strings! !

!SWSU class categoriesFor: #rootPathOf:!paths!public! !

!SWSU class categoriesFor: #split:atLast:!public!strings! !

!SWSU class categoriesFor: #truncate:to:!public!strings! !

!SWSU class categoriesFor: #truncateStart:to:!public!strings! !

"Binary Globals"!

"Resources"!

!

"22:58:24, 17 November 2004: Loading package 'SW HTTPClient Support' from: C:\Documents and Settings\Ted\Desktop\Mugpunters\Placepot\Steve Waring\HTTPClient\SW HTTPClient Support.pac"!

"Class Definitions"!

Object subclass: #SptHTTPUrl
	instanceVariableNames: 'urlString'
	classVariableNames: 'EncodeArray'
	poolDictionaries: ''
	classInstanceVariableNames: ''!

"Global Aliases"!

"Loose Methods"!

"End of package definition"!

"Source Globals"!

"Classes"!

SptHTTPUrl guid: (GUID fromString: '{1F077915-0DD0-461C-9DD1-894EB69E24AA}')!

SptHTTPUrl guid: (GUID fromString: '{1F077915-0DD0-461C-9DD1-894EB69E24AA}')!
SptHTTPUrl comment: 'I am an absolute HTTP Url.

I can be constructed in the context of a ''previous'' instance, and I will:
  - If not absolute, use the previous instance to make myself absolute

My class has a number of utility methods for testing/accessing url <String>s

Instance Variables:
	urlString		<String> 


'!

SptHTTPUrl comment:
'I am an absolute HTTP Url.

I can be constructed in the context of a ''previous'' instance, and I will:
  - If not absolute, use the previous instance to make myself absolute

My class has a number of utility methods for testing/accessing url <String>s

Instance Variables:
	urlString		<String> 


'!
!SptHTTPUrl categoriesForClass!Kernel-Objects! !
!SptHTTPUrl methodsFor!
= aSptHTTPUrl
	"Note: this is quick and dirty and will have false negatives"

	^(aSptHTTPUrl isKindOf: self class) and: [urlString = aSptHTTPUrl urlString]! !
!SptHTTPUrl categoriesFor: #=!public! !

!SptHTTPUrl methodsFor!
absolutePath
	| stream |
	stream := urlString readStream.
	self authorityFrom: stream.
	^'/' , (stream atEnd ifTrue: [''] ifFalse: [stream upToEnd])! !
!SptHTTPUrl categoriesFor: #absolutePath!public! !

!SptHTTPUrl methodsFor!
asSegments
	| coll stream |
	coll := OrderedCollection new.
	coll add: self hostPort.
	stream := self path readStream.
	self assert: [stream next = $/].
	[stream atEnd] whileFalse: [coll add: (stream upTo: $/)].
	^coll asArray! !
!SptHTTPUrl categoriesFor: #asSegments!public! !

!SptHTTPUrl methodsFor!
authority
	^self authorityFrom: urlString readStream! !
!SptHTTPUrl categoriesFor: #authority!public! !

!SptHTTPUrl methodsFor!
authorityFrom: stream
	self schemeFrom: stream.
	^stream upTo: $/! !
!SptHTTPUrl categoriesFor: #authorityFrom:!public! !

!SptHTTPUrl methodsFor!
defaultPort
	self scheme = 'http' ifTrue: [^80].
	self scheme = 'https' ifTrue: [^443].
	self error: 'Scheme not knowen ' , self scheme displayString! !
!SptHTTPUrl categoriesFor: #defaultPort!public! !

!SptHTTPUrl methodsFor!
displayOn: aStream
	aStream display: urlString! !
!SptHTTPUrl categoriesFor: #displayOn:!public! !

!SptHTTPUrl methodsFor!
hash
	^urlString hash! !
!SptHTTPUrl categoriesFor: #hash!public! !

!SptHTTPUrl methodsFor!
hasUserInfo
	^self authority includes: $@! !
!SptHTTPUrl categoriesFor: #hasUserInfo!public! !

!SptHTTPUrl methodsFor!
host
	^self hostPort readStream upTo: $:! !
!SptHTTPUrl categoriesFor: #host!public! !

!SptHTTPUrl methodsFor!
hostPort
	| authority authorityStream |
	authority := self authority.
	authorityStream := authority readStream.
	(authority includes: $@) ifTrue: [authorityStream upTo: $@].
	^authorityStream upToEnd! !
!SptHTTPUrl categoriesFor: #hostPort!public! !

!SptHTTPUrl methodsFor!
isFileScheme
	^false! !
!SptHTTPUrl categoriesFor: #isFileScheme!public! !

!SptHTTPUrl methodsFor!
isHttpUrl
	^true! !
!SptHTTPUrl categoriesFor: #isHttpUrl!public! !

!SptHTTPUrl methodsFor!
isInSpaceOf: aString
	^urlString beginsWith: (self class fromString: aString) localBaseUrlString! !
!SptHTTPUrl categoriesFor: #isInSpaceOf:!public! !

!SptHTTPUrl methodsFor!
isNullUrl
	^urlString isNil or: [urlString isEmpty]! !
!SptHTTPUrl categoriesFor: #isNullUrl!public! !

!SptHTTPUrl methodsFor!
isSecure
	^self scheme = 'https'! !
!SptHTTPUrl categoriesFor: #isSecure!public! !

!SptHTTPUrl methodsFor!
lastSegment
	"
	(SptHTTPUrl fromString: 'http://www.foo.org/index.html') lastSegment
		'index.html' 
	"

	^self class lastSegmentOfPath: self path! !
!SptHTTPUrl categoriesFor: #lastSegment!public! !

!SptHTTPUrl methodsFor!
lastSegmentAndQuery
	"
	(SptHTTPUrl fromString: 'http://www.foo.org/index.html?foo=bar') lastSegmentAndQuery
		'index.html?foo=bar'
	"

	| query |
	^(query := self queryString) isEmpty 
		ifTrue: [self lastSegment]
		ifFalse: [self lastSegment , '?' , query]! !
!SptHTTPUrl categoriesFor: #lastSegmentAndQuery!public! !

!SptHTTPUrl methodsFor!
localBasePath
	"
	(SptHTTPUrl fromString: 'http://www.foo.org/bar/index.html') localBasePath
		'/bar/'
	"

	| path |
	path := self path.
	^path last = $/ 
		ifTrue: [path]
		ifFalse: [path copyFrom: 1 to: (path findLast: [:each | each = $/])]! !
!SptHTTPUrl categoriesFor: #localBasePath!public! !

!SptHTTPUrl methodsFor!
localBaseUrl
	Notification deprecated.
	^self localBaseUrlString! !
!SptHTTPUrl categoriesFor: #localBaseUrl!public! !

!SptHTTPUrl methodsFor!
localBaseUrlString
	"
	(SptHTTPUrl fromString: 'http://www.foo.org/bar/index.html') localBaseUrlString
		'http://www.foo.org/bar/'
	"

	^self rootBaseUrlString , self localBasePath! !
!SptHTTPUrl categoriesFor: #localBaseUrlString!public! !

!SptHTTPUrl methodsFor!
path
	| absolutePath end |
	absolutePath := self absolutePath.
	end := absolutePath indexOfAnyOf: '?#' startingAt: 1.
	^end = 0 ifTrue: [absolutePath] ifFalse: [absolutePath copyFrom: 1 to: end - 1]! !
!SptHTTPUrl categoriesFor: #path!public! !

!SptHTTPUrl methodsFor!
port
	| stream |
	stream := self hostPort readStream.
	stream upTo: $:.
	^stream atEnd ifTrue: [self defaultPort] ifFalse: [stream upToEnd asNumber]! !
!SptHTTPUrl categoriesFor: #port!public! !

!SptHTTPUrl methodsFor!
querySegments
	"
	(SptHTTPUrl fromString: 'http://www.foo.org/index.html?foo=bar') querySegments
		an OrderedCollection('foo' 'bar')
	"

	| segments |
	segments := OrderedCollection new.
	(self queryString subStrings: $&) do: 
			[:each | 
			| stream |
			stream := each trimBlanks readStream.
			segments add: (stream upTo: $=).
			stream atEnd ifFalse: [segments add: stream upToEnd]].
	^segments! !
!SptHTTPUrl categoriesFor: #querySegments!public! !

!SptHTTPUrl methodsFor!
queryString
	"
	(SptHTTPUrl fromString: 'http://www.foo.org/index.html?foo=bar') queryString
		'foo=bar'
	"

	| stream |
	stream := self absolutePath readStream.
	stream upTo: $?.
	^stream upToEnd! !
!SptHTTPUrl categoriesFor: #queryString!public! !

!SptHTTPUrl methodsFor!
queryStrings
	"
	(SptHTTPUrl fromString: 'http://www.foo.org/index.html?foo=bar') queryStrings
		#('foo' -> 'bar')
	"

	^(self queryString subStrings: $&) collect: 
			[:each | 
			| k v stream |
			stream := each trimBlanks readStream.
			k := stream upTo: $=.
			v := stream atEnd ifTrue: [] ifFalse: [stream upToEnd].
			k -> v]! !
!SptHTTPUrl categoriesFor: #queryStrings!public! !

!SptHTTPUrl methodsFor!
rootBaseUrl
	Notification deprecated.
	^self rootBaseUrlString! !
!SptHTTPUrl categoriesFor: #rootBaseUrl!public! !

!SptHTTPUrl methodsFor!
rootBaseUrlString
	"
	(SptHTTPUrl fromString: 'http://www.foo.org/bar/index.html') rootBaseUrlString
		'http://www.foo.org'
	"

	| stream scheme |
	stream := urlString readStream.
	scheme := self schemeFrom: stream.
	^scheme , '://' , (stream upTo: $/)! !
!SptHTTPUrl categoriesFor: #rootBaseUrlString!public! !

!SptHTTPUrl methodsFor!
scheme
	"
	(SptHTTPUrl fromString: 'http://www.foo.org/bar/index.html') scheme
		'http'
	"

	^self schemeFrom: urlString readStream! !
!SptHTTPUrl categoriesFor: #scheme!public! !

!SptHTTPUrl methodsFor!
schemeFrom: aReadStream
	| scheme |
	scheme := aReadStream upTo: $:.
	self assert: [(aReadStream next: 2) = '//'].
	^scheme! !
!SptHTTPUrl categoriesFor: #schemeFrom:!public! !

!SptHTTPUrl methodsFor!
url: aUrlString
	Notification deprecated.
	urlString := aUrlString! !
!SptHTTPUrl categoriesFor: #url:!public! !

!SptHTTPUrl methodsFor!
urlString
	^urlString! !
!SptHTTPUrl categoriesFor: #urlString!public! !

!SptHTTPUrl methodsFor!
urlString: aUrlString
	urlString := aUrlString! !
!SptHTTPUrl categoriesFor: #urlString:!public! !

!SptHTTPUrl methodsFor!
userInfo
	| authority authorityStream |
	((authority := self authority) includes: $@) ifFalse: [^nil].
	authorityStream := authority readStream.
	^authorityStream upTo: $@! !
!SptHTTPUrl categoriesFor: #userInfo!public! !

!SptHTTPUrl categoriesFor: #=!comparing!public! !

!SptHTTPUrl categoriesFor: #absolutePath!accessing!public! !

!SptHTTPUrl categoriesFor: #asSegments!accessing!public! !

!SptHTTPUrl categoriesFor: #authority!accessing!public! !

!SptHTTPUrl categoriesFor: #authorityFrom:!helpers!private! !

!SptHTTPUrl categoriesFor: #defaultPort!accessing!public! !

!SptHTTPUrl categoriesFor: #displayOn:!displaying!public! !

!SptHTTPUrl categoriesFor: #hash!comparing!public! !

!SptHTTPUrl categoriesFor: #hasUserInfo!public!testing! !

!SptHTTPUrl categoriesFor: #host!accessing!public! !

!SptHTTPUrl categoriesFor: #hostPort!accessing!public! !

!SptHTTPUrl categoriesFor: #isFileScheme!public!testing! !

!SptHTTPUrl categoriesFor: #isHttpUrl!public!testing! !

!SptHTTPUrl categoriesFor: #isInSpaceOf:!public!testing! !

!SptHTTPUrl categoriesFor: #isNullUrl!private!testing! !

!SptHTTPUrl categoriesFor: #isSecure!public!testing! !

!SptHTTPUrl categoriesFor: #lastSegment!accessing!public! !

!SptHTTPUrl categoriesFor: #lastSegmentAndQuery!accessing!public! !

!SptHTTPUrl categoriesFor: #localBasePath!accessing!public! !

!SptHTTPUrl categoriesFor: #localBaseUrl!accessing!public! !

!SptHTTPUrl categoriesFor: #localBaseUrlString!accessing!public! !

!SptHTTPUrl categoriesFor: #path!accessing!public! !

!SptHTTPUrl categoriesFor: #port!accessing!public! !

!SptHTTPUrl categoriesFor: #querySegments!accessing!public! !

!SptHTTPUrl categoriesFor: #queryString!accessing!public! !

!SptHTTPUrl categoriesFor: #queryStrings!accessing!public! !

!SptHTTPUrl categoriesFor: #rootBaseUrl!accessing!public! !

!SptHTTPUrl categoriesFor: #rootBaseUrlString!accessing!public! !

!SptHTTPUrl categoriesFor: #scheme!accessing!public! !

!SptHTTPUrl categoriesFor: #schemeFrom:!helpers!private! !

!SptHTTPUrl categoriesFor: #url:!accessing!public! !

!SptHTTPUrl categoriesFor: #urlString!accessing!public! !

!SptHTTPUrl categoriesFor: #urlString:!accessing!private! !

!SptHTTPUrl categoriesFor: #userInfo!accessing!public! !

!SptHTTPUrl class methodsFor!
canonicalize: aString
	"Answer a <String>"

	| stream encoding |
	stream := (String new: aString size) writeStream.
	aString do: 
			[:each | 
			(EncodeArray at: each asInteger) 
				ifTrue: 
					[encoding := each asInteger printStringRadix: 16 showRadix: false.
					stream nextPut: $%.
					encoding size = 1 ifTrue: [stream nextPut: $0].
					stream nextPutAll: encoding]
				ifFalse: [stream nextPut: each]].
	^stream contents! !
!SptHTTPUrl class categoriesFor: #canonicalize:!public! !

!SptHTTPUrl class methodsFor!
containerOf: aUrlString
	"Answer the container url <String> of aUrlString or nil if it is the root url 
		self containerOf: 'http://www.foo.org/'  answers nil.
		self containerOf: 'http://www.foo.org/foo'  answers 'http://www.foo.org/'.
		self containerOf: 'http://www.foo.org/foo/'  answers 'http://www.foo.org/'.
		self containerOf: 'http://www.foo.org/foo/bar'  answers 'http://www.foo.org/foo/'."

	| contRemoved lastSlash |
	((self isAbsolute: aUrlString) and: [(self fromString: aUrlString) absolutePath = '/']) 
		ifTrue: [^nil].
	aUrlString = '/' ifTrue: [^nil].
	contRemoved := (self isContainer: aUrlString) 
				ifTrue: [aUrlString allButLast]
				ifFalse: [aUrlString].
	lastSlash := contRemoved findLast: [:c | c = $/].
	^aUrlString copyFrom: 1 to: lastSlash! !
!SptHTTPUrl class categoriesFor: #containerOf:!public! !

!SptHTTPUrl class methodsFor!
doesHost: aString1 match: aString2
	"
		SptHTTPUrl doesHost: 'cache.foo.org' match: 'www.foo.org'
			true
	"

	| host1 host2 requiredMatches |
	host1 := (aString1 subStrings: $.) reverse.
	host2 := (aString2 subStrings: $.) reverse.
	host1 isEmpty ifTrue: [^false].
	requiredMatches := (self specialDomainEndings includes: host1 first asLowercase) 
				ifTrue: [2]
				ifFalse: [3].
	(host1 size < requiredMatches or: [host2 size < requiredMatches]) ifTrue: [^false].
	1 to: requiredMatches do: [:i | ((host1 at: i) sameAs: (host2 at: i)) ifFalse: [^false]].
	^true! !
!SptHTTPUrl class categoriesFor: #doesHost:match:!public! !

!SptHTTPUrl class methodsFor!
extensionOf: aUrlString
	"Answer the last segment <String> of aUrlString  
		self extensionOf: 'http://www.foo.org/'  answers nil.
		self extensionOf: 'http://www.foo.org/foo'  answers nil.
		self extensionOf: 'http://www.foo.org/foo.'  answers ''.
		self extensionOf: 'http://www.foo.org/foo.bar'  answers 'bar'."

	^(SWSU split: (self lastSegmentOf: aUrlString) atLast: $.) second! !
!SptHTTPUrl class categoriesFor: #extensionOf:!public! !

!SptHTTPUrl class methodsFor!
fromString: aUrlString
	"Answer an instance.
	aUrlString must be absolute (ie http://host:port/path)"

	^self fromString: aUrlString previous: nil! !
!SptHTTPUrl class categoriesFor: #fromString:!public! !

!SptHTTPUrl class methodsFor!
fromString: aUrlString previous: aSptHTTPUrlOrNil
	"Answer a new instance.
	- If aUrlString is an absolutePath (ie '/foo/index.html') or local (ie 'index.html') 
		then make it absolute to aSptHTTPUrl"

	^self new urlString: (self makeAbsolute: aUrlString previous: aSptHTTPUrlOrNil)! !
!SptHTTPUrl class categoriesFor: #fromString:previous:!public! !

!SptHTTPUrl class methodsFor!
initialize
	"
	self initialize
	"

	EncodeArray := Array new: 255.
	1 to: 255 do: [:i | EncodeArray at: i put: (self shouldEncode: (Character codePoint: i))]! !
!SptHTTPUrl class categoriesFor: #initialize!public! !

!SptHTTPUrl class methodsFor!
is: aUrlString1 childOf: aUrlString2
	"Assume both strings are the same type of url (ie absolute/relative), 
		answer if 1 is a direct child of 2 in the url namespace"

	| relative separatorPosition |
	(self is: aUrlString1 descendentOf: aUrlString2) ifFalse: [^false].
	relative := aUrlString1 copyFrom: aUrlString2 size + 1 to: aUrlString1 size.
	separatorPosition := relative findFirst: [:each | each = $/].
	^separatorPosition = 0 or: [separatorPosition = relative size]! !
!SptHTTPUrl class categoriesFor: #is:childOf:!public! !

!SptHTTPUrl class methodsFor!
is: aUrlString1 descendentOf: aUrlString2
	"Assume both strings are the same type of url (ie absolute/relative), 
		answer if 1 is a descendent of 2 in the url namespace"

	^(self is: aUrlString1 descendentOrSelfOf: aUrlString2) 
		and: [aUrlString1 size > aUrlString2 size]! !
!SptHTTPUrl class categoriesFor: #is:descendentOf:!public! !

!SptHTTPUrl class methodsFor!
is: aUrlString1 descendentOrSelfOf: aUrlString2
	"Assume both strings are the same type of url (ie absolute/relative), 
		answer if 1 is a descendent or the same as  2 in the url namespace"

	^aUrlString1 beginsWith: aUrlString2! !
!SptHTTPUrl class categoriesFor: #is:descendentOrSelfOf:!public! !

!SptHTTPUrl class methodsFor!
isAbsolute: aUrlString
	"
	self isAbsolute:  'http://www.foo.org/index.html'. 
		true
	self isAbsolute:  '/index.html'. 
		false
	"

	^(self schemeOf: aUrlString) 
		ifNil: [false]
		ifNotNil: [:s | #('http' 'https') includes: s asLowercase]! !
!SptHTTPUrl class categoriesFor: #isAbsolute:!public! !

!SptHTTPUrl class methodsFor!
isAbsolutePath: aUrlString
	^aUrlString beginsWith: '/'! !
!SptHTTPUrl class categoriesFor: #isAbsolutePath:!public! !

!SptHTTPUrl class methodsFor!
isCommonNonHTTPScheme: aUrlString
	| stream possibleScheme |
	stream := aUrlString readStream.
	possibleScheme := stream upTo: $:.
	^#('ftp' 'gopher' 'mailto' 'emailto' 'news' 'telnet' 'javascript') 
		includes: possibleScheme asLowercase! !
!SptHTTPUrl class categoriesFor: #isCommonNonHTTPScheme:!public! !

!SptHTTPUrl class methodsFor!
isContainer: aUrlString
	^aUrlString last = $/! !
!SptHTTPUrl class categoriesFor: #isContainer:!public! !

!SptHTTPUrl class methodsFor!
isLocal: aUrlString
	"
	self isLocal:  'http://www.foo.org/index.html'. 
		false
	self isLocal:  '/index.html'. 
		false
	self isLocal:  'index.html'. 
		true

	"

	^(self isAbsolute: aUrlString) not and: [(self isAbsolutePath: aUrlString) not]! !
!SptHTTPUrl class categoriesFor: #isLocal:!public! !

!SptHTTPUrl class methodsFor!
lastSegmentOf: aUrlString
	"Answer the last segment <String> of aUrlString  
		self lastSegmentOf: 'http://www.foo.org/'  answers '/'.
		self lastSegmentOf: 'http://www.foo.org/foo'  answers 'foo'.
		self lastSegmentOf: 'http://www.foo.org/foo/'  answers 'foo'.
		self lastSegmentOf: 'http://www.foo.org/foo/bar'  answers 'bar'.

		self lastSegmentOf: 'http://www.foo.org/foo/bar?blab'  answers 'bar'."

	^self lastSegmentOfPath: ((self isAbsolute: aUrlString) 
				ifTrue: [(self fromString: aUrlString) path]
				ifFalse: [aUrlString])! !
!SptHTTPUrl class categoriesFor: #lastSegmentOf:!public! !

!SptHTTPUrl class methodsFor!
lastSegmentOfPath: aPathString
	| slashRemoved index |
	aPathString = '/' ifTrue: [^aPathString].
	index := (slashRemoved := (self isContainer: aPathString) 
						ifTrue: [aPathString allButLast]
						ifFalse: [aPathString]) findLast: [:c | c = $/].
	self assert: [index > 0].
	^slashRemoved copyFrom: index + 1 to: slashRemoved size! !
!SptHTTPUrl class categoriesFor: #lastSegmentOfPath:!public! !

!SptHTTPUrl class methodsFor!
makeAbsolute: aUrlString previous: aSptHTTPUrl
	| canUrlString |
	canUrlString := self recan: aUrlString.
	(self isAbsolute: canUrlString) 
		ifTrue: [^canUrlString]
		ifFalse: [aSptHTTPUrl isNil ifTrue: [self error: 'Can not make absolute']].
	^(self isAbsolutePath: canUrlString) 
		ifTrue: [aSptHTTPUrl rootBaseUrlString , canUrlString]
		ifFalse: [self makeRelAbsolute: canUrlString previous: aSptHTTPUrl]! !
!SptHTTPUrl class categoriesFor: #makeAbsolute:previous:!public! !

!SptHTTPUrl class methodsFor!
makeRelAbsolute: aRelUrlString previous: aSptHTTPUrl
	"http://www.ietf.org/rfc/rfc2396.txt  5.2"

	"a) All but the last segment of the base URI's path component is copied to the buffer. "

	| urlString |
	urlString := aSptHTTPUrl localBasePath allButFirst.

	"b) The reference's path component is appended to the buffer string. "
	urlString := urlString , aRelUrlString.	"(SWSU split: aRelUrlString atLast: $/) second displayString."

	"c) All occurrences of './', where '.' is a complete path segment, are removed from the buffer string. "
	urlString := self removeDotSlashOf: urlString.

	"d) If the buffer string ends with '.' as a complete path segment, that '.' is removed. "
	(SWSU does: urlString endWith: '/.') ifTrue: [urlString := urlString allButLast].

	"e) All occurrences of '/../', where is a complete path segment not equal to '..', are removed from the buffer string. Removal of these path segments is performed iteratively, removing the leftmost matching pattern on each iteration, until no matching pattern remains. "
	urlString := self removeSegmentDotDotSlashOf: urlString.

	"f) If the buffer string ends with '/..', where is a complete path segment not equal to '..', that '/..' is removed. "
	(SWSU does: urlString endWith: '/..') ifTrue: [urlString := urlString allButLast: 3].

	"g) If the resulting buffer string still begins with one or more complete path segments of '..', then the reference is considered to be in error. Implementations may handle this error by retaining these components in the resolved path (i.e., treating them as part of the final URI), by removing them from the resolved path (i.e., discarding relative levels above the root), or by avoiding traversal of the reference. "
	(urlString beginsWith: '../') ifTrue: [urlString := urlString allButFirst: 3].
	(urlString beginsWith: './') ifTrue: [urlString := urlString allButFirst: 2].
	^aSptHTTPUrl rootBaseUrlString , '/' , urlString! !
!SptHTTPUrl class categoriesFor: #makeRelAbsolute:previous:!public! !

!SptHTTPUrl class methodsFor!
makeSchemeLowercase: aString
	| stream scheme |
	(scheme := self schemeOf: aString) ifNil: [^aString].
	stream := aString readStream.
	stream skipTo: $:.
	^scheme asLowercase , ':' , stream upToEnd! !
!SptHTTPUrl class categoriesFor: #makeSchemeLowercase:!public! !

!SptHTTPUrl class methodsFor!
makeUrlRefString: aString
	"This method attempts to make a urlString from aString"

	| text firstLine |
	text := aString trimBlanks.
	firstLine := text readStream nextLine.
	firstLine := self makeSchemeLowercase: firstLine.
	"If aString has an existing scheme, we cant make a http url"
	(#('http' 'https' nil) includes: (self schemeOf: firstLine)) 
		ifFalse: [self error: 'Cant not create a url from a non-http scheme'].
	"Is it already an http url?"
	('http*' match: firstLine) ifTrue: [^firstLine].
	"Doesnt it start with 'www'?"
	('www.*' match: firstLine) ifTrue: [^'http://' , firstLine].
	"If all else fails ... use the same technique as IE"
	^'http://www.' , firstLine! !
!SptHTTPUrl class categoriesFor: #makeUrlRefString:!public! !

!SptHTTPUrl class methodsFor!
recan: aString
	"Answer a <String>"

	^self canonicalize: (self uncanonicalize: aString)! !
!SptHTTPUrl class categoriesFor: #recan:!public! !

!SptHTTPUrl class methodsFor!
removeDotSlashOf: aUrlString
	| urlString index |
	urlString := aUrlString.
	[(index := urlString indexOfSubCollection: '/./') = 0] whileFalse: 
			[urlString := (urlString copyFrom: 1 to: index) 
						, (urlString copyFrom: index + 3 to: urlString size)].
	^urlString! !
!SptHTTPUrl class categoriesFor: #removeDotSlashOf:!public! !

!SptHTTPUrl class methodsFor!
removeSegmentDotDotSlashOf: aUrlString
	| urlString index |
	urlString := aUrlString.
	[(index := urlString indexOfSubCollection: '/../') = 0] whileFalse: 
			[| segmentIndex |
			segmentIndex := urlString 
						prevIndexOf: $/
						from: index - 1
						to: 1.
			urlString := (urlString copyFrom: 1 to: segmentIndex) 
						, (urlString copyFrom: index + 4 to: urlString size)].
	^urlString! !
!SptHTTPUrl class categoriesFor: #removeSegmentDotDotSlashOf:!public! !

!SptHTTPUrl class methodsFor!
schemeOf: aUrlString
	| stream scheme |
	stream := aUrlString readStream.
	scheme := stream upToAll: '://'.
	stream atEnd ifTrue: [^nil].
	^scheme! !
!SptHTTPUrl class categoriesFor: #schemeOf:!public! !

!SptHTTPUrl class methodsFor!
shouldEncode: aCharacter
	^(aCharacter isAlphaNumeric 
		or: [('-_.!!~*''()' includes: aCharacter) or: [';/?:@=&' includes: aCharacter]]) not! !
!SptHTTPUrl class categoriesFor: #shouldEncode:!public! !

!SptHTTPUrl class methodsFor!
specialDomainEndings
	"As defined by the Cookie specification"

	^#('com' 'edu' 'net' 'org' 'gov' 'mil' 'int')! !
!SptHTTPUrl class categoriesFor: #specialDomainEndings!public! !

!SptHTTPUrl class methodsFor!
splitFragmentOf: aUrlReferenceString
	"http://www.ietf.org/rfc/rfc2396.txt
	A URI reference may be absolute or relative, and may have additional information attached in the form of a fragment identifier. However, 'the URI' that results from such a reference includes only the absolute URI after the fragment identifier (if any) is removed and after any relative URI is resolved to its absolute form."

	^SWSU split: aUrlReferenceString atLast: $#! !
!SptHTTPUrl class categoriesFor: #splitFragmentOf:!public! !

!SptHTTPUrl class methodsFor!
uncanonicalize: aString
	"Answer a <String>"

	^aString unescapePercents
	"| outStream inStream |
	outStream := String writeStream.
	inStream := aString readStream.
	[inStream atEnd] whileFalse: 
			[| char |
			outStream nextPut: ((char := inStream next) = $% 
						ifTrue: 
							[Character value: (Integer readFrom: (inStream next: 2) asUppercase readStream radix: 16)]
						ifFalse: [char])].
	^outStream contents"! !
!SptHTTPUrl class categoriesFor: #uncanonicalize:!public! !

!SptHTTPUrl class categoriesFor: #canonicalize:!canonicalizing!public! !

!SptHTTPUrl class categoriesFor: #containerOf:!public!utilities-accessing! !

!SptHTTPUrl class categoriesFor: #doesHost:match:!public!utilities-testing! !

!SptHTTPUrl class categoriesFor: #extensionOf:!public!utilities-accessing! !

!SptHTTPUrl class categoriesFor: #fromString:!instance creation!public! !

!SptHTTPUrl class categoriesFor: #fromString:previous:!instance creation!public! !

!SptHTTPUrl class categoriesFor: #initialize!initializing!private! !

!SptHTTPUrl class categoriesFor: #is:childOf:!public!utilities-testing! !

!SptHTTPUrl class categoriesFor: #is:descendentOf:!public!utilities-testing! !

!SptHTTPUrl class categoriesFor: #is:descendentOrSelfOf:!public!utilities-testing! !

!SptHTTPUrl class categoriesFor: #isAbsolute:!public!utilities-testing! !

!SptHTTPUrl class categoriesFor: #isAbsolutePath:!public!utilities-testing! !

!SptHTTPUrl class categoriesFor: #isCommonNonHTTPScheme:!public!utilities-testing! !

!SptHTTPUrl class categoriesFor: #isContainer:!public!utilities-testing! !

!SptHTTPUrl class categoriesFor: #isLocal:!public!utilities-testing! !

!SptHTTPUrl class categoriesFor: #lastSegmentOf:!public!utilities-accessing! !

!SptHTTPUrl class categoriesFor: #lastSegmentOfPath:!private!utilities-accessing! !

!SptHTTPUrl class categoriesFor: #makeAbsolute:previous:!private!utilities-converting! !

!SptHTTPUrl class categoriesFor: #makeRelAbsolute:previous:!private!utilities-converting! !

!SptHTTPUrl class categoriesFor: #makeSchemeLowercase:!private!utilities-converting! !

!SptHTTPUrl class categoriesFor: #makeUrlRefString:!public!utilities-converting! !

!SptHTTPUrl class categoriesFor: #recan:!canonicalizing!public! !

!SptHTTPUrl class categoriesFor: #removeDotSlashOf:!private!utilities-converting! !

!SptHTTPUrl class categoriesFor: #removeSegmentDotDotSlashOf:!private!utilities-converting! !

!SptHTTPUrl class categoriesFor: #schemeOf:!public!utilities-accessing! !

!SptHTTPUrl class categoriesFor: #shouldEncode:!canonicalizing!private! !

!SptHTTPUrl class categoriesFor: #specialDomainEndings!public!utilities-accessing! !

!SptHTTPUrl class categoriesFor: #splitFragmentOf:!public!utilities-converting! !

!SptHTTPUrl class categoriesFor: #uncanonicalize:!canonicalizing!public! !

"Binary Globals"!

"Resources"!

!

"22:58:24, 17 November 2004: Loading package 'Base64' from: C:\Documents and Settings\Ted\Desktop\Mugpunters\Placepot\Steve Waring\Utilities\Base64\Base64.pac"!

"Class Definitions"!

Object subclass: #Base64Decoder
	instanceVariableNames: 'bitCount inputStream outputStream data'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #Base64Encoder
	instanceVariableNames: 'data currentByteIndex outputStream bitCount outputCharPosition charsRead'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

"Global Aliases"!

"Loose Methods"!

"End of package definition"!

"Source Globals"!

"Classes"!

Base64Decoder guid: (GUID fromString: '{57C4AB3F-1E44-4145-9B9A-78D8BE4E1A1D}')!

Base64Decoder guid: (GUID fromString: '{57C4AB3F-1E44-4145-9B9A-78D8BE4E1A1D}')!
Base64Decoder comment: 'Performs Base64 decoding
This class by Steve Wart
at; http://www.serf.org/steve/Dolphin/'!

Base64Decoder comment:
'Performs Base64 decoding
This class by Steve Wart
at; http://www.serf.org/steve/Dolphin/'!
!Base64Decoder categoriesForClass!Unclassified! !
!Base64Decoder methodsFor!
bits: char
	"Return the bits represented by a base64 char.  If character is out of range
	 return nil."

	| code |
	code := char codePoint.
	(code > ##($A asciiValue - 1) and: [code < ##($Z asciiValue + 1)]) 
		ifTrue: [^code - 65	"Char - $A"].
	(code > ##($a asciiValue - 1) and: [code < ##($z asciiValue + 1)]) 
		ifTrue: [^code - 97 + 26	"Char - $a"].
	(code > ##($0 asciiValue - 1) and: [code < ##($9 asciiValue + 1)]) 
		ifTrue: [^code - 48 + 52	"Char - $0"].
	char == $+ ifTrue: [^62].
	char == $/ ifTrue: [^63].
	^nil! !
!Base64Decoder categoriesFor: #bits:!public! !

!Base64Decoder methodsFor!
decode: inputTextStream to: outputByteStream
	"Perform a decoding."

	| char |
	bitCount := 0.	"Bits in the data to be written out."
	inputStream := inputTextStream.
	outputStream := outputByteStream.
	data := 0.
	[inputStream atEnd] whileFalse: 
			[char := inputStream next.

			"Check for terminator before EOF (means data was padded to nearest 6 bits)."
			char = $= ifTrue: [^self terminate].
			self processChar: char]! !
!Base64Decoder categoriesFor: #decode:to:!public! !

!Base64Decoder methodsFor!
processBits
	"Process the 8-bit groups in 'data'."

	| bitGroup index bitMask bitShift |
	[bitCount > 0] whileTrue: 
			["Index into bit maks and shifts."

			index := (bitCount / 8) asInteger.

			"Get the mask to extract out the appropriate 8 bits."
			bitMask := #(255 65280 16711680) at: index.

			"The shift value to get the bits down to 0-255."
			bitShift := 8 - bitCount.

			"Extract the bits."
			bitGroup := (data bitAnd: bitMask) bitShift: bitShift.

			"Write out the byte."
			outputStream nextPut: bitGroup.
			bitCount := bitCount - 8]! !
!Base64Decoder categoriesFor: #processBits!public! !

!Base64Decoder methodsFor!
processChar: aChar
	"Process a new character."

	"Ignore non base-64 chars."

	| bits |
	(bits := self bits: aChar) isNil ifTrue: [^self].
	data := (data bitShift: 6) bitOr: bits.
	(bitCount := bitCount + 6) = 24 
		ifTrue: 
			[self processBits.
			bitCount := 0.
			data := 0]! !
!Base64Decoder categoriesFor: #processChar:!public! !

!Base64Decoder methodsFor!
terminate
	"A $= char has been hit, which indicates a messy end to to the data i.e. a padding
	 to the nearest 6 bits. Check for another $= which means that 8 bits of the data
	 are meaningful, else 16 bits are to be used."

	"If  16 bits to be used, then data was padded to 18, so shift by -2."

	| shift |
	shift := -2.
	inputStream atEnd 
		ifFalse: 
			[inputStream skipSeparators 
				ifTrue: 
					[inputStream next = $= 
						ifTrue: 
							["If  8 bits to be used, then data was padded to 12, so shift by -4."

							shift := -4]]].
	bitCount := bitCount + shift.
	data := data bitShift: shift.
	self processBits! !
!Base64Decoder categoriesFor: #terminate!public! !

!Base64Decoder categoriesFor: #bits:!helpers!public! !

!Base64Decoder categoriesFor: #decode:to:!operations!public! !

!Base64Decoder categoriesFor: #processBits!operations!public! !

!Base64Decoder categoriesFor: #processChar:!operations!public! !

!Base64Decoder categoriesFor: #terminate!operations!public! !

Base64Encoder guid: (GUID fromString: '{458608E4-38AF-435A-878D-B382585C3958}')!

Base64Encoder guid: (GUID fromString: '{458608E4-38AF-435A-878D-B382585C3958}')!
Base64Encoder comment: 'Performs Base64 decoding
This class by Steve Wart
at; http://www.serf.org/steve/Dolphin/'!

Base64Encoder comment:
'Performs Base64 decoding
This class by Steve Wart
at; http://www.serf.org/steve/Dolphin/'!
!Base64Encoder categoriesForClass!Unclassified! !
!Base64Encoder methodsFor!
base64Char: index
	"Return the appropriate base64 char."

	index < 26 ifTrue: [^Character value: $A codePoint + index].
	index < 52 ifTrue: [^Character value: $a codePoint + index - 26].
	index < 62 ifTrue: [^Character value: $0 codePoint + index - 52].
	index == 62 ifTrue: [^$+].
	index == 63 ifTrue: [^$/]! !
!Base64Encoder categoriesFor: #base64Char:!public! !

!Base64Encoder methodsFor!
encode: inputByteStream to: outputTextStream
	"Perform an encoding."

	charsRead := 0.	"Number of chars read in the file."
	bitCount := 0.	"Bits in the data to be written out."
	outputCharPosition := 0.	"Char position in the output line."
	outputStream := outputTextStream.
	data := 0.
	[inputByteStream atEnd] whileFalse: [self processByte: inputByteStream next].

	"Check to see if any padding at the end is required. See RFC1521 -
	the aim is to make things up to the the nearest 6 bits."
	bitCount = 8 
		ifTrue: 
			[data := data bitShift: 4.
			bitCount := 12.
			self
				processBits;
				writeChar: $=;
				writeChar: $=]
		ifFalse: 
			[bitCount = 16 
				ifTrue: 
					[data := data bitShift: 2.
					bitCount := 18.
					self
						processBits;
						writeChar: $=]]! !
!Base64Encoder categoriesFor: #encode:to:!public! !

!Base64Encoder methodsFor!
processBits
	"Process the 6-bit groups in 'data'."

	| bitGroup index bitMask bitShift |
	[bitCount > 0] whileTrue: 
			["Index into bit maks and shifts."

			index := (bitCount / 6) asInteger.

			"Get the mask to extract out the appropriate 6 bits."
			bitMask := #(63 4032 258048 16515072) at: index.

			"The shift value to get the bits down to 0-63."
			bitShift := (bitCount - 6) negated.

			"Extract the bits."
			bitGroup := (data bitAnd: bitMask) bitShift: bitShift.

			"Write out the char."
			self writeChar: (self base64Char: bitGroup).
			bitCount := bitCount - 6]! !
!Base64Encoder categoriesFor: #processBits!public! !

!Base64Encoder methodsFor!
processByte: aByte
	"Process a new byte."

	data := (data bitShift: 8) bitOr: aByte.
	(bitCount := bitCount + 8) = 24 
		ifTrue: 
			[self processBits.
			bitCount := 0.
			data := 0]! !
!Base64Encoder categoriesFor: #processByte:!public! !

!Base64Encoder methodsFor!
writeChar: c
	"Write out the character and handle line ends."

	outputStream nextPut: c.
	(outputCharPosition := outputCharPosition + 1) = 70 
		ifTrue: 
			["Base64 RFC says allow no more than 76 chars per line."

			outputStream cr.
			outputCharPosition := 0]! !
!Base64Encoder categoriesFor: #writeChar:!public! !

!Base64Encoder categoriesFor: #base64Char:!helpers!public! !

!Base64Encoder categoriesFor: #encode:to:!operations!public! !

!Base64Encoder categoriesFor: #processBits!operations!public! !

!Base64Encoder categoriesFor: #processByte:!operations!public! !

!Base64Encoder categoriesFor: #writeChar:!operations!public! !

"Binary Globals"!

"Resources"!

!

"22:58:24, 17 November 2004: Loading package 'SZ Sockets' from: C:\Documents and Settings\Ted\Desktop\Mugpunters\Placepot\Steve Waring\Utilities\Sockets\SZ Sockets.pac"!

"Class Definitions"!

ReadWriteStream subclass: #SZReadWriteSocketStream
	instanceVariableNames: 'readStream writeStream'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

SZReadWriteSocketStream subclass: #SZLoggingSocketStream
	instanceVariableNames: 'logStream'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

"Global Aliases"!

SwazooLoggingStream := SZLoggingSocketStream!

SwazooStream := SZReadWriteSocketStream!

"Loose Methods"!

!ServerSocket methodsFor!
preBindPort: anInteger
	"Private - Same as #bindPort, but dont call bind."

	#swAdded.
	self
		port: anInteger;
		create;
		registerDescriptor;
		allowAsyncEvents! !
!ServerSocket categoriesFor: #preBindPort:!public! !

!ServerSocket methodsFor!
setREUSEADDR
	| result v |
	#swAdded.
	result := WSockLibrary default 
				setsockopt: self asParameter
				level: 65535
				optname: 4
				optval: (v := DWORD fromInteger: 1) asParameter
				optlen: v byteSize.	"SOL_SOCKET      0xffff"	"SO_REUSEADDR    0x0004 /* allow local address reuse */"
	result = 0 ifFalse: [self error]! !
!ServerSocket categoriesFor: #setREUSEADDR!public! !

!ServerSocket categoriesFor: #preBindPort:!operations!private!swazoo! !

!ServerSocket categoriesFor: #setREUSEADDR!accessing!public!swazoo! !

!ServerSocket class methodsFor!
portReuseAddr: anIntegerPort
	#swAdded.
	^self portReuseAddr: anIntegerPort backlog: self defaultMaxPendingConnects! !
!ServerSocket class categoriesFor: #portReuseAddr:!public! !

!ServerSocket class methodsFor!
portReuseAddr: anIntegerPort backlog: anInteger
	"Answer a new instance of the receiver set up to listen on anIntegerPort.
	Setting the REUSEADDR option means that the server can start listening 
	if there is a socket with the same host/port in the TIME_WAIT state. 
	Practically it means that we can stop and restart the server without 
	waiting a couple of minutes)"

	#swAdded.
	^(self new)
		preBindPort: anIntegerPort;
		setREUSEADDR;
		bind;
		listen: anInteger;
		yourself! !
!ServerSocket class categoriesFor: #portReuseAddr:backlog:!public! !

!ServerSocket class categoriesFor: #portReuseAddr:!instance creation!public!swazoo! !

!ServerSocket class categoriesFor: #portReuseAddr:backlog:!instance creation!public!swazoo! !

!Socket methodsFor!
localAddress
	"Answer an InternetAddress representing the address of the peer machine."

	| winSockAddr winSockAddrLen result |
	#swAdded.
	winSockAddr := SOCKADDR_IN new.
	winSockAddrLen := SDWORD new.
	winSockAddrLen value: winSockAddr byteSize.
	result := WSockLibrary default 
				getsockname: self asParameter
				name: winSockAddr
				namelen: winSockAddrLen.
	result = -1 ifTrue: [self error].
	^InternetAddress ipAddress: winSockAddr sin_addr! !
!Socket categoriesFor: #localAddress!public! !

!Socket methodsFor!
swazooLogStream
	#swAdded.
	^SZLoggingSocketStream socket: self! !
!Socket categoriesFor: #swazooLogStream!public! !

!Socket methodsFor!
swazooStream
	#swAdded.
	^SZReadWriteSocketStream socket: self! !
!Socket categoriesFor: #swazooStream!public! !

!Socket categoriesFor: #localAddress!accessing!public!swazoo! !

!Socket categoriesFor: #swazooLogStream!accessing!public!swazoo! !

!Socket categoriesFor: #swazooStream!accessing!public!swazoo! !

"End of package definition"!

"Source Globals"!

"Classes"!

SZReadWriteSocketStream guid: (GUID fromString: '{557229A8-E4DE-4B75-BB8D-B088E2E202F8}')!

SZReadWriteSocketStream guid: (GUID fromString: '{557229A8-E4DE-4B75-BB8D-B088E2E202F8}')!
SZReadWriteSocketStream comment: 'I am  a ReadWrite SocketStream. My stream contentSpecies is <String>, but I also provide methods to access the streams using ByteArrays/Integers.

Instance Variables:
	readStream	<SocketReadStream> 
	writeStream	<SocketWriteStream>

==========
Note:
-The readStream and writeStream can be streams (on ByteArrays) for testing purposes
'!

SZReadWriteSocketStream comment:
'I am  a ReadWrite SocketStream. My stream contentSpecies is <String>, but I also provide methods to access the streams using ByteArrays/Integers.

Instance Variables:
	readStream	<SocketReadStream> 
	writeStream	<SocketWriteStream>

==========
Note:
-The readStream and writeStream can be streams (on ByteArrays) for testing purposes
'!
!SZReadWriteSocketStream categoriesForClass!Unclassified! !
!SZReadWriteSocketStream methodsFor!
atEnd
	^readStream atEnd! !
!SZReadWriteSocketStream categoriesFor: #atEnd!public! !

!SZReadWriteSocketStream methodsFor!
close
	writeStream notNil ifTrue: [writeStream close].
	readStream notNil ifTrue: [readStream close].
	writeStream := readStream := nil! !
!SZReadWriteSocketStream categoriesFor: #close!public! !

!SZReadWriteSocketStream methodsFor!
contentsSpecies
	^String! !
!SZReadWriteSocketStream categoriesFor: #contentsSpecies!public! !

!SZReadWriteSocketStream methodsFor!
crlf
	self nextPutBytes: #[13 10]! !
!SZReadWriteSocketStream categoriesFor: #crlf!public! !

!SZReadWriteSocketStream methodsFor!
doBytes: operation
	[operation value: self nextByte] repeat! !
!SZReadWriteSocketStream categoriesFor: #doBytes:!public! !

!SZReadWriteSocketStream methodsFor!
flush
	writeStream flush! !
!SZReadWriteSocketStream categoriesFor: #flush!public! !

!SZReadWriteSocketStream methodsFor!
hasInput 
	^readStream hasInput! !
!SZReadWriteSocketStream categoriesFor: #hasInput!public! !

!SZReadWriteSocketStream methodsFor!
log
	^''! !
!SZReadWriteSocketStream categoriesFor: #log!public! !

!SZReadWriteSocketStream methodsFor!
next
	"Answer a Character"

	^Character codePoint:  readStream next
! !
!SZReadWriteSocketStream categoriesFor: #next!public! !

!SZReadWriteSocketStream methodsFor!
next: anInteger
	^(self nextBytes: anInteger) asString
! !
!SZReadWriteSocketStream categoriesFor: #next:!public! !

!SZReadWriteSocketStream methodsFor!
next: count into: aSequenceableCollection startingAt: startAt
	^readStream 
		next: count
		into: aSequenceableCollection
		startingAt: startAt! !
!SZReadWriteSocketStream categoriesFor: #next:into:startingAt:!public! !

!SZReadWriteSocketStream methodsFor!
next: size putAll: aSequenceableCollection startingAt: start
	^writeStream 
		next: size
		putAll: aSequenceableCollection
		startingAt: start! !
!SZReadWriteSocketStream categoriesFor: #next:putAll:startingAt:!public! !

!SZReadWriteSocketStream methodsFor!
nextByte
	^(self nextBytes: 1) first
! !
!SZReadWriteSocketStream categoriesFor: #nextByte!public! !

!SZReadWriteSocketStream methodsFor!
nextBytes: anInteger
	^readStream 
		next: anInteger
		into: (ByteArray new: anInteger)
		startingAt: 1! !
!SZReadWriteSocketStream categoriesFor: #nextBytes:!public! !

!SZReadWriteSocketStream methodsFor!
nextPut: aCharacter
	^self nextPutByte: aCharacter asInteger
! !
!SZReadWriteSocketStream categoriesFor: #nextPut:!public! !

!SZReadWriteSocketStream methodsFor!
nextPutAll: aByteObject
	self nextPutBytes: aByteObject asByteArray.
	^aByteObject
! !
!SZReadWriteSocketStream categoriesFor: #nextPutAll:!public! !

!SZReadWriteSocketStream methodsFor!
nextPutByte: anInteger
	^writeStream nextPut: anInteger 
! !
!SZReadWriteSocketStream categoriesFor: #nextPutByte:!public! !

!SZReadWriteSocketStream methodsFor!
nextPutBytes: aByteArray
	^writeStream nextPutAll: aByteArray
! !
!SZReadWriteSocketStream categoriesFor: #nextPutBytes:!public! !

!SZReadWriteSocketStream methodsFor!
peek
	^self peekByte asCharacter! !
!SZReadWriteSocketStream categoriesFor: #peek!public! !

!SZReadWriteSocketStream methodsFor!
peekByte
	^readStream peek! !
!SZReadWriteSocketStream categoriesFor: #peekByte!public! !

!SZReadWriteSocketStream methodsFor!
readStream
	^readStream! !
!SZReadWriteSocketStream categoriesFor: #readStream!public! !

!SZReadWriteSocketStream methodsFor!
readStream: aReadStream writeStream: aWriteStream
	readStream := aReadStream.
	writeStream := aWriteStream.! !
!SZReadWriteSocketStream categoriesFor: #readStream:writeStream:!public! !

!SZReadWriteSocketStream methodsFor!
resetLogStream! !
!SZReadWriteSocketStream categoriesFor: #resetLogStream!public! !

!SZReadWriteSocketStream methodsFor!
socket
	^readStream socket! !
!SZReadWriteSocketStream categoriesFor: #socket!public! !

!SZReadWriteSocketStream methodsFor!
upToCRLF
	| line |
	line := self upTo: Character cr.
	self assert: [self next = Character lf].
	^line! !
!SZReadWriteSocketStream categoriesFor: #upToCRLF!public! !

!SZReadWriteSocketStream methodsFor!
writeStream
	^writeStream! !
!SZReadWriteSocketStream categoriesFor: #writeStream!public! !

!SZReadWriteSocketStream methodsFor!
writeStream: aWriteStream
	writeStream := aWriteStream! !
!SZReadWriteSocketStream categoriesFor: #writeStream:!public! !

!SZReadWriteSocketStream categoriesFor: #atEnd!public!testing! !

!SZReadWriteSocketStream categoriesFor: #close!operations!public! !

!SZReadWriteSocketStream categoriesFor: #contentsSpecies!accessing!private! !

!SZReadWriteSocketStream categoriesFor: #crlf!accessing-string!public! !

!SZReadWriteSocketStream categoriesFor: #doBytes:!accessing-bytes!public! !

!SZReadWriteSocketStream categoriesFor: #flush!operations!public! !

!SZReadWriteSocketStream categoriesFor: #hasInput!private!testing! !

!SZReadWriteSocketStream categoriesFor: #log!accessing!private! !

!SZReadWriteSocketStream categoriesFor: #next!accessing-string!public! !

!SZReadWriteSocketStream categoriesFor: #next:!accessing-string!public! !

!SZReadWriteSocketStream categoriesFor: #next:into:startingAt:!accessing!private! !

!SZReadWriteSocketStream categoriesFor: #next:putAll:startingAt:!accessing!private! !

!SZReadWriteSocketStream categoriesFor: #nextByte!accessing-bytes!public! !

!SZReadWriteSocketStream categoriesFor: #nextBytes:!accessing-bytes!public! !

!SZReadWriteSocketStream categoriesFor: #nextPut:!accessing-string!public! !

!SZReadWriteSocketStream categoriesFor: #nextPutAll:!accessing-string!public! !

!SZReadWriteSocketStream categoriesFor: #nextPutByte:!accessing-bytes!public! !

!SZReadWriteSocketStream categoriesFor: #nextPutBytes:!accessing-bytes!public! !

!SZReadWriteSocketStream categoriesFor: #peek!accessing-string!public! !

!SZReadWriteSocketStream categoriesFor: #peekByte!accessing-bytes!public! !

!SZReadWriteSocketStream categoriesFor: #readStream!accessing!public! !

!SZReadWriteSocketStream categoriesFor: #readStream:writeStream:!accessing!private! !

!SZReadWriteSocketStream categoriesFor: #resetLogStream!operations!public! !

!SZReadWriteSocketStream categoriesFor: #socket!accessing!public! !

!SZReadWriteSocketStream categoriesFor: #upToCRLF!accessing-string!public! !

!SZReadWriteSocketStream categoriesFor: #writeStream!accessing!public! !

!SZReadWriteSocketStream categoriesFor: #writeStream:!accessing!public! !

!SZReadWriteSocketStream class methodsFor!
port: anIntegerPort host: aStringHostName
	^self socket: ((Socket port: anIntegerPort host: aStringHostName)
				connect;
				yourself)! !
!SZReadWriteSocketStream class categoriesFor: #port:host:!public! !

!SZReadWriteSocketStream class methodsFor!
readStream: aReadStream writeStream: aWriteStream
	^self basicNew readStream: aReadStream writeStream: aWriteStream
! !
!SZReadWriteSocketStream class categoriesFor: #readStream:writeStream:!public! !

!SZReadWriteSocketStream class methodsFor!
socket: aSocket
	^self readStream: aSocket readStream writeStream: aSocket writeStream

! !
!SZReadWriteSocketStream class categoriesFor: #socket:!public! !

!SZReadWriteSocketStream class methodsFor!
testStreamReading: aByteObject
	"SW Test helper method.
	-aByteArray is set (and reset) into the readStream."

	^self readStream: aByteObject asByteArray readStream writeStream: ByteArray writeStream! !
!SZReadWriteSocketStream class categoriesFor: #testStreamReading:!public! !

!SZReadWriteSocketStream class categoriesFor: #port:host:!instance creation!public! !

!SZReadWriteSocketStream class categoriesFor: #readStream:writeStream:!instance creation!public! !

!SZReadWriteSocketStream class categoriesFor: #socket:!instance creation!public! !

!SZReadWriteSocketStream class categoriesFor: #testStreamReading:!instance creation!public! !

SZLoggingSocketStream guid: (GUID fromString: '{99847C40-41CE-4170-93D2-FC4F389A15C3}')!

SZLoggingSocketStream guid: (GUID fromString: '{99847C40-41CE-4170-93D2-FC4F389A15C3}')!
SZLoggingSocketStream comment: 'I can be used in place of a SwazooStream. I logs everything read and written to me.
'!

SZLoggingSocketStream comment:
'I can be used in place of a SwazooStream. I logs everything read and written to me.
'!
!SZLoggingSocketStream categoriesForClass!Unclassified! !
!SZLoggingSocketStream methodsFor!
doLog: operation
	logStream notNil ifTrue: [operation value]! !
!SZLoggingSocketStream categoriesFor: #doLog:!public! !

!SZLoggingSocketStream methodsFor!
log
	^logStream contents! !
!SZLoggingSocketStream categoriesFor: #log!public! !

!SZLoggingSocketStream methodsFor!
next
	| ans |
	ans := super next.
	self doLog: [logStream nextPut: ans].
	^ans! !
!SZLoggingSocketStream categoriesFor: #next!public! !

!SZLoggingSocketStream methodsFor!
next: count into: aSequenceableCollection startingAt: startAt
	| ans |
	ans := super 
				next: count
				into: aSequenceableCollection
				startingAt: startAt.
	self doLog: [logStream nextPutAll: ans asString].
	^ans! !
!SZLoggingSocketStream categoriesFor: #next:into:startingAt:!public! !

!SZLoggingSocketStream methodsFor!
next: size putAll: aSequenceableCollection startingAt: start
	| ans |
	ans := super 
				next: size
				putAll: aSequenceableCollection
				startingAt: start.
	self doLog: [logStream nextPutAll: aSequenceableCollection asString].
	^ans! !
!SZLoggingSocketStream categoriesFor: #next:putAll:startingAt:!public! !

!SZLoggingSocketStream methodsFor!
nextBytes: aNumber
	| ans |
	ans := super nextBytes: aNumber.
	self doLog: [logStream nextPutAll: ans asString].
	^ans
! !
!SZLoggingSocketStream categoriesFor: #nextBytes:!public! !

!SZLoggingSocketStream methodsFor!
nextPutByte: anInteger
	| ans |
	ans := super nextPutByte: anInteger.
	self doLog: [logStream nextPut: (Character value: anInteger)].
	^ans! !
!SZLoggingSocketStream categoriesFor: #nextPutByte:!public! !

!SZLoggingSocketStream methodsFor!
nextPutBytes: aByteArray
	| ans |
	ans := super nextPutBytes: aByteArray.
	self doLog: [logStream nextPutAll: aByteArray asString].
	^ans
! !
!SZLoggingSocketStream categoriesFor: #nextPutBytes:!public! !

!SZLoggingSocketStream methodsFor!
readStream: aReadStream writeStream: aWriteStream
	super readStream: aReadStream writeStream: aWriteStream.
	self resetLogStream.! !
!SZLoggingSocketStream categoriesFor: #readStream:writeStream:!public! !

!SZLoggingSocketStream methodsFor!
resetLogStream
	logStream := WriteStream on: String new.! !
!SZLoggingSocketStream categoriesFor: #resetLogStream!public! !

!SZLoggingSocketStream categoriesFor: #doLog:!operations!private! !

!SZLoggingSocketStream categoriesFor: #log!accessing!public! !

!SZLoggingSocketStream categoriesFor: #next!accessing-string!public! !

!SZLoggingSocketStream categoriesFor: #next:into:startingAt:!accessing!private! !

!SZLoggingSocketStream categoriesFor: #next:putAll:startingAt:!accessing!private! !

!SZLoggingSocketStream categoriesFor: #nextBytes:!accessing-bytes!public! !

!SZLoggingSocketStream categoriesFor: #nextPutByte:!accessing-bytes!public! !

!SZLoggingSocketStream categoriesFor: #nextPutBytes:!accessing-bytes!public! !

!SZLoggingSocketStream categoriesFor: #readStream:writeStream:!accessing!private! !

!SZLoggingSocketStream categoriesFor: #resetLogStream!operations!public! !

"Binary Globals"!

"Resources"!

!

"22:58:24, 17 November 2004: Loading package 'SW HTTPClient' from: C:\Documents and Settings\Ted\Desktop\Mugpunters\Placepot\Steve Waring\HTTPClient\SW HTTPClient.pac"!

"Class Definitions"!

Object subclass: #SptCredentials
	instanceVariableNames: 'user challenge'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #SptHTTPChallenge
	instanceVariableNames: 'scheme realm params rootUri digestUri method'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #SptHTTPConfiguration
	instanceVariableNames: 'httpConnectionClass httpsConnectionClass responseClass progressClass sendEntityBufferSize readEntityBufferSize'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #SptHTTPConnection
	instanceVariableNames: 'host port socket socketStream timeoutState keepAliveTime'
	classVariableNames: 'IsLoggingWire WireLogStream'
	poolDictionaries: ''
	classInstanceVariableNames: 'keepAlives'!

Object subclass: #SptHTTPCookie
	instanceVariableNames: 'domain path values expires isSecure'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #SptHTTPCookieJar
	instanceVariableNames: 'cookies'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #SptHTTPEntity
	instanceVariableNames: 'stream contentLength contentType'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #SptHTTPHostCache
	instanceVariableNames: 'cache ipFactory'
	classVariableNames: 'Current'
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #SptHTTPProgressAbstract
	instanceVariableNames: 'request'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #SptHTTPProxySettings
	instanceVariableNames: 'useProxy proxyHost proxyPort'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #SptHTTPRequest
	instanceVariableNames: 'connection url method headers responses entity deferredSend okBodyStream state flags progress conf timeoutLoop'
	classVariableNames: 'IsAuthenticateMask IsFollowRedirectsMask IsRangeRequestMask IsUseCookiesMask IsVersion11Mask'
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #SptHTTPResponse
	instanceVariableNames: 'statusLine headers bodyStream request'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #SptHTTPSessionState
	instanceVariableNames: 'proxySettings credentials timeout cookieJar maxRedirects'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #SptHTTPStatus
	instanceVariableNames: 'statusLine'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #SptHTTPUser
	instanceVariableNames: 'username password'
	classVariableNames: 'Users'
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Error subclass: #SptHTTPError
	instanceVariableNames: 'httpStatus'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Error subclass: #SptHTTPNotAuthorized
	instanceVariableNames: 'target challenge site'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

SptHTTPError subclass: #SptHTTPClientError
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

SptHTTPError subclass: #SptHTTPServerError
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Dialog subclass: #SptHTTPAuthorizationDialog
	instanceVariableNames: 'sitePresenter realmPresenter userPresenter passPresenter exception'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Dialog subclass: #SptProxySettingDialog
	instanceVariableNames: 'useProxyP hostP portP'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

SptCredentials subclass: #SptBasicCredentials
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

SptHTTPConnection subclass: #SptHTTPSConnection
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

SptHTTPProgressAbstract subclass: #SptHTTPProgress
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

SptHTTPProgressAbstract subclass: #SptHTTPProgressDev
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

SptHTTPProgress subclass: #SptHTTPTriggerProgress
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

SptHTTPProgress subclass: #SptHTTPValueProgress
	instanceVariableNames: 'percentageValue stateValue'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

SptHTTPProgressDev subclass: #SptHTTPTestProgress
	instanceVariableNames: 'sentMessages'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

SptHTTPProgressDev subclass: #SptHTTPTranscriptProgress
	instanceVariableNames: 'stream nextProgress'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

"Global Aliases"!

"Loose Methods"!

!WriteStream methodsFor!
crlf
	"Store the line delimiter character sequence (as required by
	the environment) as the next element(s) of the receiver."

	self cr! !
!WriteStream categoriesFor: #crlf!public! !

!WriteStream categoriesFor: #crlf!accessing!public! !

"End of package definition"!

"Source Globals"!

"Classes"!

SptCredentials guid: (GUID fromString: '{87A2DCFF-C516-487E-8B2C-51C788BC8F16}')!

SptCredentials guid: (GUID fromString: '{87A2DCFF-C516-487E-8B2C-51C788BC8F16}')!
SptCredentials comment: 'SptCredentials

I am the credentials that supply the value of an ''Authorization'' http header.

Typically an instance is created by sending a <SptHTTPChallenge> the #credentialsFor: message.

Note: While ''Basic'' Authorization could be implemented more simply, creating the <SptCredentials> from the <SptHTTPChallenge> is necessary for ''Digest'' Authorization.

See <http://www.ietf.org/rfc/rfc2617.txt> for details on HTTP Authentication.

Instance Variables

	user		SptHTTPUser
	challenge		SptHTTPChallenge'!

SptCredentials comment:
'SptCredentials

I am the credentials that supply the value of an ''Authorization'' http header.

Typically an instance is created by sending a <SptHTTPChallenge> the #credentialsFor: message.

Note: While ''Basic'' Authorization could be implemented more simply, creating the <SptCredentials> from the <SptHTTPChallenge> is necessary for ''Digest'' Authorization.

See <http://www.ietf.org/rfc/rfc2617.txt> for details on HTTP Authentication.

Instance Variables

	user		SptHTTPUser
	challenge		SptHTTPChallenge'!
!SptCredentials categoriesForClass!Kernel-Objects! !
!SptCredentials methodsFor!
challenge
	^challenge! !
!SptCredentials categoriesFor: #challenge!public! !

!SptCredentials methodsFor!
challenge: aSptDigestCredentials
	challenge := aSptDigestCredentials! !
!SptCredentials categoriesFor: #challenge:!public! !

!SptCredentials methodsFor!
httpHeaderValue
	"Answer the <String> header that authorizes the user in response to the server's challenge"

	^self subclassResponsibility! !
!SptCredentials categoriesFor: #httpHeaderValue!public! !

!SptCredentials methodsFor!
isInProtectionSpace: aUrlString
	"Answer whether it is valid to use (or reuse) these credential for aUrlString"

	^self subclassResponsibility! !
!SptCredentials categoriesFor: #isInProtectionSpace:!public! !

!SptCredentials methodsFor!
password
	^user password! !
!SptCredentials categoriesFor: #password!public! !

!SptCredentials methodsFor!
realm
	^challenge realm! !
!SptCredentials categoriesFor: #realm!public! !

!SptCredentials methodsFor!
user
	^user! !
!SptCredentials categoriesFor: #user!public! !

!SptCredentials methodsFor!
user: aSptHTTPUser
	user := aSptHTTPUser! !
!SptCredentials categoriesFor: #user:!public! !

!SptCredentials methodsFor!
username
	^user username! !
!SptCredentials categoriesFor: #username!public! !

!SptCredentials categoriesFor: #challenge!accessing!public! !

!SptCredentials categoriesFor: #challenge:!accessing!public! !

!SptCredentials categoriesFor: #httpHeaderValue!accessing!public! !

!SptCredentials categoriesFor: #isInProtectionSpace:!public!testing! !

!SptCredentials categoriesFor: #password!accessing!public! !

!SptCredentials categoriesFor: #realm!accessing!public! !

!SptCredentials categoriesFor: #user!accessing!public! !

!SptCredentials categoriesFor: #user:!accessing!public! !

!SptCredentials categoriesFor: #username!accessing!public! !

!SptCredentials class methodsFor!
forUser: aSptHTTPUser
	^self new user: aSptHTTPUser! !
!SptCredentials class categoriesFor: #forUser:!public! !

!SptCredentials class methodsFor!
icon
	^Icon fromId: 45 in: ShellLibrary default
! !
!SptCredentials class categoriesFor: #icon!public! !

!SptCredentials class categoriesFor: #forUser:!instance creation!public! !

!SptCredentials class categoriesFor: #icon!constants!public! !

SptHTTPChallenge guid: (GUID fromString: '{10748A61-33B9-4D3A-8385-F18AF07120B0}')!

SptHTTPChallenge guid: (GUID fromString: '{10748A61-33B9-4D3A-8385-F18AF07120B0}')!
SptHTTPChallenge comment: 'SptHTTPChallenge

I am a HTTP Authentication challenge. I contain the information that is parsed from a ''WWW-Authenticate'' header included in a 401 (Unauthorized) response.

By supplying user infromation, I can be used to construct the <SptCredentials> required to authorize a request.

See <http://www.ietf.org/rfc/rfc2617.txt> for details on HTTP Authentication.

Instance Variables:
	scheme	<String> ... should be either Basic or Digest
	realm	<String>
	params	<LookupTable>
	rootUri	<String>
	digestUri	<String>
	method	<String>'!

SptHTTPChallenge comment:
'SptHTTPChallenge

I am a HTTP Authentication challenge. I contain the information that is parsed from a ''WWW-Authenticate'' header included in a 401 (Unauthorized) response.

By supplying user infromation, I can be used to construct the <SptCredentials> required to authorize a request.

See <http://www.ietf.org/rfc/rfc2617.txt> for details on HTTP Authentication.

Instance Variables:
	scheme	<String> ... should be either Basic or Digest
	realm	<String>
	params	<LookupTable>
	rootUri	<String>
	digestUri	<String>
	method	<String>'!
!SptHTTPChallenge categoriesForClass!Kernel-Objects! !
!SptHTTPChallenge methodsFor!
absoluteUrl: aString
	| url |
	url := SptHTTPUrl fromString: aString.
	rootUri := url rootBaseUrlString.
	self domain: url path! !
!SptHTTPChallenge categoriesFor: #absoluteUrl:!public! !

!SptHTTPChallenge methodsFor!
credentialsFor: aSptUser
	self isBasic ifFalse: [self error: 'Basic authentication only is supported.'].
	^(SptBasicCredentials new)
		challenge: self;
		user: aSptUser;
		yourself! !
!SptHTTPChallenge categoriesFor: #credentialsFor:!public! !

!SptHTTPChallenge methodsFor!
credentialsForUsername: aString password: aString2
	^self credentialsFor: (SptHTTPUser username: aString password: aString2)! !
!SptHTTPChallenge categoriesFor: #credentialsForUsername:password:!public! !

!SptHTTPChallenge methodsFor!
digestUri
	^digestUri! !
!SptHTTPChallenge categoriesFor: #digestUri!public! !

!SptHTTPChallenge methodsFor!
digestUri: aString
	digestUri := aString! !
!SptHTTPChallenge categoriesFor: #digestUri:!public! !

!SptHTTPChallenge methodsFor!
domain
	^params at: 'domain' ifAbsent: ['/']! !
!SptHTTPChallenge categoriesFor: #domain!public! !

!SptHTTPChallenge methodsFor!
domain: aString
	params at: 'domain' put: aString! !
!SptHTTPChallenge categoriesFor: #domain:!public! !

!SptHTTPChallenge methodsFor!
initialize
	super initialize.
	params := LookupTable new! !
!SptHTTPChallenge categoriesFor: #initialize!public! !

!SptHTTPChallenge methodsFor!
isBasic
	^scheme asLowercase = 'basic'! !
!SptHTTPChallenge categoriesFor: #isBasic!public! !

!SptHTTPChallenge methodsFor!
isInProtectionSpace: aString
	"SPEC:
The protection space determines the domain over which credentials can be automatically applied. If a prior request has been authorized, the same credentials MAY be reused for all other requests within that protection space for a period of time determined by the authentication scheme, parameters, and/or user preference. "

	| url |
	url := SptHTTPUrl fromString: aString.
	^self protectionSpaces anySatisfy: [:each | url isInSpaceOf: each]! !
!SptHTTPChallenge categoriesFor: #isInProtectionSpace:!public! !

!SptHTTPChallenge methodsFor!
method
	^method! !
!SptHTTPChallenge categoriesFor: #method!public! !

!SptHTTPChallenge methodsFor!
method: aString
	method := aString! !
!SptHTTPChallenge categoriesFor: #method:!public! !

!SptHTTPChallenge methodsFor!
nonce
	^params at: 'nonce' ifAbsent: []! !
!SptHTTPChallenge categoriesFor: #nonce!public! !

!SptHTTPChallenge methodsFor!
opaque
	^params at: 'opaque' ifAbsent: []! !
!SptHTTPChallenge categoriesFor: #opaque!public! !

!SptHTTPChallenge methodsFor!
params
	^params! !
!SptHTTPChallenge categoriesFor: #params!public! !

!SptHTTPChallenge methodsFor!
params: aCollection
	params := aCollection! !
!SptHTTPChallenge categoriesFor: #params:!public! !

!SptHTTPChallenge methodsFor!
parseParameter: aString
	| stream token value |
	stream := aString readStream.
	token := stream upTo: $=.
	value := stream upToEnd.
	params at: token put: (value copyFrom: 2 to: value size - 1)! !
!SptHTTPChallenge categoriesFor: #parseParameter:!public! !

!SptHTTPChallenge methodsFor!
protectionSpaces
	| url |
	url := SptHTTPUrl fromString: rootUri.
	^(self domain subStrings: $ ) 
		collect: [:each | (SptHTTPUrl fromString: each previous: url) urlString]! !
!SptHTTPChallenge categoriesFor: #protectionSpaces!public! !

!SptHTTPChallenge methodsFor!
qop
	^params at: 'qop' ifAbsent: []! !
!SptHTTPChallenge categoriesFor: #qop!public! !

!SptHTTPChallenge methodsFor!
realm
	^realm! !
!SptHTTPChallenge categoriesFor: #realm!public! !

!SptHTTPChallenge methodsFor!
realm: aString
	realm := aString! !
!SptHTTPChallenge categoriesFor: #realm:!public! !

!SptHTTPChallenge methodsFor!
rootUri
	^rootUri! !
!SptHTTPChallenge categoriesFor: #rootUri!public! !

!SptHTTPChallenge methodsFor!
rootUri: aString
	rootUri := aString! !
!SptHTTPChallenge categoriesFor: #rootUri:!public! !

!SptHTTPChallenge methodsFor!
scheme
	^scheme! !
!SptHTTPChallenge categoriesFor: #scheme!public! !

!SptHTTPChallenge methodsFor!
scheme: aString
	scheme := aString! !
!SptHTTPChallenge categoriesFor: #scheme:!public! !

!SptHTTPChallenge categoriesFor: #absoluteUrl:!accessing!public! !

!SptHTTPChallenge categoriesFor: #credentialsFor:!accessing!public! !

!SptHTTPChallenge categoriesFor: #credentialsForUsername:password:!accessing!public! !

!SptHTTPChallenge categoriesFor: #digestUri!accessing!public! !

!SptHTTPChallenge categoriesFor: #digestUri:!accessing!public! !

!SptHTTPChallenge categoriesFor: #domain!accessing!public! !

!SptHTTPChallenge categoriesFor: #domain:!accessing!public! !

!SptHTTPChallenge categoriesFor: #initialize!initializing!public! !

!SptHTTPChallenge categoriesFor: #isBasic!public!testing! !

!SptHTTPChallenge categoriesFor: #isInProtectionSpace:!public!testing! !

!SptHTTPChallenge categoriesFor: #method!accessing!public! !

!SptHTTPChallenge categoriesFor: #method:!accessing!public! !

!SptHTTPChallenge categoriesFor: #nonce!accessing!public! !

!SptHTTPChallenge categoriesFor: #opaque!accessing!public! !

!SptHTTPChallenge categoriesFor: #params!accessing!public! !

!SptHTTPChallenge categoriesFor: #params:!accessing!public! !

!SptHTTPChallenge categoriesFor: #parseParameter:!operations!public! !

!SptHTTPChallenge categoriesFor: #protectionSpaces!accessing!public! !

!SptHTTPChallenge categoriesFor: #qop!accessing!public! !

!SptHTTPChallenge categoriesFor: #realm!accessing!public! !

!SptHTTPChallenge categoriesFor: #realm:!accessing!public! !

!SptHTTPChallenge categoriesFor: #rootUri!accessing!public! !

!SptHTTPChallenge categoriesFor: #rootUri:!accessing!public! !

!SptHTTPChallenge categoriesFor: #scheme!accessing!public! !

!SptHTTPChallenge categoriesFor: #scheme:!accessing!public! !

!SptHTTPChallenge class methodsFor!
csStringsFrom: stream
	"Answer a collection of comma-separated strings ... ignoring commas embedded in quoted strings"

	| coll string start isQuoted |
	coll := OrderedCollection new.
	string := stream contents.
	[stream atEnd] whileFalse: 
			[start := stream position + 1.
			isQuoted := false.
			stream skipWhile: 
					[:c | 
					c = $" ifTrue: [isQuoted := isQuoted not].
					isQuoted or: [c ~= $,]].
			coll add: (string copyFrom: start to: stream position) trimBlanks.
			"skip ,"
			stream atEnd ifFalse: [stream next].
			stream skipSeparators].
	^coll! !
!SptHTTPChallenge class categoriesFor: #csStringsFrom:!public! !

!SptHTTPChallenge class methodsFor!
fromChallengeString: aString
	| scheme realm stream |
	stream := aString readStream.
	scheme := stream upTo: Character space.
	stream upTo: $=.
	realm := stream upToEnd.
	^(self new)
		scheme: scheme;
		realm: (realm copyFrom: 2 to: realm size - 1);
		yourself! !
!SptHTTPChallenge class categoriesFor: #fromChallengeString:!public! !

!SptHTTPChallenge class methodsFor!
isChallengeString: aString
	| stream |
	stream := aString readStream.
	stream upTo: Character space.
	^(stream nextAvailable: 5) = 'realm'! !
!SptHTTPChallenge class categoriesFor: #isChallengeString:!public! !

!SptHTTPChallenge class methodsFor!
makeUserIdFor: aUsernameString password: aPasswordString
	| outStream |
	outStream := String writeStream.
	Base64Encoder new 
		encode: (aUsernameString , ':' , aPasswordString) asByteArray readStream
		to: outStream.
	^outStream contents! !
!SptHTTPChallenge class categoriesFor: #makeUserIdFor:password:!public! !

!SptHTTPChallenge class methodsFor!
new
	^super new initialize! !
!SptHTTPChallenge class categoriesFor: #new!public! !

!SptHTTPChallenge class methodsFor!
newBasicChallenge
	^(self new)
		scheme: 'Basic';
		yourself! !
!SptHTTPChallenge class categoriesFor: #newBasicChallenge!public! !

!SptHTTPChallenge class methodsFor!
newBasicChallengeRealm: aString absoluteUri: aUrlString
	^(self newBasicChallenge)
		realm: aString;
		absoluteUrl: aUrlString;
		yourself! !
!SptHTTPChallenge class categoriesFor: #newBasicChallengeRealm:absoluteUri:!public! !

!SptHTTPChallenge class methodsFor!
readAllFrom: aReadStream
	| subStrings instances |
	subStrings := self csStringsFrom: aReadStream.
	instances := OrderedCollection new.
	subStrings keysAndValuesDo: 
			[:i :each | 
			(self isChallengeString: each) 
				ifTrue: [instances add: (self fromChallengeString: each)]
				ifFalse: 
					[i = 1 ifTrue: [self error: 'Error parsing WWW-Authenticate header'].
					instances last parseParameter: each]].
	^instances! !
!SptHTTPChallenge class categoriesFor: #readAllFrom:!public! !

!SptHTTPChallenge class categoriesFor: #csStringsFrom:!helpers!private! !

!SptHTTPChallenge class categoriesFor: #fromChallengeString:!instance creation!public! !

!SptHTTPChallenge class categoriesFor: #isChallengeString:!private!testing! !

!SptHTTPChallenge class categoriesFor: #makeUserIdFor:password:!helpers!public! !

!SptHTTPChallenge class categoriesFor: #new!instance creation!public! !

!SptHTTPChallenge class categoriesFor: #newBasicChallenge!instance creation!public! !

!SptHTTPChallenge class categoriesFor: #newBasicChallengeRealm:absoluteUri:!instance creation!public! !

!SptHTTPChallenge class categoriesFor: #readAllFrom:!instance creation!public! !

SptHTTPConfiguration guid: (GUID fromString: '{64A3E099-55D7-4CDD-8256-DCCEEBFE2E9E}')!

SptHTTPConfiguration guid: (GUID fromString: '{64A3E099-55D7-4CDD-8256-DCCEEBFE2E9E}')!
SptHTTPConfiguration comment: 'SptHTTPConfiguration

I am a configuration class that can be used to modify what classes an <SptHTTPRequest> uses.

Typical use would be to create your own subclass which answers your own classes, and then create requests like:

	
	request := SptHTTPRequest newFor: (MyHTTPConfiguration newDefault)



Instance Variables:
	httpConnectionClass	<Class>
	httpsConnectionClass	<Class>
	responseClass		<Class>
	progressClass		<Class>
	sendEntityBufferSize	<Integer> (1024 is good for frequent progress, 4096 is better for performance)
	readEntityBufferSize		<Integer>'!

SptHTTPConfiguration comment:
'SptHTTPConfiguration

I am a configuration class that can be used to modify what classes an <SptHTTPRequest> uses.

Typical use would be to create your own subclass which answers your own classes, and then create requests like:

	
	request := SptHTTPRequest newFor: (MyHTTPConfiguration newDefault)



Instance Variables:
	httpConnectionClass	<Class>
	httpsConnectionClass	<Class>
	responseClass		<Class>
	progressClass		<Class>
	sendEntityBufferSize	<Integer> (1024 is good for frequent progress, 4096 is better for performance)
	readEntityBufferSize		<Integer>'!
!SptHTTPConfiguration categoriesForClass!Kernel-Objects! !
!SptHTTPConfiguration methodsFor!
httpConnectionClass
	^httpConnectionClass! !
!SptHTTPConfiguration categoriesFor: #httpConnectionClass!public! !

!SptHTTPConfiguration methodsFor!
httpConnectionClass: anObject
	httpConnectionClass := anObject! !
!SptHTTPConfiguration categoriesFor: #httpConnectionClass:!public! !

!SptHTTPConfiguration methodsFor!
httpsConnectionClass
	^httpsConnectionClass! !
!SptHTTPConfiguration categoriesFor: #httpsConnectionClass!public! !

!SptHTTPConfiguration methodsFor!
httpsConnectionClass: anObject
	httpsConnectionClass := anObject! !
!SptHTTPConfiguration categoriesFor: #httpsConnectionClass:!public! !

!SptHTTPConfiguration methodsFor!
newProgressFor: aRequest
	^(self progressClass new)
		request: aRequest;
		yourself! !
!SptHTTPConfiguration categoriesFor: #newProgressFor:!public! !

!SptHTTPConfiguration methodsFor!
newResponseFor: aRequest
	^(self responseClass new)
		request: aRequest;
		yourself! !
!SptHTTPConfiguration categoriesFor: #newResponseFor:!public! !

!SptHTTPConfiguration methodsFor!
progressClass
	^progressClass! !
!SptHTTPConfiguration categoriesFor: #progressClass!public! !

!SptHTTPConfiguration methodsFor!
progressClass: anObject
	progressClass := anObject! !
!SptHTTPConfiguration categoriesFor: #progressClass:!public! !

!SptHTTPConfiguration methodsFor!
readEntityBufferSize
	^readEntityBufferSize! !
!SptHTTPConfiguration categoriesFor: #readEntityBufferSize!public! !

!SptHTTPConfiguration methodsFor!
readEntityBufferSize: anObject
	readEntityBufferSize := anObject! !
!SptHTTPConfiguration categoriesFor: #readEntityBufferSize:!public! !

!SptHTTPConfiguration methodsFor!
responseClass
	^responseClass! !
!SptHTTPConfiguration categoriesFor: #responseClass!public! !

!SptHTTPConfiguration methodsFor!
responseClass: anObject
	responseClass := anObject! !
!SptHTTPConfiguration categoriesFor: #responseClass:!public! !

!SptHTTPConfiguration methodsFor!
sendEntityBufferSize
	^sendEntityBufferSize! !
!SptHTTPConfiguration categoriesFor: #sendEntityBufferSize!public! !

!SptHTTPConfiguration methodsFor!
sendEntityBufferSize: anInteger
	sendEntityBufferSize := anInteger! !
!SptHTTPConfiguration categoriesFor: #sendEntityBufferSize:!public! !

!SptHTTPConfiguration categoriesFor: #httpConnectionClass!accessing!public! !

!SptHTTPConfiguration categoriesFor: #httpConnectionClass:!accessing!public! !

!SptHTTPConfiguration categoriesFor: #httpsConnectionClass!accessing!public! !

!SptHTTPConfiguration categoriesFor: #httpsConnectionClass:!accessing!public! !

!SptHTTPConfiguration categoriesFor: #newProgressFor:!accessing!public! !

!SptHTTPConfiguration categoriesFor: #newResponseFor:!accessing!public! !

!SptHTTPConfiguration categoriesFor: #progressClass!accessing!public! !

!SptHTTPConfiguration categoriesFor: #progressClass:!accessing!public! !

!SptHTTPConfiguration categoriesFor: #readEntityBufferSize!accessing!private! !

!SptHTTPConfiguration categoriesFor: #readEntityBufferSize:!accessing!private! !

!SptHTTPConfiguration categoriesFor: #responseClass!accessing!public! !

!SptHTTPConfiguration categoriesFor: #responseClass:!accessing!public! !

!SptHTTPConfiguration categoriesFor: #sendEntityBufferSize!accessing!public! !

!SptHTTPConfiguration categoriesFor: #sendEntityBufferSize:!accessing!public! !

!SptHTTPConfiguration class methodsFor!
newDefault
	^(self new)
		httpConnectionClass: SptHTTPConnection;
		httpsConnectionClass: SptHTTPSConnection;
		responseClass: SptHTTPResponse;
		progressClass: SptHTTPProgress;
		sendEntityBufferSize: 1024;
		readEntityBufferSize: 1024;
		yourself! !
!SptHTTPConfiguration class categoriesFor: #newDefault!public! !

!SptHTTPConfiguration class categoriesFor: #newDefault!instance creation!public! !

SptHTTPConnection guid: (GUID fromString: '{E032DBB6-4294-4B71-8421-7AC189339053}')!

SptHTTPConnection guid: (GUID fromString: '{E032DBB6-4294-4B71-8421-7AC189339053}')!
SptHTTPConnection comment: 'SptHTTPConnection

I am a connection to an HTTP server.

I can be reused, which is the default in HTTP 1.1. To avoid problems of the server closing a connection via a time-out, and having to resend the request, I will only be reused within 5 seconds of my last use. The keepAliveTime instanceVariable is used to store the millisecondClockValue of my last use.

The class mode; #beLoggingWire (#beNotLoggingWire) can be used to dump full logs of all characters received/sent over each connection to the Transcript. 

See #checkTimeout for info on timeoutState 


Instance Variables
	host		<String> (eg ''www.yahoo.com'')
	port		<Integer> (eg 80)
	socket		<Socket>
	socketStream	<SZReadWriteSocketStream>
	timeoutState	<Symbol>
	keepAliveTime	<Integer>


'!

SptHTTPConnection comment:
'SptHTTPConnection

I am a connection to an HTTP server.

I can be reused, which is the default in HTTP 1.1. To avoid problems of the server closing a connection via a time-out, and having to resend the request, I will only be reused within 5 seconds of my last use. The keepAliveTime instanceVariable is used to store the millisecondClockValue of my last use.

The class mode; #beLoggingWire (#beNotLoggingWire) can be used to dump full logs of all characters received/sent over each connection to the Transcript. 

See #checkTimeout for info on timeoutState 


Instance Variables
	host		<String> (eg ''www.yahoo.com'')
	port		<Integer> (eg 80)
	socket		<Socket>
	socketStream	<SZReadWriteSocketStream>
	timeoutState	<Symbol>
	keepAliveTime	<Integer>


'!
!SptHTTPConnection categoriesForClass!Kernel-Objects! !
!SptHTTPConnection methodsFor!
beTimeoutNotWaiting
	"See #checkTimeout"

	Notification deprecated.
	timeoutState == #wait ifTrue: [timeoutState := #on]! !
!SptHTTPConnection categoriesFor: #beTimeoutNotWaiting!public! !

!SptHTTPConnection methodsFor!
beTimeoutOff
	"See #checkTimeout"

	timeoutState := #off! !
!SptHTTPConnection categoriesFor: #beTimeoutOff!public! !

!SptHTTPConnection methodsFor!
beTimeoutOn
	"See #checkTimeout"

	timeoutState := #on! !
!SptHTTPConnection categoriesFor: #beTimeoutOn!public! !

!SptHTTPConnection methodsFor!
cancelSocket
	"Cancel the socket.
	See SptHTTPRequest>>cancelConnection "

	socket notNil ifTrue: [socket cancel]! !
!SptHTTPConnection categoriesFor: #cancelSocket!public! !

!SptHTTPConnection methodsFor!
checkTimeout
	"If the timeoutState is #wait, then we activate the timeout by cancelling the socket.
		(This will cause a timeout SocketError exception to be signaled in
		the process that is blocked trying to read (or write) from the socket)

	If the timeoutState is #on, we move it to #wait (so the next time we check, we may timeout).

	See SptHTTPRequest>>makingProgress ... which resets the timeoutState to #on each time
	we read or write to the socket"

	timeoutState == #off ifTrue: [^false].
	^timeoutState == #wait 
		ifTrue: 
			[timeoutState := #off.
			self cancelSocket.
			true]
		ifFalse: 
			[timeoutState := #wait.
			false]! !
!SptHTTPConnection categoriesFor: #checkTimeout!public! !

!SptHTTPConnection methodsFor!
close
	"Close the socket.
	-If  the DeferredValue send is blocked reading, an error will be signalled in that process (which will cause the socket to be closed)
	-An error will also be signalled in any client processes blocking on #waitOnReady"

	Notification deprecated.
	self cancelSocket! !
!SptHTTPConnection categoriesFor: #close!public! !

!SptHTTPConnection methodsFor!
closeSilently
	[self closeSocket] on: Error do: [:e | ]! !
!SptHTTPConnection categoriesFor: #closeSilently!public! !

!SptHTTPConnection methodsFor!
closeSocket
	"Close the socket.
	
	This can safely be sent to a socket that is already closed"

	socket notNil ifTrue: [socket close]! !
!SptHTTPConnection categoriesFor: #closeSocket!public! !

!SptHTTPConnection methodsFor!
connect
	self connectSocket.
	socketStream := self class socketStreamClass socket: socket! !
!SptHTTPConnection categoriesFor: #connect!public! !

!SptHTTPConnection methodsFor!
connectSocket
	| address retry |
	address := InternetAddress ipAddress: (SptHTTPHostCache current ipAddressFor: self host).
	socket := nil.
	"The retry is necessary to handle what I understand to be a WinSock bug.
	-It will only show if many small requests are made quickly. ( I can reproduce on my local network by forking 10 processes each sending 200 requests to the same address).
	-See <http://www.cygwin.com/ml/cygwin-developers/2001-11/msg00080.html> for a discussion of the problem"

	"Update: 20021113 ... this may have been caused by waiting for finalization to close sockets.
	I have not seen the Notifcation since making the changes to manually close sockets"
	retry := 5.
	[socket isNil and: [retry > 0]] whileTrue: 
			[[(socket := Socket port: self port address: address) connect] on: SocketError
				do: 
					[:e | 
					e errorCode = 10048 
						ifTrue: 
							[socket close.
							socket := nil.
							Notification signal: 'SptHTTPConnection connect  WSAEADDRINUSE'.
							(retry := retry - 1) = 0 ifTrue: [e pass]]
						ifFalse: [e pass]]].
	^socket! !
!SptHTTPConnection categoriesFor: #connectSocket!public! !

!SptHTTPConnection methodsFor!
dumpWireLog
	self class isLoggingWire 
		ifTrue: 
			[self logWire: socketStream log.
			socketStream resetLogStream]! !
!SptHTTPConnection categoriesFor: #dumpWireLog!public! !

!SptHTTPConnection methodsFor!
host
	^host! !
!SptHTTPConnection categoriesFor: #host!public! !

!SptHTTPConnection methodsFor!
host: aHostString
	host := aHostString! !
!SptHTTPConnection categoriesFor: #host:!public! !

!SptHTTPConnection methodsFor!
hostPortString
	self assert: [port >= 0].
	^host , ':' , port displayString! !
!SptHTTPConnection categoriesFor: #hostPortString!public! !

!SptHTTPConnection methodsFor!
initialize
	super initialize.
	timeoutState := #off! !
!SptHTTPConnection categoriesFor: #initialize!public! !

!SptHTTPConnection methodsFor!
isStale
	keepAliveTime isNil ifTrue: [^true].
	^Delay millisecondClockValue - keepAliveTime > self class staleMilliseconds! !
!SptHTTPConnection categoriesFor: #isStale!public! !

!SptHTTPConnection methodsFor!
isTimeoutWaiting
	^timeoutState == #wait! !
!SptHTTPConnection categoriesFor: #isTimeoutWaiting!public! !

!SptHTTPConnection methodsFor!
keepAliveIfOpen
	(socket notNil and: [socket isOpen]) ifTrue: [self class keepAlive: self]! !
!SptHTTPConnection categoriesFor: #keepAliveIfOpen!public! !

!SptHTTPConnection methodsFor!
logWire: aString
	| stream |
	stream := String writeStream.
	stream
		cr;
		nextPutAll: '=======';
		cr;
		print: socket;
		cr;
		nextPutAll: aString.
	
	[(self class wireLogStream ifNil: [Transcript])
		nextPutAll: stream contents;
		cr] 
			on: Error
			do: [:e | ]! !
!SptHTTPConnection categoriesFor: #logWire:!public! !

!SptHTTPConnection methodsFor!
port
	^port! !
!SptHTTPConnection categoriesFor: #port!public! !

!SptHTTPConnection methodsFor!
port: anObject
	port := anObject! !
!SptHTTPConnection categoriesFor: #port:!public! !

!SptHTTPConnection methodsFor!
port: aSmallInteger host: aString
	port := aSmallInteger.
	host := aString! !
!SptHTTPConnection categoriesFor: #port:host:!public! !

!SptHTTPConnection methodsFor!
setKeepAliveTime
	keepAliveTime := Delay millisecondClockValue! !
!SptHTTPConnection categoriesFor: #setKeepAliveTime!public! !

!SptHTTPConnection methodsFor!
socket
	^socket! !
!SptHTTPConnection categoriesFor: #socket!public! !

!SptHTTPConnection methodsFor!
socket: aSocket
	"Unit Test helper method"

	socket := aSocket! !
!SptHTTPConnection categoriesFor: #socket:!public! !

!SptHTTPConnection methodsFor!
socketStream
	^socketStream! !
!SptHTTPConnection categoriesFor: #socketStream!public! !

!SptHTTPConnection methodsFor!
socketStream: aSZReadWriteSocketStream
	socketStream := aSZReadWriteSocketStream! !
!SptHTTPConnection categoriesFor: #socketStream:!public! !

!SptHTTPConnection methodsFor!
timeoutState
	"Unit Test helper method"

	^timeoutState! !
!SptHTTPConnection categoriesFor: #timeoutState!public! !

!SptHTTPConnection methodsFor!
timeoutState: anObject
	"Unit Test helper method"

	timeoutState := anObject! !
!SptHTTPConnection categoriesFor: #timeoutState:!public! !

!SptHTTPConnection categoriesFor: #beTimeoutNotWaiting!modes!public! !

!SptHTTPConnection categoriesFor: #beTimeoutOff!modes!public! !

!SptHTTPConnection categoriesFor: #beTimeoutOn!modes!public! !

!SptHTTPConnection categoriesFor: #cancelSocket!operations!public! !

!SptHTTPConnection categoriesFor: #checkTimeout!operations!private! !

!SptHTTPConnection categoriesFor: #close!operations!public! !

!SptHTTPConnection categoriesFor: #closeSilently!operations!private! !

!SptHTTPConnection categoriesFor: #closeSocket!operations!public! !

!SptHTTPConnection categoriesFor: #connect!operations!private! !

!SptHTTPConnection categoriesFor: #connectSocket!operations!private! !

!SptHTTPConnection categoriesFor: #dumpWireLog!operations!public! !

!SptHTTPConnection categoriesFor: #host!accessing!private! !

!SptHTTPConnection categoriesFor: #host:!accessing!private! !

!SptHTTPConnection categoriesFor: #hostPortString!accessing!public! !

!SptHTTPConnection categoriesFor: #initialize!initializing!public! !

!SptHTTPConnection categoriesFor: #isStale!public!testing! !

!SptHTTPConnection categoriesFor: #isTimeoutWaiting!operations!private! !

!SptHTTPConnection categoriesFor: #keepAliveIfOpen!operations!public! !

!SptHTTPConnection categoriesFor: #logWire:!accessing!private! !

!SptHTTPConnection categoriesFor: #port!accessing!private! !

!SptHTTPConnection categoriesFor: #port:!accessing!private! !

!SptHTTPConnection categoriesFor: #port:host:!accessing!public! !

!SptHTTPConnection categoriesFor: #setKeepAliveTime!accessing!public! !

!SptHTTPConnection categoriesFor: #socket!accessing!private! !

!SptHTTPConnection categoriesFor: #socket:!private!test accessing! !

!SptHTTPConnection categoriesFor: #socketStream!accessing!public! !

!SptHTTPConnection categoriesFor: #socketStream:!accessing!public! !

!SptHTTPConnection categoriesFor: #timeoutState!private!test accessing! !

!SptHTTPConnection categoriesFor: #timeoutState:!private!test accessing! !

!SptHTTPConnection class methodsFor!
beLoggingWire
	"
	self beLoggingWire.
	self wireLogStream: Transcript.
	"

	IsLoggingWire := true.
	self removeKeepAlives! !
!SptHTTPConnection class categoriesFor: #beLoggingWire!public! !

!SptHTTPConnection class methodsFor!
beLoggingWireToTranscript
	"
	self beLoggingWireToTranscript.
	"

	self beLoggingWire.
	self wireLogStream: (self environment at: #Transcript)! !
!SptHTTPConnection class categoriesFor: #beLoggingWireToTranscript!public! !

!SptHTTPConnection class methodsFor!
beNotLoggingWire
	"
	self beNotLoggingWire
	"

	IsLoggingWire := false.
	self removeKeepAlives! !
!SptHTTPConnection class categoriesFor: #beNotLoggingWire!public! !

!SptHTTPConnection class methodsFor!
initialize
	"
	self initialize
	"

	keepAlives := SharedLookupTable new.
	IsLoggingWire := false.
	SessionManager current 
		when: #imageSaveStarting
		send: #onImageSaveStarting
		to: self! !
!SptHTTPConnection class categoriesFor: #initialize!public! !

!SptHTTPConnection class methodsFor!
isLoggingWire
	^IsLoggingWire! !
!SptHTTPConnection class categoriesFor: #isLoggingWire!public! !

!SptHTTPConnection class methodsFor!
isLoggingWire: aBoolean
	IsLoggingWire := aBoolean! !
!SptHTTPConnection class categoriesFor: #isLoggingWire:!public! !

!SptHTTPConnection class methodsFor!
keepAlive: aConnection
	"Add the instance to our table of connection to (possibly) re-use"

	aConnection beTimeoutOff.
	aConnection setKeepAliveTime.
	keepAlives at: aConnection hostPortString put: aConnection! !
!SptHTTPConnection class categoriesFor: #keepAlive:!public! !

!SptHTTPConnection class methodsFor!
new
	^super new initialize! !
!SptHTTPConnection class categoriesFor: #new!public! !

!SptHTTPConnection class methodsFor!
newOnPort: aSmallInteger host: aString
	^(self new)
		port: aSmallInteger host: aString;
		connect;
		yourself! !
!SptHTTPConnection class categoriesFor: #newOnPort:host:!public! !

!SptHTTPConnection class methodsFor!
onImageSaveStarting
	"Avoid saving any instances into an image"

	| temp |
	temp := keepAlives.
	keepAlives := SharedLookupTable new.
	temp values do: [:each | each closeSilently]! !
!SptHTTPConnection class categoriesFor: #onImageSaveStarting!public! !

!SptHTTPConnection class methodsFor!
port: aSmallInteger host: aString reuse: aBoolean
	"Answer an instance.
	Note: an exisiting instance will be answered if resuse is true, 
		and we have a connection that we are keeping alive for the host/port"

	^aBoolean 
		ifTrue: [self reuseOnPort: aSmallInteger host: aString]
		ifFalse: [self newOnPort: aSmallInteger host: aString]! !
!SptHTTPConnection class categoriesFor: #port:host:reuse:!public! !

!SptHTTPConnection class methodsFor!
removeKeepAlives
	"
	self removeKeepAlives.
	keepAlives
	"

	| removes |
	removes := keepAlives values asOrderedCollection.
	removes 
		do: [:each | (keepAlives removeKey: each ifAbsent: [DeafObject current]) closeSilently]! !
!SptHTTPConnection class categoriesFor: #removeKeepAlives!public! !

!SptHTTPConnection class methodsFor!
removeStaleKeepAlives
	"
	self removeStaleKeepAlives.
	keepAlives
	"

	| removes |
	removes := OrderedCollection new.
	keepAlives keysAndValuesDo: [:key :value | value isStale ifTrue: [removes add: key]].
	removes 
		do: [:each | (keepAlives removeKey: each ifAbsent: [DeafObject current]) closeSilently]! !
!SptHTTPConnection class categoriesFor: #removeStaleKeepAlives!public! !

!SptHTTPConnection class methodsFor!
reuseOnPort: aSmallInteger host: aString
	"Note: Need to be careful that two requests (each in forked process) 
		dont think they can re-use the same connection"

	self removeStaleKeepAlives.
	^keepAlives removeKey: aString , ':' , aSmallInteger displayString
		ifAbsent: [self newOnPort: aSmallInteger host: aString]! !
!SptHTTPConnection class categoriesFor: #reuseOnPort:host:!public! !

!SptHTTPConnection class methodsFor!
socketStreamClass
	^IsLoggingWire ifTrue: [SZLoggingSocketStream] ifFalse: [SZReadWriteSocketStream]! !
!SptHTTPConnection class categoriesFor: #socketStreamClass!public! !

!SptHTTPConnection class methodsFor!
staleMilliseconds
	"FWIW: I believe that Apache defaults to 20seconds, so this
	should be low enough to keep us under the radar screen while
	still being high enough to satisfy rapid fire multiple requests"

	^5000! !
!SptHTTPConnection class categoriesFor: #staleMilliseconds!public! !

!SptHTTPConnection class methodsFor!
uninitialize
	"
	self uninitialize
	"

	keepAlives := nil.
	WireLogStream := nil! !
!SptHTTPConnection class categoriesFor: #uninitialize!public! !

!SptHTTPConnection class methodsFor!
wireLogStream
	^WireLogStream! !
!SptHTTPConnection class categoriesFor: #wireLogStream!public! !

!SptHTTPConnection class methodsFor!
wireLogStream: aWriteStream
	WireLogStream := aWriteStream! !
!SptHTTPConnection class categoriesFor: #wireLogStream:!public! !

!SptHTTPConnection class categoriesFor: #beLoggingWire!modes!public! !

!SptHTTPConnection class categoriesFor: #beLoggingWireToTranscript!modes!public! !

!SptHTTPConnection class categoriesFor: #beNotLoggingWire!modes!public! !

!SptHTTPConnection class categoriesFor: #initialize!initializing!public! !

!SptHTTPConnection class categoriesFor: #isLoggingWire!public!testing! !

!SptHTTPConnection class categoriesFor: #isLoggingWire:!accessing!private! !

!SptHTTPConnection class categoriesFor: #keepAlive:!accessing!private! !

!SptHTTPConnection class categoriesFor: #new!instance creation!public! !

!SptHTTPConnection class categoriesFor: #newOnPort:host:!instance creation!public! !

!SptHTTPConnection class categoriesFor: #onImageSaveStarting!event handling!private! !

!SptHTTPConnection class categoriesFor: #port:host:reuse:!instance creation!public! !

!SptHTTPConnection class categoriesFor: #removeKeepAlives!operations!private! !

!SptHTTPConnection class categoriesFor: #removeStaleKeepAlives!operations!private! !

!SptHTTPConnection class categoriesFor: #reuseOnPort:host:!instance creation!public! !

!SptHTTPConnection class categoriesFor: #socketStreamClass!accessing!private! !

!SptHTTPConnection class categoriesFor: #staleMilliseconds!constants!public! !

!SptHTTPConnection class categoriesFor: #uninitialize!initializing!public! !

!SptHTTPConnection class categoriesFor: #wireLogStream!accessing!private! !

!SptHTTPConnection class categoriesFor: #wireLogStream:!accessing!public! !

SptHTTPCookie guid: (GUID fromString: '{480CDD9E-B451-492C-8CAD-8B6F62A64C69}')!

SptHTTPCookie guid: (GUID fromString: '{480CDD9E-B451-492C-8CAD-8B6F62A64C69}')!
SptHTTPCookie comment: 'SptHTTPCookie

I am a cookie that is parsed from a Set-Cookie http header

See <http://wp.netscape.com/newsref/std/cookie_spec.html> for more information'!

SptHTTPCookie comment:
'SptHTTPCookie

I am a cookie that is parsed from a Set-Cookie http header

See <http://wp.netscape.com/newsref/std/cookie_spec.html> for more information'!
!SptHTTPCookie categoriesForClass!Kernel-Objects! !
!SptHTTPCookie methodsFor!
atName: aString
	^values at: aString! !
!SptHTTPCookie categoriesFor: #atName:!public! !

!SptHTTPCookie methodsFor!
atName: aString ifAbsentPut: operation
	^values at: aString ifAbsentPut: operation! !
!SptHTTPCookie categoriesFor: #atName:ifAbsentPut:!public! !

!SptHTTPCookie methodsFor!
domain
	^domain! !
!SptHTTPCookie categoriesFor: #domain!public! !

!SptHTTPCookie methodsFor!
domain: aString
	domain := aString! !
!SptHTTPCookie categoriesFor: #domain:!public! !

!SptHTTPCookie methodsFor!
expires
	^expires! !
!SptHTTPCookie categoriesFor: #expires!public! !

!SptHTTPCookie methodsFor!
expires: aString
	expires := aString! !
!SptHTTPCookie categoriesFor: #expires:!public! !

!SptHTTPCookie methodsFor!
initialize
	super initialize.
	values := LookupTable new.
	isSecure := false! !
!SptHTTPCookie categoriesFor: #initialize!public! !

!SptHTTPCookie methodsFor!
isDomainMatch: aString
	^aString size > domain size 
		ifTrue: [self isDomainS: domain matchDomainL: aString]
		ifFalse: [self isDomainS: aString matchDomainL: domain]! !
!SptHTTPCookie categoriesFor: #isDomainMatch:!public! !

!SptHTTPCookie methodsFor!
isDomainS: aSmallerString matchDomainL: aLargerString
	| compString |
	compString := aLargerString copyFrom: aLargerString size - aSmallerString size + 1
				to: aLargerString size.
	^compString sameAs: aSmallerString! !
!SptHTTPCookie categoriesFor: #isDomainS:matchDomainL:!public! !

!SptHTTPCookie methodsFor!
isPathMatch: aString
	^aString beginsWith: path! !
!SptHTTPCookie categoriesFor: #isPathMatch:!public! !

!SptHTTPCookie methodsFor!
isSameAs: aSptHTTPCookie
	^path = aSptHTTPCookie path and: [self isDomainMatch: aSptHTTPCookie domain]! !
!SptHTTPCookie categoriesFor: #isSameAs:!public! !

!SptHTTPCookie methodsFor!
isSecure
	^isSecure! !
!SptHTTPCookie categoriesFor: #isSecure!public! !

!SptHTTPCookie methodsFor!
isSecure: aBoolean
	isSecure := aBoolean! !
!SptHTTPCookie categoriesFor: #isSecure:!public! !

!SptHTTPCookie methodsFor!
nameValuesDo: aTwoArgBlock
	values keysAndValuesDo: aTwoArgBlock! !
!SptHTTPCookie categoriesFor: #nameValuesDo:!public! !

!SptHTTPCookie methodsFor!
path
	^path! !
!SptHTTPCookie categoriesFor: #path!public! !

!SptHTTPCookie methodsFor!
path: aString
	self assert: [aString size >= 1].
	self assert: [aString first = $/].
	path := aString! !
!SptHTTPCookie categoriesFor: #path:!public! !

!SptHTTPCookie methodsFor!
printNameValueOn: aWriteStream
	values associationsDo: 
			[:a | 
			aWriteStream
				display: a key;
				nextPut: $=;
				display: a value]
		separatedBy: [aWriteStream nextPut: $;]! !
!SptHTTPCookie categoriesFor: #printNameValueOn:!public! !

!SptHTTPCookie methodsFor!
setDomain: aString
	"The cookie contains a 'domain' field.
	-If this value is not legal (ie check against the actual url's host ), signal an error"

	(domain sameAs: aString) ifTrue: [^self].
	(((self class isSpecialDomain: aString) or: [self class isValidDomain: aString]) 
		and: ['*' , aString match: domain ignoreCase: true]) 
			ifTrue: 
				[domain := aString.
				^self].
	self error: ('The cookies suggested domain %1 is not valid for %2' formatWith: aString
				with: domain)! !
!SptHTTPCookie categoriesFor: #setDomain:!public! !

!SptHTTPCookie methodsFor!
setExpires: aString
	expires := aString! !
!SptHTTPCookie categoriesFor: #setExpires:!public! !

!SptHTTPCookie methodsFor!
setFromFields: aLookupTable
	(aLookupTable includesKey: 'domain') 
		ifTrue: [self setDomain: (aLookupTable removeKey: 'domain')].
	(aLookupTable includesKey: 'path') 
		ifTrue: [self setPath: (aLookupTable removeKey: 'path')].
	(aLookupTable includesKey: 'expires') 
		ifTrue: [self setExpires: (aLookupTable removeKey: 'expires')].
	(aLookupTable includesKey: 'secure') 
		ifTrue: [self setSecure: (aLookupTable removeKey: 'secure')].
	values := aLookupTable! !
!SptHTTPCookie categoriesFor: #setFromFields:!public! !

!SptHTTPCookie methodsFor!
setPath: aString
	self assert: [aString size >= 1].
	self assert: [aString first = $/].
	path := aString! !
!SptHTTPCookie categoriesFor: #setPath:!public! !

!SptHTTPCookie methodsFor!
setSecure: aString
	"Note: It is secure"

	isSecure := true! !
!SptHTTPCookie categoriesFor: #setSecure:!public! !

!SptHTTPCookie methodsFor!
values
	^values! !
!SptHTTPCookie categoriesFor: #values!public! !

!SptHTTPCookie categoriesFor: #atName:!accessing!public! !

!SptHTTPCookie categoriesFor: #atName:ifAbsentPut:!accessing!public! !

!SptHTTPCookie categoriesFor: #domain!accessing!private! !

!SptHTTPCookie categoriesFor: #domain:!accessing!private! !

!SptHTTPCookie categoriesFor: #expires!accessing!private! !

!SptHTTPCookie categoriesFor: #expires:!accessing!private! !

!SptHTTPCookie categoriesFor: #initialize!initializing!public! !

!SptHTTPCookie categoriesFor: #isDomainMatch:!public!testing! !

!SptHTTPCookie categoriesFor: #isDomainS:matchDomainL:!public!testing! !

!SptHTTPCookie categoriesFor: #isPathMatch:!public!testing! !

!SptHTTPCookie categoriesFor: #isSameAs:!public!testing! !

!SptHTTPCookie categoriesFor: #isSecure!accessing!private! !

!SptHTTPCookie categoriesFor: #isSecure:!accessing!private! !

!SptHTTPCookie categoriesFor: #nameValuesDo:!printing!public! !

!SptHTTPCookie categoriesFor: #path!accessing!private! !

!SptHTTPCookie categoriesFor: #path:!accessing!private! !

!SptHTTPCookie categoriesFor: #printNameValueOn:!printing!public! !

!SptHTTPCookie categoriesFor: #setDomain:!public!setting! !

!SptHTTPCookie categoriesFor: #setExpires:!public!setting! !

!SptHTTPCookie categoriesFor: #setFromFields:!public!setting! !

!SptHTTPCookie categoriesFor: #setPath:!public!setting! !

!SptHTTPCookie categoriesFor: #setSecure:!public!setting! !

!SptHTTPCookie categoriesFor: #values!accessing!public! !

!SptHTTPCookie class methodsFor!
addNextCookieString: cookieString to: aCollection startingAt: anIndex
	"Private - Answer 0 if no more"

	| expiresPos commaPos |
	expiresPos := cookieString indexOfSubCollection: 'expires' startingAt: anIndex.
	commaPos := cookieString indexOfSubCollection: ',' startingAt: anIndex.
	commaPos > expiresPos 
		ifTrue: 
			["The commaPos is in 'DATE', find the next"

			commaPos := cookieString indexOfSubCollection: ',' startingAt: commaPos + 1].
	"Is it the last cookie?"
	^commaPos = 0 
		ifTrue: 
			[aCollection add: (cookieString copyFrom: anIndex to: cookieString size).
			0]
		ifFalse: 
			[aCollection add: (cookieString copyFrom: anIndex to: commaPos - 1).
			commaPos + 1]! !
!SptHTTPCookie class categoriesFor: #addNextCookieString:to:startingAt:!public! !

!SptHTTPCookie class methodsFor!
allFromSetCookieString: aString url: aSptHTTPUrl
	"Answer a collection of Cookies"

	| cookieStrings pos |
	cookieStrings := OrderedCollection new.
	pos := 1.
	"This is disgusting ... multiple cookies can be separated by commas ... NAME=VALUE strings can not contain a comma, 
		but, expires=DATE does ... arrrg"
	[pos = 0] whileFalse: 
			[pos := self 
						addNextCookieString: aString
						to: cookieStrings
						startingAt: pos].
	^cookieStrings select: [:each | each trimBlanks notEmpty]
		thenCollect: [:each | self fromCookieString: aString url: aSptHTTPUrl]! !
!SptHTTPCookie class categoriesFor: #allFromSetCookieString:url:!public! !

!SptHTTPCookie class methodsFor!
fromCookieString: aString url: aSptHTTPUrl
	"Answer a single cookie"

	| fields instance |
	fields := LookupTable new.
	(aString subStrings: $;) do: 
			[:each | 
			each trimBlanks notEmpty 
				ifTrue: 
					[| stream key value |
					stream := each readStream.
					key := (stream upTo: $=) trimBlanks.
					value := stream upToEnd trimBlanks.
					(value notEmpty or: [key = 'secure']) ifTrue: [fields at: key put: value]]].
	instance := self newForUrl: aSptHTTPUrl.
	instance setFromFields: fields.
	^instance! !
!SptHTTPCookie class categoriesFor: #fromCookieString:url:!public! !

!SptHTTPCookie class methodsFor!
isSpecialDomain: aString
	aString size < 5 ifTrue: [^false].
	"SPEC: Any domain that fails within one of the seven special top level domains listed below only require two periods"
	(aString select: [:each | each = $.]) size >= 2 ifFalse: [^false].
	^SptHTTPUrl specialDomainEndings 
		includes: (aString copyFrom: aString size - 2 to: aString size) asLowercase! !
!SptHTTPCookie class categoriesFor: #isSpecialDomain:!public! !

!SptHTTPCookie class methodsFor!
isValidDomain: aString
	"SPEC
		and domains must have at least .... three (3) periods "

	^(aString select: [:each | each = $.]) size >= 3! !
!SptHTTPCookie class categoriesFor: #isValidDomain:!public! !

!SptHTTPCookie class methodsFor!
new
	^super new initialize! !
!SptHTTPCookie class categoriesFor: #new!public! !

!SptHTTPCookie class methodsFor!
newForUrl: aSptHTTPUrl
	^(self new)
		domain: aSptHTTPUrl host;
		path: aSptHTTPUrl path;
		yourself! !
!SptHTTPCookie class categoriesFor: #newForUrl:!public! !

!SptHTTPCookie class categoriesFor: #addNextCookieString:to:startingAt:!instance creation!private! !

!SptHTTPCookie class categoriesFor: #allFromSetCookieString:url:!instance creation!public! !

!SptHTTPCookie class categoriesFor: #fromCookieString:url:!instance creation!public! !

!SptHTTPCookie class categoriesFor: #isSpecialDomain:!helpers!public! !

!SptHTTPCookie class categoriesFor: #isValidDomain:!helpers!public! !

!SptHTTPCookie class categoriesFor: #new!instance creation!public! !

!SptHTTPCookie class categoriesFor: #newForUrl:!instance creation!public! !

SptHTTPCookieJar guid: (GUID fromString: '{749F82E9-E24B-4E46-9D19-3DCE5EDDC4E0}')!

SptHTTPCookieJar guid: (GUID fromString: '{749F82E9-E24B-4E46-9D19-3DCE5EDDC4E0}')!
SptHTTPCookieJar comment: 'SptHTTPCookieJar

I am used to store and access http cookies.

See SptHTTPRequest(class)>>exampleCookies

Instance Variables:
	cookies	<SharedIdentitySet>'!

SptHTTPCookieJar comment:
'SptHTTPCookieJar

I am used to store and access http cookies.

See SptHTTPRequest(class)>>exampleCookies

Instance Variables:
	cookies	<SharedIdentitySet>'!
!SptHTTPCookieJar categoriesForClass!Kernel-Objects! !
!SptHTTPCookieJar methodsFor!
addCookie: aSptHTTPCookie
	"SPEC: Instances of the same path and name will overwrite each other, with the latest instance taking precedence. Instances of the same path but different names will add additional mappings. "

	| removed |
	#todo.	"Parse the expires date so that;
		SPEC: If a CGI script wishes to delete a cookie, it can do so by returning a cookie 
			with the same name, and an expires time which is in the past"
	removed := self removeCookiesMatching: aSptHTTPCookie.
	self assert: [removed size <= 1].
	removed do: 
			[:eachCookie | 
			eachCookie nameValuesDo: 
					[:n :v | 
					"only add the NAME=VALUE pair if not present"

					aSptHTTPCookie atName: n ifAbsentPut: [v]]].
	cookies add: aSptHTTPCookie! !
!SptHTTPCookieJar categoriesFor: #addCookie:!public! !

!SptHTTPCookieJar methodsFor!
cookies
	^cookies! !
!SptHTTPCookieJar categoriesFor: #cookies!public! !

!SptHTTPCookieJar methodsFor!
cookiesFor: aSptHTTPUrl
	| fromDomain host path |
	host := aSptHTTPUrl host.
	path := aSptHTTPUrl path.
	fromDomain := cookies select: [:each | each isDomainMatch: host].
	^fromDomain select: [:each | each isPathMatch: path]! !
!SptHTTPCookieJar categoriesFor: #cookiesFor:!public! !

!SptHTTPCookieJar methodsFor!
emptyJar
	cookies := SharedIdentitySet new! !
!SptHTTPCookieJar categoriesFor: #emptyJar!public! !

!SptHTTPCookieJar methodsFor!
headerFor: aSptHTTPUrl
	| stream matching |
	matching := self cookiesFor: aSptHTTPUrl.
	stream := String writeStream.
	matching do: [:each | each printNameValueOn: stream] separatedBy: [stream nextPut: $;].
	^stream contents! !
!SptHTTPCookieJar categoriesFor: #headerFor:!public! !

!SptHTTPCookieJar methodsFor!
initialize
	super initialize.
	cookies := SharedIdentitySet new! !
!SptHTTPCookieJar categoriesFor: #initialize!public! !

!SptHTTPCookieJar methodsFor!
numberOfCookies
	^cookies size! !
!SptHTTPCookieJar categoriesFor: #numberOfCookies!public! !

!SptHTTPCookieJar methodsFor!
removeCookiesMatching: aSptHTTPCookie
	| same |
	same := cookies select: [:each | each isSameAs: aSptHTTPCookie].
	same do: [:each | cookies remove: each ifAbsent: []].
	^same! !
!SptHTTPCookieJar categoriesFor: #removeCookiesMatching:!public! !

!SptHTTPCookieJar categoriesFor: #addCookie:!adding!public! !

!SptHTTPCookieJar categoriesFor: #cookies!accessing!private! !

!SptHTTPCookieJar categoriesFor: #cookiesFor:!accessing!public! !

!SptHTTPCookieJar categoriesFor: #emptyJar!operations!public! !

!SptHTTPCookieJar categoriesFor: #headerFor:!accessing!public! !

!SptHTTPCookieJar categoriesFor: #initialize!initializing!public! !

!SptHTTPCookieJar categoriesFor: #numberOfCookies!accessing!public! !

!SptHTTPCookieJar categoriesFor: #removeCookiesMatching:!private!removing! !

!SptHTTPCookieJar class methodsFor!
new
	^super new initialize! !
!SptHTTPCookieJar class categoriesFor: #new!public! !

!SptHTTPCookieJar class categoriesFor: #new!instance creation!public! !

SptHTTPEntity guid: (GUID fromString: '{49FC9ECA-DE1D-420A-B1BE-835D4704B9DE}')!

SptHTTPEntity guid: (GUID fromString: '{49FC9ECA-DE1D-420A-B1BE-835D4704B9DE}')!
SptHTTPEntity comment: 'I am an HTTP Entity sent with an HTTP Request used with requests that send a body (ie POST, PUT)

Instance Variables:
	stream		<ReadStream>
	contentLength	<Integer>
	contentType	<String>'!

SptHTTPEntity comment:
'I am an HTTP Entity sent with an HTTP Request used with requests that send a body (ie POST, PUT)

Instance Variables:
	stream		<ReadStream>
	contentLength	<Integer>
	contentType	<String>'!
!SptHTTPEntity categoriesForClass!Kernel-Objects! !
!SptHTTPEntity methodsFor!
beAppOctetStream
	contentType := 'application/octet-stream'! !
!SptHTTPEntity categoriesFor: #beAppOctetStream!public! !

!SptHTTPEntity methodsFor!
beTextHtml
	contentType := 'text/html'! !
!SptHTTPEntity categoriesFor: #beTextHtml!public! !

!SptHTTPEntity methodsFor!
beTextPlain
	contentType := 'text/plain'! !
!SptHTTPEntity categoriesFor: #beTextPlain!public! !

!SptHTTPEntity methodsFor!
beTextXml
	contentType := 'text/xml'! !
!SptHTTPEntity categoriesFor: #beTextXml!public! !

!SptHTTPEntity methodsFor!
contentLength
	^contentLength ifNil: [0]! !
!SptHTTPEntity categoriesFor: #contentLength!public! !

!SptHTTPEntity methodsFor!
contentType
	^contentType! !
!SptHTTPEntity categoriesFor: #contentType!public! !

!SptHTTPEntity methodsFor!
contentType: aString
	contentType := aString! !
!SptHTTPEntity categoriesFor: #contentType:!public! !

!SptHTTPEntity methodsFor!
hasContentType
	^contentType notNil! !
!SptHTTPEntity categoriesFor: #hasContentType!public! !

!SptHTTPEntity methodsFor!
stream
	^stream! !
!SptHTTPEntity categoriesFor: #stream!public! !

!SptHTTPEntity methodsFor!
stream: aReadStream contentLength: anInteger
	stream := aReadStream.
	contentLength := anInteger! !
!SptHTTPEntity categoriesFor: #stream:contentLength:!public! !

!SptHTTPEntity categoriesFor: #beAppOctetStream!content types!public! !

!SptHTTPEntity categoriesFor: #beTextHtml!content types!public! !

!SptHTTPEntity categoriesFor: #beTextPlain!content types!public! !

!SptHTTPEntity categoriesFor: #beTextXml!content types!public! !

!SptHTTPEntity categoriesFor: #contentLength!accessing!public! !

!SptHTTPEntity categoriesFor: #contentType!accessing!public! !

!SptHTTPEntity categoriesFor: #contentType:!accessing!public! !

!SptHTTPEntity categoriesFor: #hasContentType!public!testing! !

!SptHTTPEntity categoriesFor: #stream!accessing!public! !

!SptHTTPEntity categoriesFor: #stream:contentLength:!accessing!public! !

!SptHTTPEntity class methodsFor!
fromByteObject: aByteObject
	^(self new)
		stream: aByteObject asByteArray readStream contentLength: aByteObject size;
		yourself! !
!SptHTTPEntity class categoriesFor: #fromByteObject:!public! !

!SptHTTPEntity class methodsFor!
fromString: aString
	^self fromByteObject: aString! !
!SptHTTPEntity class categoriesFor: #fromString:!public! !

!SptHTTPEntity class methodsFor!
onFileStream: aFileStream
	"The FileStream should be opened in the text: false mode"

	^(self new)
		stream: aFileStream contentLength: aFileStream size;
		yourself! !
!SptHTTPEntity class categoriesFor: #onFileStream:!public! !

!SptHTTPEntity class methodsFor!
onStream: aByteReadStream contentLength: anInteger
	^(self new)
		stream: aByteReadStream contentLength: anInteger;
		yourself! !
!SptHTTPEntity class categoriesFor: #onStream:contentLength:!public! !

!SptHTTPEntity class categoriesFor: #fromByteObject:!instance creation!public! !

!SptHTTPEntity class categoriesFor: #fromString:!instance creation!public! !

!SptHTTPEntity class categoriesFor: #onFileStream:!instance creation!public! !

!SptHTTPEntity class categoriesFor: #onStream:contentLength:!instance creation!public! !

SptHTTPHostCache guid: (GUID fromString: '{2290F0AC-58A3-402A-905F-0C4C8BF81652}')!

SptHTTPHostCache guid: (GUID fromString: '{2290F0AC-58A3-402A-905F-0C4C8BF81652}')!
SptHTTPHostCache comment: 'SptHTTPHostCache

I am an optimization class; I cache the ip address of host to avoid a DNS lookup

Instance Variables
	cache		<SharedLookupTable>
	ipFactory		<SptHTTPHostCache>'!

SptHTTPHostCache comment:
'SptHTTPHostCache

I am an optimization class; I cache the ip address of host to avoid a DNS lookup

Instance Variables
	cache		<SharedLookupTable>
	ipFactory		<SptHTTPHostCache>'!
!SptHTTPHostCache categoriesForClass!Kernel-Objects! !
!SptHTTPHostCache methodsFor!
cache
	^cache! !
!SptHTTPHostCache categoriesFor: #cache!public! !

!SptHTTPHostCache methodsFor!
cache: anObject
	cache := anObject! !
!SptHTTPHostCache categoriesFor: #cache:!public! !

!SptHTTPHostCache methodsFor!
freshMilliseconds
	^##(1000 * 60 * 2)! !
!SptHTTPHostCache categoriesFor: #freshMilliseconds!public! !

!SptHTTPHostCache methodsFor!
hasExpired: entry
	^Delay millisecondClockValue - entry first > self freshMilliseconds! !
!SptHTTPHostCache categoriesFor: #hasExpired:!public! !

!SptHTTPHostCache methodsFor!
initialize
	super initialize.
	cache := SharedLookupTable new.
	ipFactory := self! !
!SptHTTPHostCache categoriesFor: #initialize!public! !

!SptHTTPHostCache methodsFor!
ipAddressFor: aString
	| entry |
	entry := cache at: aString ifAbsent: [].
	(entry isNil or: [self hasExpired: entry]) 
		ifTrue: [cache at: aString put: (entry := self newEntryFor: aString)].
	^entry second! !
!SptHTTPHostCache categoriesFor: #ipAddressFor:!public! !

!SptHTTPHostCache methodsFor!
ipAddressFromString: aString
	^(InternetAddress fromString: aString) ipAddress! !
!SptHTTPHostCache categoriesFor: #ipAddressFromString:!public! !

!SptHTTPHostCache methodsFor!
ipFactory
	^ipFactory! !
!SptHTTPHostCache categoriesFor: #ipFactory!public! !

!SptHTTPHostCache methodsFor!
ipFactory: anObject
	ipFactory := anObject! !
!SptHTTPHostCache categoriesFor: #ipFactory:!public! !

!SptHTTPHostCache methodsFor!
newEntryFor: aString
	^self newEntryForIP: (ipFactory ipAddressFromString: aString)! !
!SptHTTPHostCache categoriesFor: #newEntryFor:!public! !

!SptHTTPHostCache methodsFor!
newEntryForIP: anIPAddress
	^Array with: Delay millisecondClockValue with: anIPAddress! !
!SptHTTPHostCache categoriesFor: #newEntryForIP:!public! !

!SptHTTPHostCache categoriesFor: #cache!accessing!private! !

!SptHTTPHostCache categoriesFor: #cache:!accessing!private! !

!SptHTTPHostCache categoriesFor: #freshMilliseconds!constants!private! !

!SptHTTPHostCache categoriesFor: #hasExpired:!caching!private! !

!SptHTTPHostCache categoriesFor: #initialize!initializing!private! !

!SptHTTPHostCache categoriesFor: #ipAddressFor:!caching!public! !

!SptHTTPHostCache categoriesFor: #ipAddressFromString:!helpers!private! !

!SptHTTPHostCache categoriesFor: #ipFactory!accessing!private! !

!SptHTTPHostCache categoriesFor: #ipFactory:!accessing!private! !

!SptHTTPHostCache categoriesFor: #newEntryFor:!entries!private! !

!SptHTTPHostCache categoriesFor: #newEntryForIP:!entries!private! !

!SptHTTPHostCache class methodsFor!
current
	Current isNil ifTrue: [Current := self new].
	^Current! !
!SptHTTPHostCache class categoriesFor: #current!public! !

!SptHTTPHostCache class methodsFor!
initialize
"Private - Register the receiver with the #onStartup event"
"
self initialize
"
SessionManager current
when: #sessionStarted
send: #onStartup
to: self! !
!SptHTTPHostCache class categoriesFor: #initialize!public! !

!SptHTTPHostCache class methodsFor!
new
	^super new initialize! !
!SptHTTPHostCache class categoriesFor: #new!public! !

!SptHTTPHostCache class methodsFor!
onStartup
Current := nil! !
!SptHTTPHostCache class categoriesFor: #onStartup!public! !

!SptHTTPHostCache class methodsFor!
uninitialize
	Current := nil! !
!SptHTTPHostCache class categoriesFor: #uninitialize!public! !

!SptHTTPHostCache class categoriesFor: #current!accessing!public! !

!SptHTTPHostCache class categoriesFor: #initialize!initializing!public! !

!SptHTTPHostCache class categoriesFor: #new!instance creation!public! !

!SptHTTPHostCache class categoriesFor: #onStartup!event handling!public! !

!SptHTTPHostCache class categoriesFor: #uninitialize!initializing!public! !

SptHTTPProgressAbstract guid: (GUID fromString: '{C81AB512-C74D-4C14-A919-03EC9622A7AD}')!

SptHTTPProgressAbstract guid: (GUID fromString: '{C81AB512-C74D-4C14-A919-03EC9622A7AD}')!
SptHTTPProgressAbstract comment: '

Instance Variables
	request 	<SptHTTPRequest>'!

SptHTTPProgressAbstract comment:
'

Instance Variables
	request 	<SptHTTPRequest>'!
!SptHTTPProgressAbstract categoriesForClass!Kernel-Objects! !
!SptHTTPProgressAbstract methodsFor!
request
	^request! !
!SptHTTPProgressAbstract categoriesFor: #request!public! !

!SptHTTPProgressAbstract methodsFor!
request: anObject
	request := anObject! !
!SptHTTPProgressAbstract categoriesFor: #request:!public! !

!SptHTTPProgressAbstract methodsFor!
response
	^request lastResponse! !
!SptHTTPProgressAbstract categoriesFor: #response!public! !

!SptHTTPProgressAbstract categoriesFor: #request!accessing!public! !

!SptHTTPProgressAbstract categoriesFor: #request:!accessing!public! !

!SptHTTPProgressAbstract categoriesFor: #response!accessing!public! !

!SptHTTPProgressAbstract class methodsFor!
new
	^super new initialize! !
!SptHTTPProgressAbstract class categoriesFor: #new!public! !

!SptHTTPProgressAbstract class categoriesFor: #new!instance creation!public! !

SptHTTPProxySettings guid: (GUID fromString: '{49FAC93F-87B7-41F8-8735-1439A0CBC3BD}')!

SptHTTPProxySettings guid: (GUID fromString: '{49FAC93F-87B7-41F8-8735-1439A0CBC3BD}')!
SptHTTPProxySettings comment: 'SptHTTPProxySettings

See SptHTTPRequest(class)>>exampleProxy

Instance Variables:
	useProxy		<Boolean>
	proxyHost		<String>
	proxyPort		<Integer>'!

SptHTTPProxySettings comment:
'SptHTTPProxySettings

See SptHTTPRequest(class)>>exampleProxy

Instance Variables:
	useProxy		<Boolean>
	proxyHost		<String>
	proxyPort		<Integer>'!
!SptHTTPProxySettings categoriesForClass!Unclassified! !
!SptHTTPProxySettings methodsFor!
proxyHost
	proxyHost isNil ifTrue: [proxyHost := 'localhost'].
	^proxyHost! !
!SptHTTPProxySettings categoriesFor: #proxyHost!public! !

!SptHTTPProxySettings methodsFor!
proxyHost: aString
	proxyHost := aString! !
!SptHTTPProxySettings categoriesFor: #proxyHost:!public! !

!SptHTTPProxySettings methodsFor!
proxyPort
	proxyPort isNil ifTrue: [proxyPort := 8000].
	^proxyPort! !
!SptHTTPProxySettings categoriesFor: #proxyPort!public! !

!SptHTTPProxySettings methodsFor!
proxyPort: anInteger
	proxyPort := anInteger! !
!SptHTTPProxySettings categoriesFor: #proxyPort:!public! !

!SptHTTPProxySettings methodsFor!
useHost: aString port: aSmallInteger
	useProxy := true.
	proxyHost := aString.
	proxyPort := aSmallInteger! !
!SptHTTPProxySettings categoriesFor: #useHost:port:!public! !

!SptHTTPProxySettings methodsFor!
useProxy
	useProxy isNil ifTrue: [useProxy := false].
	^useProxy! !
!SptHTTPProxySettings categoriesFor: #useProxy!public! !

!SptHTTPProxySettings methodsFor!
useProxy: aBool
	useProxy := aBool ! !
!SptHTTPProxySettings categoriesFor: #useProxy:!public! !

!SptHTTPProxySettings categoriesFor: #proxyHost!accessing!public! !

!SptHTTPProxySettings categoriesFor: #proxyHost:!accessing!public! !

!SptHTTPProxySettings categoriesFor: #proxyPort!accessing!public! !

!SptHTTPProxySettings categoriesFor: #proxyPort:!accessing!public! !

!SptHTTPProxySettings categoriesFor: #useHost:port:!accessing!public! !

!SptHTTPProxySettings categoriesFor: #useProxy!accessing!public! !

!SptHTTPProxySettings categoriesFor: #useProxy:!accessing!public! !

!SptHTTPProxySettings class methodsFor!
useHost: aString port: aSmallInteger
	^self new useHost: aString port: aSmallInteger! !
!SptHTTPProxySettings class categoriesFor: #useHost:port:!public! !

!SptHTTPProxySettings class categoriesFor: #useHost:port:!instance creation!public! !

SptHTTPRequest guid: (GUID fromString: '{C344AF47-93BE-48FF-BFB8-E96CF447A82A}')!

SptHTTPRequest guid: (GUID fromString: '{C344AF47-93BE-48FF-BFB8-E96CF447A82A}')!
SptHTTPRequest comment: 'I am a single request and response http message send in a background process.

I am a single request and response http message send in a background process.

==========
Features:
	Each feature of the HTTPClient is demonstrated in one of the class #example* methods

==========
Instance Variables:
	connection 	<SptHTTPConnection>
	url		<SptHTTPUrl> 
	method		<String>. (HTTP method)
	headers		<Dictionary> (HTTP request headers)
	entity 		<SptHTTPEntity> or nil (content to be sent with PUT/POST etc)
	responses 	<Collection> of <SptHTTPResponse>s
	okBodyStream 	<WriteStream> or nil 
	state 		<SptSessionState>
	flags		<Integer>
	progess		<SptHTTPProgress>
	conf		<SptHTTPConfiguration>

==========
Debugging

	See #send

==========
Flags
	IsAuthenticateMask 
		(true) controls whether an Authorization header can be added 
	IsFollowRedirectsMask 
		(true) controls whether 300 responses are automatically resent to the new Location 
	IsRangeRequestMask
		(false) controls whether the okBodyStream is set to the start position of a Range interval 
	IsUseCookiesMask
		(true) controls whether Cookies are added to a Request
	IsVersion11Mask
		(true) controls whether the request is sent as 1.1 and whether connections are resused

==========
How it works

	1) Set-Up
	 - A new instance is created for each request that you want to send to a server. You set
	the url/method/entity/flags and any additonal headers into the request. You can also set existing
	state <SptHTTPSessionState> into the request (which holds information usually needed
	across a series of requests)

	2) Sending
	 - The #send method starts the request in a background process and returns immediately.
	- In this background process the request is sent, and the response is read. Certain responses
	may create the need to send a new request (for example redirection), and therefore a single
	request may have multiple responses.

	3) Waiting
	 - You can use the #isReady message to check if the request has finished, or ...
	 - You can block using one of the #waitOnReady* methods. The #waitOnReady* methods
	can make use of a timeoutLoop to limit the time that the process blocks.
	
	4) Timeouts
	 - It was necessary to implement a timeoutLoop as WinSock1 does not have configurable
	OS layer timeouts.
	 - If a timeout is activated, a SocketWaitCancelled error will be signalled in the process
	blocked in the #waitOnReady* method
	
	5) Finishing
	- Access the #lastResponse, or use the methods in the accessing-response category.
	- If you are making a series of requests, you may want to store the #state


==========
Notes

	- The multiple-process design of this class (ie the deferredSend and the timeoutLoop)
	was driven by the lack of configurable WinSock1 OS-level timeouts. 
	- WinSock2 does have timeouts, and would allow much of the process synchronization code
	to be removed.
	 
	- I have used this class heavily over the past six months; I  have a queue class (not included) that
	processes 4-5 requests concurrently. 
	
	-What I have not used heavily (and may be a more likely source of bugs)
		- The authorization/authentication code
 		- Cookies
		- Range Requests are a new feature

		

	
	
	



'!

SptHTTPRequest comment:
'I am a single request and response http message send in a background process.

I am a single request and response http message send in a background process.

==========
Features:
	Each feature of the HTTPClient is demonstrated in one of the class #example* methods

==========
Instance Variables:
	connection 	<SptHTTPConnection>
	url		<SptHTTPUrl> 
	method		<String>. (HTTP method)
	headers		<Dictionary> (HTTP request headers)
	entity 		<SptHTTPEntity> or nil (content to be sent with PUT/POST etc)
	responses 	<Collection> of <SptHTTPResponse>s
	okBodyStream 	<WriteStream> or nil 
	state 		<SptSessionState>
	flags		<Integer>
	progess		<SptHTTPProgress>
	conf		<SptHTTPConfiguration>

==========
Debugging

	See #send

==========
Flags
	IsAuthenticateMask 
		(true) controls whether an Authorization header can be added 
	IsFollowRedirectsMask 
		(true) controls whether 300 responses are automatically resent to the new Location 
	IsRangeRequestMask
		(false) controls whether the okBodyStream is set to the start position of a Range interval 
	IsUseCookiesMask
		(true) controls whether Cookies are added to a Request
	IsVersion11Mask
		(true) controls whether the request is sent as 1.1 and whether connections are resused

==========
How it works

	1) Set-Up
	 - A new instance is created for each request that you want to send to a server. You set
	the url/method/entity/flags and any additonal headers into the request. You can also set existing
	state <SptHTTPSessionState> into the request (which holds information usually needed
	across a series of requests)

	2) Sending
	 - The #send method starts the request in a background process and returns immediately.
	- In this background process the request is sent, and the response is read. Certain responses
	may create the need to send a new request (for example redirection), and therefore a single
	request may have multiple responses.

	3) Waiting
	 - You can use the #isReady message to check if the request has finished, or ...
	 - You can block using one of the #waitOnReady* methods. The #waitOnReady* methods
	can make use of a timeoutLoop to limit the time that the process blocks.
	
	4) Timeouts
	 - It was necessary to implement a timeoutLoop as WinSock1 does not have configurable
	OS layer timeouts.
	 - If a timeout is activated, a SocketWaitCancelled error will be signalled in the process
	blocked in the #waitOnReady* method
	
	5) Finishing
	- Access the #lastResponse, or use the methods in the accessing-response category.
	- If you are making a series of requests, you may want to store the #state


==========
Notes

	- The multiple-process design of this class (ie the deferredSend and the timeoutLoop)
	was driven by the lack of configurable WinSock1 OS-level timeouts. 
	- WinSock2 does have timeouts, and would allow much of the process synchronization code
	to be removed.
	 
	- I have used this class heavily over the past six months; I  have a queue class (not included) that
	processes 4-5 requests concurrently. 
	
	-What I have not used heavily (and may be a more likely source of bugs)
		- The authorization/authentication code
 		- Cookies
		- Range Requests are a new feature

		

	
	
	



'!
!SptHTTPRequest categoriesForClass!Unclassified! !
!SptHTTPRequest methodsFor!
addAuthorizationHeader
	self addIfAbsentHeader: 'Authorization' value: state authorizationHeader! !
!SptHTTPRequest categoriesFor: #addAuthorizationHeader!public! !

!SptHTTPRequest methodsFor!
addCookieHeader
	| header |
	header := state cookieHeaderFor: url.
	(header notNil and: [header notEmpty]) 
		ifTrue: [self addIfAbsentHeader: 'Cookie' value: header]! !
!SptHTTPRequest categoriesFor: #addCookieHeader!public! !

!SptHTTPRequest methodsFor!
addHeader: aHeaderString value: aHeaderValue
	"Add the HTTP header to the request. 
	Note: do *not* include the colon in aHeaderString, (it will be added)"

	headers at: aHeaderString put: aHeaderValue! !
!SptHTTPRequest categoriesFor: #addHeader:value:!public! !

!SptHTTPRequest methodsFor!
addIfAbsentHeader: aName value: aValue
	headers at: aName ifAbsentPut: [aValue]! !
!SptHTTPRequest categoriesFor: #addIfAbsentHeader:value:!public! !

!SptHTTPRequest methodsFor!
addRequiredHeaders
	"Add any required headers, **only** if they have not been manually added"

	self addHeader: 'Host' value: self url hostPort.
	self addIfAbsentHeader: 'User-Agent' value: self class defaultUserAgent.
	(state shouldAuthenticate: self urlString) ifTrue: [self addAuthorizationHeader].
	self isUseCookies ifTrue: [self addCookieHeader].
	self hasEntity 
		ifTrue: [self addIfAbsentHeader: 'Content-Length' value: entity contentLength].
	(self hasEntity and: [self entity hasContentType]) 
		ifTrue: [self addIfAbsentHeader: 'Content-Type' value: entity contentType]! !
!SptHTTPRequest categoriesFor: #addRequiredHeaders!public! !

!SptHTTPRequest methodsFor!
beVersion10
	"This effectively stops connections from being re-used"

	self isVersion11: false! !
!SptHTTPRequest categoriesFor: #beVersion10!public! !

!SptHTTPRequest methodsFor!
bodyStream
	Notification deprecated.
	^okBodyStream! !
!SptHTTPRequest categoriesFor: #bodyStream!public! !

!SptHTTPRequest methodsFor!
cancelConnection
	"This cancels the socket.
	-If  the DeferredValue send is blocked reading, an error will be signalled in that process (which will cause the socket to be closed)
	-An error will also be signalled in any client processes blocking on #waitOnReady"

	connection notNil ifTrue: [connection cancelSocket]! !
!SptHTTPRequest categoriesFor: #cancelConnection!public! !

!SptHTTPRequest methodsFor!
canRangeRetry
	"Answer whether we can retry the request, only asking for the range of bytes we dont have"

	^responses notEmpty and: [self lastResponse canRangeRetry]! !
!SptHTTPRequest categoriesFor: #canRangeRetry!public! !

!SptHTTPRequest methodsFor!
close
	"With persistent connections, the meaning of this message can be ambiguous.
	
		If you want to cancel the background processing of the request, use the method #cancelConnection
		
	"

	Notification deprecated.
	self cancelConnection! !
!SptHTTPRequest categoriesFor: #close!public! !

!SptHTTPRequest methodsFor!
closeOrKeepAliveConnection
	"Use the block temporary so that another process (possibly trying to cancel the connection)
		doesnt interupt the close-down sequence"

	connection ifNotNil: 
			[:conn | 
			connection := nil.
			conn beTimeoutOff.
			self terminateTimeoutLoop.
			conn dumpWireLog.
			(self isVersion11 not or: 
					[responses isEmpty or: 
							[self lastResponse hasStatus not 
								or: [self lastResponse isConnectionClose or: [self isConnectionClose]]]]) 
				ifTrue: [conn closeSocket]
				ifFalse: [conn keepAliveIfOpen]]! !
!SptHTTPRequest categoriesFor: #closeOrKeepAliveConnection!public! !

!SptHTTPRequest methodsFor!
conf
	"Answer a <SptHTTPConfiguration>"

	^conf! !
!SptHTTPRequest categoriesFor: #conf!public! !

!SptHTTPRequest methodsFor!
conf: aSptHTTPConfiguration
	conf := aSptHTTPConfiguration! !
!SptHTTPRequest categoriesFor: #conf:!public! !

!SptHTTPRequest methodsFor!
connect
	self progress onConnecting.
	connection := (url isSecure 
				ifTrue: [conf httpsConnectionClass]
				ifFalse: [conf httpConnectionClass]) 
					port: self immediatePort
					host: self immediateHost
					reuse: self isVersion11.
	self makingProgress onConnected! !
!SptHTTPRequest categoriesFor: #connect!public! !

!SptHTTPRequest methodsFor!
connection
	"Answer a <SptHTTPConnection>"

	^connection! !
!SptHTTPRequest categoriesFor: #connection!public! !

!SptHTTPRequest methodsFor!
connection: aSptHTTPConnection
	"Unit Test helper method"

	connection := aSptHTTPConnection! !
!SptHTTPRequest categoriesFor: #connection:!public! !

!SptHTTPRequest methodsFor!
cookieJar
	^state cookieJar! !
!SptHTTPRequest categoriesFor: #cookieJar!public! !

!SptHTTPRequest methodsFor!
cookieJar: aSptHTTPCookieJar
	state cookieJar: aSptHTTPCookieJar! !
!SptHTTPRequest categoriesFor: #cookieJar:!public! !

!SptHTTPRequest methodsFor!
credentials: aSptCredentials
	state credentials: aSptCredentials! !
!SptHTTPRequest categoriesFor: #credentials:!public! !

!SptHTTPRequest methodsFor!
deferredSend: anObject
	"Unit Test helper method"

	deferredSend := anObject! !
!SptHTTPRequest categoriesFor: #deferredSend:!public! !

!SptHTTPRequest methodsFor!
doAuthorizing: operation
	^operation on: SptHTTPNotAuthorized
		do: 
			[:e | 
			self removeAuthorizationHeader.
			e target: state.
			e site: self urlString.
			^(SptHTTPAuthorizationDialog showOnException: e) 
				ifTrue: [self doAuthorizing: operation]
				ifFalse: [self error: 'Authorization canceled']]! !
!SptHTTPRequest categoriesFor: #doAuthorizing:!public! !

!SptHTTPRequest methodsFor!
entity
	"Answer a <SptHTTPEntity>"

	^entity! !
!SptHTTPRequest categoriesFor: #entity!public! !

!SptHTTPRequest methodsFor!
entity: aSptHTTPEntity
	entity := aSptHTTPEntity! !
!SptHTTPRequest categoriesFor: #entity:!public! !

!SptHTTPRequest methodsFor!
entityString: aString
	entity := SptHTTPEntity fromString: aString! !
!SptHTTPRequest categoriesFor: #entityString:!public! !

!SptHTTPRequest methodsFor!
errorAuthenticationFailed
	self 
		error: 'Authentication failed. No Basic Authentication challenge, Digest is not supported'! !
!SptHTTPRequest categoriesFor: #errorAuthenticationFailed!public! !

!SptHTTPRequest methodsFor!
errorInternalError
	"Private - If this error is signalled, something has gone wrong with the 
	synchronisation  of the multiple processes the reciever uses"

	self error: 'HTTPClient internal synchronisation error'! !
!SptHTTPRequest categoriesFor: #errorInternalError!public! !

!SptHTTPRequest methodsFor!
errorMaximumRedirections
	self error: 'Maximum number of redirections reached'! !
!SptHTTPRequest categoriesFor: #errorMaximumRedirections!public! !

!SptHTTPRequest methodsFor!
errorRedirectionLoop
	self error: 'Redirection loop detected'! !
!SptHTTPRequest categoriesFor: #errorRedirectionLoop!public! !

!SptHTTPRequest methodsFor!
errorRetryNonIdempotentMethod
	self error: 'Should not automatically retry non-Idempotent methods'! !
!SptHTTPRequest categoriesFor: #errorRetryNonIdempotentMethod!public! !

!SptHTTPRequest methodsFor!
hasEntity
	^entity notNil	"and: [entity contentLength ~= 0]"! !
!SptHTTPRequest categoriesFor: #hasEntity!public! !

!SptHTTPRequest methodsFor!
headerAt: aString
	"Answer the <String> value of the request header"

	^headers at: aString! !
!SptHTTPRequest categoriesFor: #headerAt:!public! !

!SptHTTPRequest methodsFor!
headerReportString
	| stream |
	stream := String writeStream.
	stream
		nextPutAll: '===Out';
		cr.
	self putMessageStartOn: stream.
	self putSortedHeadersOn: stream.
	stream cr.
	responses do: 
			[:each | 
			each putHeaderReportOn: stream.
			stream
				cr;
				cr].
	^stream contents! !
!SptHTTPRequest categoriesFor: #headerReportString!public! !

!SptHTTPRequest methodsFor!
headers
	"Answer a <PluggableLookupTable >"

	^headers! !
!SptHTTPRequest categoriesFor: #headers!public! !

!SptHTTPRequest methodsFor!
host
	Notification deprecated.
	self halt
	"^self useProxy ifTrue: [proxySettings proxyHost] ifFalse: [self url host]"! !
!SptHTTPRequest categoriesFor: #host!public! !

!SptHTTPRequest methodsFor!
httpVersionString
	^self isVersion11 ifTrue: ['HTTP/1.1'] ifFalse: ['HTTP/1.0']! !
!SptHTTPRequest categoriesFor: #httpVersionString!public! !

!SptHTTPRequest methodsFor!
immediateHost
	"Answer the <String> host that the connection's socket should connect to."

	^state useProxy ifTrue: [self proxySettings proxyHost] ifFalse: [url host]! !
!SptHTTPRequest categoriesFor: #immediateHost!public! !

!SptHTTPRequest methodsFor!
immediatePort
	"Answer the <Integer> port that the connection's socket should connect to."

	^state useProxy ifTrue: [self proxySettings proxyPort] ifFalse: [url port]! !
!SptHTTPRequest categoriesFor: #immediatePort!public! !

!SptHTTPRequest methodsFor!
initializeFor: aConfiguration
	headers := PluggableLookupTable new searchPolicy: SearchPolicy caseInsensitive.
	responses := OrderedCollection new.
	conf := aConfiguration.
	url := SptHTTPUrl new.
	state := SptHTTPSessionState new.
	progress := aConfiguration newProgressFor: self.
	flags := IsVersion11Mask | IsFollowRedirectsMask | IsAuthenticateMask | IsUseCookiesMask! !
!SptHTTPRequest categoriesFor: #initializeFor:!public! !

!SptHTTPRequest methodsFor!
isAuthenticate
	^flags anyMask: IsAuthenticateMask! !
!SptHTTPRequest categoriesFor: #isAuthenticate!public! !

!SptHTTPRequest methodsFor!
isAuthenticate: aBoolean
	flags := flags mask: IsAuthenticateMask set: aBoolean! !
!SptHTTPRequest categoriesFor: #isAuthenticate:!public! !

!SptHTTPRequest methodsFor!
isConnectionClose
	"Answer whether the user added a Connection: close header to the request.
	-The server should respond with the same header, but use the fact that the user added it to ensure the
	connection is not re-used"

	^(headers at: 'Connection' ifAbsent: [^false]) = 'close'! !
!SptHTTPRequest categoriesFor: #isConnectionClose!public! !

!SptHTTPRequest methodsFor!
isFollowRedirects
	^flags anyMask: IsFollowRedirectsMask! !
!SptHTTPRequest categoriesFor: #isFollowRedirects!public! !

!SptHTTPRequest methodsFor!
isFollowRedirects: aBoolean
	flags := flags mask: IsFollowRedirectsMask set: aBoolean! !
!SptHTTPRequest categoriesFor: #isFollowRedirects:!public! !

!SptHTTPRequest methodsFor!
isIdempotent
	^#('GET' 'HEAD' 'PUT' 'DELETE' 'OPTIONS' 'TRACE') includes: method! !
!SptHTTPRequest categoriesFor: #isIdempotent!public! !

!SptHTTPRequest methodsFor!
isRangeRequest
	"Answer if this is a range request.
		-If so, on a successful response, the okBodyStream's position 
		will be set to the starting byte position"

	^flags anyMask: IsRangeRequestMask! !
!SptHTTPRequest categoriesFor: #isRangeRequest!public! !

!SptHTTPRequest methodsFor!
isRangeRequest: aBoolean
	"Set if this is a range request.
		-If so, on a successful response, the okBodyStream's position 
		will be set to the starting byte position"

	flags := flags mask: IsRangeRequestMask set: aBoolean! !
!SptHTTPRequest categoriesFor: #isRangeRequest:!public! !

!SptHTTPRequest methodsFor!
isReady
	"Answer whether the response has been fully read."

	^deferredSend hasValue
		
		! !
!SptHTTPRequest categoriesFor: #isReady!public! !

!SptHTTPRequest methodsFor!
isUseCookies
	^flags anyMask: IsUseCookiesMask! !
!SptHTTPRequest categoriesFor: #isUseCookies!public! !

!SptHTTPRequest methodsFor!
isUseCookies: aBoolean
	flags := flags mask: IsUseCookiesMask set: aBoolean! !
!SptHTTPRequest categoriesFor: #isUseCookies:!public! !

!SptHTTPRequest methodsFor!
isVersion11
	^flags anyMask: IsVersion11Mask! !
!SptHTTPRequest categoriesFor: #isVersion11!public! !

!SptHTTPRequest methodsFor!
isVersion11: aBoolean
	flags := flags mask: IsVersion11Mask set: aBoolean! !
!SptHTTPRequest categoriesFor: #isVersion11:!public! !

!SptHTTPRequest methodsFor!
lastResponse
	"Answer the last <SptHTTPResponse> received (previous responses may be
	redirects/not authorized responses that are automatically resent"

	^responses isEmpty ifTrue: [nil] ifFalse: [responses last]! !
!SptHTTPRequest categoriesFor: #lastResponse!public! !

!SptHTTPRequest methodsFor!
makingProgress
	"Answer the <SptHTTPProgress>.
	- Reset any timeouts"

	connection ifNotNil: [:o | o beTimeoutOn].
	^progress! !
!SptHTTPRequest categoriesFor: #makingProgress!public! !

!SptHTTPRequest methodsFor!
maxRedirects
	"Answer the maximum number of redirections that can automatically be followed"

	^state maxRedirects! !
!SptHTTPRequest categoriesFor: #maxRedirects!public! !

!SptHTTPRequest methodsFor!
maxRedirects: aNumber
	state maxRedirects: aNumber! !
!SptHTTPRequest categoriesFor: #maxRedirects:!public! !

!SptHTTPRequest methodsFor!
method
	"Private - Answer the <String> method of the request (ie 'GET', 'POST' etc)"

	^method! !
!SptHTTPRequest categoriesFor: #method!public! !

!SptHTTPRequest methodsFor!
method: aString
	"Set the HTTP method of the request (ie GET POST etc)"

	method := aString! !
!SptHTTPRequest categoriesFor: #method:!public! !

!SptHTTPRequest methodsFor!
okBodyStream
	"Answer the <WriteStream> that any OK response (ie 2xx) will be streamed to"

	^okBodyStream! !
!SptHTTPRequest categoriesFor: #okBodyStream!public! !

!SptHTTPRequest methodsFor!
okBodyStream: aByteWriteStream
	"Optional, Set the <WriteStream> (on a ByteArray)  that a 200 response will stream to"

	okBodyStream := aByteWriteStream! !
!SptHTTPRequest categoriesFor: #okBodyStream:!public! !

!SptHTTPRequest methodsFor!
open: aMethodString bstrUrl: aUrl varAsync: aBool bstrUser: s1 bstrPassword: s2
	"MSXML IXMLHTTPRequest compatibility method"

	#deprecated.
	self urlString: aUrl.
	method := aMethodString.
	((s1 isNil or: [s1 isEmpty]) and: [s2 isNil or: [s2 isEmpty]]) 
		ifFalse: [self username: s1 password: s2]! !
!SptHTTPRequest categoriesFor: #open:bstrUrl:varAsync:bstrUser:bstrPassword:!public! !

!SptHTTPRequest methodsFor!
open: aMethodString to: aUrlString
	"Set the receiver to send a request using the HTTP method (typically GET or POST), to the url"

	self urlString: aUrlString.
	method := aMethodString! !
!SptHTTPRequest categoriesFor: #open:to:!public! !

!SptHTTPRequest methodsFor!
openGetTo: aUrlString
	"Set the receiver to send a GET request to the url"

	self open: 'GET' to: aUrlString! !
!SptHTTPRequest categoriesFor: #openGetTo:!public! !

!SptHTTPRequest methodsFor!
openPostTo: aUrlString
	"Set the receiver to send a POST request to the url"

	self open: 'POST' to: aUrlString! !
!SptHTTPRequest categoriesFor: #openPostTo:!public! !

!SptHTTPRequest methodsFor!
port
	Notification deprecated.
	self halt
	"^self useProxy ifTrue: [proxySettings proxyPort] ifFalse: [self url port]"! !
!SptHTTPRequest categoriesFor: #port!public! !

!SptHTTPRequest methodsFor!
prepareForAuthorize
	| basicChallenge user |
	self assert: [self isAuthenticate].
	(basicChallenge := self lastResponse basicChallenge) isNil 
		ifTrue: [self errorAuthenticationFailed].
	"Info required for Digest authentication (but not yet implemented)"
	basicChallenge rootUri: self url rootBaseUrlString.
	basicChallenge digestUri: self requestURI.
	"Note: we must check if we have previously sent authorization. If so, only resend if we get new info"
	((headers includesKey: 'Authorization') 
		or: [(user := SptHTTPUser userFor: basicChallenge realm host: url host) isNil]) 
			ifTrue: 
				[((SptHTTPNotAuthorized new)
					challenge: basicChallenge;
					target: self) signal]
			ifFalse: [self credentials: (basicChallenge credentialsFor: user)].
	^true! !
!SptHTTPRequest categoriesFor: #prepareForAuthorize!public! !

!SptHTTPRequest methodsFor!
prepareForRedirect
	"Set the new url
		-remove any authentication or cookie headers.
		- add any new authentication or cookie headers for the new url."

	self urlString: self lastResponse location.
	self removeAuthorizationHeader.
	(state shouldAuthenticate: self urlString) ifTrue: [self addAuthorizationHeader].
	self removeCookieHeader.
	self isUseCookies ifTrue: [self addCookieHeader].
	self makingProgress onRedirecting! !
!SptHTTPRequest categoriesFor: #prepareForRedirect!public! !

!SptHTTPRequest methodsFor!
prepareForRetry
	"There was an error retry the request.
		-make sure we *can* send a Range request, and whether it makes sense"

	(self canRangeRetry and: [self lastResponse bodyStreamSize > 0]) 
		ifTrue: 
			["Setting the beRangeRequest  mode means that if a response is read with a 'Range' header,
				the SptHTTPResponse instance will set the position of the okBodyStream to
				the start of the range interval."

			self isRangeRequest: true.
			"eg The second 500 bytes (byte offsets 500-999, inclusive): bytes=500-999 "
			self addHeader: 'Range'
				value: 'bytes=' , self lastResponse bodyStreamSize displayString , '-' 
						, (self lastResponse contentLength - 1) displayString].
	"Reset the bodyStream regardless ... we cant count on a server returning a range "
	okBodyStream notNil ifTrue: [okBodyStream reset]! !
!SptHTTPRequest categoriesFor: #prepareForRetry!public! !

!SptHTTPRequest methodsFor!
prepareForSpecRetry
	"Prepare for a simple retry based on 
		<http://www.w3.org/Protocols/rfc2616/rfc2616-sec8.html#sec8.2.4>

	Unlike #prepareForRetry, dont attempt a 'Range' request ... this is intended for
		situations where the server closes the connection before we see any request "

	"mmm, maybe we dont need to do anything in this method?"

	okBodyStream notNil ifTrue: [okBodyStream reset]! !
!SptHTTPRequest categoriesFor: #prepareForSpecRetry!public! !

!SptHTTPRequest methodsFor!
prepareNextMessage: visited
	(self lastResponse isRedirect and: [self isFollowRedirects]) 
		ifTrue: 
			["I default to a low number of maxRedirects, but there is no standard maximum"

			visited size > self maxRedirects ifTrue: [self errorMaximumRedirections].
			self prepareForRedirect.
			"Allow the same url to be visted twice, but not three times.
			This allows sites that redirect back to the original url after setting a cookie."
			(visited select: [:each | each = self urlString]) size > 2 
				ifTrue: [self errorRedirectionLoop].
			^true].
	(self lastResponse isUnauthorized and: [self isAuthenticate]) 
		ifTrue: [^self prepareForAuthorize].
	^false! !
!SptHTTPRequest categoriesFor: #prepareNextMessage:!public! !

!SptHTTPRequest methodsFor!
progress
	"Answer a <SptHTTPProgress>"

	^progress! !
!SptHTTPRequest categoriesFor: #progress!public! !

!SptHTTPRequest methodsFor!
progress: aSptHTTPProgress
	progress := aSptHTTPProgress! !
!SptHTTPRequest categoriesFor: #progress:!public! !

!SptHTTPRequest methodsFor!
proxySettings
	^state proxySettings! !
!SptHTTPRequest categoriesFor: #proxySettings!public! !

!SptHTTPRequest methodsFor!
proxySettings: aSptHTTPProxySettings
	state proxySettings: aSptHTTPProxySettings! !
!SptHTTPRequest categoriesFor: #proxySettings:!public! !

!SptHTTPRequest methodsFor!
putHeaderName: nameString value: valueString on: aStream
	aStream
		nextPutAll: nameString;
		nextPutAll: ': ';
		nextPutAll: valueString displayString;
		crlf! !
!SptHTTPRequest categoriesFor: #putHeaderName:value:on:!public! !

!SptHTTPRequest methodsFor!
putMessageStartOn: aStream
	aStream
		nextPutAll: method;
		space;
		nextPutAll: self requestURI;
		space;
		nextPutAll: self httpVersionString;
		crlf! !
!SptHTTPRequest categoriesFor: #putMessageStartOn:!public! !

!SptHTTPRequest methodsFor!
putSortedHeadersOn: aStream
	self sortedHeadersAndValuesDo: 
			[:name :value | 
			self 
				putHeaderName: name
				value: value
				on: aStream]! !
!SptHTTPRequest categoriesFor: #putSortedHeadersOn:!public! !

!SptHTTPRequest methodsFor!
readEntityBufferSize
	^conf readEntityBufferSize! !
!SptHTTPRequest categoriesFor: #readEntityBufferSize!public! !

!SptHTTPRequest methodsFor!
readResponse
	"Create a new response object, add it to our responses collection, then ask it to read the response.
	Note: adding the response to responses before reading it, allows it to be accessed through me.
		-Progress classes can take advantage of this."

	| response |
	self responses add: (response := conf newResponseFor: self).
	response readResponse: connection! !
!SptHTTPRequest categoriesFor: #readResponse!public! !

!SptHTTPRequest methodsFor!
removeAuthorizationHeader
	headers removeKey: 'Authorization' ifAbsent: []! !
!SptHTTPRequest categoriesFor: #removeAuthorizationHeader!public! !

!SptHTTPRequest methodsFor!
removeCookieHeader
	headers removeKey: 'Cookie' ifAbsent: []! !
!SptHTTPRequest categoriesFor: #removeCookieHeader!public! !

!SptHTTPRequest methodsFor!
requestURI
	^self useProxy ifTrue: [self urlString] ifFalse: [url absolutePath]! !
!SptHTTPRequest categoriesFor: #requestURI!public! !

!SptHTTPRequest methodsFor!
responseBody
	"Answer a the response entity <String>"

	^self lastResponse body! !
!SptHTTPRequest categoriesFor: #responseBody!public! !

!SptHTTPRequest methodsFor!
responseHeaders
	"Answer a table of response headers"

	^self lastResponse headers! !
!SptHTTPRequest categoriesFor: #responseHeaders!public! !

!SptHTTPRequest methodsFor!
responses
	"Answer a collection of <SptHTTPResponse>s"
	^responses! !
!SptHTTPRequest categoriesFor: #responses!public! !

!SptHTTPRequest methodsFor!
send
	"Send the request with no entity (typical for a GET Request).
	This method returns immediately.
	You can either:
		-test with #isReady (and when true access the #responseBody).
		-wait (block) on #waitOnReady or  #waitOnReadyCancelling (and then access #responseBody)"

	"Note: If you are debuging an exception that occurs in the deferred send, you can
	uncomment the 'self halt' to open a debugger on the problem"

	deferredSend := 
			[[self sendMessages] on: Error
				do: 
					[:e | 
					"self halt."

					e]] 
					deferredValue! !
!SptHTTPRequest categoriesFor: #send!public! !

!SptHTTPRequest methodsFor!
send: aString
	"Use #setEntityOn: "

	#deprecated.
	self setEntityOn: aString.
	self send! !
!SptHTTPRequest categoriesFor: #send:!public! !

!SptHTTPRequest methodsFor!
sendAndRead
	"Private ... send the message and read the response.
	If this is curtailed, close the socket. This is not strictly necessary as. the socket
		would be closed anyway, however the 'contents' of the socket (consider 
		peristent connections) may now
		be in an inconsistent state. Closing the socket ensures an error is signalled
		if we try to read/write from it again."

	
	[self sendMessage.
	self readResponse] 
			ifCurtailed: [connection notNil ifTrue: [connection closeSocket]]! !
!SptHTTPRequest categoriesFor: #sendAndRead!public! !

!SptHTTPRequest methodsFor!
sendEntityBufferSize
	^conf sendEntityBufferSize! !
!SptHTTPRequest categoriesFor: #sendEntityBufferSize!public! !

!SptHTTPRequest methodsFor!
sendHeader: anAssoc
	(self socketStream)
		nextPutAll: anAssoc key;
		nextPutAll: ': ';
		nextPutAll: anAssoc value displayString;
		crlf! !
!SptHTTPRequest categoriesFor: #sendHeader:!public! !

!SptHTTPRequest methodsFor!
sendMessage
	self connect.
	self sendMessageStart.
	self sendMessageHeaders.
	self hasEntity ifTrue: [self sendMessageBody].
	self socketStream flush! !
!SptHTTPRequest categoriesFor: #sendMessage!public! !

!SptHTTPRequest methodsFor!
sendMessageBody
	| sent total chunk |
	self makingProgress onSendingEntity.
	sent := 0.
	total := entity contentLength.
	[entity stream atEnd] whileFalse: 
			[self socketStream 
				nextPutAll: (chunk := entity stream nextAvailable: self sendEntityBufferSize).
			self makingProgress sent: (sent := sent + chunk size) of: total].
	self makingProgress onSentEntity! !
!SptHTTPRequest categoriesFor: #sendMessageBody!public! !

!SptHTTPRequest methodsFor!
sendMessageHeaders
	self makingProgress onSendingHeaders.
	self addRequiredHeaders.
	self putSortedHeadersOn: self socketStream.
	self socketStream crlf.
	self makingProgress onSentHeaders! !
!SptHTTPRequest categoriesFor: #sendMessageHeaders!public! !

!SptHTTPRequest methodsFor!
sendMessages
	"sent in the deferred process(thread)"

	| visited |
	visited := OrderedCollection new.
	
	[visited add: self urlString.
	[self sendAndRead] ensure: [self closeOrKeepAliveConnection].
	self prepareNextMessage: visited] 
			whileTrue.
	self makingProgress onCompleted! !
!SptHTTPRequest categoriesFor: #sendMessages!public! !

!SptHTTPRequest methodsFor!
sendMessageStart
	self putMessageStartOn: self socketStream! !
!SptHTTPRequest categoriesFor: #sendMessageStart!public! !

!SptHTTPRequest methodsFor!
setEntityOn: aString
	entity := SptHTTPEntity fromByteObject: aString! !
!SptHTTPRequest categoriesFor: #setEntityOn:!public! !

!SptHTTPRequest methodsFor!
setProgress: aSptHTTPProgress
	progress := aSptHTTPProgress.
	progress request: self! !
!SptHTTPRequest categoriesFor: #setProgress:!public! !

!SptHTTPRequest methodsFor!
setRequestHeader: aHeaderString bstrValue: aHeaderValue
	"MSXML IXMLHTTPRequest compatibility method"

	#deprecated.
	self addHeader: aHeaderString value: aHeaderValue! !
!SptHTTPRequest categoriesFor: #setRequestHeader:bstrValue:!public! !

!SptHTTPRequest methodsFor!
setTimeouts: t1 connectTimeout: t2 sendTimeout: t3 receiveTimeout: t4
	"MSXML IXMLHTTPRequest compatibility method"

	"On the receive timeout is used. See class comments."

	#deprecated.
	self timeout: t4! !
!SptHTTPRequest categoriesFor: #setTimeouts:connectTimeout:sendTimeout:receiveTimeout:!public! !

!SptHTTPRequest methodsFor!
setUrl: aSptHTTPUrl
	"aSptHTTPUrl isDifferentAuthority ifTrue: [self removeAuthorizationHeader]."

	url := aSptHTTPUrl! !
!SptHTTPRequest categoriesFor: #setUrl:!public! !

!SptHTTPRequest methodsFor!
socketStream
	^connection socketStream! !
!SptHTTPRequest categoriesFor: #socketStream!public! !

!SptHTTPRequest methodsFor!
sortedHeadersAndValuesDo: aTwoArgBlock
	| keys |
	keys := headers keys asSortedCollection: self class.	"collect: [:each | each asLowercase]"
	keys do: [:each | aTwoArgBlock value: each value: (headers at: each)]! !
!SptHTTPRequest categoriesFor: #sortedHeadersAndValuesDo:!public! !

!SptHTTPRequest methodsFor!
startTimeoutLoop
	"
	-Fork a second process that repeats until terminated. It sends the receiver the #checkTimeout message. 
	This method firstly checks whether the receiver is in a state that can timeout (See #checkTimeout comment) , 
		and if so closes the socket. (See #close comment)"

	timeoutLoop isNil ifFalse: [self errorInternalError].
	timeoutLoop := 
			[
			[(Delay forMilliseconds: self waitTimingMilliseconds) wait.
			connection notNil ifTrue: [connection checkTimeout ifTrue: [progress onTimeout]].
			true] 
					whileTrue] 
					forkAt: 6.
	timeoutLoop name: 'Timeout for: ' , self urlString! !
!SptHTTPRequest categoriesFor: #startTimeoutLoop!public! !

!SptHTTPRequest methodsFor!
state
	"Answer a <SptHTTPSessionState>"

	^state! !
!SptHTTPRequest categoriesFor: #state!public! !

!SptHTTPRequest methodsFor!
state: aSptHTTPSessionState
	state := aSptHTTPSessionState! !
!SptHTTPRequest categoriesFor: #state:!public! !

!SptHTTPRequest methodsFor!
status
	"Answer the status code <Integer> of the last response"

	^self lastResponse status! !
!SptHTTPRequest categoriesFor: #status!public! !

!SptHTTPRequest methodsFor!
statusText
	"Answer the Status text of the response"

	^self lastResponse statusText! !
!SptHTTPRequest categoriesFor: #statusText!public! !

!SptHTTPRequest methodsFor!
terminateTimeoutLoop
	timeoutLoop isNil ifTrue: [^nil].
	timeoutLoop terminate.
	timeoutLoop := nil! !
!SptHTTPRequest categoriesFor: #terminateTimeoutLoop!public! !

!SptHTTPRequest methodsFor!
timeout
	^state timeout! !
!SptHTTPRequest categoriesFor: #timeout!public! !

!SptHTTPRequest methodsFor!
timeout: millisecondsOrNil
	"Set the timeout value. 
	Note: The actual time before timing out will be somewhere between milliseconds and milliseconds * 2.
	nil disables the receiver's timeouts and relies on win socket timeouts"

	state timeout: millisecondsOrNil! !
!SptHTTPRequest categoriesFor: #timeout:!public! !

!SptHTTPRequest methodsFor!
timeoutLoop
	"Unit Test helper method"

	^timeoutLoop! !
!SptHTTPRequest categoriesFor: #timeoutLoop!public! !

!SptHTTPRequest methodsFor!
timeoutLoop: anObject
	"Unit Test helper method"

	timeoutLoop := anObject! !
!SptHTTPRequest categoriesFor: #timeoutLoop:!public! !

!SptHTTPRequest methodsFor!
url
	"Private - Answer the <SptHTTPUrl> url.
	If a redirect was followed, this will be the actual url of the resource."

	^url! !
!SptHTTPRequest categoriesFor: #url!public! !

!SptHTTPRequest methodsFor!
url: aString
	"Must be of the form 'http://host/resource'"

	Notification deprecated.
	self urlString: aString! !
!SptHTTPRequest categoriesFor: #url:!public! !

!SptHTTPRequest methodsFor!
urlString
	^url displayString! !
!SptHTTPRequest categoriesFor: #urlString!public! !

!SptHTTPRequest methodsFor!
urlString: aString
	self setUrl: (SptHTTPUrl fromString: aString previous: url)! !
!SptHTTPRequest categoriesFor: #urlString:!public! !

!SptHTTPRequest methodsFor!
useProxy
	^state useProxy! !
!SptHTTPRequest categoriesFor: #useProxy!public! !

!SptHTTPRequest methodsFor!
userId: aStringOrNil
	Notification deprecated.
	self halt.
	url userId: aStringOrNil! !
!SptHTTPRequest categoriesFor: #userId:!public! !

!SptHTTPRequest methodsFor!
username: aUsernameString password: aPasswordString
	(url isNil or: [url isNullUrl]) 
		ifTrue: [self error: 'Error: no url for the authentication, please set the url first'].
	state 
		username: aUsernameString
		password: aPasswordString
		for: self urlString! !
!SptHTTPRequest categoriesFor: #username:password:!public! !

!SptHTTPRequest methodsFor!
waitOnReady
	"Block the active process until the request has been processed. 
	-This will signal an error in the active process if one occurs in the background process.
	"

	#todo.	"Should timeout of 0 return immediately?"
	"Necessary if sent from the main process"
	Processor forkMainIfMain.
	^
	[(self timeout isNil or: [self timeout = 0]) 
		ifFalse: 
			["-Fork a second process that repeats until terminated. It sends the receiver the #checkTimeout message. 
				This method firstly checks whether the receiver is in a state that can timeout 
				(See #checkTimeout comment) , and if so closes the socket. (See #close comment)"

			self startTimeoutLoop].
	deferredSend value] 
			ensure: [self terminateTimeoutLoop]! !
!SptHTTPRequest categoriesFor: #waitOnReady!public! !

!SptHTTPRequest methodsFor!
waitOnReadyCancelling
	"Same as #waitOnReady except if the waiting process is terminated,
		cancel the connection (which will cause the deferredSends process to terminate)"

	[self waitOnReady] ifCurtailed: [self cancelConnection]! !
!SptHTTPRequest categoriesFor: #waitOnReadyCancelling!public! !

!SptHTTPRequest methodsFor!
waitOnReadyRetrying: aNumber
	"This will retry a request if the server closes the connection.
	It is *not* an implementation of 
		<http://www.w3.org/Protocols/rfc2616/rfc2616-sec8.html#sec8.2.4>
		8.2.4 Client Behavior if Server Prematurely Closes Connection 

		-It doesnt do a time back-off
		-It will retry even if a partial response has been read.

	See #prepareForRetry comment"

	| shouldRetry |
	self isIdempotent ifFalse: [self errorRetryNonIdempotentMethod].
	shouldRetry := false.
	[self waitOnReady] on: SocketClosed
		do: [:e | aNumber = 0 ifTrue: [e pass] ifFalse: [shouldRetry := true]].
	shouldRetry ifFalse: [^aNumber].
	"self reportPreRetry: aNumber."
	deferredSend hasValue ifFalse: [self errorInternalError].
	"This will check to see if we can use a 'Range' request"
	self prepareForRetry.
	"self reportPostRetry."
	self send.
	^self waitOnReadyRetrying: aNumber - 1! !
!SptHTTPRequest categoriesFor: #waitOnReadyRetrying:!public! !

!SptHTTPRequest methodsFor!
waitOnReadySpecRetrying: aNumber
	"This will retry a request if the server closes the connection before we receive any status from the server
	It is a loose implementation of 
		<http://www.w3.org/Protocols/rfc2616/rfc2616-sec8.html#sec8.2.4>
		8.2.4 Client Behavior if Server Prematurely Closes Connection 

		-It doesnt do a time back-off.

	Note: this method is more robust than #waitOnReadyRetrying: which attempts to retry requests that
		have been partially received (and also attempts to use a 'Range' Request"

	| shouldRetry |
	shouldRetry := false.
	[self waitOnReady] on: SocketClosed
		do: 
			[:e | 
			"Can only retry if we dont receive any status from the server"

			(aNumber = 0 or: [self lastResponse hasStatus]) 
				ifTrue: [e pass]
				ifFalse: [shouldRetry := true]].
	shouldRetry ifFalse: [^aNumber].
	deferredSend hasValue ifFalse: [self errorInternalError].
	self prepareForSpecRetry.
	"The spec suggests using a 'binary exponential backoff' algorithm, but a constant looks fine to me.
	Note: This delay should occur after sending the headers, but before sending any entity"
	[Delay forSeconds: 5] wait.
	self send.
	^self waitOnReadyRetrying: aNumber - 1! !
!SptHTTPRequest categoriesFor: #waitOnReadySpecRetrying:!public! !

!SptHTTPRequest methodsFor!
waitTimingMilliseconds
	^(connection notNil and: [connection isTimeoutWaiting]) 
		ifTrue: [self timeout]
		ifFalse: [3000]! !
!SptHTTPRequest categoriesFor: #waitTimingMilliseconds!public! !

!SptHTTPRequest categoriesFor: #addAuthorizationHeader!operations-sending!private! !

!SptHTTPRequest categoriesFor: #addCookieHeader!operations-sending!private! !

!SptHTTPRequest categoriesFor: #addHeader:value:!accessing-request!public! !

!SptHTTPRequest categoriesFor: #addIfAbsentHeader:value:!accessing-request!public! !

!SptHTTPRequest categoriesFor: #addRequiredHeaders!operations-sending!private! !

!SptHTTPRequest categoriesFor: #beVersion10!modes!public! !

!SptHTTPRequest categoriesFor: #bodyStream!accessing!public! !

!SptHTTPRequest categoriesFor: #cancelConnection!operations-closing!public! !

!SptHTTPRequest categoriesFor: #canRangeRetry!public!testing! !

!SptHTTPRequest categoriesFor: #close!operations-closing!public! !

!SptHTTPRequest categoriesFor: #closeOrKeepAliveConnection!operations-reading!private! !

!SptHTTPRequest categoriesFor: #conf!accessing-settings!public! !

!SptHTTPRequest categoriesFor: #conf:!accessing-settings!public! !

!SptHTTPRequest categoriesFor: #connect!operations-sending!private! !

!SptHTTPRequest categoriesFor: #connection!accessing!private! !

!SptHTTPRequest categoriesFor: #connection:!private!test accessing! !

!SptHTTPRequest categoriesFor: #cookieJar!accessing-settings!public! !

!SptHTTPRequest categoriesFor: #cookieJar:!accessing-settings!public! !

!SptHTTPRequest categoriesFor: #credentials:!accessing-settings!public! !

!SptHTTPRequest categoriesFor: #deferredSend:!private!test accessing! !

!SptHTTPRequest categoriesFor: #doAuthorizing:!operations-sending!public! !

!SptHTTPRequest categoriesFor: #entity!accessing!public! !

!SptHTTPRequest categoriesFor: #entity:!accessing-request!public! !

!SptHTTPRequest categoriesFor: #entityString:!accessing-request!public! !

!SptHTTPRequest categoriesFor: #errorAuthenticationFailed!exceptions!private! !

!SptHTTPRequest categoriesFor: #errorInternalError!exceptions!private! !

!SptHTTPRequest categoriesFor: #errorMaximumRedirections!exceptions!private! !

!SptHTTPRequest categoriesFor: #errorRedirectionLoop!exceptions!private! !

!SptHTTPRequest categoriesFor: #errorRetryNonIdempotentMethod!exceptions!private! !

!SptHTTPRequest categoriesFor: #hasEntity!private!testing! !

!SptHTTPRequest categoriesFor: #headerAt:!accessing!public! !

!SptHTTPRequest categoriesFor: #headerReportString!accessing!public! !

!SptHTTPRequest categoriesFor: #headers!accessing!private! !

!SptHTTPRequest categoriesFor: #host!accessing!public! !

!SptHTTPRequest categoriesFor: #httpVersionString!accessing!private! !

!SptHTTPRequest categoriesFor: #immediateHost!accessing!public! !

!SptHTTPRequest categoriesFor: #immediatePort!accessing!public! !

!SptHTTPRequest categoriesFor: #initializeFor:!initializing!private! !

!SptHTTPRequest categoriesFor: #isAuthenticate!public!testing! !

!SptHTTPRequest categoriesFor: #isAuthenticate:!accessing-settings!public! !

!SptHTTPRequest categoriesFor: #isConnectionClose!public!testing! !

!SptHTTPRequest categoriesFor: #isFollowRedirects!public!testing! !

!SptHTTPRequest categoriesFor: #isFollowRedirects:!accessing-settings!public! !

!SptHTTPRequest categoriesFor: #isIdempotent!public!testing! !

!SptHTTPRequest categoriesFor: #isRangeRequest!public!testing! !

!SptHTTPRequest categoriesFor: #isRangeRequest:!accessing-settings!public! !

!SptHTTPRequest categoriesFor: #isReady!process synchronisation!public!testing! !

!SptHTTPRequest categoriesFor: #isUseCookies!public!testing! !

!SptHTTPRequest categoriesFor: #isUseCookies:!accessing-settings!public! !

!SptHTTPRequest categoriesFor: #isVersion11!public!testing! !

!SptHTTPRequest categoriesFor: #isVersion11:!accessing-settings!public! !

!SptHTTPRequest categoriesFor: #lastResponse!accessing-response!public! !

!SptHTTPRequest categoriesFor: #makingProgress!accessing!public! !

!SptHTTPRequest categoriesFor: #maxRedirects!accessing!private! !

!SptHTTPRequest categoriesFor: #maxRedirects:!accessing-settings!public! !

!SptHTTPRequest categoriesFor: #method!accessing!private! !

!SptHTTPRequest categoriesFor: #method:!accessing-request!public! !

!SptHTTPRequest categoriesFor: #okBodyStream!accessing!private! !

!SptHTTPRequest categoriesFor: #okBodyStream:!accessing-request!public! !

!SptHTTPRequest categoriesFor: #open:bstrUrl:varAsync:bstrUser:bstrPassword:!accessing-msxml!public! !

!SptHTTPRequest categoriesFor: #open:to:!accessing-request!public! !

!SptHTTPRequest categoriesFor: #openGetTo:!accessing-request!public! !

!SptHTTPRequest categoriesFor: #openPostTo:!accessing-request!public! !

!SptHTTPRequest categoriesFor: #port!accessing!public! !

!SptHTTPRequest categoriesFor: #prepareForAuthorize!operations-resending!private! !

!SptHTTPRequest categoriesFor: #prepareForRedirect!operations-resending!private! !

!SptHTTPRequest categoriesFor: #prepareForRetry!operations-resending!private! !

!SptHTTPRequest categoriesFor: #prepareForSpecRetry!operations-resending!private! !

!SptHTTPRequest categoriesFor: #prepareNextMessage:!operations-resending!private! !

!SptHTTPRequest categoriesFor: #progress!accessing!public! !

!SptHTTPRequest categoriesFor: #progress:!accessing!private! !

!SptHTTPRequest categoriesFor: #proxySettings!accessing!private! !

!SptHTTPRequest categoriesFor: #proxySettings:!accessing-settings!public! !

!SptHTTPRequest categoriesFor: #putHeaderName:value:on:!operations-sending!private! !

!SptHTTPRequest categoriesFor: #putMessageStartOn:!operations-sending!private! !

!SptHTTPRequest categoriesFor: #putSortedHeadersOn:!operations-sending!private! !

!SptHTTPRequest categoriesFor: #readEntityBufferSize!accessing!public! !

!SptHTTPRequest categoriesFor: #readResponse!operations-reading!private! !

!SptHTTPRequest categoriesFor: #removeAuthorizationHeader!operations-sending!public! !

!SptHTTPRequest categoriesFor: #removeCookieHeader!operations-sending!private! !

!SptHTTPRequest categoriesFor: #requestURI!accessing!private! !

!SptHTTPRequest categoriesFor: #responseBody!accessing-response!public! !

!SptHTTPRequest categoriesFor: #responseHeaders!accessing-response!public! !

!SptHTTPRequest categoriesFor: #responses!accessing-response!public! !

!SptHTTPRequest categoriesFor: #send!operations-sending!public! !

!SptHTTPRequest categoriesFor: #send:!accessing-msxml!public! !

!SptHTTPRequest categoriesFor: #sendAndRead!operations-sending!private! !

!SptHTTPRequest categoriesFor: #sendEntityBufferSize!accessing!public! !

!SptHTTPRequest categoriesFor: #sendHeader:!operations-sending!private! !

!SptHTTPRequest categoriesFor: #sendMessage!operations-sending!private! !

!SptHTTPRequest categoriesFor: #sendMessageBody!operations-sending!private! !

!SptHTTPRequest categoriesFor: #sendMessageHeaders!operations-sending!private! !

!SptHTTPRequest categoriesFor: #sendMessages!operations-sending!public! !

!SptHTTPRequest categoriesFor: #sendMessageStart!operations-sending!private! !

!SptHTTPRequest categoriesFor: #setEntityOn:!accessing-request!public! !

!SptHTTPRequest categoriesFor: #setProgress:!accessing-request!public! !

!SptHTTPRequest categoriesFor: #setRequestHeader:bstrValue:!accessing-msxml!public! !

!SptHTTPRequest categoriesFor: #setTimeouts:connectTimeout:sendTimeout:receiveTimeout:!accessing-msxml!public! !

!SptHTTPRequest categoriesFor: #setUrl:!accessing-request!public! !

!SptHTTPRequest categoriesFor: #socketStream!accessing!private! !

!SptHTTPRequest categoriesFor: #sortedHeadersAndValuesDo:!operations-sending!private! !

!SptHTTPRequest categoriesFor: #startTimeoutLoop!private!process synchronisation! !

!SptHTTPRequest categoriesFor: #state!accessing!public! !

!SptHTTPRequest categoriesFor: #state:!accessing!private! !

!SptHTTPRequest categoriesFor: #status!accessing-response!public! !

!SptHTTPRequest categoriesFor: #statusText!accessing-response!public! !

!SptHTTPRequest categoriesFor: #terminateTimeoutLoop!private!process synchronisation! !

!SptHTTPRequest categoriesFor: #timeout!accessing!private! !

!SptHTTPRequest categoriesFor: #timeout:!accessing-settings!public! !

!SptHTTPRequest categoriesFor: #timeoutLoop!private!test accessing! !

!SptHTTPRequest categoriesFor: #timeoutLoop:!private!test accessing! !

!SptHTTPRequest categoriesFor: #url!accessing!private! !

!SptHTTPRequest categoriesFor: #url:!accessing!public! !

!SptHTTPRequest categoriesFor: #urlString!accessing!public! !

!SptHTTPRequest categoriesFor: #urlString:!accessing-request!public! !

!SptHTTPRequest categoriesFor: #useProxy!private!testing! !

!SptHTTPRequest categoriesFor: #userId:!public! !

!SptHTTPRequest categoriesFor: #username:password:!accessing-settings!public! !

!SptHTTPRequest categoriesFor: #waitOnReady!process synchronisation!public! !

!SptHTTPRequest categoriesFor: #waitOnReadyCancelling!process synchronisation!public! !

!SptHTTPRequest categoriesFor: #waitOnReadyRetrying:!process synchronisation!public! !

!SptHTTPRequest categoriesFor: #waitOnReadySpecRetrying:!process synchronisation!public! !

!SptHTTPRequest categoriesFor: #waitTimingMilliseconds!private!process synchronisation! !

!SptHTTPRequest class methodsFor!
defaultUserAgent
	"^'Test'"

	^'sw-dol/0.60'! !
!SptHTTPRequest class categoriesFor: #defaultUserAgent!public! !

!SptHTTPRequest class methodsFor!
example
	"
		Using the HTTPClient - general principles
	"

	" 1) Create the instance"

	| request |
	request := SptHTTPRequest new.

	" 2) Set the instance with the url and HTTP method"
	request openGetTo: 'http://www.dolphinharbor.org/'.

	"3) Set optional information (like headers/cookies/authorization/timeouts)"
	request addHeader: 'Accept' value: '*/*'.

	"4) Send the request (in a background process)"
	request send.

	"5) Wait (blocking) on the request to finish (or poll it)"
	request waitOnReady.

	"6) Access the response"
	request responseBody.	"Inspect It"
	request responseHeaders.	"Inspect It "
	request status.	"Inspect It "
	request statusText	"Inspect It "! !
!SptHTTPRequest class categoriesFor: #example!public! !

!SptHTTPRequest class methodsFor!
exampleAuthentication
	"
		The HTTPClient currently only supports basic authentication.

		If a request's state includes credentials for the request's url, an Authorization header
		will be automatically added to the request.
		 
	"

	| request |
	request := SptHTTPRequest new.
	request
		openGetTo: 'http://www.dolphinharbor.org/authtest/index.html';
		addHeader: 'Accept' value: '*/*'.
	"This is a helper method which associates the username/password with the request's url"
	request username: 'user1' password: 'pass1'.
	request
		send;
		waitOnReady.
	request lastResponse body.

	"Or ... Accessing the state directly"
	request := SptHTTPRequest new.
	request
		openGetTo: 'http://www.dolphinharbor.org/authtest/index.html';
		addHeader: 'Accept' value: '*/*'.
	request state 
		username: 'user1'
		password: 'pass1'
		for: 'http://www.dolphinharbor.org/'.
	request
		send;
		waitOnReady.
	request lastResponse body.

	"Incorrect, or missing credentials will cause a SptHTTPNotAuthorized to be signalled.
		-See #exampleAuthorizationDialog"
	request := SptHTTPRequest new.
	request
		openGetTo: 'http://www.dolphinharbor.org/authtest/index.html';
		addHeader: 'Accept' value: '*/*'.
	request username: 'user1' password: 'NotPass1'.
	request
		send;
		waitOnReady! !
!SptHTTPRequest class categoriesFor: #exampleAuthentication!public! !

!SptHTTPRequest class methodsFor!
exampleAuthenticationDialog
	"
		A Dialog is included that can be used to ask the user for Auth information.
		 
	"

	| request |
	request := SptHTTPRequest new.
	request
		openGetTo: 'http://www.dolphinharbor.org/authtest/index.html';
		addHeader: 'Accept' value: '*/*'.

	"use: user1/pass1"
	request doAuthorizing: 
			[request
				send;
				waitOnReady].
	request lastResponse body! !
!SptHTTPRequest class categoriesFor: #exampleAuthenticationDialog!public! !

!SptHTTPRequest class methodsFor!
exampleBestPractice
	"
		Using the HTTPClient - best practice
	"

	| request |
	request := SptHTTPRequest new.
	"setup"
	request
		openGetTo: 'http://www.dolphinharbor.org/';
		addHeader: 'Accept' value: '*/*';
		addHeader: 'Accept-Encoding' value: ''.
	"sending"
	request
		send;
		waitOnReadySpecRetrying: 2.
	"accessing"
	^(request lastResponse hasStatus and: [request lastResponse isSuccessful]) 
		ifTrue: [request lastResponse body]
		ifFalse: ['']! !
!SptHTTPRequest class categoriesFor: #exampleBestPractice!public! !

!SptHTTPRequest class methodsFor!
exampleCommonHeaders
	"
		The HTTPClient will automatically add some headers (if they have not already been added)
		including: Content-Length,Host, Content-Type, User-Agent , Authorization , Cookie 

		Some other headers that may be useful are:

		See <http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html> for more info
	"

	| request |
	(request := SptHTTPRequest new) openGetTo: 'http://www.dolphinharbor.org/ns3/test'.

	"Use the Accept header to limit what content-type(s) you will accept. 
		The value '*/*' indicates any response is acceptable."
	request addHeader: 'Accept' value: '*/*'.

	"Use the Accept-Encoding header to limit the content-codings you will accept. 
		To avoid receiving responses that are gzipped or compressed use the following"
	request addHeader: 'Accept-Encoding' value: ''.

	"To force caches to revalidate use both"
	request addHeader: 'Pragma' value: 'no-cache'.
	request addHeader: 'Cache-Control' value: 'no-cache'! !
!SptHTTPRequest class categoriesFor: #exampleCommonHeaders!public! !

!SptHTTPRequest class methodsFor!
exampleConfiguration
	"

		You can use a <SptHTTPConfiguration> instance to customize requests to:
			-Use your own connection classes (advanced)
			-Use your own progress class (more typical).
	"

	| conf request1 request2 |
	conf := SptHTTPConfiguration newDefault.
	conf progressClass: SptHTTPValueProgress.
	request1 := SptHTTPRequest newFor: conf.
	" ... use it etc"
	request2 := SptHTTPRequest newFor: conf
	" ... use it etc"! !
!SptHTTPRequest class categoriesFor: #exampleConfiguration!public! !

!SptHTTPRequest class methodsFor!
exampleCookies
	"
		A <SptHTTPSessionState> instance can be used to store information needed across multiple requests.
		A <SptHTTPSessionState> includes a cookieJar which can be used to store cookies.

		- Cookies are parsed from responses and stored in the CookieJar.
		- Before a request is sent, it checks the CookieJar for any cookies
			that should be sent with the request.

		If you dont re-use a <SptHTTPSessionState> instance, cookies will not be sent"

	| request1 request2 |
	request1 := SptHTTPRequest new.
	request1 openGetTo: 'http://www.amazon.com/'.
	request1 send.
	"Will block until complete"
	request1 waitOnReady.

	"Inspect the following, it should contain a Set-Cookie header"
	request1 lastResponse headers.

	"Inspect the following, and look in the cookieJar, there should be one cookie
		Note: (multiple cookies can be set from a single Set-Cookie header)"
	request1 state.

	"state <SptHTTPSessionState> contains information that can be used over multiple requests."
	request2 := SptHTTPRequest new.
	"re-use the <SptHTTPSessionState> instance"
	request2 state: request1 state.
	request2 openGetTo: 'http://www.amazon.com/'.
	request2 send.
	"Will block until complete"
	request2 waitOnReady.

	"Inspect the following, it should contain the cookie header we sent to the server"
	request2 headers! !
!SptHTTPRequest class categoriesFor: #exampleCookies!public! !

!SptHTTPRequest class methodsFor!
exampleDebuging
	"
		The HTTPClient provides a number of tools to aid debuging.

		1) Wire Logging. Everything sent/received on all sockets can be logged to the Transcript.
			To enable this see the SptHTTPConnection class methed #beLoggingWireToTranscript.

		2) SptHTTPTranscriptProgress is a progress class that prints all progress events
			to the transcript. 

		For debuging the SptHTTPRequest itself see the method #send
	"

	| request |
	SptHTTPConnection beLoggingWireToTranscript.	"Note: this is a global setting that remains until turned off"
	(request := SptHTTPRequest new)
		openGetTo: 'http://www.dolphinharbor.org/dh/index.html';
		addHeader: 'Accept' value: '*/*'.
	request send.
	request waitOnReady.
	SptHTTPConnection beNotLoggingWire.

	"
		Using SptHTTPTranscriptProgress 
	"
	(request := SptHTTPRequest new)
		openGetTo: 'http://www.dolphinharbor.org/dh/index.html';
		addHeader: 'Accept' value: '*'.
	request setProgress: SptHTTPTranscriptProgress new.
	request send.
	request waitOnReady! !
!SptHTTPRequest class categoriesFor: #exampleDebuging!public! !

!SptHTTPRequest class methodsFor!
exampleHeaders
	"
		The HTTPClient will automatically add required headers, but *only* if they have not
		been added by the user. This gives the user full control, but care must be taken for
		certain headers.

		Headers that are automatically added:
			Content-Length (if an entity is to be sent)
			Host 
			Content-Type (if an entity is to be sent, and it contains a Content-Type)
			User-Agent (defaults to the class constant #defaultUserAgent)
			Authorization (if credentials are supplied that match the url)
			Cookie (if a cookie-jar is supplied with cookies that match the url)
	"

	| request stream |
	(request := SptHTTPRequest new)
		openGetTo: 'http://www.dolphinharbor.org/ns3/test';
		addHeader: 'Accept' value: '*/*'.
	"Note: the above url is for a page that echoes the headers we send"
	request send.
	request waitOnReady.	"Will block until response received"
	stream := request responseBody readStream.
	stream upToAll: 'HTTP_USER_AGENT'.
	stream next: 40.	"Should answer the default #defaultUserAgent"

	"
		This time manually add the User-Agent header		
	"
	(request := SptHTTPRequest new)
		openGetTo: 'http://www.dolphinharbor.org/ns3/test';
		addHeader: 'Accept' value: '*/*';
		addHeader: 'User-Agent' value: 'A test Agent'.
	request send.
	request waitOnReady.	"Will block until response received"
	stream := request responseBody readStream.
	stream upToAll: 'HTTP_USER_AGENT'.
	stream next: 40! !
!SptHTTPRequest class categoriesFor: #exampleHeaders!public! !

!SptHTTPRequest class methodsFor!
exampleHeadRequest
	"
		'HEAD' requests have no body
	"

	| request |
	request := SptHTTPRequest new.
	request
		open: 'HEAD' to: 'http://www.dolphinharbor.org/';
		addHeader: 'Accept' value: '*/*';
		isFollowRedirects: false.
	request
		send;
		waitOnReady.
	"Inspect It"
	request lastResponse! !
!SptHTTPRequest class categoriesFor: #exampleHeadRequest!public! !

!SptHTTPRequest class methodsFor!
examplePersistentConnections
	"
		The HTTPClient supports HTTP 1.1's persistent connections.

		To disable this for a request, evaluate:
			request isVersion11: false

		Connections are only reused within 5 seconds (see SptHTTPConnection(class)>>staleMilliseconds.
			This takes advantage of being able to send a series of requests, and minimizes the
			probability that the server will kill the connection 
	
	"

	"Enable wire logging in order to see the connection being reused"

	| request |
	SptHTTPConnection beLoggingWireToTranscript.
	2 timesRepeat: 
			[(request := SptHTTPRequest new)
				openGetTo: 'http://www.dolphinharbor.org/dh/index.html';
				addHeader: 'Accept' value: '*/*'.
			request send.
			request waitOnReady].

	"On the Transcript, you should see the same Socket (ie '  a Socket(xyz) '  being used for both requests.
	(Note: if this is not the case, ensure that the server did not include a Connection: close header)"
	SptHTTPConnection beNotLoggingWire! !
!SptHTTPRequest class categoriesFor: #examplePersistentConnections!public! !

!SptHTTPRequest class methodsFor!
exampleProcessSync
	"
		The HTTPClient sends the request and reads responses in a background process.

		There are various methods that you can use to block 
			another process until the request completes (or times out)
	
	"

	| request |
	(request := SptHTTPRequest new)
		openGetTo: 'http://www.chartexplorer.com/dh/projects/spray/docs/google/ssGoogleResults.jpg';
		addHeader: 'Accept' value: '*/*'.

	"Send it"
	request send.	"returns immedaitely"

	"Then use either:"
	request isReady.	"returns immedaitely"

	"Or ... block"
	request waitOnReady.

	"Or ... block, if the blocked process is curtailed (ie terminated) ensure the request is closed"
	request waitOnReadyCancelling.

	"Or ... block, retrying the request if the server closes the connection
		before any response is received"
	request waitOnReadySpecRetrying: 2.

	"Or ... block, retrying the request if the server closes the connection
		If a partial response has been read, this method will attempt
		a partial range request"
	request waitOnReadyRetrying: 2! !
!SptHTTPRequest class categoriesFor: #exampleProcessSync!public! !

!SptHTTPRequest class methodsFor!
exampleProgress
	"
		The HTTPClient will send progress messages to a <SptHTTPProgress> instance.

		The default progress class has empty stubs for these messages. Create your own
			subclass and override these methods, for customized progress.

		*Important* The progress messages are sent from the background process.
	"

	| request progress presenter1 presenter2 transcriptProgress |
	progress := SptHTTPValueProgress new.
	presenter1 := TextPresenter showOn: progress stateValue.
	presenter2 := NumberPresenter showOn: progress percentageValue.
	(request := SptHTTPRequest new)
		openGetTo: 'http://www.chartexplorer.com/dh/projects/spray/docs/google/ssGoogleResults.jpg';
		addHeader: 'Accept' value: '*/*';
		setProgress: progress.
	request
		send;
		waitOnReady.

	"
		For debuging purposes, the SptHTTPTranscriptProgress can be chained
		to a second progress.

		(Note: the following example needs to be evaluated with the presenters still open
			from the above example)

	"
	(transcriptProgress := SptHTTPTranscriptProgress new) nextProgress: progress.
	(request := SptHTTPRequest new)
		openGetTo: 'http://www.chartexplorer.com/dh/projects/spray/docs/google/ssGoogleResults.jpg';
		addHeader: 'Accept' value: '*';
		setProgress: transcriptProgress.
	request
		send;
		waitOnReady.

	"clean up"
	presenter1 topShell exit.
	presenter2 topShell exit! !
!SptHTTPRequest class categoriesFor: #exampleProgress!public! !

!SptHTTPRequest class methodsFor!
exampleProgressControl
	"
		A progress instance <SptHTTPProgress> can also  be used to control a request:		

		Please review  #exampleProgress before this example.

		1) It provides access to the request, and you can send the request the #cancelConnection
		message at any time (and from any process) to shutdown the request.

		2) (Advanced) The progress messages are sent within the background
		process. Therefore, with a customized progress class, you can alter
		how a request is processed

	"

	| progress request |
	progress := SptHTTPTranscriptProgress new.
	(request := SptHTTPRequest new)
		openGetTo: 'http://www.chartexplorer.com/dh/projects/spray/docs/google/ssGoogleResults.jpg';
		addHeader: 'Accept' value: '*/*'.
	request setProgress: progress.
	request send.

	"Instead of blocking on the request, wait a couple of seconds and evaluate:"
	progress request cancelConnection.

	"A copy of the exception will be signalled in any waiting process.
		for example:"
	request waitOnReady! !
!SptHTTPRequest class categoriesFor: #exampleProgressControl!public! !

!SptHTTPRequest class methodsFor!
exampleProxy
	"
		The HTTPClient can be configured to use a proxy. 

		A Dialog is provided to get this information from the user

		The SptHTTPProxySettings instance is set into the request, but
			is stored in the request's 'state' <SptHTTPSessionState> instance variable.
			This state can be used across multiple requests. (see #exampleState)
	"

	| request proxySettings |
	proxySettings := SptProxySettingDialog showModal.
	SptHTTPConnection beLoggingWireToTranscript.	"Note: this is a global setting that remains until turned off"
	(request := SptHTTPRequest new)
		openGetTo: 'http://www.dolphinharbor.org/dh/index.html';
		addHeader: 'Accept' value: '*/*';
		proxySettings: proxySettings.
	request send.
	request waitOnReady.

	"Clean up"
	SptHTTPConnection beNotLoggingWire! !
!SptHTTPRequest class categoriesFor: #exampleProxy!public! !

!SptHTTPRequest class methodsFor!
exampleRedirection
	"
		The HTTPClient can automatically follow redirection responses.

		Following redirects can be fully disabled using the #isFollowRedirects setting.

		If this is enabled (the default):
			1/ It will check for redirection loops and signal an error if a url is visited more than twice.
			2/ The #maxRedirects: setting puts a limit on how many redirections will be followed.
				The default is SptHTTPSessionState(class)>>defaultMaxRedirects (5)
	"

	| request |
	(request := SptHTTPRequest new)
		openGetTo: 'http://www.dolphinharbor.org/';
		addHeader: 'Accept' value: '*'.
	request send.
	request waitOnReady.	"Will block until response received"
	request status.	"Inspect It ... should be a 200"
	"Inspect the last response received"
	request lastResponse.
	"Inspect all responses received ... should have two response, the first being the redirection."
	request responses.

	"
		To disable redirection:
	"
	(request := SptHTTPRequest new)
		openGetTo: 'http://www.dolphinharbor.org/';
		addHeader: 'Accept' value: '*/*';
		isFollowRedirects: false.
	request send.
	request waitOnReady.	"Will block until response received"
	request status.	"Inspect It ... should be a 302"
	"Inspect the last response received"
	request lastResponse.
	"Inspect all responses received ... should ony have one response"
	request responses! !
!SptHTTPRequest class categoriesFor: #exampleRedirection!public! !

!SptHTTPRequest class methodsFor!
exampleSSL
	#todo! !
!SptHTTPRequest class categoriesFor: #exampleSSL!public! !

!SptHTTPRequest class methodsFor!
exampleState
	"
		A <SptHTTPSessionState> instance can be used to store information needed across multiple requests.
		including
			-Cookies
			-Timeouts
			-Authentication information
			-Proxy settings
	"

	| state request1 request2 |
	state := SptHTTPSessionState new.
	state timeout: nil.	"nil disables timeouts"
	state maxRedirects: 6.	"maximum number of redirects that will be automatically followed"
	state proxySettings: (SptHTTPProxySettings useHost: 'localhost' port: 8000).
	"Note: the following will cause an Authorization header only for urls in the http://www.foo.org/ namespace"
	state 
		username: 'steve'
		password: 'steve'
		for: 'http://www.foo.org/'.


	"This state can then be reused across requests"
	request1 := SptHTTPRequest new openGetTo: 'http://www.foo.org/1'.
	request1 state: state.
	"Do stuff"
	request2 := SptHTTPRequest new openGetTo: 'http://www.foo.org/2'.
	request2 state: state! !
!SptHTTPRequest class categoriesFor: #exampleState!public! !

!SptHTTPRequest class methodsFor!
exampleStreaming
	"
		The HTTPClient can be configured to either
			1/ Stream an entity to a server as part of request (typically a POST or PUT)
			2/ Stream an entity from a server (typically a GET)

		When streaming from a server, only a successful response (200) will use the stream
	"

	| request myStream |
	(request := SptHTTPRequest new)
		openGetTo: 'http://www.dolphinharbor.org/';
		addHeader: 'Accept' value: '*/*'.

	"Create the stream and set it into the request"
	myStream := FileStream 
				write: (FileLocator default localFileSpecFor: 'spt_stream_test.html')
				text: false.
	request okBodyStream: myStream.
	
	[request
		send;
		waitOnReady] ensure: [myStream close].

	"Notice that the first response received (a 302 redirection) was not streamed to 'myStream'"
	request responses! !
!SptHTTPRequest class categoriesFor: #exampleStreaming!public! !

!SptHTTPRequest class methodsFor!
exampleTimeouts
	"
		The HTTPClient will process a request in a background process.

		The #waitOnReady message will block the active process until the background
			process completes. A timeout can be used to set a limit on how long the
			active process will block. (without any progress being made in the request)

		The #waitOnReadyCancelling message behaves the same as #waitOnReady except
			if the waiting process is terminated, the request will be cancelled.

		Timeouts are tied into the HTTPClients progress messages. Everytime a progress
			message is sent, the timeout is reset.

		A timeout value of 0 or nil will disable timeouts

		
	"

	#todo! !
!SptHTTPRequest class categoriesFor: #exampleTimeouts!public! !

!SptHTTPRequest class methodsFor!
generalHeaders
	^#('cache-control' 'connection' 'date' 'pragma' 'transfer-encoding' 'upgrade' 'via')! !
!SptHTTPRequest class categoriesFor: #generalHeaders!public! !

!SptHTTPRequest class methodsFor!
headerRankOf: aString
	| aLowercaseString |
	aLowercaseString := aString asLowercase.
	(self generalHeaders includes: aLowercaseString) ifTrue: [^1].
	(self requestHeaders includes: aLowercaseString) ifTrue: [^2].
	^3! !
!SptHTTPRequest class categoriesFor: #headerRankOf:!public! !

!SptHTTPRequest class methodsFor!
icon
	^Icon fromId: 179 in: ShellLibrary default
! !
!SptHTTPRequest class categoriesFor: #icon!public! !

!SptHTTPRequest class methodsFor!
initialize
	"
	self initialize
	"

	IsVersion11Mask := 1.
	IsFollowRedirectsMask := 2.
	IsAuthenticateMask := 4.
	IsUseCookiesMask := 8.
	IsRangeRequestMask := 16! !
!SptHTTPRequest class categoriesFor: #initialize!public! !

!SptHTTPRequest class methodsFor!
logDebug: aString
	Transcript
		nextPutAll: 'SptHTTPRequest warning: ' , aString;
		cr! !
!SptHTTPRequest class categoriesFor: #logDebug:!public! !

!SptHTTPRequest class methodsFor!
new
	^self newFor: SptHTTPConfiguration newDefault! !
!SptHTTPRequest class categoriesFor: #new!public! !

!SptHTTPRequest class methodsFor!
newFor: aConfiguration
	^super new initializeFor: aConfiguration! !
!SptHTTPRequest class categoriesFor: #newFor:!public! !

!SptHTTPRequest class methodsFor!
requestHeaders
	^#('accept' 'accept-charset' 'accept-encoding' 'accept-language' 'authorization' 'from' 'host' 'if-modified-since' 'if-match' 'if-none-match' 'if-range' 'if-unmodified-since' 'max-forwards' 'proxy-authorization' 'range' 'referer' 'user-agent')! !
!SptHTTPRequest class categoriesFor: #requestHeaders!public! !

!SptHTTPRequest class methodsFor!
sendEntityBufferSize
	Notification deprecated.
	^1024! !
!SptHTTPRequest class categoriesFor: #sendEntityBufferSize!public! !

!SptHTTPRequest class methodsFor!
value: header1 value: header2
	"Private - The receiver acts as the default sort block for HTTP Headers"

	| rank1 rank2 |
	(rank1 := self headerRankOf: header1) < (rank2 := self headerRankOf: header2) 
		ifTrue: [^true].
	rank1 = rank2 ifTrue: [^header1 <= header2].
	^false! !
!SptHTTPRequest class categoriesFor: #value:value:!public! !

!SptHTTPRequest class categoriesFor: #defaultUserAgent!constants!public! !

!SptHTTPRequest class categoriesFor: #example!must strip!public!spray examples! !

!SptHTTPRequest class categoriesFor: #exampleAuthentication!must strip!public!spray examples! !

!SptHTTPRequest class categoriesFor: #exampleAuthenticationDialog!must strip!public!spray examples! !

!SptHTTPRequest class categoriesFor: #exampleBestPractice!must strip!public!spray examples! !

!SptHTTPRequest class categoriesFor: #exampleCommonHeaders!must strip!public!spray examples! !

!SptHTTPRequest class categoriesFor: #exampleConfiguration!must strip!public!spray examples! !

!SptHTTPRequest class categoriesFor: #exampleCookies!must strip!public!spray examples! !

!SptHTTPRequest class categoriesFor: #exampleDebuging!must strip!public!spray examples! !

!SptHTTPRequest class categoriesFor: #exampleHeaders!must strip!public!spray examples! !

!SptHTTPRequest class categoriesFor: #exampleHeadRequest!must strip!public!spray examples! !

!SptHTTPRequest class categoriesFor: #examplePersistentConnections!must strip!public!spray examples! !

!SptHTTPRequest class categoriesFor: #exampleProcessSync!must strip!public!spray examples! !

!SptHTTPRequest class categoriesFor: #exampleProgress!must strip!public!spray examples! !

!SptHTTPRequest class categoriesFor: #exampleProgressControl!must strip!public!spray examples! !

!SptHTTPRequest class categoriesFor: #exampleProxy!must strip!public!spray examples! !

!SptHTTPRequest class categoriesFor: #exampleRedirection!must strip!public!spray examples! !

!SptHTTPRequest class categoriesFor: #exampleSSL!must strip!public!spray examples! !

!SptHTTPRequest class categoriesFor: #exampleState!must strip!public!spray examples! !

!SptHTTPRequest class categoriesFor: #exampleStreaming!must strip!public!spray examples! !

!SptHTTPRequest class categoriesFor: #exampleTimeouts!must strip!public!spray examples! !

!SptHTTPRequest class categoriesFor: #generalHeaders!constants!private! !

!SptHTTPRequest class categoriesFor: #headerRankOf:!helpers!private! !

!SptHTTPRequest class categoriesFor: #icon!constants!public! !

!SptHTTPRequest class categoriesFor: #initialize!initializing!public! !

!SptHTTPRequest class categoriesFor: #logDebug:!helpers!public! !

!SptHTTPRequest class categoriesFor: #new!instance creation!public! !

!SptHTTPRequest class categoriesFor: #newFor:!instance creation!public! !

!SptHTTPRequest class categoriesFor: #requestHeaders!constants!private! !

!SptHTTPRequest class categoriesFor: #sendEntityBufferSize!constants!public! !

!SptHTTPRequest class categoriesFor: #value:value:!helpers!public! !

SptHTTPResponse guid: (GUID fromString: '{396290D6-6D98-45D6-851D-6171AB65FF41}')!

SptHTTPResponse guid: (GUID fromString: '{396290D6-6D98-45D6-851D-6171AB65FF41}')!
SptHTTPResponse comment: 'I am an HTTP Response message.

I can read responses that either;
  1/ Have a content-Length
  2/ Use chunked transer encoding
  3/ Have a Content-Range
  Or (if HTTP 1.0)  I will read the socket until it is closed by the server

Notes:
 - I will lazily initialize bodyStream to be a <WriteStream> on a ByteArray, however when I read a 200 response, I will ask my <SptHTTPRequest> request for its okBodyStream and if not nil, I will stream to it.

 - If 
        1/ I receive a ''Content-Range'' response (typically in response to a request with a ''Range'' header) and If
        2/ My Request answers true to isRangeRequest
   Then I will set the position of the bodyStream to the start of the Content-Range



Instance Variables:
	statusLine	<String>
	headers		<PluggableLookupTable> (case-insensitive)
	cookies		<OrderedCollection> of <SptHTTPCookie>s
	bodyStream	<WriteStream>
	request		<SptHTTPRequest>

'!

SptHTTPResponse comment:
'I am an HTTP Response message.

I can read responses that either;
  1/ Have a content-Length
  2/ Use chunked transer encoding
  3/ Have a Content-Range
  Or (if HTTP 1.0)  I will read the socket until it is closed by the server

Notes:
 - I will lazily initialize bodyStream to be a <WriteStream> on a ByteArray, however when I read a 200 response, I will ask my <SptHTTPRequest> request for its okBodyStream and if not nil, I will stream to it.

 - If 
        1/ I receive a ''Content-Range'' response (typically in response to a request with a ''Range'' header) and If
        2/ My Request answers true to isRangeRequest
   Then I will set the position of the bodyStream to the start of the Content-Range



Instance Variables:
	statusLine	<String>
	headers		<PluggableLookupTable> (case-insensitive)
	cookies		<OrderedCollection> of <SptHTTPCookie>s
	bodyStream	<WriteStream>
	request		<SptHTTPRequest>

'!
!SptHTTPResponse categoriesForClass!Kernel-Objects! !
!SptHTTPResponse methodsFor!
basicChallenge
	| header challenges |
	header := headers at: 'WWW-Authenticate' ifAbsent: [^nil].
	challenges := SptHTTPChallenge readAllFrom: header readStream.
	^challenges detect: [:each | each isBasic] ifNone: []! !
!SptHTTPResponse categoriesFor: #basicChallenge!public! !

!SptHTTPResponse methodsFor!
body
	"Answer the body of the response as a <String>"

	^bodyStream contents asString! !
!SptHTTPResponse categoriesFor: #body!public! !

!SptHTTPResponse methodsFor!
bodyBytes
	"Answer the body of the response as a <ByteArray>"

	^bodyStream contents! !
!SptHTTPResponse categoriesFor: #bodyBytes!public! !

!SptHTTPResponse methodsFor!
bodyStream
	^bodyStream! !
!SptHTTPResponse categoriesFor: #bodyStream!public! !

!SptHTTPResponse methodsFor!
bodyStreamSize
	^bodyStream size! !
!SptHTTPResponse categoriesFor: #bodyStreamSize!public! !

!SptHTTPResponse methodsFor!
canRangeRetry
	"Answer whether we can retry the request, only asking for the range of bytes we dont have"

	#todo.	"handle ChunkedTransferEncoding responses?"
	^self hasStatus and: 
			[self isSuccessful and: 
					[self isAcceptRangesBytes 
						and: [self isChunkedTransferEncoding not and: [self hasContentLength]]]]! !
!SptHTTPResponse categoriesFor: #canRangeRetry!public! !

!SptHTTPResponse methodsFor!
chunkSizeFrom: stream
	| chunkString |
	chunkString := (stream upToCRLF readStream upTo: $;) asUppercase.
	"Transcript
		nextPutAll: chunkString;
		cr."
	^Integer readFrom: chunkString readStream radix: 16! !
!SptHTTPResponse categoriesFor: #chunkSizeFrom:!public! !

!SptHTTPResponse methodsFor!
contentLength
	^(headers at: 'Content-Length') asNumber! !
!SptHTTPResponse categoriesFor: #contentLength!public! !

!SptHTTPResponse methodsFor!
contentRangeInterval
	| header stream rangeStart rangeEnd instanceLength |
	header := (self headerAt: 'Content-Range') trimBlanks.
	stream := header readStream.
	(stream upTo: $ ) trimBlanks = 'bytes' 
		ifFalse: [self error: 'Unexpected Content-Range header: ' , header displayString].
	rangeStart := (stream upTo: $-) trimBlanks.
	rangeEnd := (stream upTo: $/) trimBlanks.
	instanceLength := stream upToEnd trimBlanks.
	"Ignore the instanceLength ... we only need the range"
	^rangeStart asNumber to: rangeEnd asNumber! !
!SptHTTPResponse categoriesFor: #contentRangeInterval!public! !

!SptHTTPResponse methodsFor!
contentType
	^headers at: 'Content-Type' ifAbsent: ['*']! !
!SptHTTPResponse categoriesFor: #contentType!public! !

!SptHTTPResponse methodsFor!
contentTypeOrNil
	^headers at: 'Content-Type' ifAbsent: []! !
!SptHTTPResponse categoriesFor: #contentTypeOrNil!public! !

!SptHTTPResponse methodsFor!
defaultIsConnectionClose
	^[self isVersion11 not] on: Error do: [:e | true]! !
!SptHTTPResponse categoriesFor: #defaultIsConnectionClose!public! !

!SptHTTPResponse methodsFor!
hasContentLength
	^headers includesKey: 'Content-Length'! !
!SptHTTPResponse categoriesFor: #hasContentLength!public! !

!SptHTTPResponse methodsFor!
hasContentRange
	^headers includesKey: 'Content-Range'! !
!SptHTTPResponse categoriesFor: #hasContentRange!public! !

!SptHTTPResponse methodsFor!
hasRange
	Notification deprecated.
	^headers includesKey: 'Range'! !
!SptHTTPResponse categoriesFor: #hasRange!public! !

!SptHTTPResponse methodsFor!
hasStatus
	^statusLine notNil and: [statusLine trimBlanks notEmpty]! !
!SptHTTPResponse categoriesFor: #hasStatus!public! !

!SptHTTPResponse methodsFor!
headerAt: aString
	^headers at: aString! !
!SptHTTPResponse categoriesFor: #headerAt:!public! !

!SptHTTPResponse methodsFor!
headerAt: aString ifAbsent: operation
	^headers at: aString ifAbsent: operation! !
!SptHTTPResponse categoriesFor: #headerAt:ifAbsent:!public! !

!SptHTTPResponse methodsFor!
headers
	"Answer a table of response headers"

	^headers! !
!SptHTTPResponse categoriesFor: #headers!public! !

!SptHTTPResponse methodsFor!
httpException
	"Answer an exception instance that describes the error"

	"See SptHTTPStatus>>httpException"

	^self httpStatus httpException! !
!SptHTTPResponse categoriesFor: #httpException!public! !

!SptHTTPResponse methodsFor!
httpStatus
	^SptHTTPStatus fromString: statusLine! !
!SptHTTPResponse categoriesFor: #httpStatus!public! !

!SptHTTPResponse methodsFor!
initialize
	super initialize.
	headers := PluggableLookupTable new searchPolicy: SearchPolicy caseInsensitive.
	bodyStream := ByteArray writeStream! !
!SptHTTPResponse categoriesFor: #initialize!public! !

!SptHTTPResponse methodsFor!
isAcceptRangesBytes
	^(self headerAt: 'Accept-Ranges' ifAbsent: [^false]) trimBlanks = 'bytes'! !
!SptHTTPResponse categoriesFor: #isAcceptRangesBytes!public! !

!SptHTTPResponse methodsFor!
isChunkedTransferEncoding
	^(headers at: 'transfer-encoding' ifAbsent: [^false]) = 'chunked'! !
!SptHTTPResponse categoriesFor: #isChunkedTransferEncoding!public! !

!SptHTTPResponse methodsFor!
isClientOrServerError
	^self httpStatus isClientOrServerError! !
!SptHTTPResponse categoriesFor: #isClientOrServerError!public! !

!SptHTTPResponse methodsFor!
isConnectionClose
	^(headers at: 'Connection' ifAbsent: [^self defaultIsConnectionClose]) asLowercase 
		= 'close'! !
!SptHTTPResponse categoriesFor: #isConnectionClose!public! !

!SptHTTPResponse methodsFor!
isHTMLContentType
	^(self headerAt: 'Content-Type' ifAbsent: [^false]) beginsWith: 'text/html'! !
!SptHTTPResponse categoriesFor: #isHTMLContentType!public! !

!SptHTTPResponse methodsFor!
isImageContentType
	^(self headerAt: 'Content-Type' ifAbsent: [^false]) beginsWith: 'image/'! !
!SptHTTPResponse categoriesFor: #isImageContentType!public! !

!SptHTTPResponse methodsFor!
isInformational
	^self httpStatus isInformational! !
!SptHTTPResponse categoriesFor: #isInformational!public! !

!SptHTTPResponse methodsFor!
isRedirect
	^self status >= 300 and: [self status < 400 and: [headers includesKey: 'Location']]! !
!SptHTTPResponse categoriesFor: #isRedirect!public! !

!SptHTTPResponse methodsFor!
isSuccessful
	^self httpStatus isSuccessful! !
!SptHTTPResponse categoriesFor: #isSuccessful!public! !

!SptHTTPResponse methodsFor!
isUnauthorized
	^self status = 401! !
!SptHTTPResponse categoriesFor: #isUnauthorized!public! !

!SptHTTPResponse methodsFor!
isVersion11
	^self httpStatus isVersion11! !
!SptHTTPResponse categoriesFor: #isVersion11!public! !

!SptHTTPResponse methodsFor!
location
	^headers at: 'Location'! !
!SptHTTPResponse categoriesFor: #location!public! !

!SptHTTPResponse methodsFor!
makingProgress
	"Answer the request's <SptHTTPProgress> progress.

	Inform the <SptHTTPRequest> request that we are 'making progress' ...
		(ie we have either read or written something to the socket.

	Note: DeafObject is used for UnitTesting purposes "

	^request isNil ifTrue: [DeafObject current] ifFalse: [request makingProgress]! !
!SptHTTPResponse categoriesFor: #makingProgress!public! !

!SptHTTPResponse methodsFor!
onReadHeaders
	Notification deprecated! !
!SptHTTPResponse categoriesFor: #onReadHeaders!public! !

!SptHTTPResponse methodsFor!
parseCookie: aString
	"Note: aString may contain multiple cookies separated by a $,"

	| allCookies |
	(request isNil or: [request isUseCookies not]) ifTrue: [^nil].
	"Note: an error parsing any of the cookies, means we reject all cookies"
	allCookies := [SptHTTPCookie allFromSetCookieString: aString url: request url] on: Error
				do: 
					[:e | 
					SptHTTPRequest logDebug: 'Cookie rejected: ' , e description.
					nil].
	allCookies notNil ifTrue: [allCookies do: [:cookie | request state addCookie: cookie]]! !
!SptHTTPResponse categoriesFor: #parseCookie:!public! !

!SptHTTPResponse methodsFor!
parseHeaderLine: aString
	| stream key value |
	stream := aString readStream.
	key := stream upTo: $:.
	value := stream upToEnd.
	"cookies are a special-case ... we need to parse them to make sure they are valid
	before blindly returning them in a new request"
	key asLowercase = 'set-cookie' ifTrue: [self parseCookie: value].
	(headers includesKey: key) ifTrue: [value := (headers at: key) , ',' , value].
	headers at: key put: value trimBlanks! !
!SptHTTPResponse categoriesFor: #parseHeaderLine:!public! !

!SptHTTPResponse methodsFor!
progress
	"Note: DeafObject is used for UnitTesting purposes "

	^request isNil ifTrue: [DeafObject current] ifFalse: [request progress]! !
!SptHTTPResponse categoriesFor: #progress!public! !

!SptHTTPResponse methodsFor!
putHeaderReportOn: stream
	stream
		nextPutAll: '===In';
		cr;
		display: statusLine;
		cr.
	headers keysAndValuesDo: 
			[:k :v | 
			stream
				display: k;
				nextPut: $:;
				display: v;
				cr]! !
!SptHTTPResponse categoriesFor: #putHeaderReportOn:!public! !

!SptHTTPResponse methodsFor!
rangeInterval
	| header stream rangeStart rangeEnd cl |
	cl := self contentLength.
	header := self headerAt: 'Range'.
	"We can only handle a single range"
	(header includes: $,) 
		ifTrue: [self error: 'Unexpected range header: ' , header displayString].
	stream := header readStream.
	(stream upTo: $=) trimBlanks = 'bytes' 
		ifFalse: [self error: 'Unexpected range header: ' , header displayString].
	rangeStart := (stream upTo: $-) trimBlanks.
	rangeEnd := stream upToEnd trimBlanks.
	"The final 500 bytes (byte offsets 9500-9999, inclusive): bytes=-500"
	rangeStart isEmpty ifTrue: [^cl - rangeEnd asNumber to: cl - 1].
	"The final 500 bytes ... Or bytes=9500- "
	rangeEnd isEmpty ifTrue: [^rangeStart asNumber to: cl - 1].
	^rangeStart asNumber to: rangeEnd asNumber! !
!SptHTTPResponse categoriesFor: #rangeInterval!public! !

!SptHTTPResponse methodsFor!
readBodyToEnd: aConnection
	"Read the socket until it is closed (ie HTTP1.0 semantics.
	Note: read readEntityChunkSize bytes at a time so that we can update any progress/status objects."

	| inStream read |
	self makingProgress onReadingBody.
	read := 0.
	inStream := aConnection socketStream.
	
	[inStream doBytes: 
			[:each | 
			bodyStream nextPut: each.
			read := read + 1.
			read % self readEntityBufferSize = 0 ifTrue: [self makingProgress read: read of: nil]]] 
			on: SocketClosed , ReadStream endOfStreamSignal
			do: [:e | ].
	self makingProgress onReadBody! !
!SptHTTPResponse categoriesFor: #readBodyToEnd:!public! !

!SptHTTPResponse methodsFor!
readChunkedEncodedBody: aConnection
	"The response is using chunked encoding
		... read the chunks"

	| chunkSize stream read |
	self makingProgress onReadingBody.
	stream := aConnection socketStream.
	read := 0.
	
	[chunkSize := self chunkSizeFrom: stream.
	chunkSize > 0] whileTrue: 
				[| crlf |
				bodyStream nextPutAll: (stream nextBytes: chunkSize).
				crlf := stream next: 2.
				self assert: [crlf = String lineDelimiter].
				self makingProgress read: (read := read + chunkSize) of: nil].
	self readMessageHeaders: aConnection.
	self makingProgress onReadBody! !
!SptHTTPResponse categoriesFor: #readChunkedEncodedBody:!public! !

!SptHTTPResponse methodsFor!
readContentLengthBody: aConnection
	"Read Content-Length bytes from the socket (ie HTTP1.1 semantics).
	Note: read readEntityChunkSize bytes at a time so that we can update any progress/status objects."

	| total read bytes |
	self makingProgress onReadingBody.
	total := self contentLength.
	read := 0.
	[read >= total] whileFalse: 
			[bodyStream nextPutAll: (aConnection socketStream 
						nextBytes: (bytes := self readEntityBufferSize min: total - read)).
			read := read + bytes.
			self makingProgress read: read of: total].
	self makingProgress onReadBody! !
!SptHTTPResponse categoriesFor: #readContentLengthBody:!public! !

!SptHTTPResponse methodsFor!
readContentRangeBody: aConnection
	"Read Content-Length bytes from the socket (ie HTTP1.1 semantics).
	Note: read readEntityChunkSize bytes at a time so that we can update any progress/status objects."

	| total range read bytes |
	#todo.	"Refactor with readContentLengthBody"
	self makingProgress onReadingBody.
	range := self contentRangeInterval.

	"If the request isRangeRequest, set the position of the okBodyStream"
	request isRangeRequest ifTrue: [bodyStream position: range start].
	total := range stop - range start + 1.
	read := 0.
	[read >= total] whileFalse: 
			[bodyStream nextPutAll: (aConnection socketStream 
						nextBytes: (bytes := self readEntityBufferSize min: total - read)).
			read := read + bytes.
			self makingProgress read: read of: total].
	self makingProgress onReadBody! !
!SptHTTPResponse categoriesFor: #readContentRangeBody:!public! !

!SptHTTPResponse methodsFor!
readEntityBufferSize
	request ifNil: 
			["For UnitTests"

			^1024].
	^request readEntityBufferSize! !
!SptHTTPResponse categoriesFor: #readEntityBufferSize!public! !

!SptHTTPResponse methodsFor!
readMessageBody: aConnection
	self isSuccessful ifTrue: [self setRequestBodyStream].
	self isChunkedTransferEncoding ifTrue: [^self readChunkedEncodedBody: aConnection].
	self hasContentRange ifTrue: [^self readContentRangeBody: aConnection].
	self hasContentLength ifTrue: [^self readContentLengthBody: aConnection].
	"Only read to socket close if HTTP1.0. It is valid to have a response with no body"
	(self isVersion11 not or: [self isConnectionClose]) 
		ifTrue: 
			[^self readBodyToEnd: aConnection
			"mmm ... no body?"]! !
!SptHTTPResponse categoriesFor: #readMessageBody:!public! !

!SptHTTPResponse methodsFor!
readMessageHeaders: aConnection
	| line stream |
	self makingProgress onReadingHeaders.
	stream := aConnection socketStream.
	[(line := stream upToCRLF) isEmpty] whileFalse: [self parseHeaderLine: line].
	self makingProgress onReadHeaders! !
!SptHTTPResponse categoriesFor: #readMessageHeaders:!public! !

!SptHTTPResponse methodsFor!
readMessageStatus: aConnection
	| line stream |
	stream := aConnection socketStream.
	self makingProgress onReadingStatus.
	[(line := stream upToCRLF) isEmpty] whileTrue: [line := stream upToCRLF].
	statusLine := line.
	self makingProgress onReadStatus! !
!SptHTTPResponse categoriesFor: #readMessageStatus:!public! !

!SptHTTPResponse methodsFor!
readResponse: aConnection
	| startT |
	#stayDown.
	"startT := Delay millisecondClockValue."
	
	[self readMessageStatus: aConnection.
	self readMessageHeaders: aConnection.
	self isInformational] 
			whileTrue.
	self readMessageBody: aConnection

	"Transcript
		display: (Delay millisecondClockValue - startT) displayString;
		cr."! !
!SptHTTPResponse categoriesFor: #readResponse:!public! !

!SptHTTPResponse methodsFor!
request
	^request! !
!SptHTTPResponse categoriesFor: #request!public! !

!SptHTTPResponse methodsFor!
request: aSptHTTPRequest
	request := aSptHTTPRequest! !
!SptHTTPResponse categoriesFor: #request:!public! !

!SptHTTPResponse methodsFor!
setRequestBodyStream
	request isNil ifTrue: [^nil].
	"If the <SptHTTPRequest> has a nonNil bodyStream use it, otherwise set it"
	request okBodyStream notNil 
		ifTrue: [bodyStream := request okBodyStream]
		ifFalse: [request okBodyStream: bodyStream]! !
!SptHTTPResponse categoriesFor: #setRequestBodyStream!public! !

!SptHTTPResponse methodsFor!
setStatus: aString headers: aLookupTable body: aString2
	"Private - For Unit tests"

	statusLine := aString.
	headers := aLookupTable.
	bodyStream := ByteArray writeStream.
	bodyStream nextPutAll: aString2 asByteArray! !
!SptHTTPResponse categoriesFor: #setStatus:headers:body:!public! !

!SptHTTPResponse methodsFor!
setStatusCode: aString headers: aLookupTable body: aString2
	"Private - For Unit tests"

	self 
		setStatus: 'HTTP/1.1 ' , aString
		headers: aLookupTable
		body: aString2! !
!SptHTTPResponse categoriesFor: #setStatusCode:headers:body:!public! !

!SptHTTPResponse methodsFor!
status
	"Answer the status code of the response"

	^self httpStatus status! !
!SptHTTPResponse categoriesFor: #status!public! !

!SptHTTPResponse methodsFor!
statusCode
	"Answer the status code of the response"

	^self httpStatus statusCode! !
!SptHTTPResponse categoriesFor: #statusCode!public! !

!SptHTTPResponse methodsFor!
statusCodeString
	"Answer the status string of the response"

	^self httpStatus statusCodeString! !
!SptHTTPResponse categoriesFor: #statusCodeString!public! !

!SptHTTPResponse methodsFor!
statusLine
	"Answer the response status line"

	^statusLine! !
!SptHTTPResponse categoriesFor: #statusLine!public! !

!SptHTTPResponse methodsFor!
statusLine: aString
	"For example 'HTTP/1.1 200 OK'"

	statusLine := aString! !
!SptHTTPResponse categoriesFor: #statusLine:!public! !

!SptHTTPResponse methodsFor!
statusText
	"Answer the Status text of the response"

	^self httpStatus statusText! !
!SptHTTPResponse categoriesFor: #statusText!public! !

!SptHTTPResponse categoriesFor: #basicChallenge!accessing-headers!public! !

!SptHTTPResponse categoriesFor: #body!accessing-content!public! !

!SptHTTPResponse categoriesFor: #bodyBytes!accessing-content!public! !

!SptHTTPResponse categoriesFor: #bodyStream!accessing-content!public! !

!SptHTTPResponse categoriesFor: #bodyStreamSize!accessing!public! !

!SptHTTPResponse categoriesFor: #canRangeRetry!public!testing! !

!SptHTTPResponse categoriesFor: #chunkSizeFrom:!helpers!private! !

!SptHTTPResponse categoriesFor: #contentLength!accessing-headers!public! !

!SptHTTPResponse categoriesFor: #contentRangeInterval!accessing-headers!public! !

!SptHTTPResponse categoriesFor: #contentType!accessing-headers!public! !

!SptHTTPResponse categoriesFor: #contentTypeOrNil!accessing-headers!public! !

!SptHTTPResponse categoriesFor: #defaultIsConnectionClose!accessing!private! !

!SptHTTPResponse categoriesFor: #hasContentLength!public!testing! !

!SptHTTPResponse categoriesFor: #hasContentRange!public!testing! !

!SptHTTPResponse categoriesFor: #hasRange!public!testing! !

!SptHTTPResponse categoriesFor: #hasStatus!public!testing! !

!SptHTTPResponse categoriesFor: #headerAt:!accessing-headers!public! !

!SptHTTPResponse categoriesFor: #headerAt:ifAbsent:!accessing-headers!public! !

!SptHTTPResponse categoriesFor: #headers!accessing-headers!public! !

!SptHTTPResponse categoriesFor: #httpException!exceptions!public! !

!SptHTTPResponse categoriesFor: #httpStatus!accessing-status!public! !

!SptHTTPResponse categoriesFor: #initialize!initializing!private! !

!SptHTTPResponse categoriesFor: #isAcceptRangesBytes!public!testing! !

!SptHTTPResponse categoriesFor: #isChunkedTransferEncoding!public!testing! !

!SptHTTPResponse categoriesFor: #isClientOrServerError!public!testing! !

!SptHTTPResponse categoriesFor: #isConnectionClose!public!testing! !

!SptHTTPResponse categoriesFor: #isHTMLContentType!public!testing! !

!SptHTTPResponse categoriesFor: #isImageContentType!public!testing! !

!SptHTTPResponse categoriesFor: #isInformational!public!testing! !

!SptHTTPResponse categoriesFor: #isRedirect!public!testing! !

!SptHTTPResponse categoriesFor: #isSuccessful!public!testing! !

!SptHTTPResponse categoriesFor: #isUnauthorized!public!testing! !

!SptHTTPResponse categoriesFor: #isVersion11!public!testing! !

!SptHTTPResponse categoriesFor: #location!accessing-headers!public! !

!SptHTTPResponse categoriesFor: #makingProgress!accessing!private! !

!SptHTTPResponse categoriesFor: #onReadHeaders!event handling!private! !

!SptHTTPResponse categoriesFor: #parseCookie:!operations!private! !

!SptHTTPResponse categoriesFor: #parseHeaderLine:!operations!private! !

!SptHTTPResponse categoriesFor: #progress!accessing!private! !

!SptHTTPResponse categoriesFor: #putHeaderReportOn:!accessing!private! !

!SptHTTPResponse categoriesFor: #rangeInterval!accessing-headers!public! !

!SptHTTPResponse categoriesFor: #readBodyToEnd:!operations!private! !

!SptHTTPResponse categoriesFor: #readChunkedEncodedBody:!operations!private! !

!SptHTTPResponse categoriesFor: #readContentLengthBody:!operations!private! !

!SptHTTPResponse categoriesFor: #readContentRangeBody:!operations!private! !

!SptHTTPResponse categoriesFor: #readEntityBufferSize!accessing!private! !

!SptHTTPResponse categoriesFor: #readMessageBody:!operations!private! !

!SptHTTPResponse categoriesFor: #readMessageHeaders:!operations!private! !

!SptHTTPResponse categoriesFor: #readMessageStatus:!operations!private! !

!SptHTTPResponse categoriesFor: #readResponse:!operations!private! !

!SptHTTPResponse categoriesFor: #request!accessing!public! !

!SptHTTPResponse categoriesFor: #request:!accessing!public! !

!SptHTTPResponse categoriesFor: #setRequestBodyStream!operations!private! !

!SptHTTPResponse categoriesFor: #setStatus:headers:body:!private!unit tests! !

!SptHTTPResponse categoriesFor: #setStatusCode:headers:body:!private!unit tests! !

!SptHTTPResponse categoriesFor: #status!accessing-status!public! !

!SptHTTPResponse categoriesFor: #statusCode!accessing-status!public! !

!SptHTTPResponse categoriesFor: #statusCodeString!accessing-status!public! !

!SptHTTPResponse categoriesFor: #statusLine!accessing-status!public! !

!SptHTTPResponse categoriesFor: #statusLine:!accessing-status!private! !

!SptHTTPResponse categoriesFor: #statusText!accessing-status!public! !

!SptHTTPResponse class methodsFor!
fromConnection: anSptHTTPConnection request: anObject
	#deprecated.
	^(self new)
		request: anObject;
		readResponse: anSptHTTPConnection;
		yourself! !
!SptHTTPResponse class categoriesFor: #fromConnection:request:!public! !

!SptHTTPResponse class methodsFor!
new
	^super new initialize! !
!SptHTTPResponse class categoriesFor: #new!public! !

!SptHTTPResponse class methodsFor!
readEntityBufferSize
	Notification deprecated.
	^1024! !
!SptHTTPResponse class categoriesFor: #readEntityBufferSize!public! !

!SptHTTPResponse class categoriesFor: #fromConnection:request:!instance creation!public! !

!SptHTTPResponse class categoriesFor: #new!instance creation!public! !

!SptHTTPResponse class categoriesFor: #readEntityBufferSize!constants!public! !

SptHTTPSessionState guid: (GUID fromString: '{D8286C45-2454-4FC6-B58C-0C682945A03B}')!

SptHTTPSessionState guid: (GUID fromString: '{D8286C45-2454-4FC6-B58C-0C682945A03B}')!
SptHTTPSessionState comment: 'I am the state that (can) exist across a number of HTTP requests 

See SptHTTPRequest(class)>>exampleState

Instance Variables:
	proxySettings	<SptHTTPProxySettings>
	credentials	<SptCredentials>
	timeout		<Integer> or nil
	cookieJar		<SptHTTPCookieJar>
	maxRedirects	<Integer>'!

SptHTTPSessionState comment:
'I am the state that (can) exist across a number of HTTP requests 

See SptHTTPRequest(class)>>exampleState

Instance Variables:
	proxySettings	<SptHTTPProxySettings>
	credentials	<SptCredentials>
	timeout		<Integer> or nil
	cookieJar		<SptHTTPCookieJar>
	maxRedirects	<Integer>'!
!SptHTTPSessionState categoriesForClass!Kernel-Objects! !
!SptHTTPSessionState methodsFor!
addCookie: aSptHTTPCookie
	cookieJar addCookie: aSptHTTPCookie! !
!SptHTTPSessionState categoriesFor: #addCookie:!public! !

!SptHTTPSessionState methodsFor!
authorizationHeader
	^credentials httpHeaderValue! !
!SptHTTPSessionState categoriesFor: #authorizationHeader!public! !

!SptHTTPSessionState methodsFor!
cookieHeaderFor: aSptHTTPUrl
	^cookieJar headerFor: aSptHTTPUrl! !
!SptHTTPSessionState categoriesFor: #cookieHeaderFor:!public! !

!SptHTTPSessionState methodsFor!
cookieJar
	^cookieJar! !
!SptHTTPSessionState categoriesFor: #cookieJar!public! !

!SptHTTPSessionState methodsFor!
cookieJar: aSptHTTPCookieJar
	cookieJar := aSptHTTPCookieJar! !
!SptHTTPSessionState categoriesFor: #cookieJar:!public! !

!SptHTTPSessionState methodsFor!
credentials
	^credentials! !
!SptHTTPSessionState categoriesFor: #credentials!public! !

!SptHTTPSessionState methodsFor!
credentials: aSptCredentials
	credentials := aSptCredentials! !
!SptHTTPSessionState categoriesFor: #credentials:!public! !

!SptHTTPSessionState methodsFor!
initialize
	super initialize.
	timeout := self class defaultTimeout.
	maxRedirects := self class defaultMaxRedirects.
	cookieJar := SptHTTPCookieJar new! !
!SptHTTPSessionState categoriesFor: #initialize!public! !

!SptHTTPSessionState methodsFor!
maxRedirects
	"Answer the maximum number of redirections that can automatically be followed"

	^maxRedirects! !
!SptHTTPSessionState categoriesFor: #maxRedirects!public! !

!SptHTTPSessionState methodsFor!
maxRedirects: anInteger
	"Set the maximum number of redirects that will be automatically followed"

	maxRedirects := anInteger! !
!SptHTTPSessionState categoriesFor: #maxRedirects:!public! !

!SptHTTPSessionState methodsFor!
proxySettings
	^proxySettings! !
!SptHTTPSessionState categoriesFor: #proxySettings!public! !

!SptHTTPSessionState methodsFor!
proxySettings: aSptHTTPProxySettings
	proxySettings := aSptHTTPProxySettings! !
!SptHTTPSessionState categoriesFor: #proxySettings:!public! !

!SptHTTPSessionState methodsFor!
shouldAuthenticate: aUrlString
	^credentials notNil and: [credentials isInProtectionSpace: aUrlString]! !
!SptHTTPSessionState categoriesFor: #shouldAuthenticate:!public! !

!SptHTTPSessionState methodsFor!
timeout
	^timeout! !
!SptHTTPSessionState categoriesFor: #timeout!public! !

!SptHTTPSessionState methodsFor!
timeout: anInteger
	timeout := anInteger! !
!SptHTTPSessionState categoriesFor: #timeout:!public! !

!SptHTTPSessionState methodsFor!
useProxy
	proxySettings isNil ifTrue: [^false].
	^proxySettings useProxy! !
!SptHTTPSessionState categoriesFor: #useProxy!public! !

!SptHTTPSessionState methodsFor!
username: aUsernameString password: aPasswordString for: aUrlString
	| user |
	user := SptHTTPUser new.
	user username: aUsernameString password: aPasswordString.
	credentials isNil ifTrue: [credentials := SptBasicCredentials new].
	credentials user: user.
	credentials challenge: SptHTTPChallenge newBasicChallenge.
	credentials challenge absoluteUrl: aUrlString! !
!SptHTTPSessionState categoriesFor: #username:password:for:!public! !

!SptHTTPSessionState categoriesFor: #addCookie:!accessing!public! !

!SptHTTPSessionState categoriesFor: #authorizationHeader!accessing!public! !

!SptHTTPSessionState categoriesFor: #cookieHeaderFor:!enquiries!public! !

!SptHTTPSessionState categoriesFor: #cookieJar!accessing!public! !

!SptHTTPSessionState categoriesFor: #cookieJar:!accessing!public! !

!SptHTTPSessionState categoriesFor: #credentials!accessing!public! !

!SptHTTPSessionState categoriesFor: #credentials:!accessing!public! !

!SptHTTPSessionState categoriesFor: #initialize!initializing!public! !

!SptHTTPSessionState categoriesFor: #maxRedirects!accessing!public! !

!SptHTTPSessionState categoriesFor: #maxRedirects:!accessing!public! !

!SptHTTPSessionState categoriesFor: #proxySettings!accessing!public! !

!SptHTTPSessionState categoriesFor: #proxySettings:!accessing!public! !

!SptHTTPSessionState categoriesFor: #shouldAuthenticate:!public!testing! !

!SptHTTPSessionState categoriesFor: #timeout!accessing!public! !

!SptHTTPSessionState categoriesFor: #timeout:!accessing!public! !

!SptHTTPSessionState categoriesFor: #useProxy!public!testing! !

!SptHTTPSessionState categoriesFor: #username:password:for:!enquiries!public! !

!SptHTTPSessionState class methodsFor!
defaultMaxRedirects
	^5! !
!SptHTTPSessionState class categoriesFor: #defaultMaxRedirects!public! !

!SptHTTPSessionState class methodsFor!
defaultTimeout
	^20000! !
!SptHTTPSessionState class categoriesFor: #defaultTimeout!public! !

!SptHTTPSessionState class methodsFor!
new
	^super new initialize! !
!SptHTTPSessionState class categoriesFor: #new!public! !

!SptHTTPSessionState class categoriesFor: #defaultMaxRedirects!constants!public! !

!SptHTTPSessionState class categoriesFor: #defaultTimeout!constants!public! !

!SptHTTPSessionState class categoriesFor: #new!instance creation!public! !

SptHTTPStatus guid: (GUID fromString: '{EF05967E-6B00-4A4B-A557-15C5FDE51ED6}')!

SptHTTPStatus guid: (GUID fromString: '{EF05967E-6B00-4A4B-A557-15C5FDE51ED6}')!
SptHTTPStatus comment: 'I am the status of an HTTP Response message

Instance Variables:
	statusLine	<String>'!

SptHTTPStatus comment:
'I am the status of an HTTP Response message

Instance Variables:
	statusLine	<String>'!
!SptHTTPStatus categoriesForClass!Kernel-Objects! !
!SptHTTPStatus methodsFor!
displayOn: stream
	statusLine displayOn: stream! !
!SptHTTPStatus categoriesFor: #displayOn:!public! !

!SptHTTPStatus methodsFor!
httpException
	"Answer an exception instance that describes the error"

	"
	(self fromString: 'HTTP/1.1 404 Not Found') httpException signal
	"

	| exClass |
	exClass := self httpExceptionClass.
	^(exClass new)
		httpStatus: self;
		yourself! !
!SptHTTPStatus categoriesFor: #httpException!public! !

!SptHTTPStatus methodsFor!
httpExceptionClass
	^self isClientError 
		ifTrue: [SptHTTPClientError]
		ifFalse: 
			[self isServerError 
				ifTrue: [SptHTTPServerError]
				ifFalse: 
					["? If you say so"

					SptHTTPError]]! !
!SptHTTPStatus categoriesFor: #httpExceptionClass!public! !

!SptHTTPStatus methodsFor!
isClientError
	^self statusCodeString first = $4! !
!SptHTTPStatus categoriesFor: #isClientError!public! !

!SptHTTPStatus methodsFor!
isClientOrServerError
	^self statusCode >= 400! !
!SptHTTPStatus categoriesFor: #isClientOrServerError!public! !

!SptHTTPStatus methodsFor!
isInformational
	^self statusCodeString first = $1! !
!SptHTTPStatus categoriesFor: #isInformational!public! !

!SptHTTPStatus methodsFor!
isServerError
	^self statusCodeString first = $5! !
!SptHTTPStatus categoriesFor: #isServerError!public! !

!SptHTTPStatus methodsFor!
isSuccessful
	^self statusCodeString first = $2! !
!SptHTTPStatus categoriesFor: #isSuccessful!public! !

!SptHTTPStatus methodsFor!
isVersion11
	| stream |
	stream := statusLine readStream.
	self assert: [(stream next: 5) = 'HTTP/'].
	^(stream upTo: Character space) = '1.1'! !
!SptHTTPStatus categoriesFor: #isVersion11!public! !

!SptHTTPStatus methodsFor!
status
	"Answer the status code of the response"

	"
	(self fromString: 'HTTP/1.1 404 Not Found') status
		404
	"

	^self statusCodeString asNumber! !
!SptHTTPStatus categoriesFor: #status!public! !

!SptHTTPStatus methodsFor!
statusCode
	"Answer the status code of the response"

	"
	(self fromString: 'HTTP/1.1 404 Not Found') statusCode
		404
	"

	^self status! !
!SptHTTPStatus categoriesFor: #statusCode!public! !

!SptHTTPStatus methodsFor!
statusCodeString
	"Answer the status code of the response"

	"
	(self fromString: 'HTTP/1.1 404 Not Found') statusCodeString
		'404'
	"

	| stream |
	stream := statusLine readStream.
	stream upTo: Character space.
	^stream upTo: Character space! !
!SptHTTPStatus categoriesFor: #statusCodeString!public! !

!SptHTTPStatus methodsFor!
statusLine
	"Answer the response status line"

	^statusLine! !
!SptHTTPStatus categoriesFor: #statusLine!public! !

!SptHTTPStatus methodsFor!
statusLine: aString
	statusLine := aString! !
!SptHTTPStatus categoriesFor: #statusLine:!public! !

!SptHTTPStatus methodsFor!
statusText
	"Answer the Status text of the response"

	"
	(self fromString: 'HTTP/1.1 404 Not Found') statusText
		'Not Found'
	"

	| stream |
	stream := statusLine readStream.
	stream upTo: Character space.
	stream upTo: Character space.
	^stream upToEnd! !
!SptHTTPStatus categoriesFor: #statusText!public! !

!SptHTTPStatus categoriesFor: #displayOn:!displaying!public! !

!SptHTTPStatus categoriesFor: #httpException!exceptions!public! !

!SptHTTPStatus categoriesFor: #httpExceptionClass!exceptions!private! !

!SptHTTPStatus categoriesFor: #isClientError!public!testing! !

!SptHTTPStatus categoriesFor: #isClientOrServerError!public!testing! !

!SptHTTPStatus categoriesFor: #isInformational!public!testing! !

!SptHTTPStatus categoriesFor: #isServerError!public!testing! !

!SptHTTPStatus categoriesFor: #isSuccessful!public!testing! !

!SptHTTPStatus categoriesFor: #isVersion11!public!testing! !

!SptHTTPStatus categoriesFor: #status!accessing!public! !

!SptHTTPStatus categoriesFor: #statusCode!accessing!public! !

!SptHTTPStatus categoriesFor: #statusCodeString!accessing!public! !

!SptHTTPStatus categoriesFor: #statusLine!accessing!public! !

!SptHTTPStatus categoriesFor: #statusLine:!private!test accessing! !

!SptHTTPStatus categoriesFor: #statusText!accessing!public! !

!SptHTTPStatus class methodsFor!
fromString: aString
	^self new statusLine: aString! !
!SptHTTPStatus class categoriesFor: #fromString:!public! !

!SptHTTPStatus class categoriesFor: #fromString:!instance creation!public! !

SptHTTPUser guid: (GUID fromString: '{867DFB03-6E58-48C9-905A-BE3F90F62EDF}')!

SptHTTPUser guid: (GUID fromString: '{867DFB03-6E58-48C9-905A-BE3F90F62EDF}')!
SptHTTPUser comment: ''!

SptHTTPUser comment:
''!
!SptHTTPUser categoriesForClass!Kernel-Objects! !
!SptHTTPUser methodsFor!
password
	^password! !
!SptHTTPUser categoriesFor: #password!public! !

!SptHTTPUser methodsFor!
username
	^username! !
!SptHTTPUser categoriesFor: #username!public! !

!SptHTTPUser methodsFor!
username: aUsernameString password: aPasswordString
	username := aUsernameString.
	password := aPasswordString! !
!SptHTTPUser categoriesFor: #username:password:!public! !

!SptHTTPUser categoriesFor: #password!accessing!private! !

!SptHTTPUser categoriesFor: #username!accessing!private! !

!SptHTTPUser categoriesFor: #username:password:!accessing!public! !

!SptHTTPUser class methodsFor!
addRealm: aString host: aHostName username: aUsernameString password: aPasswordString
	self assert: [aString first ~= $" and: [aString last ~= $"]].
	self assert: [(aHostName beginsWith: 'http://') not].
	Users at: (Array with: aString with: aHostName)
		put: (self username: aUsernameString password: aPasswordString)! !
!SptHTTPUser class categoriesFor: #addRealm:host:username:password:!public! !

!SptHTTPUser class methodsFor!
initialize
	"
	self initialize
	"

	
	Users := LookupTable new
! !
!SptHTTPUser class categoriesFor: #initialize!public! !

!SptHTTPUser class methodsFor!
uninitialize
	Users := nil! !
!SptHTTPUser class categoriesFor: #uninitialize!public! !

!SptHTTPUser class methodsFor!
userFor: aString host: aHostName
	self assert: [(aHostName beginsWith: 'http://') not].
	^Users at: (Array with: aString with: aHostName) ifAbsent: []! !
!SptHTTPUser class categoriesFor: #userFor:host:!public! !

!SptHTTPUser class methodsFor!
username: aUsernameString password: aPasswordString
	^self new username: aUsernameString password: aPasswordString! !
!SptHTTPUser class categoriesFor: #username:password:!public! !

!SptHTTPUser class methodsFor!
users
	^Users! !
!SptHTTPUser class categoriesFor: #users!public! !

!SptHTTPUser class methodsFor!
users: aLookupTable
	Users := aLookupTable! !
!SptHTTPUser class categoriesFor: #users:!public! !

!SptHTTPUser class categoriesFor: #addRealm:host:username:password:!accessing!public! !

!SptHTTPUser class categoriesFor: #initialize!initializing!public! !

!SptHTTPUser class categoriesFor: #uninitialize!initializing!public! !

!SptHTTPUser class categoriesFor: #userFor:host:!accessing!public! !

!SptHTTPUser class categoriesFor: #username:password:!instance creation!public! !

!SptHTTPUser class categoriesFor: #users!accessing!private! !

!SptHTTPUser class categoriesFor: #users:!accessing!private! !

SptHTTPError guid: (GUID fromString: '{92B85167-C0BB-4A99-A215-0ABE324C8317}')!

SptHTTPError guid: (GUID fromString: '{92B85167-C0BB-4A99-A215-0ABE324C8317}')!
SptHTTPError comment: ''!

SptHTTPError comment:
''!
!SptHTTPError categoriesForClass!Kernel-Exception Handling! !
!SptHTTPError methodsFor!
_descriptionArguments
	"Answer the set of arguments to be substitued into the receiver's descriptionFormat
	String."

	^super _descriptionArguments , (Array with: httpStatus displayString)! !
!SptHTTPError categoriesFor: #_descriptionArguments!public! !

!SptHTTPError methodsFor!
_descriptionFormat
	"Answer the Win32 format String to be used to format the description for the receiver."

	^'HTTP Error %3'! !
!SptHTTPError categoriesFor: #_descriptionFormat!public! !

!SptHTTPError methodsFor!
httpStatus
	^httpStatus! !
!SptHTTPError categoriesFor: #httpStatus!public! !

!SptHTTPError methodsFor!
httpStatus: aSptHTTPStatus
	httpStatus := aSptHTTPStatus.
	messageText := httpStatus displayString! !
!SptHTTPError categoriesFor: #httpStatus:!public! !

!SptHTTPError methodsFor!
statusCode
	"Answer the status code of the response"

	^self httpStatus statusCode! !
!SptHTTPError categoriesFor: #statusCode!public! !

!SptHTTPError methodsFor!
statusText
	"Answer the Status text of the response"

	^self httpStatus statusText! !
!SptHTTPError categoriesFor: #statusText!public! !

!SptHTTPError categoriesFor: #_descriptionArguments!displaying!public! !

!SptHTTPError categoriesFor: #_descriptionFormat!displaying!public! !

!SptHTTPError categoriesFor: #httpStatus!accessing!private! !

!SptHTTPError categoriesFor: #httpStatus:!accessing!private! !

!SptHTTPError categoriesFor: #statusCode!accessing!public! !

!SptHTTPError categoriesFor: #statusText!accessing!public! !

SptHTTPNotAuthorized guid: (GUID fromString: '{7B5D985E-3684-457E-AC48-2BDC0851AE8D}')!

SptHTTPNotAuthorized guid: (GUID fromString: '{7B5D985E-3684-457E-AC48-2BDC0851AE8D}')!
SptHTTPNotAuthorized comment: ''!

SptHTTPNotAuthorized comment:
''!
!SptHTTPNotAuthorized categoriesForClass!Kernel-Exception Handling! !
!SptHTTPNotAuthorized methodsFor!
_descriptionArguments
	"Answer the set of arguments to be substitued into the receiver's descriptionFormat
	String."

	^super _descriptionArguments , (Array with: site displayString)! !
!SptHTTPNotAuthorized categoriesFor: #_descriptionArguments!public! !

!SptHTTPNotAuthorized methodsFor!
_descriptionFormat
	"Answer the Win32 format String to be used to format the description for the receiver."

	^'HTTP Not Authorized for %3'! !
!SptHTTPNotAuthorized categoriesFor: #_descriptionFormat!public! !

!SptHTTPNotAuthorized methodsFor!
challenge
	^challenge! !
!SptHTTPNotAuthorized categoriesFor: #challenge!public! !

!SptHTTPNotAuthorized methodsFor!
challenge: aSptHTTPChallenge
	challenge := aSptHTTPChallenge! !
!SptHTTPNotAuthorized categoriesFor: #challenge:!public! !

!SptHTTPNotAuthorized methodsFor!
realm
	^challenge realm! !
!SptHTTPNotAuthorized categoriesFor: #realm!public! !

!SptHTTPNotAuthorized methodsFor!
removeCredentials
	target notNil ifTrue: [target credentials: nil]! !
!SptHTTPNotAuthorized categoriesFor: #removeCredentials!public! !

!SptHTTPNotAuthorized methodsFor!
site
	^site! !
!SptHTTPNotAuthorized categoriesFor: #site!public! !

!SptHTTPNotAuthorized methodsFor!
site: aString
	site := aString! !
!SptHTTPNotAuthorized categoriesFor: #site:!public! !

!SptHTTPNotAuthorized methodsFor!
target
	^target! !
!SptHTTPNotAuthorized categoriesFor: #target!public! !

!SptHTTPNotAuthorized methodsFor!
target: anObject
	target := anObject! !
!SptHTTPNotAuthorized categoriesFor: #target:!public! !

!SptHTTPNotAuthorized methodsFor!
username: aString password: aString2
	target notNil 
		ifTrue: [target credentials: (challenge credentialsForUsername: aString password: aString2)]! !
!SptHTTPNotAuthorized categoriesFor: #username:password:!public! !

!SptHTTPNotAuthorized categoriesFor: #_descriptionArguments!displaying!public! !

!SptHTTPNotAuthorized categoriesFor: #_descriptionFormat!displaying!public! !

!SptHTTPNotAuthorized categoriesFor: #challenge!accessing!public! !

!SptHTTPNotAuthorized categoriesFor: #challenge:!accessing!public! !

!SptHTTPNotAuthorized categoriesFor: #realm!accessing!public! !

!SptHTTPNotAuthorized categoriesFor: #removeCredentials!operations!public! !

!SptHTTPNotAuthorized categoriesFor: #site!accessing!public! !

!SptHTTPNotAuthorized categoriesFor: #site:!accessing!public! !

!SptHTTPNotAuthorized categoriesFor: #target!accessing!public! !

!SptHTTPNotAuthorized categoriesFor: #target:!accessing!public! !

!SptHTTPNotAuthorized categoriesFor: #username:password:!operations!public! !

!SptHTTPNotAuthorized class methodsFor!
newForRealm: aString absoluteUri: aUrlString
	^(self new)
		challenge: (SptHTTPChallenge newBasicChallengeRealm: aString absoluteUri: aUrlString);
		site: aUrlString;
		yourself! !
!SptHTTPNotAuthorized class categoriesFor: #newForRealm:absoluteUri:!public! !

!SptHTTPNotAuthorized class categoriesFor: #newForRealm:absoluteUri:!instance creation!public! !

SptHTTPClientError guid: (GUID fromString: '{3C7DC990-DDA8-4C79-BB3A-7F40DA3522B5}')!

SptHTTPClientError guid: (GUID fromString: '{3C7DC990-DDA8-4C79-BB3A-7F40DA3522B5}')!
SptHTTPClientError comment: ''!

SptHTTPClientError comment:
''!
!SptHTTPClientError categoriesForClass!Kernel-Exception Handling! !
!SptHTTPClientError methodsFor!
_descriptionFormat
	"Answer the Win32 format String to be used to format the description for the receiver."

	^'Client Error %3'! !
!SptHTTPClientError categoriesFor: #_descriptionFormat!public! !

!SptHTTPClientError categoriesFor: #_descriptionFormat!displaying!public! !

SptHTTPServerError guid: (GUID fromString: '{D984E100-485E-4D21-9BF7-743ADA49E59F}')!

SptHTTPServerError guid: (GUID fromString: '{D984E100-485E-4D21-9BF7-743ADA49E59F}')!
SptHTTPServerError comment: ''!

SptHTTPServerError comment:
''!
!SptHTTPServerError categoriesForClass!Kernel-Exception Handling! !
!SptHTTPServerError methodsFor!
_descriptionFormat
	"Answer the Win32 format String to be used to format the description for the receiver."

	^'Server Error %3'! !
!SptHTTPServerError categoriesFor: #_descriptionFormat!public! !

!SptHTTPServerError categoriesFor: #_descriptionFormat!displaying!public! !

SptHTTPAuthorizationDialog guid: (GUID fromString: '{FC57A867-9621-4646-9729-A09890CFC8B3}')!

SptHTTPAuthorizationDialog guid: (GUID fromString: '{FC57A867-9621-4646-9729-A09890CFC8B3}')!
SptHTTPAuthorizationDialog comment: ''!

SptHTTPAuthorizationDialog comment:
''!
!SptHTTPAuthorizationDialog categoriesForClass!MVP-Presenters! !
!SptHTTPAuthorizationDialog methodsFor!
answer
	"Answer the model if the receiver was confirmed (with #apply, #ok) or nil otherwise"

	^self isConfirmed! !
!SptHTTPAuthorizationDialog categoriesFor: #answer!public! !

!SptHTTPAuthorizationDialog methodsFor!
cancel
	super cancel.
	exception removeCredentials! !
!SptHTTPAuthorizationDialog categoriesFor: #cancel!public! !

!SptHTTPAuthorizationDialog methodsFor!
createComponents
	super createComponents.
	sitePresenter := self add: TextPresenter new name: 'site'.
	realmPresenter := self add: TextPresenter new name: 'realm'.
	userPresenter := self add: TextPresenter new name: 'user'.
	passPresenter := self add: TextPresenter new name: 'pass'! !
!SptHTTPAuthorizationDialog categoriesFor: #createComponents!public! !

!SptHTTPAuthorizationDialog methodsFor!
exception: aSptHTTPNotAuthorized
	exception := aSptHTTPNotAuthorized! !
!SptHTTPAuthorizationDialog categoriesFor: #exception:!public! !

!SptHTTPAuthorizationDialog methodsFor!
ok
	| ans |
	ans := super ok.
	exception username: userPresenter value password: passPresenter value.
	^ans! !
!SptHTTPAuthorizationDialog categoriesFor: #ok!public! !

!SptHTTPAuthorizationDialog methodsFor!
onViewOpened
	super onViewOpened.
	realmPresenter model: exception realm.
	sitePresenter model: exception site! !
!SptHTTPAuthorizationDialog categoriesFor: #onViewOpened!public! !

!SptHTTPAuthorizationDialog categoriesFor: #answer!accessing!public! !

!SptHTTPAuthorizationDialog categoriesFor: #cancel!commands!public! !

!SptHTTPAuthorizationDialog categoriesFor: #createComponents!initializing!public! !

!SptHTTPAuthorizationDialog categoriesFor: #exception:!accessing!public! !

!SptHTTPAuthorizationDialog categoriesFor: #ok!commands!public! !

!SptHTTPAuthorizationDialog categoriesFor: #onViewOpened!event handling!public! !

!SptHTTPAuthorizationDialog class methodsFor!
icon
	^Icon fromId: 45 in: ShellLibrary default! !
!SptHTTPAuthorizationDialog class categoriesFor: #icon!public! !

!SptHTTPAuthorizationDialog class methodsFor!
showOnException: aSptHTTPNotAuthorized
	"
	self showOnException: (SptHTTPNotAuthorized new challenge: (SptHTTPChallenge fromChallengeString: 'Basic realm=Foo')) 
	"

	^(self on: false)
		exception: aSptHTTPNotAuthorized;
		createView: self defaultView;
		showModal! !
!SptHTTPAuthorizationDialog class categoriesFor: #showOnException:!public! !

!SptHTTPAuthorizationDialog class categoriesFor: #icon!constants!public! !

!SptHTTPAuthorizationDialog class categoriesFor: #showOnException:!instance creation!public! !

SptProxySettingDialog guid: (GUID fromString: '{92139124-C2F2-46A9-831A-95DDC6BCC595}')!

SptProxySettingDialog guid: (GUID fromString: '{92139124-C2F2-46A9-831A-95DDC6BCC595}')!
SptProxySettingDialog comment: ''!

SptProxySettingDialog comment:
''!
!SptProxySettingDialog categoriesForClass!Unclassified! !
!SptProxySettingDialog methodsFor!
createComponents
	super createComponents.
	useProxyP := self add: BooleanPresenter new name: 'useProxy'.
	hostP := self add: TextPresenter new name: 'host'.
	portP := self add: TextPresenter new name: 'port'
! !
!SptProxySettingDialog categoriesFor: #createComponents!public! !

!SptProxySettingDialog methodsFor!
model: aSptHTTPProxySettings
	"Set the model associated with the receiver."

	| aspectBuffer |
	super model: aSptHTTPProxySettings.
	aspectBuffer := self model.
	useProxyP model: (aspectBuffer aspectValue: #useProxy).
	hostP model: (aspectBuffer aspectValue: #proxyHost).
	portP model: (aspectBuffer aspectValue: #proxyPort)! !
!SptProxySettingDialog categoriesFor: #model:!public! !

!SptProxySettingDialog categoriesFor: #createComponents!initializing!public! !

!SptProxySettingDialog categoriesFor: #model:!initializing!public! !

!SptProxySettingDialog class methodsFor!
defaultModel
	^SptHTTPProxySettings new! !
!SptProxySettingDialog class categoriesFor: #defaultModel!public! !

!SptProxySettingDialog class methodsFor!
icon
	^Icon fromId: 18 in: ShellLibrary default
! !
!SptProxySettingDialog class categoriesFor: #icon!public! !

!SptProxySettingDialog class categoriesFor: #defaultModel!models!public! !

!SptProxySettingDialog class categoriesFor: #icon!constants!public! !

SptBasicCredentials guid: (GUID fromString: '{1397B5C2-AE3A-4EC2-9F8A-8FA666F61400}')!

SptBasicCredentials guid: (GUID fromString: '{1397B5C2-AE3A-4EC2-9F8A-8FA666F61400}')!
SptBasicCredentials comment: ''!

SptBasicCredentials comment:
''!
!SptBasicCredentials categoriesForClass!Kernel-Objects! !
!SptBasicCredentials methodsFor!
httpHeaderValue
	"Answer the <String> header that authorizes the user in response to the server's challenge"

	^'Basic ' , (self class makeUserIdFor: self username password: self password)! !
!SptBasicCredentials categoriesFor: #httpHeaderValue!public! !

!SptBasicCredentials methodsFor!
isInProtectionSpace: aUrlString
	"Answer whether it is valid to use (or reuse) these credential for aUrlString"

	^challenge isInProtectionSpace: aUrlString! !
!SptBasicCredentials categoriesFor: #isInProtectionSpace:!public! !

!SptBasicCredentials categoriesFor: #httpHeaderValue!accessing!public! !

!SptBasicCredentials categoriesFor: #isInProtectionSpace:!public!testing! !

!SptBasicCredentials class methodsFor!
makeUserIdFor: aUsernameString password: aPasswordString
	| outStream |
	outStream := String writeStream.
	Base64Encoder new 
		encode: (aUsernameString , ':' , aPasswordString) asByteArray readStream
		to: outStream.
	^outStream contents! !
!SptBasicCredentials class categoriesFor: #makeUserIdFor:password:!public! !

!SptBasicCredentials class categoriesFor: #makeUserIdFor:password:!helpers!public! !

SptHTTPSConnection guid: (GUID fromString: '{3C0B36ED-E0F8-4664-8BC6-5646BCA19879}')!

SptHTTPSConnection guid: (GUID fromString: '{3C0B36ED-E0F8-4664-8BC6-5646BCA19879}')!
SptHTTPSConnection comment: ''!

SptHTTPSConnection comment:
''!
!SptHTTPSConnection categoriesForClass!Kernel-Objects! !
!SptHTTPSConnection methodsFor!
connectSocket
	| address tmp |
	address := InternetAddress fromString: self host.
	socket := SSLSocket port: self port address: address.
	socket connect.
	^socket! !
!SptHTTPSConnection categoriesFor: #connectSocket!public! !

!SptHTTPSConnection categoriesFor: #connectSocket!operations!private! !

!SptHTTPSConnection class methodsFor!
initialize
	"
	self initialize
	"

	super initialize! !
!SptHTTPSConnection class categoriesFor: #initialize!public! !

!SptHTTPSConnection class methodsFor!
uninitialize
	"
	self uninitialize
	"

	super uninitialize! !
!SptHTTPSConnection class categoriesFor: #uninitialize!public! !

!SptHTTPSConnection class categoriesFor: #initialize!initializing!public! !

!SptHTTPSConnection class categoriesFor: #uninitialize!initializing!public! !

SptHTTPProgress guid: (GUID fromString: '{F544C1C1-32A1-4E80-B5DF-18F1D2094ED3}')!

SptHTTPProgress guid: (GUID fromString: '{F544C1C1-32A1-4E80-B5DF-18F1D2094ED3}')!
SptHTTPProgress comment: '
This is a stub class that implements all the messages a request''s progress can receive.

	See: SptHTTPRequest(class)>>exampleProgress

Subclasses can implement the methods that they are interested in.

Two subclasses are provided:
	SptHTTPTriggerProgress ... for triggering notifications of the % of a download/upload complete
	SptHTTPValueProgress ... sets string descriptions of progress into a value model

'!

SptHTTPProgress comment:
'
This is a stub class that implements all the messages a request''s progress can receive.

	See: SptHTTPRequest(class)>>exampleProgress

Subclasses can implement the methods that they are interested in.

Two subclasses are provided:
	SptHTTPTriggerProgress ... for triggering notifications of the % of a download/upload complete
	SptHTTPValueProgress ... sets string descriptions of progress into a value model

'!
!SptHTTPProgress categoriesForClass!Kernel-Objects! !
!SptHTTPProgress methodsFor!
initialize
	super initialize! !
!SptHTTPProgress categoriesFor: #initialize!public! !

!SptHTTPProgress methodsFor!
onCompleted
	! !
!SptHTTPProgress categoriesFor: #onCompleted!public! !

!SptHTTPProgress methodsFor!
onConnected
	! !
!SptHTTPProgress categoriesFor: #onConnected!public! !

!SptHTTPProgress methodsFor!
onConnecting
	! !
!SptHTTPProgress categoriesFor: #onConnecting!public! !

!SptHTTPProgress methodsFor!
onReadBody
	! !
!SptHTTPProgress categoriesFor: #onReadBody!public! !

!SptHTTPProgress methodsFor!
onReadHeaders
	"Note: In the case of chunked transfer encoding, this will be sent both before and after reading the body"

	! !
!SptHTTPProgress categoriesFor: #onReadHeaders!public! !

!SptHTTPProgress methodsFor!
onReadingBody
	! !
!SptHTTPProgress categoriesFor: #onReadingBody!public! !

!SptHTTPProgress methodsFor!
onReadingHeaders
	"Note: In the case of chunked transfer encoding, this will be sent both before and after reading the body"

	! !
!SptHTTPProgress categoriesFor: #onReadingHeaders!public! !

!SptHTTPProgress methodsFor!
onReadingStatus
	"Note: This may be sent more than once if the server sends a informational CONTINUE response, "

	! !
!SptHTTPProgress categoriesFor: #onReadingStatus!public! !

!SptHTTPProgress methodsFor!
onReadStatus
	"Note: This may be sent more than once if the server sends a informational CONTINUE response, "

	! !
!SptHTTPProgress categoriesFor: #onReadStatus!public! !

!SptHTTPProgress methodsFor!
onRedirecting
	! !
!SptHTTPProgress categoriesFor: #onRedirecting!public! !

!SptHTTPProgress methodsFor!
onSendingEntity
	! !
!SptHTTPProgress categoriesFor: #onSendingEntity!public! !

!SptHTTPProgress methodsFor!
onSendingHeaders
	! !
!SptHTTPProgress categoriesFor: #onSendingHeaders!public! !

!SptHTTPProgress methodsFor!
onSentEntity
	! !
!SptHTTPProgress categoriesFor: #onSentEntity!public! !

!SptHTTPProgress methodsFor!
onSentHeaders
	! !
!SptHTTPProgress categoriesFor: #onSentHeaders!public! !

!SptHTTPProgress methodsFor!
onTimeout
	! !
!SptHTTPProgress categoriesFor: #onTimeout!public! !

!SptHTTPProgress methodsFor!
progressChanged: aNumber
	Notification deprecated! !
!SptHTTPProgress categoriesFor: #progressChanged:!public! !

!SptHTTPProgress methodsFor!
read: cumulativeNumOfBytes of: totalNumOfBytesOrNil
	"totalNumOfBytesOrNil will be nil unless we received a content-length header.
		-For HTTP1.0 this can be common ... we are expected to read from the server until it closes its end of the socket
		-For HTTP1.1 this will occur if the server is using chunked transfer-encoding"

	! !
!SptHTTPProgress categoriesFor: #read:of:!public! !

!SptHTTPProgress methodsFor!
sent: cumulativeNumOfBytes of: totalNumOfBytes
	! !
!SptHTTPProgress categoriesFor: #sent:of:!public! !

!SptHTTPProgress categoriesFor: #initialize!initializing!public! !

!SptHTTPProgress categoriesFor: #onCompleted!event handling!public! !

!SptHTTPProgress categoriesFor: #onConnected!event handling!public! !

!SptHTTPProgress categoriesFor: #onConnecting!event handling!public! !

!SptHTTPProgress categoriesFor: #onReadBody!event handling!public! !

!SptHTTPProgress categoriesFor: #onReadHeaders!event handling!public! !

!SptHTTPProgress categoriesFor: #onReadingBody!event handling!public! !

!SptHTTPProgress categoriesFor: #onReadingHeaders!event handling!public! !

!SptHTTPProgress categoriesFor: #onReadingStatus!event handling!public! !

!SptHTTPProgress categoriesFor: #onReadStatus!event handling!public! !

!SptHTTPProgress categoriesFor: #onRedirecting!event handling!public! !

!SptHTTPProgress categoriesFor: #onSendingEntity!event handling!public! !

!SptHTTPProgress categoriesFor: #onSendingHeaders!event handling!public! !

!SptHTTPProgress categoriesFor: #onSentEntity!event handling!public! !

!SptHTTPProgress categoriesFor: #onSentHeaders!event handling!public! !

!SptHTTPProgress categoriesFor: #onTimeout!event handling!public! !

!SptHTTPProgress categoriesFor: #progressChanged:!accessing!public! !

!SptHTTPProgress categoriesFor: #read:of:!accessing!public! !

!SptHTTPProgress categoriesFor: #sent:of:!accessing!public! !

SptHTTPProgressDev guid: (GUID fromString: '{F6998E0D-ED90-4EE0-84A2-AAF78441E314}')!

SptHTTPProgressDev guid: (GUID fromString: '{F6998E0D-ED90-4EE0-84A2-AAF78441E314}')!
SptHTTPProgressDev comment: '
These classes are used for development and testing purposes.

see SptHTTPRequest(class)>>exampleProgress'!

SptHTTPProgressDev comment:
'
These classes are used for development and testing purposes.

see SptHTTPRequest(class)>>exampleProgress'!
!SptHTTPProgressDev categoriesForClass!Kernel-Objects! !
SptHTTPTriggerProgress guid: (GUID fromString: '{48B429D9-854C-46BB-BD3A-56367EFDFED1}')!

SptHTTPTriggerProgress guid: (GUID fromString: '{48B429D9-854C-46BB-BD3A-56367EFDFED1}')!
SptHTTPTriggerProgress comment: ''!

SptHTTPTriggerProgress comment:
''!
!SptHTTPTriggerProgress categoriesForClass!Kernel-Objects! !
!SptHTTPTriggerProgress methodsFor!
progressChanged: aNumber
	request trigger: #progressChanged: with: aNumber
	"valueModel value: aNumber"! !
!SptHTTPTriggerProgress categoriesFor: #progressChanged:!public! !

!SptHTTPTriggerProgress methodsFor!
read: cumulativeNumOfBytes of: totalNumOfBytes
	"totalNumOfBytesOrNil will be nil unless we received a content-length header.
		-For HTTP1.0 this can be common ... we are expected to read from the server until it closes its end of the socket
		-For HTTP1.1 this will occur if the server is using chunked transfer-encoding"

	| total |
	total := totalNumOfBytes ifNil: [50000] ifNotNil: [:o | totalNumOfBytes].
	self progressChanged: cumulativeNumOfBytes * 100 // total! !
!SptHTTPTriggerProgress categoriesFor: #read:of:!public! !

!SptHTTPTriggerProgress methodsFor!
sent: cumulativeNumOfBytes of: totalNumOfBytes
	self progressChanged: cumulativeNumOfBytes * 100 // totalNumOfBytes! !
!SptHTTPTriggerProgress categoriesFor: #sent:of:!public! !

!SptHTTPTriggerProgress categoriesFor: #progressChanged:!accessing!public! !

!SptHTTPTriggerProgress categoriesFor: #read:of:!accessing!public! !

!SptHTTPTriggerProgress categoriesFor: #sent:of:!accessing!public! !

SptHTTPValueProgress guid: (GUID fromString: '{D4A397F6-970A-4875-A149-680790BD4279}')!

SptHTTPValueProgress guid: (GUID fromString: '{D4A397F6-970A-4875-A149-680790BD4279}')!
SptHTTPValueProgress comment: ''!

SptHTTPValueProgress comment:
''!
!SptHTTPValueProgress categoriesForClass!Kernel-Objects! !
!SptHTTPValueProgress methodsFor!
initialize
	super initialize.
	percentageValue := ValueHolder new.
	stateValue := ValueHolder new! !
!SptHTTPValueProgress categoriesFor: #initialize!public! !

!SptHTTPValueProgress methodsFor!
onCompleted
	percentageValue value: 0.
	stateValue value: ''! !
!SptHTTPValueProgress categoriesFor: #onCompleted!public! !

!SptHTTPValueProgress methodsFor!
onConnected
	stateValue value: 'Connected'! !
!SptHTTPValueProgress categoriesFor: #onConnected!public! !

!SptHTTPValueProgress methodsFor!
onConnecting
	stateValue value: 'Connecting'! !
!SptHTTPValueProgress categoriesFor: #onConnecting!public! !

!SptHTTPValueProgress methodsFor!
onReadingBody
	stateValue value: 'Reading'! !
!SptHTTPValueProgress categoriesFor: #onReadingBody!public! !

!SptHTTPValueProgress methodsFor!
onReadingHeaders
	stateValue value: 'Reading'! !
!SptHTTPValueProgress categoriesFor: #onReadingHeaders!public! !

!SptHTTPValueProgress methodsFor!
onSendingEntity
	stateValue value: 'Sending'! !
!SptHTTPValueProgress categoriesFor: #onSendingEntity!public! !

!SptHTTPValueProgress methodsFor!
onSendingHeaders
	stateValue value: 'Sending'! !
!SptHTTPValueProgress categoriesFor: #onSendingHeaders!public! !

!SptHTTPValueProgress methodsFor!
percentageValue
	^percentageValue! !
!SptHTTPValueProgress categoriesFor: #percentageValue!public! !

!SptHTTPValueProgress methodsFor!
percentageValue: anObject
	percentageValue := anObject! !
!SptHTTPValueProgress categoriesFor: #percentageValue:!public! !

!SptHTTPValueProgress methodsFor!
progressChanged: aNumber
	percentageValue value: aNumber! !
!SptHTTPValueProgress categoriesFor: #progressChanged:!public! !

!SptHTTPValueProgress methodsFor!
read: cumulativeNumOfBytes of: totalNumOfBytes
	"totalNumOfBytesOrNil will be nil unless we received a content-length header.
		-For HTTP1.0 this can be common ... we are expected to read from the server until it closes its end of the socket
		-For HTTP1.1 this will occur if the server is using chunked transfer-encoding"

	| total |
	total := totalNumOfBytes ifNil: [50000] ifNotNil: [:o | totalNumOfBytes].
	self progressChanged: cumulativeNumOfBytes * 100 // total! !
!SptHTTPValueProgress categoriesFor: #read:of:!public! !

!SptHTTPValueProgress methodsFor!
sent: cumulativeNumOfBytes of: totalNumOfBytes
	self progressChanged: cumulativeNumOfBytes * 100 // totalNumOfBytes! !
!SptHTTPValueProgress categoriesFor: #sent:of:!public! !

!SptHTTPValueProgress methodsFor!
stateValue
	^stateValue! !
!SptHTTPValueProgress categoriesFor: #stateValue!public! !

!SptHTTPValueProgress methodsFor!
stateValue: anObject
	stateValue := anObject! !
!SptHTTPValueProgress categoriesFor: #stateValue:!public! !

!SptHTTPValueProgress categoriesFor: #initialize!initializing!public! !

!SptHTTPValueProgress categoriesFor: #onCompleted!event handling!public! !

!SptHTTPValueProgress categoriesFor: #onConnected!event handling!public! !

!SptHTTPValueProgress categoriesFor: #onConnecting!event handling!public! !

!SptHTTPValueProgress categoriesFor: #onReadingBody!event handling!public! !

!SptHTTPValueProgress categoriesFor: #onReadingHeaders!event handling!public! !

!SptHTTPValueProgress categoriesFor: #onSendingEntity!event handling!public! !

!SptHTTPValueProgress categoriesFor: #onSendingHeaders!event handling!public! !

!SptHTTPValueProgress categoriesFor: #percentageValue!accessing!public! !

!SptHTTPValueProgress categoriesFor: #percentageValue:!accessing!public! !

!SptHTTPValueProgress categoriesFor: #progressChanged:!accessing!public! !

!SptHTTPValueProgress categoriesFor: #read:of:!accessing!public! !

!SptHTTPValueProgress categoriesFor: #sent:of:!accessing!public! !

!SptHTTPValueProgress categoriesFor: #stateValue!accessing!public! !

!SptHTTPValueProgress categoriesFor: #stateValue:!accessing!public! !

SptHTTPTestProgress guid: (GUID fromString: '{32463B34-1C80-419A-A047-E7044C49C077}')!

SptHTTPTestProgress guid: (GUID fromString: '{32463B34-1C80-419A-A047-E7044C49C077}')!
SptHTTPTestProgress comment: ''!

SptHTTPTestProgress comment:
''!
!SptHTTPTestProgress categoriesForClass!Kernel-Objects! !
!SptHTTPTestProgress methodsFor!
doesNotUnderstand: aMessage
	sentMessages add: aMessage! !
!SptHTTPTestProgress categoriesFor: #doesNotUnderstand:!public! !

!SptHTTPTestProgress methodsFor!
initialize
	super initialize.
	sentMessages := OrderedCollection new! !
!SptHTTPTestProgress categoriesFor: #initialize!public! !

!SptHTTPTestProgress methodsFor!
sentMessages
	^sentMessages! !
!SptHTTPTestProgress categoriesFor: #sentMessages!public! !

!SptHTTPTestProgress categoriesFor: #doesNotUnderstand:!exceptions!public! !

!SptHTTPTestProgress categoriesFor: #initialize!initializing!public! !

!SptHTTPTestProgress categoriesFor: #sentMessages!accessing!public! !

SptHTTPTranscriptProgress guid: (GUID fromString: '{B51BE21D-DD3A-47E1-AB99-FE183DD59D11}')!

SptHTTPTranscriptProgress guid: (GUID fromString: '{B51BE21D-DD3A-47E1-AB99-FE183DD59D11}')!
SptHTTPTranscriptProgress comment: ''!

SptHTTPTranscriptProgress comment:
''!
!SptHTTPTranscriptProgress categoriesForClass!Kernel-Objects! !
!SptHTTPTranscriptProgress methodsFor!
doesNotUnderstand: aMessage
	stream
		nextPutAll: 'SptHTTPTranscriptProgress: ' , request hash displayString , ' ' 
					, (request connection 
							ifNil: ['nil']
							ifNotNil: [:c | c socket displayString , c socket hash displayString]) 
						, ' ' , aMessage selector printString 
					, ' ' , aMessage arguments printString;
		cr.
	nextProgress notNil ifTrue: [aMessage forwardTo: nextProgress]! !
!SptHTTPTranscriptProgress categoriesFor: #doesNotUnderstand:!public! !

!SptHTTPTranscriptProgress methodsFor!
initialize
	super initialize.
	stream := Transcript! !
!SptHTTPTranscriptProgress categoriesFor: #initialize!public! !

!SptHTTPTranscriptProgress methodsFor!
nextProgress: anObject
	nextProgress := anObject! !
!SptHTTPTranscriptProgress categoriesFor: #nextProgress:!public! !

!SptHTTPTranscriptProgress methodsFor!
stream: anObject
	stream := anObject! !
!SptHTTPTranscriptProgress categoriesFor: #stream:!public! !

!SptHTTPTranscriptProgress categoriesFor: #doesNotUnderstand:!exceptions!public! !

!SptHTTPTranscriptProgress categoriesFor: #initialize!initializing!public! !

!SptHTTPTranscriptProgress categoriesFor: #nextProgress:!accessing!public! !

!SptHTTPTranscriptProgress categoriesFor: #stream:!accessing!public! !

"Binary Globals"!

"Resources"!

(ResourceIdentifier class: SptHTTPAuthorizationDialog name: 'Default view') assign: (Object fromBinaryStoreBytes:
(ByteArray fromHexString: '2153544220312046020C0001000000566965775265736F75726365000000000E0124005354425265736F757263655354424279746541727261794163636573736F7250726F7879000000007200000086110000215354422031204E080C000A0000005354425669657750726F7879000000009A000000000000005200000010000000446F6C7068696E204D56502042617365520000000A0000004469616C6F6756696577620000001E000000000000000000000062000000020000000100900101000200A001000000000000000000000000000087000000000000000000000000000000A001000006070C00426F726465724C61796F7574000000000100000001000000000000009A010000000000009A00000000000000C0010000520000000D0000005265666572656E636556696577620000000E00000000000000A0010000620000000200000082000000040000000000004401000200200200000000000000000000000000000700000000000000000000000000000020020000060212005265736F757263654964656E746966696572000000009A00000000000000C0010000520000000900000050726573656E74657252000000160000004F4B2043616E63656C20627574746F6E20626C6F636B0000000006010F004D65737361676553657175656E636500000000CA00000000000000D0000000620000000100000006030B004D65737361676553656E6400000000BA00000000000000520000001000000063726561746541743A657874656E743A620000000200000006020500506F696E7400000000150000009B0100006203000000000000F7020000470000002002000006010F0057494E444F57504C4143454D454E5400000000720000002C0000002C0000000000000001000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0A000000CD00000085010000F000000062000000000000006203000000000000C1000000C10000000000000015000000000000000000000000000000EA000000000000000001000062000000080000009A010000000000009A00000000000000C001000052000000080000005465787445646974620000001000000000000000A00100006200000002000000820000000400000080000144010000000004000000000000000000000000000007000000000000000000000000000000000400000000000082000000040000006F30E27706020D004E756C6C436F6E76657274657200000000000000000000000003000000D202000000000000CA00000000000000D000000062000000030000001203000000000000300300006200000002000000620300000000000023010000650000006203000000000000C301000033000000000400001203000000000000BA00000000000000520000000F00000073656C656374696F6E52616E67653A620000000100000006030800496E74657276616C00000000030000000100000003000000000400001203000000000000BA00000000000000520000000F0000006973546578744D6F6469666965643A620000000100000020000000000400009203000000000000720000002C0000002C0000000000000001000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF9100000032000000720100004B000000CA00000000000000D00000006200000000000000D003000000000000130000005200000004000000736974659A0100000000000010040000620000001000000000000000A0010000620000000200000082000000040000008000014401000000F005000000000000000000000000000007000000000000000000000000000000F00500000000000082000000040000006F30E2777204000000000000000000000000000003000000D202000000000000CA00000000000000D000000062000000030000001203000000000000300300006200000002000000620300000000000023010000A10000006203000000000000C301000033000000F005000012030000000000001005000062000000010000004205000000000000030000000100000003000000F0050000120300000000000070050000620000000100000020000000F00500009203000000000000720000002C0000002C0000000000000001000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF91000000500000007201000069000000CA00000000000000D0000000D0050000D0030000000000001300000052000000050000007265616C6D9A0100000000000010040000620000001000000000000000A001000062000000020000008200000004000000A0000144010400005007000000000000000000000000000007000000000000000000000000000000500700000000000082000000040000006F30E2777204000000000000000000000000000001000000D202000000000000CA00000000000000D000000062000000030000001203000000000000300300006200000002000000620300000000000023010000370100006203000000000000C301000033000000500700001203000000000000100500006200000001000000420500000000000003000000010000000300000050070000120300000000000070050000620000000100000020000000500700009203000000000000720000002C0000002C0000000000000001000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF910000009B00000072010000B4000000CA00000000000000D0000000D0050000D003000000000000130000005200000004000000706173739A0100000000000010040000620000001000000000000000A0010000620000000200000082000000040000008000014401040000B008000000000000000000000000000007000000000000000000000000000000B00800000000000082000000040000006F30E2777204000000000000000000000000000001000000D202000000000000CA00000000000000D000000062000000030000001203000000000000300300006200000002000000620300000000000023010000F10000006203000000000000C301000033000000B008000012030000000000001005000062000000010000004205000000000000030000000100000003000000B0080000120300000000000070050000620000000100000020000000B00800009203000000000000720000002C0000002C0000000000000001000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF91000000780000007201000091000000CA00000000000000D0000000D0050000D003000000000000130000005200000004000000757365720602090052656374616E676C6500000000620300000000000015000000150000006203000000000000150000001500000000000000000000000000000000000000732D0000000000000000000000000000000000000100000000000000000000000603090053656D6170686F7265000000000000000000000000010000000000000082000000040000004C73E177D202000000000000CA00000000000000D00000006200000003000000120300000000000030030000620000000200000062030000000000000B0000000B00000062030000000000002B03000027020000A00100001203000000000000BA000000000000005200000005000000746578743A62000000010000005200000016000000456E746572204E6574776F726B2050617373776F7264A00100001203000000000000BA0000000000000052000000080000006D656E754261723A620000000100000000000000A00100009203000000000000720000002C0000002C0000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF05000000050000009A01000018010000CA00000000000000D0000000620000000A000000200200009A010000000000009A00000000000000C0010000520000000A00000053746174696354657874620000001000000000000000A0010000620000000200000082000000040000000001004401000000C00B000000000000000000000000000007000000000000000000000000000000C00B00000000000082000000040000007073E1777204000000000000000000000000000000000000D202000000000000CA00000000000000D0000000620000000200000012030000000000003003000062000000020000006203000000000000790000002900000062030000000000002702000033000000C00B00001203000000000000000B000062000000010000005200000028000000506C65617365207479706520796F75722075736572206E616D6520616E642070617373776F72642EC00B00009203000000000000720000002C0000002C0000000000000001000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF3C000000140000004F0100002D000000CA00000000000000D0000000D0050000D003000000000000130000009A01000000000000D00B0000620000001000000000000000A0010000620000000200000082000000040000000001004401000000100D000000000000000000000000000007000000000000000000000000000000100D00000000000082000000040000007073E1777204000000000000000000000000000000000000D202000000000000CA00000000000000D000000062000000020000001203000000000000300300006200000002000000620300000000000079000000650000006203000000000000A100000033000000100D00001203000000000000000B000062000000010000005200000005000000536974653A100D00009203000000000000720000002C0000002C0000000000000001000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF3C000000320000008C0000004B000000CA00000000000000D0000000D0050000D003000000000000130000009A01000000000000D00B0000620000001000000000000000A0010000620000000200000082000000040000000001004401000000400E000000000000000000000000000007000000000000000000000000000000400E00000000000082000000040000007073E1777204000000000000000000000000000000000000D202000000000000CA00000000000000D000000062000000020000001203000000000000300300006200000002000000620300000000000079000000A10000006203000000000000A100000033000000400E00001203000000000000000B0000620000000100000052000000060000005265616C6D3A400E00009203000000000000720000002C0000002C0000000000000001000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF3C000000500000008C00000069000000CA00000000000000D0000000D0050000D003000000000000130000009A01000000000000D00B0000620000001000000000000000A0010000620000000200000082000000040000000001004401000000700F000000000000000000000000000007000000000000000000000000000000700F00000000000082000000040000007073E1777204000000000000000000000000000000000000D202000000000000CA00000000000000D000000062000000020000001203000000000000300300006200000002000000620300000000000079000000F10000006203000000000000A100000033000000700F00001203000000000000000B00006200000001000000520000000A00000055736572204E616D653A700F00009203000000000000720000002C0000002C0000000000000001000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF3C000000780000008C00000091000000CA00000000000000D0000000D0050000D003000000000000130000009A01000000000000D00B0000620000001000000000000000A0010000620000000200000082000000040000000001004401000000A010000000000000000000000000000007000000000000000000000000000000A01000000000000082000000040000007073E1777204000000000000000000000000000000000000D202000000000000CA00000000000000D000000062000000020000001203000000000000300300006200000002000000620300000000000079000000370100006203000000000000A100000033000000A01000001203000000000000000B00006200000001000000520000000900000050617373776F72643AA01000009203000000000000720000002C0000002C0000000000000001000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF3C0000009B0000008C000000B4000000CA00000000000000D0000000D0050000D00300000000000013000000B00800005007000000040000F0050000D00300000000000015000000460504000300000049636F6E0000000000000000100000000E02110053544253696E676C65746F6E50726F7879000000009A000000000000005200000007000000446F6C7068696E5200000018000000496D61676552656C617469766546696C654C6F6361746F72BA00000000000000520000000700000063757272656E74520000000E0000004469616C6F67566965772E69636F0E021F0053544245787465726E616C5265736F757263654C69627261727950726F7879000000005200000010000000646F6C7068696E64723030352E646C6C00000000'))!

(ResourceIdentifier class: SptProxySettingDialog name: 'Default view') assign: (Object fromBinaryStoreBytes:
(ByteArray fromHexString: '2153544220312046020C0001000000566965775265736F75726365000000000E0124005354425265736F757263655354424279746541727261794163636573736F7250726F78790000000072000000BA0F0000215354422031204E080C000A0000005354425669657750726F7879000000009A000000000000005200000010000000446F6C7068696E204D56502042617365520000000A0000004469616C6F6756696577620000001E000000000000000000000062000000020000000100900101000200A0010000000000000000000006020500506F696E740000000009020000E101000087020000000000000000000000000000A001000006010D004672616D696E674C61796F757400000000EA00000000000000F0000000620000000E0000009A010000000000009A00000000000000C0010000520000000D0000005265666572656E636556696577620000000E00000000000000A0010000620000000200000082000000040000000000004401000200600200000000000000000000000000000700000000000000000000000000000060020000060212005265736F757263654964656E746966696572000000009A00000000000000C0010000520000000900000050726573656E74657252000000160000004F4B2043616E63656C20627574746F6E20626C6F636B0000000006010F004D65737361676553657175656E636500000000CA00000000000000D0000000620000000100000006030B004D65737361676553656E6400000000BA00000000000000520000001000000063726561746541743A657874656E743A62000000020000000202000000000000A10000004B010000020200000000000055010000470000006002000006010F0057494E444F57504C4143454D454E5400000000720000002C0000002C0000000000000001000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF50000000A5000000FA000000C800000062000000000000000202000000000000C1000000C1000000000000001500000046081200010000004672616D696E67436F6E73747261696E747300000000BA00000000000000520000000E0000006669786564566965775269676874ADFEFFFFBA0000000000000052000000100000006669786564506172656E745269676874F9FFFFFFBA0000000000000052000000110000006669786564506172656E74426F74746F6D9DFFFFFFBA00000000000000520000000C000000666978656456696577546F70470000009A010000000000009A00000000000000C0010000520000000A00000053746174696354657874620000001000000000000000A0010000620000000200000082000000040000000001004401000000B004000000000000000000000000000007000000000000000000000000000000B0040000000000008200000004000000DB10E27706020D004E756C6C436F6E766572746572000000000000000000000000000000001203000000000000CA00000000000000D00000006200000002000000520300000000000070030000620000000200000002020000000000001F0000008D00000002020000000000006500000033000000B00400005203000000000000BA000000000000005200000005000000746578743A62000000010000005200000005000000486F73743AB0040000C203000000000000720000002C0000002C0000000000000001000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0F00000046000000410000005F000000CA00000000000000D000000062000000000000000004000000000000130000001204000000000000BA00000000000000520000000F0000006669786564506172656E744C6566741F000000BA00000000000000520000000D0000006669786564566965774C65667465000000BA00000000000000520000000E0000006669786564506172656E74546F708D00000090040000330000009A010000000000009A00000000000000C0010000520000000800000047726F7570426F78620000000E00000000000000A0010000620000000200000082000000040000000700004441000000B006000000000000000000000000000007000000000000000000000000000000B0060000000000008200000004000000D304E2771203000000000000CA00000000000000D00000006200000002000000520300000000000070030000620000000200000002020000000000000B0000005B0000000202000000000000EB010000C9000000B00600005203000000000000C00500006200000001000000520000000F00000050726F78792053657474696E67733AB0060000C203000000000000720000002C0000002C0000000000000001000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF050000002D000000FA00000091000000CA00000000000000D0000000300600000004000000000000130000001204000000000000500600000B00000050040000F9FFFFFF900600005B00000090040000C90000009A010000000000009A00000000000000C001000052000000080000005465787445646974620000001000000000000000A0010000620000000200000082000000040000000020014401040000000800000000000000000000000000000700000000000000000000000000000000080000000000008200000004000000A627E27706030D00496E7465676572546F546578740000000000000000520000000000000000000000010000001203000000000000CA00000000000000D000000062000000030000005203000000000000700300006200000002000000020200000000000097000000C900000002020000000000004901000033000000000800005203000000000000BA00000000000000520000000F00000073656C656374696F6E52616E67653A620000000100000006030800496E74657276616C00000000030000000100000003000000000800005203000000000000BA00000000000000520000000F0000006973546578744D6F6469666965643A62000000010000002000000000080000C203000000000000720000002C0000002C0000000000000001000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF4B00000064000000EF0000007D000000CA00000000000000D0000000300600000004000000000000130000001204000000000000500600009700000050040000E3FFFFFF90060000C900000090040000330000009A010000000000009A00000000000000C00100005200000008000000436865636B426F78620000001000000000000000A0010000620000000200000082000000040000000320014401000000F009000046040B000200000056616C7565486F6C6465720000000000000000000000000E02110053544253696E676C65746F6E50726F7879000000009A000000000000005200000007000000446F6C7068696E520000000C000000536561726368506F6C696379BA0000000000000052000000050000006E6576657220000000000000000000000007000000000000000000000000000000F0090000000000008200000004000000D304E27722050000000000000000000000000000000000001203000000000000CA00000000000000D0000000620000000200000052030000000000007003000062000000020000000202000000000000150000000B0000000202000000000000E30000003D000000F00900005203000000000000C0050000620000000100000052000000090000005573652050726F7879F0090000C203000000000000720000002C0000002C0000000000000001000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0A000000050000007B00000023000000CA00000000000000D0000000300600000004000000000000130000001204000000000000500600001500000070060000E3000000900600000B000000900400003D0000009A01000000000000C0040000620000001000000000000000A0010000620000000200000082000000040000000001004401000000E00B000000000000000000000000000007000000000000000000000000000000E00B0000000000008200000004000000DB10E27722050000000000000000000000000000000000001203000000000000CA00000000000000D00000006200000002000000520300000000000070030000620000000200000002020000000000001F000000D300000002020000000000005B00000033000000E00B00005203000000000000C005000062000000010000005200000005000000506F72743AE00B0000C203000000000000720000002C0000002C0000000000000001000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0F000000690000003C00000082000000CA00000000000000D0000000300600000004000000000000130000001204000000000000500600001F000000700600005B00000090060000D300000090040000330000009A0100000000000010080000620000001000000000000000A0010000620000000200000082000000040000008000014401040000200D000000000000000000000000000007000000000000000000000000000000200D0000000000008200000004000000A627E27722050000000000000000000000000000010000001203000000000000CA00000000000000D0000000620000000300000052030000000000007003000062000000020000000202000000000000970000008300000002020000000000004901000033000000200D000052030000000000002009000062000000010000005209000000000000030000000100000003000000200D0000520300000000000080090000620000000100000020000000200D0000C203000000000000720000002C0000002C0000000000000001000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF4B00000041000000EF0000005A000000CA00000000000000D0000000300600000004000000000000130000001204000000000000500600009700000050040000E3FFFFFF90060000830000009004000033000000EA00000000000000000100006200000006000000000800005200000004000000706F7274200D00005200000004000000686F7374F0090000520000000800000075736550726F787900000000000000000000000000000000000000001D620000000000000000000000000000020200000000000009020000E10100000100000000000000000000000603090053656D6170686F7265000000000000000000000000010000000000000082000000040000000127E2771203000000000000CA00000000000000D00000006200000003000000520300000000000070030000620000000200000002020000000000000B0000000B000000020200000000000009020000E1010000A00100005203000000000000C005000062000000010000005200000013000000485454502050726F78792053657474696E6773A00100005203000000000000BA0000000000000052000000080000006D656E754261723A620000000100000000000000A0010000C203000000000000720000002C0000002C0000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF050000000500000009010000F5000000CA00000000000000D0000000620000000700000060020000F0090000B0040000E00B0000200D000000080000B0060000000400000000000015000000460504000300000049636F6E0000000000000000100000000E02110053544253696E676C65746F6E50726F7879000000009A000000000000005200000007000000446F6C7068696E5200000018000000496D61676552656C617469766546696C654C6F6361746F72BA00000000000000520000000700000063757272656E74520000000E0000004469616C6F67566965772E69636F0E021F0053544245787465726E616C5265736F757263654C69627261727950726F7879000000005200000010000000646F6C7068696E64723030352E646C6C00000000'))!

!

"22:58:26, 17 November 2004: Loading package 'soundex' from: C:\Documents and Settings\Ted\Desktop\Mugpunters\Placepot\Ted Bracht\soundex.pac"!

"Class Definitions"!

Object subclass: #Soundex
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

"Global Aliases"!

"Loose Methods"!

"End of package definition"!

"Source Globals"!

"Classes"!

Soundex guid: (GUID fromString: '{838C152F-1B81-447E-9AD6-B3DCA88A53F4}')!

Soundex guid: (GUID fromString: '{838C152F-1B81-447E-9AD6-B3DCA88A53F4}')!
Soundex comment: 'Soundex is a simple algorithm for phoenetic string-matching.  It is most
useful when you do not know the exact spelling of a string you are searching
for.  For example, telephone operators can use this to look up a name without
trying to figure out the exact spelling of the name of the person you are trying
to contact.

User-level methods are:

	Soundex class>>#encodeString:
		Given an ordinary Smalltalk string, answer the corresponding
Soundex code (also a String).

	Soundex class>>#match:against:
		Match a string against a set of possibilities using the Soundex
algorithm.  Answer the possibilities that matched.

If you would like to compare two strings rather than one string against a collection
of possibilites, you can compare the codes created by #encodeString: with #=.
For example:(Soundex encodeString: ''hello'') = (Soundex encodeString: ''hulloo'').

Send comments/questions to: ajb@tiac.net
-- Andrew Brault
'!

Soundex comment:
'Soundex is a simple algorithm for phoenetic string-matching.  It is most
useful when you do not know the exact spelling of a string you are searching
for.  For example, telephone operators can use this to look up a name without
trying to figure out the exact spelling of the name of the person you are trying
to contact.

User-level methods are:

	Soundex class>>#encodeString:
		Given an ordinary Smalltalk string, answer the corresponding
Soundex code (also a String).

	Soundex class>>#match:against:
		Match a string against a set of possibilities using the Soundex
algorithm.  Answer the possibilities that matched.

If you would like to compare two strings rather than one string against a collection
of possibilites, you can compare the codes created by #encodeString: with #=.
For example:(Soundex encodeString: ''hello'') = (Soundex encodeString: ''hulloo'').

Send comments/questions to: ajb@tiac.net
-- Andrew Brault
'!
!Soundex categoriesForClass!No category! !
!Soundex class methodsFor!
encodeString: string
	"Encode 'string' into it's Soundex representation.  Answer the
encoded string."
	| stream uppercase code |
	string isEmpty ifTrue: [^String new].
	stream := WriteStream on: String new.
	uppercase := string collect: [:each | each asUppercase].
	stream nextPut: uppercase first.
	uppercase
		inject: uppercase first
		into: [:previous :each |
			(stream position < 4 and: [each isLetter 
					and: [each ~= previous and: [each codePoint < 128]]]) ifTrue: [
				code := self soundexCodeFor: each.
				code isNil ifFalse: [stream nextPut: code]].
			each].
	^stream contents.! !
!Soundex class categoriesFor: #encodeString:!public! !

!Soundex class methodsFor!
match: string against: possibilities
	"'string' is an ordinary string and 'possibilities' is a collection of ordinary
strings to match against.  Answer a collection (possibly empty) of those elements
from 'possibilities' that matched 'string' according to the Soundex algorithm."
	| stringCode |
	stringCode := self encodeString: string.
	^possibilities select: [:each | stringCode = (self encodeString: each)].! !
!Soundex class categoriesFor: #match:against:!public! !

!Soundex class methodsFor!
soundexCodeFor: letter
	"letter must be an uppercase letter."
	| code |
	code := '*123*12**22455*12623*1*2*2'
		at: letter codePoint - ##($A codePoint - 1).
	^code == $*
		ifTrue: [nil]
		ifFalse: [code].! !
!Soundex class categoriesFor: #soundexCodeFor:!public! !

!Soundex class categoriesFor: #encodeString:!private!utility! !

!Soundex class categoriesFor: #match:against:!private!utility! !

!Soundex class categoriesFor: #soundexCodeFor:!encoding!private! !

"Binary Globals"!

"Resources"!

!

"22:58:29, 17 November 2004: Loading package 'HorseRaceBetting' from: C:\Documents and Settings\Ted\Desktop\Mugpunters\Placepot\Ted Bracht\HorseRaceBetting.pac"!

"Class Definitions"!

Object subclass: #HRBFMeeting
	instanceVariableNames: 'races'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #HRBFOdds
	instanceVariableNames: 'time back lay turnover totalTurnover'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #HRDiviEst
	instanceVariableNames: 'descr lines divi return profit'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #HRImport
	instanceVariableNames: 'contents fileName'
	classVariableNames: 'SpecialChars'
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #HRMailer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #HROddsSeries
	instanceVariableNames: 'series'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #HRPageFiler
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #HRRPLogon
	instanceVariableNames: 'username password cookieJar'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #ImperialDistance
	instanceVariableNames: 'yards'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

HRImport subclass: #HRImportBetfairDay
	instanceVariableNames: 'rawRaces meetings'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

HRImport subclass: #HRImportBetfairMenu
	instanceVariableNames: 'nodes'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

HRImport subclass: #HRImportBetfairNag
	instanceVariableNames: 'nag time raceTO nagTO'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

HRImport subclass: #HRImportBetfairRace
	instanceVariableNames: 'rawNags race time'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

HRImport subclass: #HRImportPPEsts
	instanceVariableNames: 'meeting'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

HRImport subclass: #HRImportRPPreRaceDay
	instanceVariableNames: 'meetingURLs'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

HRImport subclass: #HRImportRPPreRaceMeeting
	instanceVariableNames: 'meeting raceURLs'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

HRImport subclass: #HRImportRPRace
	instanceVariableNames: 'contentsStream race rawNags'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

HRImport subclass: #HRImportSLPreMeetingNR
	instanceVariableNames: 'meetings rawMeetings meeting'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

HRImport subclass: #HRImportToteEarlyResult
	instanceVariableNames: 'meeting rawRaces'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

HRImport subclass: #HRImportTotePPDay
	instanceVariableNames: 'meetingURLs meetingURLIDs'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

HRImport subclass: #HRImportTotePPRace
	instanceVariableNames: 'meeting leg poolTotal poolBF bets'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

HRImportBetfairMenu subclass: #HRImportBetfairMainMenu
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

HRImportBetfairMenu subclass: #HRImportBetfairMeetingMenu
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

HRImportRPRace subclass: #HRImportRPPostRaceRace
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

HRImportRPRace subclass: #HRImportRPPreRaceRace
	instanceVariableNames: 'rpSpotlight noOdds url course meeting'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

HRImportRPPostRaceRace subclass: #HRImportSLLiveShow
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

HRImportRPPostRaceRace subclass: #HRImportSLPostRaceRace
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

HRImportRPPreRaceRace subclass: #HRImportSLPreRaceRace
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

HRImportToteEarlyResult subclass: #HRImportSLEarlyResult
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

HRPageFiler subclass: #HRRPPageFiler
	instanceVariableNames: 'cookieJar'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Model subclass: #HRApplication
	instanceVariableNames: 'meetings db proxySettings rpCookieJar rpUsername rpPassword courses oodb rememberSort detailLogging fullUnlock rpProxySettings'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: 'current'!

Model subclass: #HRLogger
	instanceVariableNames: 'stream'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: 'current'!

Model subclass: #HRMeetingAbs
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: 'vocabDictionary'!

Model subclass: #HRMtgDashboardModel
	instanceVariableNames: 'meeting remainingLinesCollection remainingPotCollection slipLinesResult remainingOdds scheduleItems'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Model subclass: #HRNagAbs
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: 'vocabDictionary'!

Model subclass: #HRPPSlipModel
	instanceVariableNames: 'meeting'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Model subclass: #HRRaceAbs
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: 'vocabDictionary'!

Model subclass: #HRScheduleItem
	instanceVariableNames: 'date time process object params'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Model subclass: #HRScheduler
	instanceVariableNames: 'scheduleItems date'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: 'current process'!

Model subclass: #HRSMSSlipModel
	instanceVariableNames: 'addresses file text'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

HRMeetingAbs subclass: #HRMeeting
	instanceVariableNames: 'course going dateString totePPPool totePPCF totePPDivi races date totePPURL totePPBF csvFile toteERURL myStake myPlaceOdds toteURLID slCourseName bfAbbr'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

HRMeetingAbs subclass: #HRMeetingStrat
	instanceVariableNames: 'predecessor races'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

HRMeetingStrat subclass: #HRBlokeSystemMeeting
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

HRMeetingStrat subclass: #HRMeetingPlaceCalc
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

HRMeetingStrat subclass: #HRMyMeeting
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

HRMeetingStrat subclass: #HRPumpkin3Meeting
	instanceVariableNames: 'badMeeting sumValue'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

HRNagAbs subclass: #HRNag
	instanceVariableNames: 'name jockey trainer form fineformRating rpSpotlightMention priceWise racecardNo racecardPos proxToFav stopwatchRating courseWinner distanceWinner daysSinceLastRun postmark draw preRaceShow earlyOdds rpForecast slForecast noFavourite racePosition placed ppValue ppPercentage toteWinDivi totePlaceDivi slFinalOdds race blokeSystemFav preRaceNR rpPlaceChance ppPlaceValue ppEst mySelect bfPut bfLay bfID bfNagTO previewPlaceChance previewPPPlaceValue bfWin bfPlace bfWinID bfPlaceID'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

HRNagAbs subclass: #HRNagStrat
	instanceVariableNames: 'predecessor race fav'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

HRNagStrat subclass: #HRBlokeSystemNag
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

HRNagStrat subclass: #HRMyNag
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

HRNagStrat subclass: #HRNagPlaceCalc
	instanceVariableNames: 'placeChance placeChanceBasis ppPercentage ppPercIncFav ppPlaceValue ppLeg1Est'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

HRNagStrat subclass: #HRPumpkin3Nag
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

HRRaceAbs subclass: #HRRace
	instanceVariableNames: 'time distance name type forecastRunners actualRunners ppCarriedForward ppFav bookiesPercentage ageOfNags rpWholeSpotlight nags meeting raceID leg handicap preRaceFav ppFavEst bfRaceID bfRaceTO lastUpdate myPlaceOdds myUnnamedFav ppValDirty'
	classVariableNames: 'RaceTypes'
	poolDictionaries: ''
	classInstanceVariableNames: ''!

HRRaceAbs subclass: #HRRaceStrat
	instanceVariableNames: 'predecessor meeting nags'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

HRRaceStrat subclass: #HRBlokeSystemRace
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

HRRaceStrat subclass: #HRMyRace
	instanceVariableNames: 'happy'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

HRRaceStrat subclass: #HRPumpkin3Race
	instanceVariableNames: 'sortedOdds badRace sumValue favCount'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

HRRaceStrat subclass: #HRRacePlaceCalc
	instanceVariableNames: 'preRaceFavs allRunners allRunnersBasis mainRunners mainRunnersBasis sumOfFinalOdds places preRaceFav sumOfBFOdds hasRealPPValues totalPPEst totalPPLeg1Est allPlaceChances'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Presenter subclass: #HRDiviEstPresenter
	instanceVariableNames: 'ests'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Presenter subclass: #HRGraphPresenter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Shell subclass: #HRDiviEstShell
	instanceVariableNames: 'ests'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Shell subclass: #HRMeetingIDEditor
	instanceVariableNames: 'bfAbbrPres bfListPres bfEditPres toteIDPres slNamePres bfSkip'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Shell subclass: #HRMtgDashboardPresenter
	instanceVariableNames: 'graphPresenter linesPresenter estPresenter linesWithEstPresenter'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Shell subclass: #HRPPSlipPresenter
	instanceVariableNames: 'leg1 leg2 leg3 leg4 leg5 leg6 lines unitStake totalStake winningLines divi payOut profit'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Shell subclass: #HRPPSlipTextPresenter
	instanceVariableNames: 'text'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Shell subclass: #HRRacePresenter
	instanceVariableNames: 'racesListPres slPres ppEstTotalPres ppFavEstPres nagsListPres bfPres ppEstPres nagSelectPres raceTypePres placesPres runnersPres racesList currentRace nrPres lastRace rememberSort changedBF'
	classVariableNames: ''
	poolDictionaries: 'Win32Constants'
	classInstanceVariableNames: ''!

Shell subclass: #HRSchedulerPresenter
	instanceVariableNames: 'scheduleListPresenter logPresenter statusPresenter listUpdateCounter lock pwdPresenter pwd'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Shell subclass: #HRSMSSlipPresenter
	instanceVariableNames: 'addresses address text'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Dialog subclass: #HRRPLogonDialog
	instanceVariableNames: 'usernamePresenter passwordPresenter'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Dialog subclass: #HRScheduleItemPresenter
	instanceVariableNames: 'datePresenter timePresenter processPresenter objectPresenter paramsPresenter'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

View subclass: #HRLineGraphView
	instanceVariableNames: 'canvas origin borderX borderY xEnd xLength yEnd yLength xStep'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Splitter subclass: #RestrictedSplitter
	instanceVariableNames: 'constrain'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

"Global Aliases"!

"Loose Methods"!

!Boolean methodsFor!
<= aBoolean

	self asDword <= aBoolean asDword! !
!Boolean categoriesFor: #<=!public! !

!Boolean methodsFor!
printTrueOrBlank

	"print blank if not true"
#tbAdded.

	^''! !
!Boolean categoriesFor: #printTrueOrBlank!public! !

!Boolean categoriesFor: #<=!must not strip!public! !

!Boolean categoriesFor: #printTrueOrBlank!must not strip!public! !

!CDOIMessage methodsFor!
addAttachment: url
	"Answer the <CDOIBodyPart> result of invoking the COM Object's AddAttachment() method.
	Helpstring: 'Adds an attachment (BodyPart) to the message.'"

	| answer |
	answer := CDOIBodyPart newPointer.
	self
		AddAttachment: url
		UserName: ''
		Password: ''
		ppBody: answer.
	^answer asObject
! !
!CDOIMessage categoriesFor: #addAttachment:!public! !

!CDOIMessage categoriesFor: #addAttachment:!**auto generated**!methods!must not strip!public! !

!Date methodsFor!
displayBetfairFormat

#tbAdded.
	^self ordinalDayOfMonth, ' ', (self class shortNameOfMonth: self monthIndex).
	! !
!Date categoriesFor: #displayBetfairFormat!public! !

!Date methodsFor!
displayShortFormat

	| stream |
#tbAdded.
	stream := String writeStream.
	self printOn: stream format: self class defaultShortFormat.
	^stream contents! !
!Date categoriesFor: #displayShortFormat!public! !

!Date methodsFor!
displayUsingFormat: aFormat

	| stream |
#tbAdded.
	stream := String writeStream.
	self printOn: stream format: aFormat.
	^stream contents! !
!Date categoriesFor: #displayUsingFormat:!public! !

!Date methodsFor!
ordinalDayOfMonth
	"Answer the day of the month represented by the receiver."
#tbAdded.
	^self dayOfMonth ordinalAbbreviated! !
!Date categoriesFor: #ordinalDayOfMonth!public! !

!Date categoriesFor: #displayBetfairFormat!must not strip!public! !

!Date categoriesFor: #displayShortFormat!must not strip!public! !

!Date categoriesFor: #displayUsingFormat:!must not strip!public! !

!Date categoriesFor: #ordinalDayOfMonth!accessing!public! !

!Integer methodsFor!
ordinalAbbreviated

	| char |
#tbAdded.
	self > 9 ifTrue: [char := self displayString at: (self displayString size - 1).
			char == $1 ifTrue: [^self displayString, 'th']].
	char := self displayString last.
	char == $1 ifTrue: [^self displayString, 'st'].
	char == $2 ifTrue: [^self displayString, 'nd'].
	char == $3 ifTrue: [^self displayString, 'rd'].
	^self displayString, 'th'
! !
!Integer categoriesFor: #ordinalAbbreviated!public! !

!Integer categoriesFor: #ordinalAbbreviated!public! !

!ListView methodsFor!
resort

#TBAdded.
	lastClickedColIndex ifNotNil: [ :a |
		self sortOnColumn: (self columnAtIndex: lastClickedColIndex)]
! !
!ListView categoriesFor: #resort!public! !

!ListView categoriesFor: #resort!must not strip!public!updating! !

!Model methodsFor!
canHaveDashboard

		^false! !
!Model categoriesFor: #canHaveDashboard!public! !

!Model categoriesFor: #canHaveDashboard!public! !

!ProportionalLayout methodsFor!
layoutContainer: aContainerView 
	"Performs a layout operation on the contents in aContainerView"

	| subviews extent majorExtent minorExtent point freeSize totalProportion fixedSize insets |
#tbModified.
	subviews := aContainerView managedSubViews.
	insets := aContainerView actualInsets.
	extent := (aContainerView clientWidth - (insets left + insets right)) 
				@ (aContainerView clientHeight - (insets top + insets bottom)).
	majorExtent := self majorDimensionOf: extent.
	minorExtent := self minorDimensionOf: extent.
	fixedSize := 0.
	(subviews select: [:aView | self hasFixedSize: aView]) 
		do: [:aView | fixedSize := fixedSize + (self majorDimensionOf: aView layoutExtent)].
	freeSize := majorExtent - fixedSize max: 0.
	totalProportion := self totalProportionsOf: subviews.
	point := insets origin.
	subviews keysAndValuesDo: 
			[:index :aView | 
			| viewMajorExtent viewExtent |
			viewMajorExtent := (self hasFixedSize: aView) 
						ifTrue: [self majorDimensionOf: aView layoutExtent]
						ifFalse: 
							[index = subviews size 
								ifTrue: 
									[majorExtent + (self majorDimensionOf: insets origin) - (self majorDimensionOf: point)]
								ifFalse: [((self arrangementOf: aView) / totalProportion * freeSize) truncated]
"Change this block to read"
"								ifFalse: [
									| temp |
									temp := ((self arrangementOf: aView) / totalProportion * freeSize) truncated.
									index = 1 & (temp < 150) ifTrue: [temp := 150].
									temp]"
									].
			viewExtent := self pointWithMajor: viewMajorExtent minor: minorExtent.
			aView basicInvalidateLayout.
			aView rectangle: (point extent: viewExtent).
			point := point + (self pointWithMajor: viewMajorExtent minor: 0)].
	aContainerView validateLayout! !
!ProportionalLayout categoriesFor: #layoutContainer:!geometry!public! !

!ProportionalLayout categoriesFor: #layoutContainer:!geometry!public! !

!SequenceableCollection methodsFor!
sortByLastElm: anotherCollection

	(self isEmpty and: [anotherCollection isEmpty]) ifTrue: [^true].
	anotherCollection isEmpty ifTrue: [^false].
	self isEmpty ifTrue: [^true].
	^self last <= anotherCollection last
! !
!SequenceableCollection categoriesFor: #sortByLastElm:!public! !

!SequenceableCollection categoriesFor: #sortByLastElm:!must not strip!public! !

!String methodsFor!
isNumber

	^self allSatisfy: [ :each | each isDigit or: [ each == $. ]].
! !
!String categoriesFor: #isNumber!public! !

!String methodsFor!
soundsLike: comparant

	^(Soundex encodeString: self) sameAs: 
				(Soundex encodeString: comparant)! !
!String categoriesFor: #soundsLike:!public! !

!String methodsFor!
words
	"Answer an Array containing the words of the receiver as substrings. Words only contain letters"

	| aStream answer wordStream next |
	answer := OrderedCollection new.
	aStream := self readStream.
	wordStream := self species writeStream: 10.
	[aStream atEnd] whileFalse: [
		wordStream reset.
		[aStream atEnd or: [(next:= aStream next) isLetter not]]
			whileFalse: [wordStream nextPut: next].
		next := wordStream contents.
		next isEmpty ifFalse: [answer add: next]].
	^answer asArray
! !
!String categoriesFor: #words!public! !

!String categoriesFor: #isNumber!must not strip!public! !

!String categoriesFor: #soundsLike:!must not strip!public! !

!String categoriesFor: #words!must not strip!public! !

!True methodsFor!
printTrueOrBlank

	"print blank if not true"
#tbAdded.

	^'true'! !
!True categoriesFor: #printTrueOrBlank!public! !

!True categoriesFor: #printTrueOrBlank!must not strip!public! !

"End of package definition"!

"Source Globals"!

"Classes"!

HRBFMeeting guid: (GUID fromString: '{74259811-8B8C-40B7-990D-C687FE9C98AB}')!

HRBFMeeting guid: (GUID fromString: '{74259811-8B8C-40B7-990D-C687FE9C98AB}')!
HRBFMeeting comment: ''!

HRBFMeeting comment:
''!
!HRBFMeeting categoriesForClass!Kernel-Objects! !
!HRBFMeeting methodsFor!
addRace: anId time: aTime
	self races at: aTime put: anId! !
!HRBFMeeting categoriesFor: #addRace:time:!public! !

!HRBFMeeting methodsFor!
raceAt: aTime
	^self races at: aTime ifAbsent: [
		HRLogger current showError: 'No Betfair node found for ', 
		aTime printString, String lineDelimiter.
		^'']! !
!HRBFMeeting categoriesFor: #raceAt:!public! !

!HRBFMeeting methodsFor!
races
	races ifNil: [ races := Dictionary new ].
	^races! !
!HRBFMeeting categoriesFor: #races!public! !

!HRBFMeeting categoriesFor: #addRace:time:!public! !

!HRBFMeeting categoriesFor: #raceAt:!public! !

!HRBFMeeting categoriesFor: #races!public! !

HRBFOdds guid: (GUID fromString: '{EDF46C18-9A62-4227-BD21-4A867CF15AF2}')!

HRBFOdds guid: (GUID fromString: '{EDF46C18-9A62-4227-BD21-4A867CF15AF2}')!
HRBFOdds comment: ''!

HRBFOdds comment:
''!
!HRBFOdds categoriesForClass!Kernel-Objects! !
!HRBFOdds methodsFor!
back
	back ifNil: [back := 0].
	^back! !
!HRBFOdds categoriesFor: #back!public! !

!HRBFOdds methodsFor!
back: anObject
	back := anObject! !
!HRBFOdds categoriesFor: #back:!public! !

!HRBFOdds methodsFor!
lay
	lay ifNil: [lay := 0].
	^lay! !
!HRBFOdds categoriesFor: #lay!public! !

!HRBFOdds methodsFor!
lay: anObject
	lay := anObject! !
!HRBFOdds categoriesFor: #lay:!public! !

!HRBFOdds methodsFor!
odds
	(self back + self lay) isZero ifTrue: [^0].
	^((self back - 1) + (self lay - 1)) / 2.0! !
!HRBFOdds categoriesFor: #odds!public! !

!HRBFOdds methodsFor!
time
	time ifNil: [time := Time fromSeconds: 0].
	^time! !
!HRBFOdds categoriesFor: #time!public! !

!HRBFOdds methodsFor!
time: anObject
	time := anObject! !
!HRBFOdds categoriesFor: #time:!public! !

!HRBFOdds methodsFor!
totalTurnover
	totalTurnover ifNil: [totalTurnover := 0].
	^totalTurnover! !
!HRBFOdds categoriesFor: #totalTurnover!public! !

!HRBFOdds methodsFor!
totalTurnover: anObject
	totalTurnover := anObject! !
!HRBFOdds categoriesFor: #totalTurnover:!public! !

!HRBFOdds methodsFor!
turnover
	turnover ifNil: [turnover := 0].
	^turnover! !
!HRBFOdds categoriesFor: #turnover!public! !

!HRBFOdds methodsFor!
turnover: anObject
	turnover := anObject! !
!HRBFOdds categoriesFor: #turnover:!public! !

!HRBFOdds methodsFor!
turnover: aTO totalTurnover: aTotalTO
	self turnover: aTO.
	self totalTurnover: aTotalTO! !
!HRBFOdds categoriesFor: #turnover:totalTurnover:!public! !

!HRBFOdds categoriesFor: #back!accessing!private! !

!HRBFOdds categoriesFor: #back:!accessing!private! !

!HRBFOdds categoriesFor: #lay!accessing!private! !

!HRBFOdds categoriesFor: #lay:!accessing!private! !

!HRBFOdds categoriesFor: #odds!public! !

!HRBFOdds categoriesFor: #time!accessing!private! !

!HRBFOdds categoriesFor: #time:!accessing!private! !

!HRBFOdds categoriesFor: #totalTurnover!accessing!private! !

!HRBFOdds categoriesFor: #totalTurnover:!accessing!private! !

!HRBFOdds categoriesFor: #turnover!accessing!private! !

!HRBFOdds categoriesFor: #turnover:!accessing!private! !

!HRBFOdds categoriesFor: #turnover:totalTurnover:!accessing!private! !

!HRBFOdds class methodsFor!
back: aFloat lay: aFloat2 turnover: aTurnover time: aTime

	^self basicNew back: aFloat; lay: aFloat2; turnover: aTurnover; time: aTime
! !
!HRBFOdds class categoriesFor: #back:lay:turnover:time:!public! !

!HRBFOdds class methodsFor!
back: aFloat lay: aFloat2 turnover: aTO totalTurnover: aTotalTO time: aTime 
	^self basicNew back: aFloat; lay: aFloat2; turnover: aTO; totalTurnover: aTotalTO; time: aTime

! !
!HRBFOdds class categoriesFor: #back:lay:turnover:totalTurnover:time:!public! !

!HRBFOdds class categoriesFor: #back:lay:turnover:time:!public! !

!HRBFOdds class categoriesFor: #back:lay:turnover:totalTurnover:time:!public! !

HRDiviEst guid: (GUID fromString: '{117E8237-E4AA-4638-AA8A-3A5290CD5350}')!

HRDiviEst guid: (GUID fromString: '{117E8237-E4AA-4638-AA8A-3A5290CD5350}')!
HRDiviEst comment: ''!

HRDiviEst comment:
''!
!HRDiviEst categoriesForClass!Kernel-Objects! !
!HRDiviEst methodsFor!
descr
	descr ifNil: [descr := ''].
	^descr! !
!HRDiviEst categoriesFor: #descr!public! !

!HRDiviEst methodsFor!
descr: anObject
	^descr := anObject! !
!HRDiviEst categoriesFor: #descr:!public! !

!HRDiviEst methodsFor!
divi
	divi ifNil: [divi := 0].
	^divi! !
!HRDiviEst categoriesFor: #divi!public! !

!HRDiviEst methodsFor!
divi: anObject
	^divi := anObject! !
!HRDiviEst categoriesFor: #divi:!public! !

!HRDiviEst methodsFor!
lines
	lines ifNil: [lines := 0].
	^lines! !
!HRDiviEst categoriesFor: #lines!public! !

!HRDiviEst methodsFor!
lines: anObject
	^lines := anObject! !
!HRDiviEst categoriesFor: #lines:!public! !

!HRDiviEst methodsFor!
profit
	profit ifNil: [profit := 0].
	^profit! !
!HRDiviEst categoriesFor: #profit!public! !

!HRDiviEst methodsFor!
profit: anObject
	^profit := anObject! !
!HRDiviEst categoriesFor: #profit:!public! !

!HRDiviEst methodsFor!
return
	return ifNil: [return := 0].
	^return! !
!HRDiviEst categoriesFor: #return!public! !

!HRDiviEst methodsFor!
return: anObject
	^return := anObject! !
!HRDiviEst categoriesFor: #return:!public! !

!HRDiviEst categoriesFor: #descr!accessing!private! !

!HRDiviEst categoriesFor: #descr:!accessing!private! !

!HRDiviEst categoriesFor: #divi!accessing!private! !

!HRDiviEst categoriesFor: #divi:!accessing!private! !

!HRDiviEst categoriesFor: #lines!accessing!private! !

!HRDiviEst categoriesFor: #lines:!accessing!private! !

!HRDiviEst categoriesFor: #profit!accessing!private! !

!HRDiviEst categoriesFor: #profit:!accessing!private! !

!HRDiviEst categoriesFor: #return!accessing!private! !

!HRDiviEst categoriesFor: #return:!accessing!private! !

HRImport guid: (GUID fromString: '{AC11927A-8F60-4794-BAC3-D6A7F7F2F35D}')!

HRImport guid: (GUID fromString: '{AC11927A-8F60-4794-BAC3-D6A7F7F2F35D}')!
HRImport comment: ''!

HRImport comment:
''!
!HRImport categoriesForClass!Kernel-Objects! !
!HRImport methodsFor!
checkName: aString

	^self checkString: aString! !
!HRImport categoriesFor: #checkName:!public! !

!HRImport methodsFor!
checkString: aString

	^self replaceSpecialCharsFrom: aString! !
!HRImport categoriesFor: #checkString:!public! !

!HRImport methodsFor!
checkUppercase: aString

	aString = aString asUppercase ifTrue: [^true].
	^aString words anySatisfy: [ :each | each = each asUppercase and: [each size > 1] ]! !
!HRImport categoriesFor: #checkUppercase:!public! !

!HRImport methodsFor!
contents
	contents ifNil: [self contents: ''].
	^contents! !
!HRImport categoriesFor: #contents!public! !

!HRImport methodsFor!
contents: anObject
	contents := anObject! !
!HRImport categoriesFor: #contents:!public! !

!HRImport methodsFor!
fileName
	^fileName! !
!HRImport categoriesFor: #fileName!public! !

!HRImport methodsFor!
fileName: anObject
	fileName := anObject! !
!HRImport categoriesFor: #fileName:!public! !

!HRImport methodsFor!
makeFraction: aString

	| subStrings numerator denominator |
	subStrings := aString subStrings: $-.
	subStrings isEmpty ifTrue: [^0].
	subStrings size = 1 ifTrue: [^self numberFrom: (subStrings at: 1) trimBlanks].
	numerator := self numberFrom: (subStrings at: 1) trimBlanks.
	denominator := self numberFrom: (subStrings at: 2) trimBlanks.
	denominator isNull ifTrue: [^0].
	^Fraction numerator: numerator denominator: denominator! !
!HRImport categoriesFor: #makeFraction:!public! !

!HRImport methodsFor!
numberFrom: aString

	| stream result |
	aString isEmpty ifTrue: [^0].
	stream := aString readStream.
	result := WriteStream on: String new.
	[stream atEnd] whileFalse: [ |char|
		char := stream next.
		(char isDigit or: [char = $.]) ifTrue: [result nextPut: char].
		].
	^Number fromString: (result contents)! !
!HRImport categoriesFor: #numberFrom:!public! !

!HRImport methodsFor!
on: aString

	| stream |
	stream := FileStream read: aString.
	[ self contents: stream contents ] ensure: [ stream close ].! !
!HRImport categoriesFor: #on:!public! !

!HRImport methodsFor!
onURL: aURL

	
"	[ self contents: (FileStream on: (IStream onURL: aURL)) contents. ] 
		on: Error do: [:x | ^HRLogger current show: ('Could not connect to ' , aURL, String lineDelimiter)].
"
	self on: (HRPageFiler storeFromURL: aURL)! !
!HRImport categoriesFor: #onURL:!public! !

!HRImport methodsFor!
replaceSpecialCharsFrom: aString

	| stream result key |
	(aString includes: $&) ifFalse: [^aString].
	stream := aString readStream.
	result := WriteStream on: String new.
	(aString occurrencesOf: $&) timesRepeat: [ | pos |
		result nextPutAll: (stream upTo: $&).
		pos := stream position.
		key := (stream upTo: $;) asUppercase.
		stream atEnd 
			ifTrue: [stream position: pos. stream next. key := stream next: 2].
		result nextPut: (self specialCharsAt: key asSymbol)].
	result nextPutAll: stream upToEnd.
	^result contents! !
!HRImport categoriesFor: #replaceSpecialCharsFrom:!public! !

!HRImport methodsFor!
specialCharsAt: aSymbol

	SpecialChars ifNil: [self class setupSpecialChars].
	^SpecialChars at: aSymbol ifAbsent: [
		aSymbol isNumber 
			ifTrue: [Character instanceClass value: aSymbol asNumber] 
			ifFalse: [Character space]]! !
!HRImport categoriesFor: #specialCharsAt:!public! !

!HRImport methodsFor!
stripTags: aString
	| stream result |
	stream := ReadStream on: aString.
	result := String writeStream.
	[stream atEnd] whileFalse: [
		stream peek = $< 
			ifTrue: [ stream skipTo: $> ]
			ifFalse: [result nextPut: stream next]].
	^result contents! !
!HRImport categoriesFor: #stripTags:!public! !

!HRImport categoriesFor: #checkName:!public! !

!HRImport categoriesFor: #checkString:!public! !

!HRImport categoriesFor: #checkUppercase:!private! !

!HRImport categoriesFor: #contents!accessing!private! !

!HRImport categoriesFor: #contents:!accessing!private! !

!HRImport categoriesFor: #fileName!accessing!private! !

!HRImport categoriesFor: #fileName:!accessing!private! !

!HRImport categoriesFor: #makeFraction:!accessing!private! !

!HRImport categoriesFor: #numberFrom:!accessing!private! !

!HRImport categoriesFor: #on:!public! !

!HRImport categoriesFor: #onURL:!public! !

!HRImport categoriesFor: #replaceSpecialCharsFrom:!public! !

!HRImport categoriesFor: #specialCharsAt:!public! !

!HRImport categoriesFor: #stripTags:!private! !

!HRImport class methodsFor!
initialize

	super initialize.
	self setupSpecialChars.
! !
!HRImport class categoriesFor: #initialize!public! !

!HRImport class methodsFor!
on: aString

	^self new on: aString! !
!HRImport class categoriesFor: #on:!public! !

!HRImport class methodsFor!
onURL: aURL

	aURL isEmpty ifTrue: [^nil].
"	^self new onURL: aURL attempt: 1"
	^self new onURL: aURL! !
!HRImport class categoriesFor: #onURL:!public! !

!HRImport class methodsFor!
setupSpecialChars
	"
	HRImport setupSpecialChars
	"

	SpecialChars := Dictionary new.
	SpecialChars at: #ACUTE put: $'.
	SpecialChars at: #POUND put: $.
	SpecialChars at: #NBSP put: Character space.
	SpecialChars at: #FRAC14 put: (Character instanceClass value: 188).
	SpecialChars at: #FRAC12 put: (Character instanceClass value: 189).
	SpecialChars at: #FRAC34 put: (Character instanceClass value: 190).
! !
!HRImport class categoriesFor: #setupSpecialChars!public! !

!HRImport class categoriesFor: #initialize!public! !

!HRImport class categoriesFor: #on:!public! !

!HRImport class categoriesFor: #onURL:!public! !

!HRImport class categoriesFor: #setupSpecialChars!public! !

HRMailer guid: (GUID fromString: '{BC69EBF6-0FEF-4005-A7C1-24FAF00A6492}')!

HRMailer guid: (GUID fromString: '{BC69EBF6-0FEF-4005-A7C1-24FAF00A6492}')!
HRMailer comment: ''!

HRMailer comment:
''!
!HRMailer categoriesForClass!Kernel-Objects! !
!HRMailer methodsFor!
addToMailIni: aString
	| enabled stream |
	stream := FileStream readWrite: HRApplication current paramsPath , 'mail.ini'.
	stream setToEnd;
		nextPutAll: '

',
aString,
'
Enabled=false
Description=
Sender=
Destination=
Newsgroups=

'.
	stream
		flush;
		close! !
!HRMailer categoriesFor: #addToMailIni:!public! !

!HRMailer methodsFor!
canMailPlacepotSMS

	| tag |
	tag := self readTagFor: '[SMS]'.
	^tag at: #mailEnabled.
! !
!HRMailer categoriesFor: #canMailPlacepotSMS!public! !

!HRMailer methodsFor!
createMailIni
	| enabled stream |
	stream := FileStream write: HRApplication current paramsPath , 'mail.ini'.
	stream 
		nextPutAll: '
[PREVIEW]
Enabled=false
Description=
Sender=
Destination=
Newsgroups=

[RESULTS]
Enabled=false
Description=
Sender=
Destination=
Newsgroups=

[DATA]
Enabled=false
Description=
Sender=
Destination=
Newsgroups=

[TODAY]
Enabled=false
Description=
Sender=
Destination=
Newsgroups=

[SMS]
Enabled=false
Description=
Sender=
Destination=
Newsgroups=
'.
	stream
		flush;
		close! !
!HRMailer categoriesFor: #createMailIni!public! !

!HRMailer methodsFor!
mailDataFile: aFile

	| tag msg path |
	tag := self readTagFor: '[DATA]'.
	(tag at: #mailEnabled) ifFalse: [^nil].
	path := String writeStream.
	aFile do: [:char | char = $\ ifTrue: [path nextPut: $/] ifFalse: [path nextPut: char]].
	msg := CDOIMessage new.
	msg
		from: (tag at: #mailSender);
		to: (tag at: #mailDestination);
		newsgroups: (tag at: #mailNewsgroups);
		subject: 'Datafile: ', (File splitFilenameFrom: aFile);
		textBody: (tag at: #mailDescription).
	msg addAttachment: 'file://' , path contents.
	msg Send.
	msg := 'hello'.
	HRLogger current showAlways: Time now displayString, ' E-mailed Datafile: ', 
		(File splitFilenameFrom: aFile), String lineDelimiter
! !
!HRMailer categoriesFor: #mailDataFile:!public! !

!HRMailer methodsFor!
mailPlacepotSMS: aFile

	| tag msg stream header body |
#deprecated.
	tag := self readTagFor: '[SMS]'.
	(tag at: #mailEnabled) ifFalse: [^nil].
	stream := FileStream read: aFile.
	[header := stream nextLine.
	body := stream upToEnd] ensure: [
		stream close].
	msg := CDOIMessage new.
	msg
		from: (tag at: #mailSender);
		to: (tag at: #mailDestination);
		newsgroups: (tag at: #mailNewsgroups);
		subject: header;
		textBody: body.
	msg Send.
	msg := 'hello'.
	HRLogger current showAlways: Time now displayString, ' E-mailed SMS file: ', 
		(File splitFilenameFrom: aFile), String lineDelimiter
! !
!HRMailer categoriesFor: #mailPlacepotSMS:!public! !

!HRMailer methodsFor!
mailPlacepotSMS: aFile to: aDestination

	| tag msg stream header body |
	tag := self readTagFor: '[SMS]'.
	(tag at: #mailEnabled) ifFalse: [^nil].
	stream := FileStream read: aFile.
	[header := stream nextLine.
	body := stream upToEnd] ensure: [
		stream close].
	msg := CDOIMessage new.
	msg
		from: (tag at: #mailSender);
		to: aDestination;
		subject: header;
		textBody: body.
	msg Send.
	msg := 'hello'.
	HRLogger current showAlways: Time now displayString, ' E-mailed SMS file: ', 
		(File splitFilenameFrom: aFile), String lineDelimiter
! !
!HRMailer categoriesFor: #mailPlacepotSMS:to:!public! !

!HRMailer methodsFor!
mailPreviewFile: aFile

	| tag msg path |
	tag := self readTagFor: '[PREVIEW]'.
	(tag at: #mailEnabled) ifFalse: [^nil].
	path := String writeStream.
	aFile do: [:char | char = $\ ifTrue: [path nextPut: $/] ifFalse: [path nextPut: char]].
	msg := CDOIMessage new.
	msg
		from: (tag at: #mailSender);
		to: (tag at: #mailDestination);
		newsgroups: (tag at: #mailNewsgroups);
		subject: 'Preview of: ', (File splitFilenameFrom: aFile);
		textBody: (tag at: #mailDescription).
	msg addAttachment: 'file://' , path contents.
	msg Send.
	msg := 'hello'.
	HRLogger current showAlways: Time now displayString, ' E-mailed Preview of: ', 
		(File splitFilenameFrom: aFile), String lineDelimiter
! !
!HRMailer categoriesFor: #mailPreviewFile:!public! !

!HRMailer methodsFor!
mailResultsFile: aFile

	| tag msg path |
	tag := self readTagFor: '[RESULTS]'.
	(tag at: #mailEnabled) ifFalse: [^nil].
	path := String writeStream.
	aFile do: [:char | char = $\ ifTrue: [path nextPut: $/] ifFalse: [path nextPut: char]].
	msg := CDOIMessage new.
	msg
		from: (tag at: #mailSender);
		to: (tag at: #mailDestination);
		newsgroups: (tag at: #mailNewsgroups);
		subject: 'Results of: ', (File splitFilenameFrom: aFile);
		textBody: (tag at: #mailDescription).
	msg addAttachment: 'file://' , path contents.
	msg Send.
	msg := 'hello'.
	HRLogger current showFull: Time now displayString, ' E-mailed Results of: ', 
		(File splitFilenameFrom: aFile), String lineDelimiter
! !
!HRMailer categoriesFor: #mailResultsFile:!public! !

!HRMailer methodsFor!
mailTodayCsvFile: aFile

	| tag msg path |
	tag := self readTagFor: '[TODAY]'.
	(tag at: #mailEnabled) ifFalse: [^nil].
	path := String writeStream.
	aFile do: [:char | char = $\ ifTrue: [path nextPut: $/] ifFalse: [path nextPut: char]].
	msg := CDOIMessage new.
	msg
		from: (tag at: #mailSender);
		to: (tag at: #mailDestination);
		newsgroups: (tag at: #mailNewsgroups);
		subject: 'Results of: ', (File splitFilenameFrom: aFile);
		textBody: (tag at: #mailDescription).
	msg addAttachment: 'file://' , path contents.
	msg Send.
	msg := 'hello'.
	HRLogger current showAlways: Time now displayString, ' E-mailed Results of: ', 
		(File splitFilenameFrom: aFile), String lineDelimiter
! !
!HRMailer categoriesFor: #mailTodayCsvFile:!public! !

!HRMailer methodsFor!
readTagFor: aString

	| result enabled stream |
	result := Dictionary new.
	(File exists: (HRApplication current paramsPath, 'mail.ini')) ifFalse: [self createMailIni].
	stream := FileStream read: (HRApplication current paramsPath, 'mail.ini').
	stream reset; skipToAll: aString. 
	stream atEnd ifTrue: 
		[stream close.
		self addToMailIni: aString.
		stream := FileStream read: (HRApplication current paramsPath, 'mail.ini').].
	stream reset; skipToAll: aString; skipToAll: 'Description='.
	result at: #mailDescription put: (stream upToAll: String lineDelimiter) trimBlanks.
	stream reset; skipToAll: aString; skipToAll: 'Sender='.
	result at: #mailSender put: (stream upToAll: String lineDelimiter) trimBlanks.
	stream reset; skipToAll: aString; skipToAll: 'Destination='.
	result at: #mailDestination put: (stream upToAll: String lineDelimiter) trimBlanks.
	stream reset; skipToAll: aString; skipToAll: 'Newsgroups='.
	result at: #mailNewsgroups put: (stream upToAll: String lineDelimiter) trimBlanks.
	stream reset; skipToAll: aString; skipToAll: 'Enabled='.
	enabled := (stream upToAll: String lineDelimiter) trimBlanks asSymbol.
	stream close.
	((enabled sameAs: 'true') and: 
		[(result at: #mailSender) notEmpty and: 
			[(result at: #mailDestination) notEmpty]]) 
				ifTrue: [result at: #mailEnabled put: true]
				ifFalse: [result at: #mailEnabled put: false].
	^result! !
!HRMailer categoriesFor: #readTagFor:!public! !

!HRMailer categoriesFor: #addToMailIni:!public! !

!HRMailer categoriesFor: #canMailPlacepotSMS!public! !

!HRMailer categoriesFor: #createMailIni!public! !

!HRMailer categoriesFor: #mailDataFile:!public! !

!HRMailer categoriesFor: #mailPlacepotSMS:!public! !

!HRMailer categoriesFor: #mailPlacepotSMS:to:!public! !

!HRMailer categoriesFor: #mailPreviewFile:!public! !

!HRMailer categoriesFor: #mailResultsFile:!public! !

!HRMailer categoriesFor: #mailTodayCsvFile:!public! !

!HRMailer categoriesFor: #readTagFor:!public! !

!HRMailer class methodsFor!
canMailPlacepotSMS

	^(self new) canMailPlacepotSMS! !
!HRMailer class categoriesFor: #canMailPlacepotSMS!public! !

!HRMailer class methodsFor!
mailDataFile: aFile

	^(self new) mailDataFile: aFile! !
!HRMailer class categoriesFor: #mailDataFile:!public! !

!HRMailer class methodsFor!
mailPlacepotSMS: aFile
#deprecated.
	^(self new) mailPlacepotSMS: aFile! !
!HRMailer class categoriesFor: #mailPlacepotSMS:!public! !

!HRMailer class methodsFor!
mailPlacepotSMS: aFile to: aDestination

	^(self new) mailPlacepotSMS: aFile to: aDestination! !
!HRMailer class categoriesFor: #mailPlacepotSMS:to:!public! !

!HRMailer class methodsFor!
mailPreviewFile: aFile

	^(self new) mailPreviewFile: aFile! !
!HRMailer class categoriesFor: #mailPreviewFile:!public! !

!HRMailer class methodsFor!
mailResultsFile: aFile

	^(self new) mailResultsFile: aFile! !
!HRMailer class categoriesFor: #mailResultsFile:!public! !

!HRMailer class methodsFor!
mailTodayCsvFile: aFile

	^(self new) mailTodayCsvFile: aFile! !
!HRMailer class categoriesFor: #mailTodayCsvFile:!public! !

!HRMailer class categoriesFor: #canMailPlacepotSMS!public! !

!HRMailer class categoriesFor: #mailDataFile:!public! !

!HRMailer class categoriesFor: #mailPlacepotSMS:!public! !

!HRMailer class categoriesFor: #mailPlacepotSMS:to:!public! !

!HRMailer class categoriesFor: #mailPreviewFile:!public! !

!HRMailer class categoriesFor: #mailResultsFile:!public! !

!HRMailer class categoriesFor: #mailTodayCsvFile:!public! !

HROddsSeries guid: (GUID fromString: '{D892A868-2B1E-4924-A722-F910BCC0B013}')!

HROddsSeries guid: (GUID fromString: '{D892A868-2B1E-4924-A722-F910BCC0B013}')!
HROddsSeries comment: ''!

HROddsSeries comment:
''!
!HROddsSeries categoriesForClass!Kernel-Objects! !
!HROddsSeries methodsFor!
addBack: aFloat addLay: aFloat2 addTurnover: aTurnover addTotalTurnover: totalTurnover time: aTime 
	| last |
	self series isEmpty ifFalse: [last := self series last time].
	self series addLast: (HRBFOdds back: aFloat lay: aFloat2 turnover: aTurnover totalTurnover: totalTurnover time: aTime).
	(last notNil and: [last > aTime]) ifTrue: [
		series := (self series asSortedCollection: [ :a :b | a time < b time ]) asOrderedCollection ].! !
!HROddsSeries categoriesFor: #addBack:addLay:addTurnover:addTotalTurnover:time:!public! !

!HROddsSeries methodsFor!
addBack: aFloat addLay: aFloat2 time: aTime 
	self addBack: aFloat addLay: aFloat2 addTurnover: 0 addTotalTurnover: 0 time: aTime 
! !
!HROddsSeries categoriesFor: #addBack:addLay:time:!public! !

!HROddsSeries methodsFor!
addOdds: aFloat time: aTime 
	self addBack: (aFloat+1) addLay: (aFloat+1) time: aTime! !
!HROddsSeries categoriesFor: #addOdds:time:!public! !

!HROddsSeries methodsFor!
allOdds
	self series isEmpty ifTrue: [^OrderedCollection new].
	^self series collect: [ :each | each odds ]
! !
!HROddsSeries categoriesFor: #allOdds!public! !

!HROddsSeries methodsFor!
at: aTime 
	| result |
	result := (self series reverse detect: [ :each | each time <= aTime ] ifNone: [self series addLast: HRBFOdds new]).
	^result! !
!HROddsSeries categoriesFor: #at:!public! !

!HROddsSeries methodsFor!
direction
	self series isEmpty ifTrue: [^0].
	^self series last odds - self series first odds! !
!HROddsSeries categoriesFor: #direction!public! !

!HROddsSeries methodsFor!
lastBacked
	self series isEmpty ifTrue: [^0].
	^self series last back! !
!HROddsSeries categoriesFor: #lastBacked!public! !

!HROddsSeries methodsFor!
lastLaid
	self series isEmpty ifTrue: [^0].
	^self series last lay! !
!HROddsSeries categoriesFor: #lastLaid!public! !

!HROddsSeries methodsFor!
lastOdds
	self series isEmpty ifTrue: [^0].
	^self series last odds
! !
!HROddsSeries categoriesFor: #lastOdds!public! !

!HROddsSeries methodsFor!
lastTotalTurnover
	self series isEmpty ifTrue: [^0].
	^self series last totalTurnover
! !
!HROddsSeries categoriesFor: #lastTotalTurnover!public! !

!HROddsSeries methodsFor!
lastTurnover
	self series isEmpty ifTrue: [^0].
	^self series last turnover
! !
!HROddsSeries categoriesFor: #lastTurnover!public! !

!HROddsSeries methodsFor!
oddsAt: aTime 
	^(self at: aTime) odds! !
!HROddsSeries categoriesFor: #oddsAt:!public! !

!HROddsSeries methodsFor!
series

	series ifNil: [ series := OrderedCollection new ].
	^series! !
!HROddsSeries categoriesFor: #series!public! !

!HROddsSeries methodsFor!
stDevOdds

	| allOdds avg num |
	allOdds := self allOdds.
	allOdds size < 2 ifTrue: [^0].
	avg := (allOdds inject: 0.0 into: [ :sum :each | sum + each ])/allOdds size.
	num := allOdds inject: 0 into: [ :sum :each | sum + ((each - avg) raisedTo: 2) ].
	^(num/(allOdds size - 1)) sqrt! !
!HROddsSeries categoriesFor: #stDevOdds!public! !

!HROddsSeries categoriesFor: #addBack:addLay:addTurnover:addTotalTurnover:time:!public! !

!HROddsSeries categoriesFor: #addBack:addLay:time:!public! !

!HROddsSeries categoriesFor: #addOdds:time:!public! !

!HROddsSeries categoriesFor: #allOdds!public! !

!HROddsSeries categoriesFor: #at:!public! !

!HROddsSeries categoriesFor: #direction!public! !

!HROddsSeries categoriesFor: #lastBacked!public! !

!HROddsSeries categoriesFor: #lastLaid!public! !

!HROddsSeries categoriesFor: #lastOdds!public! !

!HROddsSeries categoriesFor: #lastTotalTurnover!public! !

!HROddsSeries categoriesFor: #lastTurnover!public! !

!HROddsSeries categoriesFor: #oddsAt:!public! !

!HROddsSeries categoriesFor: #series!private! !

!HROddsSeries categoriesFor: #stDevOdds!private! !

HRPageFiler guid: (GUID fromString: '{7E5CEACE-E1AD-4F6C-A026-CE5E0EA11D9E}')!

HRPageFiler guid: (GUID fromString: '{7E5CEACE-E1AD-4F6C-A026-CE5E0EA11D9E}')!
HRPageFiler comment: ''!

HRPageFiler comment:
''!
!HRPageFiler categoriesForClass!Kernel-Objects! !
!HRPageFiler methodsFor!
pagesDirectory

	| path |
	path := String writeStream.
	path nextPutAll: HRApplication current pagesPath.
	Date today printOn: path format: 'dd-MM-yy'.
	path nextPut: $\.
	(File exists: path contents) ifFalse: [ File createDirectory: path contents ].
	^path contents! !
!HRPageFiler categoriesFor: #pagesDirectory!public! !

!HRPageFiler methodsFor!
sptHTTPGet: aURL toFile: fileName

	| request myStream |
	(request := SptHTTPRequest new)
		openGetTo: aURL;
		addHeader: 'Accept' value: '*/*';
		proxySettings: HRApplication current proxySettings.

	"Create the stream and set it into the request"
	myStream := FileStream 
				write: fileName
				text: false.
	request okBodyStream: myStream.
	
	[request
		send;
		waitOnReady] ensure: [myStream close].! !
!HRPageFiler categoriesFor: #sptHTTPGet:toFile:!public! !

!HRPageFiler methodsFor!
storeFromURL: aURL

	^self storeFromURL: aURL attempt: 1! !
!HRPageFiler categoriesFor: #storeFromURL:!public! !

!HRPageFiler methodsFor!
storeFromURL: aURL attempt: anAttempt

	| fileName |
	fileName := self pagesDirectory, GUID newUnique asString, '.htm'.
	[self sptHTTPGet: aURL toFile: fileName] on: Error do: [:x | 
			anAttempt > 3 ifTrue: 
				[^HRLogger current showAlways: ('Could not connect to ' , aURL, String lineDelimiter)].
			(Delay forSeconds: 15) wait.
			self storeFromURL: aURL attempt: (anAttempt + 1) ].
	^fileName
! !
!HRPageFiler categoriesFor: #storeFromURL:attempt:!public! !

!HRPageFiler categoriesFor: #pagesDirectory!public! !

!HRPageFiler categoriesFor: #sptHTTPGet:toFile:!public! !

!HRPageFiler categoriesFor: #storeFromURL:!public! !

!HRPageFiler categoriesFor: #storeFromURL:attempt:!public! !

!HRPageFiler class methodsFor!
storeFromURL: aURL

	^self new storeFromURL: aURL! !
!HRPageFiler class categoriesFor: #storeFromURL:!public! !

!HRPageFiler class categoriesFor: #storeFromURL:!public! !

HRRPLogon guid: (GUID fromString: '{4BBA9F06-CF57-4663-9114-0E8AA49E2A1D}')!

HRRPLogon guid: (GUID fromString: '{4BBA9F06-CF57-4663-9114-0E8AA49E2A1D}')!
HRRPLogon comment: ''!

HRRPLogon comment:
''!
!HRRPLogon categoriesForClass!Kernel-Objects! !
!HRRPLogon methodsFor!
cookieJar

	cookieJar ifNil: [self setCookieJar].
	^cookieJar! !
!HRRPLogon categoriesFor: #cookieJar!public! !

!HRRPLogon methodsFor!
findURLFrom: aString

	| stream |
	stream := ReadStream on: aString.
	stream skipToAll: 'location="'.
	^stream upTo: $"! !
!HRRPLogon categoriesFor: #findURLFrom:!public! !

!HRRPLogon methodsFor!
setCookieJar

	| request1 request2 request3 entity logonURL |

	"request1 is a standard POST of a form. For info on how/why this request 
	works see http://www.w3.org/TR/html401/interact/forms.html#h-17.13"

	request1 := SptHTTPRequest new. 
	"We are going to keep using the same cookieJar for each request 
	so lets hold onto it" 
	cookieJar := request1 cookieJar. 
	request1 openPostTo: 'https://reg.racingpost.co.uk/cde/login_iframe.sd';
		proxySettings: HRApplication current rpProxySettings. 
	entity := SptHTTPEntity fromString: 
		('in_un=', username, '&in_pw=', password, '&process=IN'). 
	entity contentType: 'application/x-www-form-urlencoded'. 
	request1 entity: entity. 
	request1 send; waitOnReady. 

	"look in the body for a new url" 
	"request1 lastResponse body"
	"<!!-- 
	window.location=""http://www.racingpost.co.uk/horses/?MIval=rp_reg_init&TMP_CK_CK=%
	7Fv%7Dw5u%2F2%23%24%22d%5CX%5BHHV%3A%3A""; 
	//-->" 
	"OK they have set a couple of cookies (have a look in the cookieJar) and told 
	us to get a new url" 

	request2 := SptHTTPRequest new. 
	request2 
		cookieJar: cookieJar;
		openGetTo: (self findURLFrom: request1 lastResponse body);
		addHeader: 'Accept' value: '*/*';
		addHeader: 'Accept-Encoding' value: '';
		proxySettings: HRApplication current rpProxySettings.
	request2 send; waitOnReady.

	"look in the body for the url" 
	"request2 lastResponse body"
	"window.location=""https://reg.racingpost.co.uk/cde/rp_reg_init.sd?RPID=%3f9t%2fI%2d%
	2dUJ%2aGE%25%23C%2a"";
	//-->
	&nbsp;&nbsp;Logging on to www.racingpost.co.uk, please wait.......<br>"
	"Wow ... we are being redirected again ... back to another secure url" 

	logonURL := self findURLFrom: request2 lastResponse body.

	request3 := SptHTTPRequest new. 
	request3 
		cookieJar: cookieJar;
		openGetTo: logonURL;
		addHeader: 'Accept' value: '*/*';
		addHeader: 'Accept-Encoding' value: '';
		proxySettings: HRApplication current rpProxySettings. 
	request3 send; waitOnReady.
! !
!HRRPLogon categoriesFor: #setCookieJar!public! !

!HRRPLogon methodsFor!
username: aUsername password: aPassword

	username := aUsername.
	password := aPassword.
! !
!HRRPLogon categoriesFor: #username:password:!public! !

!HRRPLogon categoriesFor: #cookieJar!public! !

!HRRPLogon categoriesFor: #findURLFrom:!public! !

!HRRPLogon categoriesFor: #setCookieJar!public! !

!HRRPLogon categoriesFor: #username:password:!public! !

!HRRPLogon class methodsFor!
username: aUsername password: aPassword

	^self new username: aUsername password: aPassword! !
!HRRPLogon class categoriesFor: #username:password:!public! !

!HRRPLogon class categoriesFor: #username:password:!public! !

ImperialDistance guid: (GUID fromString: '{8F70D6A5-AF2E-47C2-8FDB-945F6B85028C}')!

ImperialDistance guid: (GUID fromString: '{8F70D6A5-AF2E-47C2-8FDB-945F6B85028C}')!
ImperialDistance comment: ''!

ImperialDistance comment:
''!
!ImperialDistance categoriesForClass!Kernel-Objects! !
!ImperialDistance methodsFor!
furlongs

	^(self yards/220) truncated
! !
!ImperialDistance categoriesFor: #furlongs!public! !

!ImperialDistance methodsFor!
furlongs: furlongs

	self yards: furlongs*220 + self yards - (self furlongs * 220)
! !
!ImperialDistance categoriesFor: #furlongs:!public! !

!ImperialDistance methodsFor!
miles

	^(self furlongs/8) truncated
! !
!ImperialDistance categoriesFor: #miles!public! !

!ImperialDistance methodsFor!
miles: miles

	self yards: miles*8*220 + self yards - (self miles*8*220)
! !
!ImperialDistance categoriesFor: #miles:!public! !

!ImperialDistance methodsFor!
printOn: aStream

	| m f y |
	m := self miles.
	f := self furlongs \\ 8.
	y := self yards \\ 220.
	m isZero ifFalse: [ aStream nextPutAll: m printString; nextPut: $m].
	f isZero ifFalse: [ aStream nextPutAll: f printString; nextPut: $f]
		ifTrue: [ m isZero ifFalse: [ aStream nextPutAll: '0f']].
	aStream nextPutAll: y printString; nextPut: $y.
	^aStream! !
!ImperialDistance categoriesFor: #printOn:!public! !

!ImperialDistance methodsFor!
yards

	yards ifNil: [self yards: 0].
	^yards! !
!ImperialDistance categoriesFor: #yards!public! !

!ImperialDistance methodsFor!
yards: dist

	yards := dist
! !
!ImperialDistance categoriesFor: #yards:!public! !

!ImperialDistance categoriesFor: #furlongs!public! !

!ImperialDistance categoriesFor: #furlongs:!public! !

!ImperialDistance categoriesFor: #miles!public! !

!ImperialDistance categoriesFor: #miles:!public! !

!ImperialDistance categoriesFor: #printOn:!public! !

!ImperialDistance categoriesFor: #yards!public! !

!ImperialDistance categoriesFor: #yards:!public! !

!ImperialDistance class methodsFor!
fromString: aString
	"Answer an instance of the receiver constructed from the string, aString"

	^self readFrom: aString readStream! !
!ImperialDistance class categoriesFor: #fromString:!public! !

!ImperialDistance class methodsFor!
furlongs: dist

	^self basicNew furlongs: dist! !
!ImperialDistance class categoriesFor: #furlongs:!public! !

!ImperialDistance class methodsFor!
miles: dist

	^self basicNew miles: dist! !
!ImperialDistance class categoriesFor: #miles:!public! !

!ImperialDistance class methodsFor!
readFrom: aStream
	"Answers a new instance of the receiver read from aStream according to
	aFormatStringOrNil"

	| miles furlongs yards |
	miles := 0.
	furlongs := 0.
	yards := 0.
"

	hours := Integer readFrom: aStream radix: 10.
	separator := aStream peek.
	(separator isNil or: [separator isLetter]) 
		ifFalse: 
			[aStream next.
			minutes := Integer readFrom: aStream radix: 10.
			aStream peek = separator 
				ifTrue: 
					[aStream next.
					seconds := Integer readFrom: aStream radix: 10].
			aStream peek = separator 
				ifTrue: 
					[aStream next.
					milliseconds := Integer readFrom: aStream radix: 10]].
	aStream skipWhile: [:c | c isWhitespace].
	am := self amMarker.
	(am notEmpty and: [am skipOver: aStream ignoreCase: true]) 
		ifTrue: 
			[((0 to: 12) includes: hours) ifFalse: [^self errorInvalidFormat].
			hours := hours % 12]
		ifFalse: 
			[| pm |
			pm := self pmMarker.
			(pm notEmpty and: [pm skipOver: aStream ignoreCase: true]) 
				ifTrue: 
					[((0 to: 12) includes: hours) ifFalse: [^self errorInvalidFormat].
					hours < 12 ifTrue: [hours := hours + 12]]].
	((0 to: 23) includes: hours) ifFalse: [^self errorInvalidFormat].
	((0 to: 59) includes: minutes) ifFalse: [^self errorInvalidFormat].
	((0 to: 59) includes: seconds) ifFalse: [^self errorInvalidFormat].
	((0 to: 999) includes: milliseconds) ifFalse: [^self errorInvalidFormat].
	^Time fromMilliseconds: (60 * (60 * hours + minutes) + seconds) * 1000 + milliseconds

"! !
!ImperialDistance class categoriesFor: #readFrom:!public! !

!ImperialDistance class methodsFor!
yards: dist

	^self basicNew yards: dist! !
!ImperialDistance class categoriesFor: #yards:!public! !

!ImperialDistance class categoriesFor: #fromString:!instance creation!public! !

!ImperialDistance class categoriesFor: #furlongs:!public! !

!ImperialDistance class categoriesFor: #miles:!public! !

!ImperialDistance class categoriesFor: #readFrom:!instance creation!public! !

!ImperialDistance class categoriesFor: #yards:!public! !

HRImportBetfairDay guid: (GUID fromString: '{72D48BE0-9A4E-4304-9D46-B94133FC81B1}')!

HRImportBetfairDay guid: (GUID fromString: '{72D48BE0-9A4E-4304-9D46-B94133FC81B1}')!
HRImportBetfairDay comment: ''!

HRImportBetfairDay comment:
''!
!HRImportBetfairDay categoriesForClass!Kernel-Objects! !
!HRImportBetfairDay methodsFor!
extractRaceFromNode: aString

	"sample
	Old '1016910~MrktR~L~2~E~0~O~0~0~13~05/10/2003 14:40'
	13/09/2004: '2085446~13~14:30 Bath ~2~O~0~0~~0~'
	note that this time is UTC - not sure about this anymore
	"
	| stream no name dateAndTime time date bfMtg localTime |
	stream := aString readStream.
	no := stream upTo: $~.
	stream skipTo: $~.
	time := Time fromString: (stream upTo: Character space).
	name := (stream upTo: $~) trimBlanks asUppercase asSymbol.
"	dateAndTime := aString last: 16.
	date := Date fromString: (dateAndTime first: 10).
	time := Time fromString: (dateAndTime last: 5)."
"	localTime := Time fromSeconds: (time asSeconds + DateAndTime defaultOffset asSeconds)."
	bfMtg := self meetingsAt: name.
	bfMtg addRace: no time: time.! !
!HRImportBetfairDay categoriesFor: #extractRaceFromNode:!public! !

!HRImportBetfairDay methodsFor!
findRawRaces
	| stream substream |
	stream := ReadStream on: self contents.
	stream skipToAll: 'm_meatArray = '''.
	substream := ReadStream on: (stream upToAll: '''; // end').
	[substream atEnd] whileFalse:
	[self rawRaces addLast: (substream upTo: $|)].
! !
!HRImportBetfairDay categoriesFor: #findRawRaces!public! !

!HRImportBetfairDay methodsFor!
meetings
	meetings ifNil: [ meetings := IdentityDictionary new ].
	^meetings! !
!HRImportBetfairDay categoriesFor: #meetings!public! !

!HRImportBetfairDay methodsFor!
meetingsAt: aMtg
	^self meetings at: aMtg ifAbsent: [ ^self meetings at: aMtg put: HRBFMeeting new ]! !
!HRImportBetfairDay categoriesFor: #meetingsAt:!public! !

!HRImportBetfairDay methodsFor!
raceAt: aMtg time: aTime
	^(self meetings 
		at: aMtg 
		ifAbsent: [HRLogger current showError: 'Did not recognise the abbreviation: ', 
			aMtg, String lineDelimiter.
			^'']) 
		raceAt: aTime! !
!HRImportBetfairDay categoriesFor: #raceAt:time:!public! !

!HRImportBetfairDay methodsFor!
rawRaces
	rawRaces ifNil: [rawRaces := OrderedCollection new].
	^rawRaces! !
!HRImportBetfairDay categoriesFor: #rawRaces!public! !

!HRImportBetfairDay methodsFor!
setAll


	self findRawRaces.
"	self rawRaces do: [ :each | self findRaceFrom: each ]."
	self rawRaces do: [ :each | self extractRaceFromNode: each ].
	HRApplication current meetings do: [ :mtg |
		mtg races do: [ :race | "race bfRaceID isEmpty ifTrue: ["
			race bfRaceID: (self raceAt: mtg bfAbbr time: race time).
			race bfRaceID isEmpty ifFalse: [
				HRLogger current showAlways: 'Betfair race ID set for: ', mtg course, ' - ', race shortTime, String lineDelimiter.
				]
			"]"]
		].! !
!HRImportBetfairDay categoriesFor: #setAll!public! !

!HRImportBetfairDay categoriesFor: #extractRaceFromNode:!public! !

!HRImportBetfairDay categoriesFor: #findRawRaces!accessing!public! !

!HRImportBetfairDay categoriesFor: #meetings!public! !

!HRImportBetfairDay categoriesFor: #meetingsAt:!public! !

!HRImportBetfairDay categoriesFor: #raceAt:time:!public! !

!HRImportBetfairDay categoriesFor: #rawRaces!public! !

!HRImportBetfairDay categoriesFor: #setAll!public! !

HRImportBetfairMenu guid: (GUID fromString: '{F9E0918B-D18D-4028-B9DC-62ED030ED558}')!

HRImportBetfairMenu guid: (GUID fromString: '{F9E0918B-D18D-4028-B9DC-62ED030ED558}')!
HRImportBetfairMenu comment: ''!

HRImportBetfairMenu comment:
''!
!HRImportBetfairMenu categoriesForClass!Unclassified! !
!HRImportBetfairMenu methodsFor!
extractMenuNodes
	nodes := (self menuSubstring subStrings: $|) collect: [ :each | each subStrings: $~ ]! !
!HRImportBetfairMenu categoriesFor: #extractMenuNodes!public! !

!HRImportBetfairMenu methodsFor!
nodes

	nodes ifNil: [self extractMenuNodes].
	^nodes! !
!HRImportBetfairMenu categoriesFor: #nodes!public! !

!HRImportBetfairMenu categoriesFor: #extractMenuNodes!accessing!public! !

!HRImportBetfairMenu categoriesFor: #nodes!public! !

HRImportBetfairNag guid: (GUID fromString: '{B024984D-0170-4B09-8BC4-3C4D79BE9440}')!

HRImportBetfairNag guid: (GUID fromString: '{B024984D-0170-4B09-8BC4-3C4D79BE9440}')!
HRImportBetfairNag comment: ''!

HRImportBetfairNag comment:
''!
!HRImportBetfairNag categoriesForClass!Kernel-Objects! !
!HRImportBetfairNag methodsFor!
nag
	^nag! !
!HRImportBetfairNag categoriesFor: #nag!public! !

!HRImportBetfairNag methodsFor!
nag: anObject
	nag := anObject! !
!HRImportBetfairNag categoriesFor: #nag:!public! !

!HRImportBetfairNag methodsFor!
setAll
#deprecated.
	self setTurnovers.
! !
!HRImportBetfairNag categoriesFor: #setAll!public! !

!HRImportBetfairNag methodsFor!
setAllPlace

	self setPlaceTurnovers.
! !
!HRImportBetfairNag categoriesFor: #setAllPlace!public! !

!HRImportBetfairNag methodsFor!
setAllWin

	self setWinTurnovers.
! !
!HRImportBetfairNag categoriesFor: #setAllWin!public! !

!HRImportBetfairNag methodsFor!
setPlaceTurnovers

	self setTurnovers.
	(nag bfPlace at: self time) turnover: (self numberFrom: nagTO) totalTurnover: (self numberFrom: raceTO).! !
!HRImportBetfairNag categoriesFor: #setPlaceTurnovers!public! !

!HRImportBetfairNag methodsFor!
setTurnovers
	| stream |
	stream := self contents readStream.
"race turnover"
	stream skipToAll: 'Total matched'.
	stream skipToAll: 'GlobalBoldedText'.
	stream skipTo: $>.
	raceTO := stream upTo: $<.
	raceTO isEmpty ifTrue: [ raceTO := '0'].
"nag turnover"
	stream skipToAll: 'Betting summary'.
	stream skipToAll: 'GlobalBoldedText'.
	stream skipTo: $>.
	nagTO := stream upTo: $<.
	nagTO isEmpty ifTrue: [ nagTO := '0'].
! !
!HRImportBetfairNag categoriesFor: #setTurnovers!public! !

!HRImportBetfairNag methodsFor!
setWinTurnovers

	self setTurnovers.
	(nag bfWin at: self time) turnover: (self numberFrom: nagTO) totalTurnover: (self numberFrom: raceTO).! !
!HRImportBetfairNag categoriesFor: #setWinTurnovers!public! !

!HRImportBetfairNag methodsFor!
time
	time ifNil: [time := Time fromSeconds: 0].
	^time! !
!HRImportBetfairNag categoriesFor: #time!public! !

!HRImportBetfairNag methodsFor!
time: anObject
	time := anObject! !
!HRImportBetfairNag categoriesFor: #time:!public! !

!HRImportBetfairNag categoriesFor: #nag!accessing!private! !

!HRImportBetfairNag categoriesFor: #nag:!accessing!private! !

!HRImportBetfairNag categoriesFor: #setAll!public! !

!HRImportBetfairNag categoriesFor: #setAllPlace!public! !

!HRImportBetfairNag categoriesFor: #setAllWin!public! !

!HRImportBetfairNag categoriesFor: #setPlaceTurnovers!accessing!private! !

!HRImportBetfairNag categoriesFor: #setTurnovers!accessing!private! !

!HRImportBetfairNag categoriesFor: #setWinTurnovers!accessing!private! !

!HRImportBetfairNag categoriesFor: #time!accessing!private! !

!HRImportBetfairNag categoriesFor: #time:!accessing!private! !

!HRImportBetfairNag class methodsFor!
on: aString nag: aNag

	^self new nag: aNag; on: aString! !
!HRImportBetfairNag class categoriesFor: #on:nag:!public! !

!HRImportBetfairNag class methodsFor!
onURL: aUrl nag: aNag

	^self new nag: aNag; onURL: aUrl! !
!HRImportBetfairNag class categoriesFor: #onURL:nag:!public! !

!HRImportBetfairNag class methodsFor!
onURL: aUrl nag: aNag time: aTime

	^self new nag: aNag; time: aTime; onURL: aUrl! !
!HRImportBetfairNag class categoriesFor: #onURL:nag:time:!public! !

!HRImportBetfairNag class categoriesFor: #on:nag:!public! !

!HRImportBetfairNag class categoriesFor: #onURL:nag:!public! !

!HRImportBetfairNag class categoriesFor: #onURL:nag:time:!public! !

HRImportBetfairRace guid: (GUID fromString: '{BC9D9A84-7E39-48AF-8828-28A04243D760}')!

HRImportBetfairRace guid: (GUID fromString: '{BC9D9A84-7E39-48AF-8828-28A04243D760}')!
HRImportBetfairRace comment: ''!

HRImportBetfairRace comment:
''!
!HRImportBetfairRace categoriesForClass!Kernel-Objects! !
!HRImportBetfairRace methodsFor!
race

	race ifNil: [race := HRRace new].
	^race! !
!HRImportBetfairRace categoriesFor: #race!public! !

!HRImportBetfairRace methodsFor!
race: aRace

	race := aRace! !
!HRImportBetfairRace categoriesFor: #race:!public! !

!HRImportBetfairRace methodsFor!
rawNags

	rawNags ifNil: [rawNags := OrderedCollection new].
	^rawNags! !
!HRImportBetfairRace categoriesFor: #rawNags!public! !

!HRImportBetfairRace methodsFor!
setAll
#deprecated.
	self race nags do: [ :each | each bfPut: 0; bfLay: 0].
	self setRawNags.
	self rawNags do: [ :nag | self setNagFrom: nag ].
		
! !
!HRImportBetfairRace categoriesFor: #setAll!public! !

!HRImportBetfairRace methodsFor!
setAllPlace

	self setRawNags.
	self rawNags do: [ :nag | self setNagPlaceFrom: nag ].
		
! !
!HRImportBetfairRace categoriesFor: #setAllPlace!public! !

!HRImportBetfairRace methodsFor!
setAllWin

	self setRawNags.
	self rawNags do: [ :nag | self setNagWinFrom: nag ].
		
! !
!HRImportBetfairRace categoriesFor: #setAllWin!public! !

!HRImportBetfairRace methodsFor!
setNagFrom: aString
	| stream nagID nagName back lay myNag |
#deprecated.
	stream := ReadStream on: aString.
"nag ID"
	stream skipToAll: 'MoreInfo('.
	nagID := stream upTo: $).
"nag name"
	stream skipToAll: '<b>'.
	nagName := (self checkName: (stream upTo: $<)) asUppercase trimBlanks.
	myNag := self race nagNamed: nagName.
	myNag isNil ifTrue: [^nil].
	myNag bfID: nagID.
"back"
	stream skipToAll: 'bgcolor="#b1bddb"'.
	stream skipToAll: '<b>'.
	back := stream upTo: $<.
	back isEmpty ifTrue: [ back := '0'].
	myNag bfPut: (self numberFrom: back).
"lay"
	stream skipToAll: 'bgcolor="#d794c4"'.
	stream skipToAll: '<b>'.
	lay := stream upTo: $<.
	lay isEmpty ifTrue: [ lay := '0'].
	myNag bfLay: (self numberFrom: lay).

	myNag bfWin addBack: (self numberFrom: back) addLay: (self numberFrom: lay) time: self time.
! !
!HRImportBetfairRace categoriesFor: #setNagFrom:!public! !

!HRImportBetfairRace methodsFor!
setNagPlaceFrom: aString

	| array nagID nagName back lay myNag |
	"4247637,447047,2018998,'Punctilious',0,false,3.2,224.0,3.25,474.0,3.3,1139.0,3.35,144.0,3.4,1219.0,3.45,585.0,oM"
	array := aString subStrings: $,.
	nagName := (array at: 4) midString: ((array at: 4) size - 2) from: 2.
	myNag := self race nagNamed: nagName.
	myNag isNil ifTrue: [^nil].
	myNag bfID: (array at: 2).
	myNag bfPlaceID: (array at: 2).
	back := self numberFrom: (array at: 11).
	lay := self numberFrom: (array at: 13).
	myNag bfPlace addBack: back addLay: lay time: self time.
	myNag preRaceNR ifTrue: [ myNag bfPlace addBack: 0 addLay: 0 time: (self time addTime: (Time fromSeconds: 1)) ].
! !
!HRImportBetfairRace categoriesFor: #setNagPlaceFrom:!public! !

!HRImportBetfairRace methodsFor!
setNagWinFrom: aString

	| array nagID nagName back lay myNag |
	"4247637,447047,2018998,'Punctilious',0,false,3.2,224.0,3.25,474.0,3.3,1139.0,3.35,144.0,3.4,1219.0,3.45,585.0,oM"
	array := aString subStrings: $,.
	nagName := (array at: 4) midString: ((array at: 4) size - 2) from: 2.
	myNag := self race nagNamed: nagName.
	myNag isNil ifTrue: [^nil].
	myNag bfID: (array at: 2).
	myNag bfWinID: (array at: 2).
	back := self numberFrom: (array at: 11).
	lay := self numberFrom: (array at: 13).
"	myNag bfPut: back.
	myNag bfLay: lay.
"	myNag bfWin addBack: back addLay: lay time: self time.
	myNag preRaceNR ifTrue: [ myNag bfWin addBack: 0 addLay: 0 time: (self time addTime: (Time fromSeconds: 1)) ].


"	| stream nagID nagName back lay myNag |
	stream := ReadStream on: aString.
	stream skipToAll: 'MoreInfo('.
	nagID := stream upTo: $).
	stream skipToAll: '<b>'.
	nagName := (self checkName: (stream upTo: $<)) asUppercase trimBlanks.
	myNag := self race nagNamed: nagName.
	myNag isNil ifTrue: [^nil].
	myNag bfID: nagID.
	myNag bfWinID: nagID.
	stream skipToAll: 'bgcolor=#b1bddb'.
	stream skipToAll: '<b>'.
	back := stream upTo: $<.
	back isEmpty ifTrue: [ back := '0'].
	myNag bfPut: (self numberFrom: back).
	stream skipToAll: 'bgcolor="#d794c4"'.
	stream skipToAll: '<b>'.
	lay := stream upTo: $<.
	lay isEmpty ifTrue: [ lay := '0'].
	myNag bfLay: (self numberFrom: lay).

	myNag bfWin addBack: (self numberFrom: back) addLay: (self numberFrom: lay) time: self time.
"! !
!HRImportBetfairRace categoriesFor: #setNagWinFrom:!public! !

!HRImportBetfairRace methodsFor!
setRawNags
	| stream |
	stream := self contents readStream.
"raw nags"
	[stream skipToAll: 'p.m_R('.
	stream atEnd] whileFalse: [ | result | 
		result := stream upTo: $).
		self rawNags addLast: result.
		].
! !
!HRImportBetfairRace categoriesFor: #setRawNags!public! !

!HRImportBetfairRace methodsFor!
time
	time ifNil: [time := Time fromSeconds: 0].
	^time! !
!HRImportBetfairRace categoriesFor: #time!public! !

!HRImportBetfairRace methodsFor!
time: anObject
	time := anObject! !
!HRImportBetfairRace categoriesFor: #time:!public! !

!HRImportBetfairRace categoriesFor: #race!public! !

!HRImportBetfairRace categoriesFor: #race:!public! !

!HRImportBetfairRace categoriesFor: #rawNags!public! !

!HRImportBetfairRace categoriesFor: #setAll!public! !

!HRImportBetfairRace categoriesFor: #setAllPlace!public! !

!HRImportBetfairRace categoriesFor: #setAllWin!public! !

!HRImportBetfairRace categoriesFor: #setNagFrom:!accessing!private! !

!HRImportBetfairRace categoriesFor: #setNagPlaceFrom:!accessing!private! !

!HRImportBetfairRace categoriesFor: #setNagWinFrom:!accessing!private! !

!HRImportBetfairRace categoriesFor: #setRawNags!accessing!private! !

!HRImportBetfairRace categoriesFor: #time!accessing!private! !

!HRImportBetfairRace categoriesFor: #time:!accessing!private! !

!HRImportBetfairRace class methodsFor!
onURL: aUrl race: aRace

	^self new race: aRace; onURL: aUrl! !
!HRImportBetfairRace class categoriesFor: #onURL:race:!public! !

!HRImportBetfairRace class methodsFor!
onURL: aUrl race: aRace time: aTime

	^self new race: aRace; time: aTime; onURL: aUrl! !
!HRImportBetfairRace class categoriesFor: #onURL:race:time:!public! !

!HRImportBetfairRace class categoriesFor: #onURL:race:!public! !

!HRImportBetfairRace class categoriesFor: #onURL:race:time:!public! !

HRImportPPEsts guid: (GUID fromString: '{B7D0089E-9AA3-446C-A698-AE1611914978}')!

HRImportPPEsts guid: (GUID fromString: '{B7D0089E-9AA3-446C-A698-AE1611914978}')!
HRImportPPEsts comment: ''!

HRImportPPEsts comment:
''!
!HRImportPPEsts categoriesForClass!Kernel-Objects! !
!HRImportPPEsts methodsFor!
checkMeeting

	| date mtg stream |
	stream := ReadStream on: self contents.
	date := Date fromString: (stream upTo: $,).
	mtg := stream upTo: $,.
	^((self meeting date = date) and: [mtg sameAs: self meeting course])! !
!HRImportPPEsts categoriesFor: #checkMeeting!public! !

!HRImportPPEsts methodsFor!
meeting

	meeting ifNil: [ meeting := HRMeeting new].
	^meeting! !
!HRImportPPEsts categoriesFor: #meeting!public! !

!HRImportPPEsts methodsFor!
meeting: aMeeting

	meeting := aMeeting! !
!HRImportPPEsts categoriesFor: #meeting:!public! !

!HRImportPPEsts methodsFor!
readEstsFor: leg

	| stream rawNags lines |
	lines := OrderedCollection new.
	stream := ReadStream on: self contents.
	stream reset.
	stream skipToAll: ('Leg ', leg displayString).
	stream skipToAll: String lineDelimiter.
	rawNags := ReadStream on: (stream upToAll: ('Leg ', (leg + 1) displayString)).
	[rawNags atEnd] whileFalse: [lines addLast: rawNags nextLine].
	lines do: [ :each | 
		| line nagNo est pick nag | 
		each isEmpty ifFalse: [
			line := ReadStream on: each.
			line peek isDigit ifTrue: [ 
				nagNo := line upTo: $,.
				17 timesRepeat: [ line skipTo: $, ].
				est := line upTo: $,.
				4 timesRepeat: [ line skipTo: $, ].
				pick := line upTo: $,.
				nag := (self meeting leg: leg) nagNo: (Number fromString: nagNo).
				nag ppEst: (Number fromString: est).
				nag mySelect: false.
				pick isEmpty ifFalse: [nag mySelect: true].
				].
			line reset.
			line peek = $, ifTrue: [
				18 timesRepeat: [ line skipTo: $, ].
				est := line upTo: $,.
				(self meeting leg: leg) ppFavEst: (Number fromString: est).
				].
			].
		].
	(self meeting leg: leg) ppValDirty: true.! !
!HRImportPPEsts categoriesFor: #readEstsFor:!public! !

!HRImportPPEsts methodsFor!
setAll

	self checkMeeting ifTrue: [
		1 to: 6 do: [ :leg | self readEstsFor: leg ]
		].! !
!HRImportPPEsts categoriesFor: #setAll!public! !

!HRImportPPEsts categoriesFor: #checkMeeting!public! !

!HRImportPPEsts categoriesFor: #meeting!public! !

!HRImportPPEsts categoriesFor: #meeting:!public! !

!HRImportPPEsts categoriesFor: #readEstsFor:!public! !

!HRImportPPEsts categoriesFor: #setAll!public! !

!HRImportPPEsts class methodsFor!
on: aFile meeting: aMeeting

	^self new on: aFile; meeting: aMeeting
! !
!HRImportPPEsts class categoriesFor: #on:meeting:!public! !

!HRImportPPEsts class categoriesFor: #on:meeting:!public! !

HRImportRPPreRaceDay guid: (GUID fromString: '{CA1CEAE9-2C17-4665-AAC4-5EFB13EF6207}')!

HRImportRPPreRaceDay guid: (GUID fromString: '{CA1CEAE9-2C17-4665-AAC4-5EFB13EF6207}')!
HRImportRPPreRaceDay comment: ''!

HRImportRPPreRaceDay comment:
''!
!HRImportRPPreRaceDay categoriesForClass!Kernel-Objects! !
!HRImportRPPreRaceDay methodsFor!
listOfCourses

	^HRApplication current courseNames! !
!HRImportRPPreRaceDay categoriesFor: #listOfCourses!public! !

!HRImportRPPreRaceDay methodsFor!
meetingURLs
	meetingURLs ifNil: [meetingURLs := OrderedCollection new].
	^meetingURLs! !
!HRImportRPPreRaceDay categoriesFor: #meetingURLs!public! !

!HRImportRPPreRaceDay methodsFor!
onURL: aURL

	
"	[ self contents: (FileStream on: (IStream onURL: aURL)) contents. ] 
		on: Error do: [:x | ^HRLogger current show: ('Could not connect to ' , aURL, String lineDelimiter)].
"
	self on: (HRRPPageFiler storeFromURL: aURL)! !
!HRImportRPPreRaceDay categoriesFor: #onURL:!public! !

!HRImportRPPreRaceDay methodsFor!
setMeetingURLs
	| stream substream url course |
	stream := ReadStream on: self contents.
	stream skipToAll: 'OTHER MEETINGS'.
	substream := ReadStream on: (stream upToAll: '</table>').
	[substream skipToAll: '<A HREF='.
	substream atEnd] whileFalse:
	[url := substream upTo: Character space. 
	substream skipTo: $>.
	course := (substream upTo: $<) words first asUppercase asSymbol.
	url := url copyFrom: 2 to: (url size - 1).
	((self listOfCourses includes: course) and: [url first = $h]) 
		ifTrue: [self meetingURLs addLast: url]].
	! !
!HRImportRPPreRaceDay categoriesFor: #setMeetingURLs!public! !

!HRImportRPPreRaceDay categoriesFor: #listOfCourses!public! !

!HRImportRPPreRaceDay categoriesFor: #meetingURLs!accessing!public! !

!HRImportRPPreRaceDay categoriesFor: #onURL:!public! !

!HRImportRPPreRaceDay categoriesFor: #setMeetingURLs!accessing!public! !

HRImportRPPreRaceMeeting guid: (GUID fromString: '{1F871A51-3FA3-4EAD-989E-8BF6EC6418DC}')!

HRImportRPPreRaceMeeting guid: (GUID fromString: '{1F871A51-3FA3-4EAD-989E-8BF6EC6418DC}')!
HRImportRPPreRaceMeeting comment: ''!

HRImportRPPreRaceMeeting comment:
''!
!HRImportRPPreRaceMeeting categoriesForClass!Kernel-Objects! !
!HRImportRPPreRaceMeeting methodsFor!
importRaceData

	self raceURLs do: [ :each | | raceImport attempt |
		attempt := 1.
		raceImport := HRImportRPPreRaceRace onURL: ('http://www.racingpost.co.uk', each).
		[raceImport isInvalid and: [attempt < 10]] whileTrue: [
			attempt := attempt + 1.
	 		(Delay forSeconds: 5) wait.
			raceImport := HRImportRPPreRaceRace onURL: each].
		raceImport isValid ifTrue: [
			raceImport setAllFor: self meeting.
			self meeting addRace: raceImport race.
			HRLogger current showAlways: (raceImport race time displayString, ' ', 
				raceImport race name, String lineDelimiter)]
			ifFalse: [HRLogger current showError: 'Could not import RP Race', String lineDelimiter].
		].! !
!HRImportRPPreRaceMeeting categoriesFor: #importRaceData!public! !

!HRImportRPPreRaceMeeting methodsFor!
meeting
	meeting ifNil: [self meeting: HRMeeting new].
	^meeting! !
!HRImportRPPreRaceMeeting categoriesFor: #meeting!public! !

!HRImportRPPreRaceMeeting methodsFor!
meeting: anObject
	meeting := anObject! !
!HRImportRPPreRaceMeeting categoriesFor: #meeting:!public! !

!HRImportRPPreRaceMeeting methodsFor!
onURL: aURL

	
"	[ self contents: (FileStream on: (IStream onURL: aURL)) contents. ] 
		on: Error do: [:x | ^HRLogger current show: ('Could not connect to ' , aURL, String lineDelimiter)].
"
	self on: (HRRPPageFiler storeFromURL: aURL)! !
!HRImportRPPreRaceMeeting categoriesFor: #onURL:!public! !

!HRImportRPPreRaceMeeting methodsFor!
raceURLs
	raceURLs ifNil: [raceURLs := OrderedCollection new].
	^raceURLs! !
!HRImportRPPreRaceMeeting categoriesFor: #raceURLs!public! !

!HRImportRPPreRaceMeeting methodsFor!
setMeetingAndRaceURLs
	| stream substream |
	stream := ReadStream on: self contents.
	"course"
	stream skipToAll: '<table cellpadding=0 cellspacing=0 width=100% ALIGN=CENTER COLS=4>'.
	stream skipToAll: '<tr><td colspan=3 align=center class="H3"><b>'.
	self meeting course: (stream upTo: $<) trimBlanks.
	"date"
"	stream skipToAll: '<p class=HC4>'.
	stream skipToAll: '<p class=HC4>'."
	stream skipToAll: '<tr><td colspan=3 align=center class="B1"><b>'.
	self meeting dateString: (stream upTo: $<).
	"race urls"
	substream := ReadStream on: (stream upToAll: '</table>').
	
	[substream skipToAll: '<a href="'.
	substream atEnd] whileFalse: 
				[self raceURLs addLast: (substream upToAll: '" ').
				substream skipToAll: '</tr>'.].
! !
!HRImportRPPreRaceMeeting categoriesFor: #setMeetingAndRaceURLs!public! !

!HRImportRPPreRaceMeeting categoriesFor: #importRaceData!public! !

!HRImportRPPreRaceMeeting categoriesFor: #meeting!accessing!private! !

!HRImportRPPreRaceMeeting categoriesFor: #meeting:!accessing!private! !

!HRImportRPPreRaceMeeting categoriesFor: #onURL:!public! !

!HRImportRPPreRaceMeeting categoriesFor: #raceURLs!accessing!private! !

!HRImportRPPreRaceMeeting categoriesFor: #setMeetingAndRaceURLs!accessing!public! !

HRImportRPRace guid: (GUID fromString: '{6C516D2B-BA93-4725-9A2E-A0613FE31AA8}')!

HRImportRPRace guid: (GUID fromString: '{6C516D2B-BA93-4725-9A2E-A0613FE31AA8}')!
HRImportRPRace comment: ''!

HRImportRPRace comment:
''!
!HRImportRPRace categoriesForClass!Kernel-Objects! !
!HRImportRPRace methodsFor!
contentsStream
	contentsStream ifNil: [self contentsStream: self contents readStream].
	^contentsStream! !
!HRImportRPRace categoriesFor: #contentsStream!public! !

!HRImportRPRace methodsFor!
contentsStream: anObject
	contentsStream := anObject! !
!HRImportRPRace categoriesFor: #contentsStream:!public! !

!HRImportRPRace methodsFor!
on: aString

	super on: aString.
	self contentsStream: self contents readStream.! !
!HRImportRPRace categoriesFor: #on:!public! !

!HRImportRPRace methodsFor!
onURL: aURL

"	super onURL: aURL attempt: 1."
	self on: (HRRPPageFiler storeFromURL: aURL).
	self contentsStream: self contents readStream.! !
!HRImportRPRace categoriesFor: #onURL:!public! !

!HRImportRPRace methodsFor!
race
	race ifNil: [self race: HRRace new].
	^race! !
!HRImportRPRace categoriesFor: #race!public! !

!HRImportRPRace methodsFor!
race: anObject
	race := anObject! !
!HRImportRPRace categoriesFor: #race:!public! !

!HRImportRPRace methodsFor!
rawNags
	rawNags ifNil: [rawNags := OrderedCollection new].
	^rawNags! !
!HRImportRPRace categoriesFor: #rawNags!public! !

!HRImportRPRace categoriesFor: #contentsStream!accessing!private! !

!HRImportRPRace categoriesFor: #contentsStream:!accessing!private! !

!HRImportRPRace categoriesFor: #on:!public! !

!HRImportRPRace categoriesFor: #onURL:!public! !

!HRImportRPRace categoriesFor: #race!accessing!private! !

!HRImportRPRace categoriesFor: #race:!accessing!private! !

!HRImportRPRace categoriesFor: #rawNags!accessing!private! !

!HRImportRPRace class methodsFor!
on: aFile race: aRace

	^self new on: aFile; race: aRace! !
!HRImportRPRace class categoriesFor: #on:race:!public! !

!HRImportRPRace class methodsFor!
onURL: aURL race: aRace

	^self new race: aRace; onURL: aURL! !
!HRImportRPRace class categoriesFor: #onURL:race:!public! !

!HRImportRPRace class categoriesFor: #on:race:!public! !

!HRImportRPRace class categoriesFor: #onURL:race:!public! !

HRImportSLPreMeetingNR guid: (GUID fromString: '{38BBC0FD-889E-4E3A-871B-59463F9B67A8}')!

HRImportSLPreMeetingNR guid: (GUID fromString: '{38BBC0FD-889E-4E3A-871B-59463F9B67A8}')!
HRImportSLPreMeetingNR comment: ''!

HRImportSLPreMeetingNR comment:
''!
!HRImportSLPreMeetingNR categoriesForClass!Unclassified! !
!HRImportSLPreMeetingNR methodsFor!
findNagsIn: aString
	| stream result |
	stream := ReadStream on: aString.
	result := OrderedCollection new.
	[stream atEnd] whileFalse: [ | nag |
		stream skipTo: Character space.
		nag := stream upTo: $,.
		nag isEmpty ifFalse: [ result addLast: nag ].
		].
	^result! !
!HRImportSLPreMeetingNR categoriesFor: #findNagsIn:!public! !

!HRImportSLPreMeetingNR methodsFor!
meeting
	^meeting! !
!HRImportSLPreMeetingNR categoriesFor: #meeting!public! !

!HRImportSLPreMeetingNR methodsFor!
meeting: anObject
	meeting := anObject! !
!HRImportSLPreMeetingNR categoriesFor: #meeting:!public! !

!HRImportSLPreMeetingNR methodsFor!
meetings
#deprecated.
	meetings ifNil: [self meetings: OrderedCollection new].
	^meetings! !
!HRImportSLPreMeetingNR categoriesFor: #meetings!public! !

!HRImportSLPreMeetingNR methodsFor!
meetings: anObject
#deprecated.
	meetings := anObject! !
!HRImportSLPreMeetingNR categoriesFor: #meetings:!public! !

!HRImportSLPreMeetingNR methodsFor!
rawMeetings
	rawMeetings ifNil: [rawMeetings := OrderedCollection new].
	^rawMeetings! !
!HRImportSLPreMeetingNR categoriesFor: #rawMeetings!public! !

!HRImportSLPreMeetingNR methodsFor!
setNonRunners
#deprecated.
	self rawMeetings do: [ :each | self setNonRunnersFrom: each ]! !
!HRImportSLPreMeetingNR categoriesFor: #setNonRunners!public! !

!HRImportSLPreMeetingNR methodsFor!
setNonRunnersFor: aMeeting

	| rawMeeting |
	rawMeeting := self rawMeetings detect: [ :each | | stream |
		stream := ReadStream on: each.
		(stream upTo: $<) trimBlanks soundsLike: aMeeting course ] ifNone: [ ].
	rawMeeting isNil ifFalse: [ self setNonRunnersFrom: rawMeeting for: aMeeting ].! !
!HRImportSLPreMeetingNR categoriesFor: #setNonRunnersFor:!public! !

!HRImportSLPreMeetingNR methodsFor!
setNonRunnersFrom: aString
	| stream meetingName mtg raceTime race nags nagName |
#deprecated.
	stream := ReadStream on: aString.
	meetingName := (stream upTo: $<) trimBlanks.
	mtg := self meetings detect: [ :each | meetingName soundsLike: each course ] 
		ifNone: [^nil].

	[stream skipToAll: '<tr>'.
	stream atEnd] whileFalse: [
		stream skipToAll: '<b>'.
		raceTime := Time fromString: (stream upTo: $&).
		stream skipTo: $;.
		race := mtg races detect: [ :each | each time = raceTime ] ifNone: [].
		race isNil ifFalse: [
			nags := self findNagsIn: (stream upToAll: '</b>').
			nags isEmpty ifFalse: [
				nags do: [ :each || nag |
					nag := race nagNamed: each.
					nag isNil ifFalse: [nag preRaceNR: true]].
			]].
		].
! !
!HRImportSLPreMeetingNR categoriesFor: #setNonRunnersFrom:!public! !

!HRImportSLPreMeetingNR methodsFor!
setNonRunnersFrom: aString for: aMeeting
	| stream raceTime race nags nagName |
	stream := ReadStream on: aString.
	[stream skipToAll: '<tr>'.
	stream atEnd] whileFalse: [
		stream skipToAll: '<b>'.
		raceTime := stream upTo: $&.
		(stream atEnd or: [raceTime size > 5]) ifFalse: [ raceTime := Time fromString: raceTime.
		(raceTime < (Time fromString: '11.00')) ifTrue: [ raceTime := raceTime addTime: (Time fromString: '12.00') ].
		stream skipTo: $;.
		race := aMeeting races detect: [ :each | each time = raceTime ] ifNone: [].
		race isNil ifFalse: [
			nags := self findNagsIn: (stream upToAll: '</b>').
			nags isEmpty ifFalse: [
				nags do: [ :each || nag |
					nag := race nagNamed: each.
					nag isNil ifFalse: [nag preRaceNR: true].
				race ppValDirty: true].
			]].
		]].
! !
!HRImportSLPreMeetingNR categoriesFor: #setNonRunnersFrom:for:!public! !

!HRImportSLPreMeetingNR methodsFor!
setPreMeetingNRs
#deprecated.
	self setRawMeetings;
		setNonRunners
! !
!HRImportSLPreMeetingNR categoriesFor: #setPreMeetingNRs!public! !

!HRImportSLPreMeetingNR methodsFor!
setPreMeetingNRsFor: aMeeting

	self setRawMeetings;
		setNonRunnersFor: aMeeting
! !
!HRImportSLPreMeetingNR categoriesFor: #setPreMeetingNRsFor:!public! !

!HRImportSLPreMeetingNR methodsFor!
setRawMeetings
	| stream |
	stream := self contents readStream.
	stream skipToAll: 'RACING NON-RUNNERS'.
"raw meetings"
	[stream skipToAll: '<td class="body_bg_1">'.
	stream atEnd] whileFalse: [ | result | 
		result := stream upToAll: '<tr height="25">'.
		result isEmpty ifFalse: [self rawMeetings addLast: result].
		].
! !
!HRImportSLPreMeetingNR categoriesFor: #setRawMeetings!public! !

!HRImportSLPreMeetingNR categoriesFor: #findNagsIn:!accessing!public! !

!HRImportSLPreMeetingNR categoriesFor: #meeting!accessing!private! !

!HRImportSLPreMeetingNR categoriesFor: #meeting:!accessing!private! !

!HRImportSLPreMeetingNR categoriesFor: #meetings!accessing!private! !

!HRImportSLPreMeetingNR categoriesFor: #meetings:!accessing!private! !

!HRImportSLPreMeetingNR categoriesFor: #rawMeetings!accessing!private! !

!HRImportSLPreMeetingNR categoriesFor: #setNonRunners!accessing!private! !

!HRImportSLPreMeetingNR categoriesFor: #setNonRunnersFor:!accessing!private! !

!HRImportSLPreMeetingNR categoriesFor: #setNonRunnersFrom:!accessing!public! !

!HRImportSLPreMeetingNR categoriesFor: #setNonRunnersFrom:for:!accessing!public! !

!HRImportSLPreMeetingNR categoriesFor: #setPreMeetingNRs!public! !

!HRImportSLPreMeetingNR categoriesFor: #setPreMeetingNRsFor:!public! !

!HRImportSLPreMeetingNR categoriesFor: #setRawMeetings!accessing!public! !

!HRImportSLPreMeetingNR class methodsFor!
on: aFile meeting: aMeeting

	^self new on: aFile; meeting: aMeeting! !
!HRImportSLPreMeetingNR class categoriesFor: #on:meeting:!public! !

!HRImportSLPreMeetingNR class methodsFor!
on: aFile meetings: aCollection

	^self new on: aFile; meetings: aCollection! !
!HRImportSLPreMeetingNR class categoriesFor: #on:meetings:!public! !

!HRImportSLPreMeetingNR class methodsFor!
onURL: aURL meeting: aMeeting

	^self new meeting: aMeeting; onURL: aURL! !
!HRImportSLPreMeetingNR class categoriesFor: #onURL:meeting:!public! !

!HRImportSLPreMeetingNR class methodsFor!
onURL: aURL meetings: aCollection

	^self new meetings: aCollection; onURL: aURL! !
!HRImportSLPreMeetingNR class categoriesFor: #onURL:meetings:!public! !

!HRImportSLPreMeetingNR class categoriesFor: #on:meeting:!public! !

!HRImportSLPreMeetingNR class categoriesFor: #on:meetings:!public! !

!HRImportSLPreMeetingNR class categoriesFor: #onURL:meeting:!public! !

!HRImportSLPreMeetingNR class categoriesFor: #onURL:meetings:!public! !

HRImportToteEarlyResult guid: (GUID fromString: '{108D2277-5F33-4E4E-9A4F-037DC9928A08}')!

HRImportToteEarlyResult guid: (GUID fromString: '{108D2277-5F33-4E4E-9A4F-037DC9928A08}')!
HRImportToteEarlyResult comment: ''!

HRImportToteEarlyResult comment:
''!
!HRImportToteEarlyResult categoriesForClass!Kernel-Objects! !
!HRImportToteEarlyResult methodsFor!
extractResultsFrom: aString for: aRace

	| stream subStream |
	stream := aString readStream.
	stream skipToAll: '</tr>';
		skipToAll: '</tr>';
		skipToAll: '</tr>'.
	subStream := (stream upToAll: '</table>') readStream.
	[subStream atEnd] whileFalse: [ | pos no |
		subStream skipToAll: '<td'; skipTo: $>.
		pos := self numberFrom: (subStream upTo: $<).
		subStream skipToAll: '<td'; skipTo: $>.
		no := self numberFrom: (subStream upTo: $<).
		(aRace nagNo: no) racePosition: pos.
		subStream skipToAll: '</tr>'.
		].
	aRace setPlaced.
! !
!HRImportToteEarlyResult categoriesFor: #extractResultsFrom:for:!public! !

!HRImportToteEarlyResult methodsFor!
meeting
	^meeting! !
!HRImportToteEarlyResult categoriesFor: #meeting!public! !

!HRImportToteEarlyResult methodsFor!
meeting: anObject
	meeting := anObject! !
!HRImportToteEarlyResult categoriesFor: #meeting:!public! !

!HRImportToteEarlyResult methodsFor!
rawRaces
	rawRaces ifNil: [rawRaces := OrderedCollection new].
	^rawRaces! !
!HRImportToteEarlyResult categoriesFor: #rawRaces!public! !

!HRImportToteEarlyResult methodsFor!
setData
	| stream substream courseName |
	stream := ReadStream on: self contents.

"meeting"
	stream skipToAll: '<th class="textHeading" align="center">'.
"	courseName := stream upToAll: ' Results'.
	(courseName sameAs: self meeting course) ifFalse: [^nil].
"
"races"
	stream skipToAll: '</table>'.
	[stream atEnd] whileFalse: [ | leg result | 
		stream skipToAll: 'Race '.
		leg := self numberFrom: (stream upTo: $<).
		stream skipToAll: '</table>'.
		result := stream upToAll: '</table>'.
		result isEmpty ifFalse: [self rawRaces addLast: (leg -> result)].
		].
	self setRaceResults! !
!HRImportToteEarlyResult categoriesFor: #setData!public! !

!HRImportToteEarlyResult methodsFor!
setRaceResults

	self rawRaces do: [ :assoc | | race |
		race := self meeting leg: assoc key.
		race hasFullResults ifFalse: [ 
			self extractResultsFrom: assoc value for: race.
			race ppValDirty: true ]]! !
!HRImportToteEarlyResult categoriesFor: #setRaceResults!public! !

!HRImportToteEarlyResult categoriesFor: #extractResultsFrom:for:!accessing!public! !

!HRImportToteEarlyResult categoriesFor: #meeting!accessing!private! !

!HRImportToteEarlyResult categoriesFor: #meeting:!accessing!private! !

!HRImportToteEarlyResult categoriesFor: #rawRaces!accessing!private! !

!HRImportToteEarlyResult categoriesFor: #setData!accessing!public! !

!HRImportToteEarlyResult categoriesFor: #setRaceResults!accessing!public! !

!HRImportToteEarlyResult class methodsFor!
on: aFile meeting: aMeeting

	^self new on: aFile; meeting: aMeeting! !
!HRImportToteEarlyResult class categoriesFor: #on:meeting:!public! !

!HRImportToteEarlyResult class methodsFor!
onURL: aURL meeting: aMeeting

	^self new meeting: aMeeting; onURL: aURL! !
!HRImportToteEarlyResult class categoriesFor: #onURL:meeting:!public! !

!HRImportToteEarlyResult class categoriesFor: #on:meeting:!public! !

!HRImportToteEarlyResult class categoriesFor: #onURL:meeting:!public! !

HRImportTotePPDay guid: (GUID fromString: '{AFF4448F-7B89-428B-AEAB-7D5300870A5A}')!

HRImportTotePPDay guid: (GUID fromString: '{AFF4448F-7B89-428B-AEAB-7D5300870A5A}')!
HRImportTotePPDay comment: ''!

HRImportTotePPDay comment:
''!
!HRImportTotePPDay categoriesForClass!Kernel-Objects! !
!HRImportTotePPDay methodsFor!
getMeetingURLFor: aCourse

	| assoc |
#deprecated. "version 55"
	assoc := self meetingURLs detect: [ :each | ('*', aCourse, '*') match: each key ] 
		ifNone: [self toteNamingExceptionsFor: aCourse].
	^assoc value! !
!HRImportTotePPDay categoriesFor: #getMeetingURLFor:!public! !

!HRImportTotePPDay methodsFor!
getURLIDFor: aCourse

	| assoc |
	assoc := self meetingURLIDs detect: [ :each | ('*', aCourse, '*') match: each key ] 
		ifNone: [self toteNamingExceptionsFor: aCourse].
	^assoc value! !
!HRImportTotePPDay categoriesFor: #getURLIDFor:!public! !

!HRImportTotePPDay methodsFor!
meetingURLIDs
	meetingURLIDs ifNil: [self setMeetingURLIDs].
	^meetingURLIDs! !
!HRImportTotePPDay categoriesFor: #meetingURLIDs!public! !

!HRImportTotePPDay methodsFor!
meetingURLs
#deprecated. "version 55"
	meetingURLs ifNil: [meetingURLs := OrderedCollection new].
	^meetingURLs! !
!HRImportTotePPDay categoriesFor: #meetingURLs!public! !

!HRImportTotePPDay methodsFor!
setMeetingURLIDs
	| stream substream urlID course|
	meetingURLIDs := OrderedCollection new.
	stream := ReadStream on: self contents.
	stream skipToAll: '<table'.
	stream skipToAll: '<select'.
	substream := ReadStream on: (stream upToAll: '</select>').
	[substream skipToAll: '<option value="course'.
	substream atEnd] whileFalse:
	[urlID := substream upTo: $.. 
	substream skipTo: $>.
	course := (substream upTo: $<).
	course isEmpty ifFalse: [	meetingURLIDs addLast: ((course subStrings first) -> urlID)]].
! !
!HRImportTotePPDay categoriesFor: #setMeetingURLIDs!public! !

!HRImportTotePPDay methodsFor!
setMeetingURLs
	| stream substream url course|
#deprecated. "version 55"
	stream := ReadStream on: self contents.
	stream skipToAll: '<table'.
	stream skipToAll: '<select'.
	substream := ReadStream on: (stream upToAll: '</select>').
	[substream skipToAll: '<option value="course'.
	substream atEnd] whileFalse:
	[url := 'http://club.totesport.com/totepoolLiveInfo/liveData/Placepot', (substream upTo: $"). 
	substream skipTo: $>.
	course := (substream upTo: $<).
	course isEmpty ifFalse: [	self meetingURLs addLast: ((course subStrings first) -> url)]].
! !
!HRImportTotePPDay categoriesFor: #setMeetingURLs!public! !

!HRImportTotePPDay methodsFor!
toteNamingExceptionsFor: aCourse

	| toteCourseName |
	toteCourseName := aCourse.
	(aCourse sameAs: 'AINTREE') ifTrue:	[ toteCourseName := 'Liverpool' ].
	^self meetingURLIDs detect: [ :each | ('*', toteCourseName, '*') match: each key ] 
		ifNone: ['' -> '']

! !
!HRImportTotePPDay categoriesFor: #toteNamingExceptionsFor:!public! !

!HRImportTotePPDay categoriesFor: #getMeetingURLFor:!accessing!public! !

!HRImportTotePPDay categoriesFor: #getURLIDFor:!accessing!public! !

!HRImportTotePPDay categoriesFor: #meetingURLIDs!accessing!public! !

!HRImportTotePPDay categoriesFor: #meetingURLs!accessing!public! !

!HRImportTotePPDay categoriesFor: #setMeetingURLIDs!accessing!public! !

!HRImportTotePPDay categoriesFor: #setMeetingURLs!accessing!public! !

!HRImportTotePPDay categoriesFor: #toteNamingExceptionsFor:!accessing!public! !

HRImportTotePPRace guid: (GUID fromString: '{7926D8EB-F3E7-451B-9BD0-C17349473E69}')!

HRImportTotePPRace guid: (GUID fromString: '{7926D8EB-F3E7-451B-9BD0-C17349473E69}')!
HRImportTotePPRace comment: ''!

HRImportTotePPRace comment:
''!
!HRImportTotePPRace categoriesForClass!Kernel-Objects! !
!HRImportTotePPRace methodsFor!
addBet: anAssociation
	self bets addLast: anAssociation! !
!HRImportTotePPRace categoriesFor: #addBet:!public! !

!HRImportTotePPRace methodsFor!
bets
	bets ifNil: [bets := OrderedCollection new].
	^bets! !
!HRImportTotePPRace categoriesFor: #bets!public! !

!HRImportTotePPRace methodsFor!
leg
	leg ifNil: [self leg: ''].
	^self numberFrom: leg! !
!HRImportTotePPRace categoriesFor: #leg!public! !

!HRImportTotePPRace methodsFor!
leg: anObject
	leg := anObject! !
!HRImportTotePPRace categoriesFor: #leg:!public! !

!HRImportTotePPRace methodsFor!
meeting
	^meeting! !
!HRImportTotePPRace categoriesFor: #meeting!public! !

!HRImportTotePPRace methodsFor!
meeting: anObject
	meeting := anObject! !
!HRImportTotePPRace categoriesFor: #meeting:!public! !

!HRImportTotePPRace methodsFor!
poolBF
	poolBF isEmpty ifTrue: [^0].
	^self numberFrom: poolBF
! !
!HRImportTotePPRace categoriesFor: #poolBF!public! !

!HRImportTotePPRace methodsFor!
poolBF: anObject
	poolBF := anObject! !
!HRImportTotePPRace categoriesFor: #poolBF:!public! !

!HRImportTotePPRace methodsFor!
poolTotal
	poolTotal isEmpty ifTrue: [^0].
	^self numberFrom: poolTotal! !
!HRImportTotePPRace categoriesFor: #poolTotal!public! !

!HRImportTotePPRace methodsFor!
poolTotal: anObject
	poolTotal := anObject! !
!HRImportTotePPRace categoriesFor: #poolTotal:!public! !

!HRImportTotePPRace methodsFor!
setData
	| stream substream nag bet |
	stream := ReadStream on: self contents.
	stream skipToAll: '<table'.
"meeting"
	stream skipToAll: 'class="textHeading"'.
	stream skipTo: $>.
	meeting := stream upTo: $<.
"leg"
	stream skipToAll: 'Placepot Leg '.
	leg := stream upTo: $<.
"pool total"
	stream skipToAll: 'textNormal">'.
	poolTotal := stream upTo: $<.
"brought forward"
	stream skipToAll: 'textNormal">'.
	poolBF := stream upTo: $<.

"start of table"
	stream skipToAll: '/Graphics/whitekeyline.gif'.
	stream skipToAll: '<tr>'.
	substream := ReadStream on: (stream upToAll: '</table>').
	[substream skipToAll: 'align="right">'.
	substream atEnd] whileFalse:
	[nag := substream upTo: $<. 
	substream skipToAll: 'align="right">'.
	bet := substream upTo: $<.
	nag isEmpty ifFalse: [ self addBet: (nag -> bet)]].

"	self renameFile"
! !
!HRImportTotePPRace categoriesFor: #setData!public! !

!HRImportTotePPRace methodsFor!
thisRace

	^self bets inject: 0 into: [ :a :b | a + (self numberFrom: b value) ]! !
!HRImportTotePPRace categoriesFor: #thisRace!public! !

!HRImportTotePPRace methodsFor!
valueFor: aNagNo

	| result |
	result := (self bets detect: [ :each | each key = aNagNo] ifNone: [0 -> '0']) value.
	^self numberFrom: result! !
!HRImportTotePPRace categoriesFor: #valueFor:!public! !

!HRImportTotePPRace categoriesFor: #addBet:!accessing!private! !

!HRImportTotePPRace categoriesFor: #bets!accessing!private! !

!HRImportTotePPRace categoriesFor: #leg!accessing!private! !

!HRImportTotePPRace categoriesFor: #leg:!accessing!private! !

!HRImportTotePPRace categoriesFor: #meeting!accessing!private! !

!HRImportTotePPRace categoriesFor: #meeting:!accessing!private! !

!HRImportTotePPRace categoriesFor: #poolBF!accessing!private! !

!HRImportTotePPRace categoriesFor: #poolBF:!accessing!private! !

!HRImportTotePPRace categoriesFor: #poolTotal!accessing!private! !

!HRImportTotePPRace categoriesFor: #poolTotal:!accessing!private! !

!HRImportTotePPRace categoriesFor: #setData!accessing!public! !

!HRImportTotePPRace categoriesFor: #thisRace!accessing!private! !

!HRImportTotePPRace categoriesFor: #valueFor:!accessing!private! !

HRImportBetfairMainMenu guid: (GUID fromString: '{B76BA476-90A4-43B1-AACB-1A0D1DDAC436}')!

HRImportBetfairMainMenu guid: (GUID fromString: '{B76BA476-90A4-43B1-AACB-1A0D1DDAC436}')!
HRImportBetfairMainMenu comment: ''!

HRImportBetfairMainMenu comment:
''!
!HRImportBetfairMainMenu categoriesForClass!Kernel-Objects! !
!HRImportBetfairMainMenu methodsFor!
idForEvent: anEvent

	| result |
	HRLogger current showFull: ('Find Betfair meeting for: ', anEvent, String lineDelimiter).
	result := self nodes detect: [ :each | (each at: 3) asUppercase sameAs: anEvent asUppercase ] ifNone: [^nil].
	HRLogger current showAlways: ('Found Betfair menuID: ', (result at: 1), ' for: ', anEvent, String lineDelimiter).
	^result at: 1! !
!HRImportBetfairMainMenu categoriesFor: #idForEvent:!public! !

!HRImportBetfairMainMenu methodsFor!
idForEvent: anEvent skip: anInteger

	| result idx |
	HRLogger current showFull: ('Find Betfair meeting for: ', anEvent, String lineDelimiter).
	result := self nodes select: [ :each | (each at: 3) asUppercase sameAs: anEvent asUppercase ].
	result isEmpty ifTrue: [^HRLogger current showError: ('Did not find Betfair menuID for: ', anEvent, String lineDelimiter)].
	idx := (anInteger\\result size) + 1.
	HRLogger current showAlways: ('Found Betfair menuID: ', ((result at: idx) at: 1), ' for: ', anEvent, String lineDelimiter).
	^(result at: idx) at: 1! !
!HRImportBetfairMainMenu categoriesFor: #idForEvent:skip:!public! !

!HRImportBetfairMainMenu methodsFor!
menuSubstring
	| stream |
	stream := ReadStream on: self contents.
	stream skipToAll: 'var skeletonString = "'.
	^stream upTo: $"
! !
!HRImportBetfairMainMenu categoriesFor: #menuSubstring!public! !

!HRImportBetfairMainMenu categoriesFor: #idForEvent:!public! !

!HRImportBetfairMainMenu categoriesFor: #idForEvent:skip:!public! !

!HRImportBetfairMainMenu categoriesFor: #menuSubstring!accessing!public! !

!HRImportBetfairMainMenu class methodsFor!
idForEvent: anEvent

	^(self onURL: self mainMenuURL) idForEvent: anEvent! !
!HRImportBetfairMainMenu class categoriesFor: #idForEvent:!public! !

!HRImportBetfairMainMenu class methodsFor!
idForEvent: anEvent skip: anInteger

	^(self onURL: self mainMenuURL) idForEvent: anEvent skip: anInteger! !
!HRImportBetfairMainMenu class categoriesFor: #idForEvent:skip:!public! !

!HRImportBetfairMainMenu class methodsFor!
mainMenuURL

	^'http://www.betfair.com/Menu.do?timeZone=Europe/London&region=GBR_IRL&locale=en_GB&brand=betfair'! !
!HRImportBetfairMainMenu class categoriesFor: #mainMenuURL!public! !

!HRImportBetfairMainMenu class categoriesFor: #idForEvent:!public! !

!HRImportBetfairMainMenu class categoriesFor: #idForEvent:skip:!public! !

!HRImportBetfairMainMenu class categoriesFor: #mainMenuURL!public! !

HRImportBetfairMeetingMenu guid: (GUID fromString: '{ECCEB8AF-6290-4A8D-A897-6B8EC83C3164}')!

HRImportBetfairMeetingMenu guid: (GUID fromString: '{ECCEB8AF-6290-4A8D-A897-6B8EC83C3164}')!
HRImportBetfairMeetingMenu comment: ''!

HRImportBetfairMeetingMenu comment:
''!
!HRImportBetfairMeetingMenu categoriesForClass!Unclassified! !
!HRImportBetfairMeetingMenu methodsFor!
idForTime: aTime

	| result time |
	time := String writeStream.
	aTime printOn: time format: 'HH:mm'.
	result := self nodes detect: [ :each | ((each at: 3) first: 5) sameAs: (time contents) ] ifNone: [^nil].
	HRLogger current showAlways: ('Found Betfair race ID: ', (result at: 1), ' for: ', aTime displayString, String lineDelimiter).
	^result at: 1! !
!HRImportBetfairMeetingMenu categoriesFor: #idForTime:!public! !

!HRImportBetfairMeetingMenu methodsFor!
menuSubstring
	| stream |
	stream := ReadStream on: self contents.
	stream skipToAll: 'm_meatArray = '''.
	^stream upTo: $'
! !
!HRImportBetfairMeetingMenu categoriesFor: #menuSubstring!public! !

!HRImportBetfairMeetingMenu categoriesFor: #idForTime:!public! !

!HRImportBetfairMeetingMenu categoriesFor: #menuSubstring!accessing!public! !

!HRImportBetfairMeetingMenu class methodsFor!
onID: anID

	| url |
	url := 'http://www.betfair.com/menu/LoadMenuNodesAction.do?sReturnPath=parent.frames[''menu'']&method=getMenuEvents&menuNodeId=', anID displayString, '&strArrayName=allSkeletonArray&iParentID=', anID displayString, '&layerName=allMarketsTreeContainer&strMenuPathArrayName=allPathArray&menuPathLayer=menuParents1&locale=en_GB'.

	^self onURL: url! !
!HRImportBetfairMeetingMenu class categoriesFor: #onID:!public! !

!HRImportBetfairMeetingMenu class categoriesFor: #onID:!public! !

HRImportRPPostRaceRace guid: (GUID fromString: '{0A43714B-B435-4A43-B4CB-65C4739ECB69}')!

HRImportRPPostRaceRace guid: (GUID fromString: '{0A43714B-B435-4A43-B4CB-65C4739ECB69}')!
HRImportRPPostRaceRace comment: ''!

HRImportRPPostRaceRace comment:
''!
!HRImportRPPostRaceRace categoriesForClass!Kernel-Objects! !
!HRImportRPPostRaceRace methodsFor!
placesFor: runners
#deprecated.
"not used anymore"
	(runners < 5) ifTrue: [ ^1 ].
	(runners between: 5 and: 7) ifTrue: [ ^2 ].
	(runners between: 8 and: 15) ifTrue: [ ^3 ].
	self race handicap ifFalse: [^3].
	^4
! !
!HRImportRPPostRaceRace categoriesFor: #placesFor:!public! !

!HRImportRPPostRaceRace methodsFor!
setAll

	self setRace;
		setRawNags;
		setNags;
		setPlaced.! !
!HRImportRPPostRaceRace categoriesFor: #setAll!public! !

!HRImportRPPostRaceRace methodsFor!
setNagFrom: aString
	| stream result nagName nag |
	stream := ReadStream on: aString.
"result"
	stream skipToAll: '<p class="H5">'.
	result := self numberFrom: (stream upTo: $<).
"nagName"
	stream skipToAll: '"H5">'.
	stream skipTo: $>.
	nagName := (self checkName: (stream upTo: $<)) trimBlanks.
"find nag"
	nag := self race nagNamed: nagName.
	nag isNil ifFalse: [nag racePosition: result].! !
!HRImportRPPostRaceRace categoriesFor: #setNagFrom:!public! !

!HRImportRPPostRaceRace methodsFor!
setNags
	self rawNags do: [ :each | self setNagFrom: each ]! !
!HRImportRPPostRaceRace categoriesFor: #setNags!public! !

!HRImportRPPostRaceRace methodsFor!
setPlaced

"	| places |
	places := self placesFor: self race actualRunners.
	self race nags do: [ :each |
		(each racePosition notNull and: [each racePosition <= places]) ifTrue: [
			each placed: true ].
		]."
	race setPlaced.! !
!HRImportRPPostRaceRace categoriesFor: #setPlaced!public! !

!HRImportRPPostRaceRace methodsFor!
setRace
	self contentsStream atEnd ifTrue: [ self contentsStream reset].
"going"
	self contentsStream skipToAll: '<p class="HC2">'.
	self race meeting going isEmpty ifTrue: [self race meeting going: (self contentsStream upTo: $<) trimBlanks].
"actual runners"
	self contentsStream skipToAll: '<!!-- Get Runners -->'.
	self contentsStream skipToAll: '</table>'.
	self contentsStream skipToAll: '<p class="B1"><b>'.
	self race actualRunners: (self numberFrom: (self contentsStream upTo: Character space)).! !
!HRImportRPPostRaceRace categoriesFor: #setRace!public! !

!HRImportRPPostRaceRace methodsFor!
setRawNags
	| stream |
	stream := self contentsStream reset.
	stream skipToAll: '<!!-- Get Runners -->'.
	stream skipToAll: '<tr bgcolor=#F5F5F5>'.
	[stream atEnd] whileFalse: [ | result | 
		result := stream upToAll: '</tr>'.
		self rawNags addLast: result.
		stream skipToAll: '<tr bgcolor=#F5F5F5>'].
! !
!HRImportRPPostRaceRace categoriesFor: #setRawNags!public! !

!HRImportRPPostRaceRace categoriesFor: #placesFor:!public! !

!HRImportRPPostRaceRace categoriesFor: #setAll!public! !

!HRImportRPPostRaceRace categoriesFor: #setNagFrom:!accessing!private! !

!HRImportRPPostRaceRace categoriesFor: #setNags!accessing!private! !

!HRImportRPPostRaceRace categoriesFor: #setPlaced!public! !

!HRImportRPPostRaceRace categoriesFor: #setRace!accessing!private! !

!HRImportRPPostRaceRace categoriesFor: #setRawNags!accessing!private! !

HRImportRPPreRaceRace guid: (GUID fromString: '{1419E8E1-F6E1-4EFB-8E41-5327C8F18BAA}')!

HRImportRPPreRaceRace guid: (GUID fromString: '{1419E8E1-F6E1-4EFB-8E41-5327C8F18BAA}')!
HRImportRPPreRaceRace comment: ''!

HRImportRPPreRaceRace comment:
''!
!HRImportRPPreRaceRace categoriesForClass!Kernel-Objects! !
!HRImportRPPreRaceRace methodsFor!
checkCompleteness

	self checkRPSpotlight.! !
!HRImportRPPreRaceRace categoriesFor: #checkCompleteness!public! !

!HRImportRPPreRaceRace methodsFor!
checkForCourseWinner: aString

	| stream result |
	stream := ReadStream on: aString.
	(stream skipToAll: 'course_winner') ifTrue: [^true].
	stream reset. 
	^stream skipToAll: 'course_distance_winner'! !
!HRImportRPPreRaceRace categoriesFor: #checkForCourseWinner:!public! !

!HRImportRPPreRaceRace methodsFor!
checkForDistanceWinner: aString

	| stream result |
	stream := ReadStream on: aString.
	(stream skipToAll: 'distance_winner') ifTrue: [^true].
	stream reset. 
	^stream skipToAll: 'course_distance_winner'! !
!HRImportRPPreRaceRace categoriesFor: #checkForDistanceWinner:!public! !

!HRImportRPPreRaceRace methodsFor!
checkRPSpotlight
	| item runDate runTime |
	self rpSpotlight isEmpty 
		ifTrue: 
			[
			runDate := Date today.
			runTime := Time now addTime: (Time fromSeconds: 3600).
			Time now > (Time fromString: '22.55') ifTrue: [
				runDate := Date today addDays: 1. 
				runTime := Time fromString: '0.30'].
			item := (HRScheduleItem new)
						date: runDate;
						time: runTime;
						object: self race;
						process: #findRPSpotlightAtURL:;
						params: (Array with: self url).
			HRScheduler current addScheduleItem: item]! !
!HRImportRPPreRaceRace categoriesFor: #checkRPSpotlight!public! !

!HRImportRPPreRaceRace methodsFor!
checkValidPage

	| stream |
	stream := self contentsStream reset.
	stream skipToAll: 'HTML'.
	stream atEnd ifTrue: [ stream := self contentsStream reset.
		stream skipToAll: 'html'.
		^stream atEnd not].
	^true! !
!HRImportRPPreRaceRace categoriesFor: #checkValidPage!public! !

!HRImportRPPreRaceRace methodsFor!
course
	course ifNil: [self course: ''].
	^course! !
!HRImportRPPreRaceRace categoriesFor: #course!public! !

!HRImportRPPreRaceRace methodsFor!
course: anObject
	course := anObject! !
!HRImportRPPreRaceRace categoriesFor: #course:!public! !

!HRImportRPPreRaceRace methodsFor!
isInvalid

	^self isValid not! !
!HRImportRPPreRaceRace categoriesFor: #isInvalid!public! !

!HRImportRPPreRaceRace methodsFor!
isValid

	| stream tmpTime hour minutes |
	stream := self contentsStream reset.
"course"
	stream skipToAll: '<table ALIGN=CENTER WIDTH=96% COLS=1 cellpadding=0 cellspacing=2 cols=3 class="H2">'.
	stream skipToAll: '<tr><td width=70% ALIGN=CENTER>'.
	stream skipToAll: '<table'.
	stream skipToAll: '<tr'.
	stream skipToAll: '<td'.
	stream skipToAll: '<b>'.
	^stream atEnd not! !
!HRImportRPPreRaceRace categoriesFor: #isValid!public! !

!HRImportRPPreRaceRace methodsFor!
lookupOddsFrom: aString

	(aString sameAs: 'No Odds') ifTrue: [^0].
	(aString sameAs: 'Evs') ifTrue: [^Fraction numerator: 1 denominator: 1].
	^(Number readFrom: aString readStream)! !
!HRImportRPPreRaceRace categoriesFor: #lookupOddsFrom:!public! !

!HRImportRPPreRaceRace methodsFor!
noOdds
	noOdds ifNil: [self noOdds: 0].
	^noOdds! !
!HRImportRPPreRaceRace categoriesFor: #noOdds!public! !

!HRImportRPPreRaceRace methodsFor!
noOdds: anObject
	noOdds := anObject! !
!HRImportRPPreRaceRace categoriesFor: #noOdds:!public! !

!HRImportRPPreRaceRace methodsFor!
onURL: aURL

	super onURL: aURL.
	self url: aURL.
! !
!HRImportRPPreRaceRace categoriesFor: #onURL:!public! !

!HRImportRPPreRaceRace methodsFor!
rpSpotlight
	rpSpotlight ifNil: [ self setRpSpotlight ].
	^rpSpotlight! !
!HRImportRPPreRaceRace categoriesFor: #rpSpotlight!public! !

!HRImportRPPreRaceRace methodsFor!
rpSpotlight: anObject
	rpSpotlight := anObject! !
!HRImportRPPreRaceRace categoriesFor: #rpSpotlight:!public! !

!HRImportRPPreRaceRace methodsFor!
rpSpotlightNoTags
	^self stripTags: self rpSpotlight! !
!HRImportRPPreRaceRace categoriesFor: #rpSpotlightNoTags!public! !

!HRImportRPPreRaceRace methodsFor!
setAllFor: aMeeting

	meeting := aMeeting.
	self setAllRPData ifFalse: [^false].
	self race meeting: aMeeting.
	[self race findSLRaceCard] forkAt: 3.
	self checkCompleteness.
	^true
! !
!HRImportRPPreRaceRace categoriesFor: #setAllFor:!public! !

!HRImportRPPreRaceRace methodsFor!
setAllRPData

	| reply |
	reply := true.
	self checkValidPage ifFalse: [ ^false ].
	self setRace.
	(self race time < Time now and: [meeting date = Date today]) ifTrue: [
		reply := MessageBox confirm: ('Race: ', self race shortTime, ' ', self race name, ' is in the past.', String lineDelimiter, 'Do you want to import it nevertheless?').
		].
	reply ifTrue: [
		self setRaceID;
			setRawNags;
			setNags.
		self setForecastAndFavourite;
			setSpotlightMention].
	^reply
! !
!HRImportRPPreRaceRace categoriesFor: #setAllRPData!public! !

!HRImportRPPreRaceRace methodsFor!
setForecastAndFavourite
	"Find forecast and Favourites"

	| stream odds |
	odds := 0.
	stream := self contentsStream reset.
	stream skipToAll: 'Betting Forecast'.
	stream skipToAll: '</b>'.
	stream atEnd ifFalse: 
		[1 to: race noOfNags
			do: 
				[:each | 
				| result tmpOdds nag nagString |
				nag := nil.
				[(stream atEnd not) and: [stream next codePoint < 38]] whileTrue.
				result := ReadStream on: (stream pop upToAll: '</a>,').
				result peek = $& ifFalse: [odds := self lookupOddsFrom: (result upTo: $&)].
				odds = 0 ifTrue: [self noOdds: (self noOdds + 1)].
				result skipTo: $>.
				nagString := self replaceSpecialCharsFrom: (result upTo: $<).
				nagString isEmpty ifFalse: [nag := self race nagNamed: nagString].
				nag isNil ifFalse: [
					nag
						noFavourite: each - self noOdds;
						rpForecast: odds.
					odds = 0 ifTrue: 
						[ nag noFavourite: (race noOfNags - self noOdds + 1)]].
				]]! !
!HRImportRPPreRaceRace categoriesFor: #setForecastAndFavourite!public! !

!HRImportRPPreRaceRace methodsFor!
setNagFrom: aString
	| stream nag cdWinnerString |
	stream := ReadStream on: aString.
	nag := HRNag new.
"rc number"
	stream skipToAll: '<b>'.
	nag racecardNo: (stream upTo: $<).
"draw"
	stream skipToAll: '"B7">'.
	nag draw: (stream upTo: $<).
"form"
	stream skipToAll: ' class="B5">'.
	nag form: (self stripTags: (stream upToAll: '</td>')).
"name"
	stream skipToAll: '<b>'.
	nag name: (self checkName: (stream upToAll: '</b>')) trimBlanks.
"last run"
	stream skipToAll: '<span class=''B7''>'.
"	stream peek = $( ifTrue: [stream skipToAll: '<span class=''B9''>']."
	nag daysSinceLastRun: (stream upToAll: '</span>').
"check for course and distance winner"
	cdWinnerString := (stream upToAll: '</td>').
	nag courseWinner: (self checkForCourseWinner: cdWinnerString).
	nag distanceWinner: (self checkForDistanceWinner: cdWinnerString).
"trainer"
	stream skipToAll: ' Statistics''>'.
	nag trainer: (self checkName: (stream upTo: $<)) trimBlanks.
"jockey"
	stream skipToAll: ' Statistics''>'.
	nag jockey: (self checkName: (stream upTo: $<)) trimBlanks.
"postmark"
	stream skipToAll: '<font color="white"><b>'.
	nag postmark: (stream upTo: $<).

	nag name isEmpty 
		ifFalse: [self race addNag: nag].
! !
!HRImportRPPreRaceRace categoriesFor: #setNagFrom:!public! !

!HRImportRPPreRaceRace methodsFor!
setNags
	self rawNags do: [ :each | self setNagFrom: each ]! !
!HRImportRPPreRaceRace categoriesFor: #setNags!public! !

!HRImportRPPreRaceRace methodsFor!
setRace
	| stream tmpTime hour minutes |
	stream := self contentsStream reset.
"course"
	stream skipToAll: '<table ALIGN=CENTER WIDTH=96% COLS=1 cellpadding=0 cellspacing=2 cols=3 class="H2">'.
	stream skipToAll: '<tr><td width=70% ALIGN=CENTER>'.
	course := (stream upTo: $,) trimBlanks.
"	course isEmpty ifTrue: [^(self class onURL: self url) setAllFor: meeting]."
"time"
	stream skipToAll: '<table'.
	stream skipToAll: '<tr'.
	stream skipToAll: '<td'.
	stream skipToAll: '<b>'.
	tmpTime := stream upTo: $<.
	hour := Number fromString: (tmpTime subStrings: $:) first.
	minutes := Number fromString: (tmpTime subStrings: $:) second.
	hour < 11 ifTrue: [hour := hour + 12].
	self race time: (Time fromSeconds: (hour * 60 + minutes * 60)).
"forecast runners"
	stream skipToAll: '<span class="b7">'.
	self race forecastRunners: (stream upTo: Character space) asNumber.
"name"
	stream skipToAll: '<td width=358 style="vertical-align:top;"><b>'.
	self race name: (stream upTo: $<) trimBlanks.
"age"
	stream skipToAll: '('.
	self race ageOfNags: (stream upTo: $)).
"distance"
	stream skipToAll: '<td width="75" align="right" class="B1" style="vertical-align:top;">'.
	stream skipToAll: '</div>'.
	stream skipToAll: '<b>'.
	self race distance: (self replaceSpecialCharsFrom: (stream upTo: $<)).
"spotlight verdict"
	stream reset.
	stream skipToAll: 'SPOTLIGHT VERDICT:'.
	self rpSpotlight: 'SPOTLIGHT VERDICT:', (stream upToAll: '</td>').
	self race rpWholeSpotlight: (self stripTags: self rpSpotlight).
! !
!HRImportRPPreRaceRace categoriesFor: #setRace!public! !

!HRImportRPPreRaceRace methodsFor!
setRaceID

	| stream id |
	stream := self url readStream.
	stream skipToAll: 'race_id='.
	id := stream upTo: $&.
	self race raceID: id.! !
!HRImportRPPreRaceRace categoriesFor: #setRaceID!public! !

!HRImportRPPreRaceRace methodsFor!
setRawNags
	| stream subStream |
	stream := self contentsStream reset.
	stream skipToAll: '<table class="B2" WIDTH=100% cols=8 border=0 cellpadding=0 cellspacing=1 align=center>'.
	stream skipToAll: '<td width="20" class="b7">RPR</td>'.
	subStream := (stream upToAll: '<tr><td colspan=8><b>Betting Forecast:') readStream.
	[subStream atEnd] whileFalse: [ | result | 
		subStream skipToAll: '<tr>'.
		result := subStream upToAll: '</tr>'.
		self rawNags addLast: result.
		].
! !
!HRImportRPPreRaceRace categoriesFor: #setRawNags!public! !

!HRImportRPPreRaceRace methodsFor!
setRPSpotlight
	| stream |
self halt.	stream := self contentsStream reset.
	stream skipToAll: '<!!-- Options -->'.
	stream skipToAll: '<table'.
"time"
	stream skipToAll: '<span class="h5">'.
"forecast runners"
	stream skipToAll: '<span class="b7">'.
"name"
	stream skipToAll: '<p class="h5">'.
"age"
	stream skipToAll: ' class="B2"> ('.
"distance"
	stream skipToAll: '<p class="br3"><b>'.
"spotlight verdict"
	stream skipToAll: '<font color=#FF0000>'.
	self rpSpotlight: (stream upToAll: '</td>').
	self race rpWholeSpotlight: (self stripTags: self rpSpotlight).
	self setSpotlightMention.
	self checkRPSpotlight.! !
!HRImportRPPreRaceRace categoriesFor: #setRPSpotlight!public! !

!HRImportRPPreRaceRace methodsFor!
setSpotlightMention

	| stream result nag val |
	stream := ReadStream on: self rpSpotlight.
"ignore the first, which is title"
	stream skipToAll: '</b>'.
	[ stream skipToAll: '<b>'.
	result := stream upToAll: '</b>'.
	stream atEnd ] whileFalse: [
		val := 1.
		(self checkUppercase: result) ifTrue: [val := 2].
		nag := self race nagNamed: result.
		nag isNil ifFalse: [nag rpSpotlightMention: val]].
! !
!HRImportRPPreRaceRace categoriesFor: #setSpotlightMention!public! !

!HRImportRPPreRaceRace methodsFor!
url
	url ifNil: [self url: ''].
	^url! !
!HRImportRPPreRaceRace categoriesFor: #url!public! !

!HRImportRPPreRaceRace methodsFor!
url: anObject
	url := anObject! !
!HRImportRPPreRaceRace categoriesFor: #url:!public! !

!HRImportRPPreRaceRace categoriesFor: #checkCompleteness!public! !

!HRImportRPPreRaceRace categoriesFor: #checkForCourseWinner:!private! !

!HRImportRPPreRaceRace categoriesFor: #checkForDistanceWinner:!private! !

!HRImportRPPreRaceRace categoriesFor: #checkRPSpotlight!public! !

!HRImportRPPreRaceRace categoriesFor: #checkValidPage!public! !

!HRImportRPPreRaceRace categoriesFor: #course!accessing!private! !

!HRImportRPPreRaceRace categoriesFor: #course:!accessing!private! !

!HRImportRPPreRaceRace categoriesFor: #isInvalid!public! !

!HRImportRPPreRaceRace categoriesFor: #isValid!public! !

!HRImportRPPreRaceRace categoriesFor: #lookupOddsFrom:!public! !

!HRImportRPPreRaceRace categoriesFor: #noOdds!accessing!private! !

!HRImportRPPreRaceRace categoriesFor: #noOdds:!accessing!private! !

!HRImportRPPreRaceRace categoriesFor: #onURL:!public! !

!HRImportRPPreRaceRace categoriesFor: #rpSpotlight!accessing!private! !

!HRImportRPPreRaceRace categoriesFor: #rpSpotlight:!accessing!private! !

!HRImportRPPreRaceRace categoriesFor: #rpSpotlightNoTags!accessing!private! !

!HRImportRPPreRaceRace categoriesFor: #setAllFor:!public! !

!HRImportRPPreRaceRace categoriesFor: #setAllRPData!public! !

!HRImportRPPreRaceRace categoriesFor: #setForecastAndFavourite!accessing!public! !

!HRImportRPPreRaceRace categoriesFor: #setNagFrom:!accessing!private! !

!HRImportRPPreRaceRace categoriesFor: #setNags!accessing!private! !

!HRImportRPPreRaceRace categoriesFor: #setRace!accessing!private! !

!HRImportRPPreRaceRace categoriesFor: #setRaceID!private! !

!HRImportRPPreRaceRace categoriesFor: #setRawNags!accessing!private! !

!HRImportRPPreRaceRace categoriesFor: #setRPSpotlight!accessing!private! !

!HRImportRPPreRaceRace categoriesFor: #setSpotlightMention!accessing!private! !

!HRImportRPPreRaceRace categoriesFor: #url!accessing!private! !

!HRImportRPPreRaceRace categoriesFor: #url:!accessing!private! !

HRImportSLLiveShow guid: (GUID fromString: '{32AD080D-4454-44FB-A50A-27424FAB867B}')!

HRImportSLLiveShow guid: (GUID fromString: '{32AD080D-4454-44FB-A50A-27424FAB867B}')!
HRImportSLLiveShow comment: ''!

HRImportSLLiveShow comment:
''!
!HRImportSLLiveShow categoriesForClass!Kernel-Objects! !
!HRImportSLLiveShow methodsFor!
lookupOddsFrom: aString

	| sub num den |
	aString isEmpty ifTrue: [^nil].
	(aString sameAs: '&nbsp;') ifTrue: [^nil].
	(aString sameAs: 'evens') ifTrue: [^Fraction numerator: 1 denominator: 1].
	(aString includes: $-) ifTrue: [ 
		sub := aString subStrings: $-.
		num := Number readFrom: (sub first) readStream.
		den := Number readFrom: (sub last) readStream.
		^Fraction numerator: num denominator: den].
	^Fraction numerator: (Number readFrom: aString readStream) denominator: 1.
! !
!HRImportSLLiveShow categoriesFor: #lookupOddsFrom:!public! !

!HRImportSLLiveShow methodsFor!
onURL: aURL

"	super onURL: aURL attempt: 1."
	self on: (HRPageFiler storeFromURL: aURL).
	self contentsStream: self contents readStream.! !
!HRImportSLLiveShow categoriesFor: #onURL:!public! !

!HRImportSLLiveShow methodsFor!
setAll

	self setRawNags;
		setNags.
! !
!HRImportSLLiveShow categoriesFor: #setAll!public! !

!HRImportSLLiveShow methodsFor!
setNagFrom: aString
	| stream nagName liveShow toteWin totePlace nag |
	stream := ReadStream on: aString.
	liveShow := OrderedCollection new.
"nagName"
	stream skipToAll: 'HORSE_NAME -->'.
	nagName := (self checkName: (stream upTo: $<)) trimBlanks.
"shows"
	1 to: 6 do: [ :each || show |
		stream skipToAll: 'HORSE_SHOW'.
		stream skipTo: $>.
		show := self lookupOddsFrom: (stream upTo: $<).
		show isNil ifFalse: [liveShow addLast: show]].
"Tote Win/Place"
	stream skipToAll: 'WIN_WILL_WIN'.
	stream skipTo: $>.
	toteWin := stream upTo: $<.
	stream skipToAll: 'PLACE_WILL_PAY'.
	stream skipTo: $>.
	totePlace := stream upTo: $<.
"find nag"
	nag := self race nagNamed: nagName.
	nag isNil ifFalse: [nag preRaceShow: liveShow asArray].
! !
!HRImportSLLiveShow categoriesFor: #setNagFrom:!public! !

!HRImportSLLiveShow methodsFor!
setRawNags
	| stream |
	stream := self contentsStream reset.
"going"
	stream skipToAll: 'RACING LIVE SHOWS'.
	stream skipToAll: 'Tote<br>Win'.
"raw nags"
	[stream skipToAll: 'HORSE_NUMBER'.
	stream atEnd] whileFalse: [ | result | 
		result := stream upToAll: 'ukbetting'.
		result isEmpty ifFalse: [self rawNags addLast: result].
		].
! !
!HRImportSLLiveShow categoriesFor: #setRawNags!public! !

!HRImportSLLiveShow categoriesFor: #lookupOddsFrom:!public! !

!HRImportSLLiveShow categoriesFor: #onURL:!public! !

!HRImportSLLiveShow categoriesFor: #setAll!public! !

!HRImportSLLiveShow categoriesFor: #setNagFrom:!accessing!public! !

!HRImportSLLiveShow categoriesFor: #setRawNags!accessing!public! !

HRImportSLPostRaceRace guid: (GUID fromString: '{7FF0DCB2-F716-4D03-BB63-1F80A7F929BD}')!

HRImportSLPostRaceRace guid: (GUID fromString: '{7FF0DCB2-F716-4D03-BB63-1F80A7F929BD}')!
HRImportSLPostRaceRace comment: ''!

HRImportSLPostRaceRace comment:
''!
!HRImportSLPostRaceRace categoriesForClass!Kernel-Objects! !
!HRImportSLPostRaceRace methodsFor!
onURL: aURL

"	super onURL: aURL attempt: 1."
	self on: (HRPageFiler storeFromURL: aURL).
	self contentsStream: self contents readStream.! !
!HRImportSLPostRaceRace categoriesFor: #onURL:!public! !

!HRImportSLPostRaceRace methodsFor!
setAll

	self setRawNags;
		setNags;
		setNonRunners;
		setPlaced.
! !
!HRImportSLPostRaceRace categoriesFor: #setAll!public! !

!HRImportSLPostRaceRace methodsFor!
setNagFrom: aString
	| stream result nonFinish nagName finalOdds nag |
	stream := ReadStream on: aString.
"result"
	stream skipToAll: '<b>'.
	result := (stream upTo: $<) trimBlanks.
	result isEmpty 
		ifTrue: [nonFinish := '']
		ifFalse: [ result first isLetter ifTrue: [nonFinish := result]].
	result := self numberFrom: result.
	result = 0 ifTrue: [result := nonFinish].
"nagName"
	stream skipToAll: '<a href='.
	stream skipTo: $>.
	nagName := (self checkName: (stream upTo: $<)) trimBlanks.
"final odds"
	stream skipToAll: 'rowspan="2"'.
	stream skipToAll: '<strong>'.
	finalOdds := stream upTo: $<.
	finalOdds first = $e ifTrue: [ finalOdds := (1/1)]
		ifFalse: [finalOdds := self makeFraction: finalOdds].
"find nag"
	nag := self race nagNamed: nagName.
	nag isNil ifFalse: [nag racePosition: result. nag slFinalOdds: finalOdds.].! !
!HRImportSLPostRaceRace categoriesFor: #setNagFrom:!public! !

!HRImportSLPostRaceRace methodsFor!
setNonRunners
	| stream |
	stream := self contentsStream reset.
"going"
	stream skipToAll: 'RACING RESULTS'.
	stream skipToAll: '<font size="-1">'.
"raw nags"
	stream skipToAll: '<table border>'.
	stream skipToAll: '<tr>'.
	[stream skipToAll: 'Non Runner'. stream atEnd] whileFalse: [ | result nag | 
		stream skipToAll: '<strong>'.
		result := stream upTo: $<.
		nag := self race nagNamed: result.
		nag isNil ifFalse: [nag racePosition: 'Non Runner']
		].
! !
!HRImportSLPostRaceRace categoriesFor: #setNonRunners!public! !

!HRImportSLPostRaceRace methodsFor!
setPlaced

	self race actualRunners: self rawNags size.
	super setPlaced.! !
!HRImportSLPostRaceRace categoriesFor: #setPlaced!public! !

!HRImportSLPostRaceRace methodsFor!
setRawNags
	| stream |
	stream := self contentsStream reset.
"going"
	stream skipToAll: 'RACING RESULTS'.
	stream skipToAll: '<font size="-1">'.
	stream skipTo: $>.
	self race meeting going isEmpty ifTrue: [self race meeting going: (stream upTo: $<) trimBlanks ].
"raw nags"
	stream skipToAll: '<table border>'.
	stream skipToAll: '<tr>'.
	[stream atEnd] whileFalse: [ | result | 
		result := stream upToAll: '<td colspan="4"'.
		(((result midString: 15 from: 2) = '<td rowspan="3"') or: [((result midString: 15 from: 3) = '<td rowspan="3"')]) ifTrue: [self rawNags addLast: result].
		stream skipToAll: '<tr>'.
		].
! !
!HRImportSLPostRaceRace categoriesFor: #setRawNags!public! !

!HRImportSLPostRaceRace categoriesFor: #onURL:!public! !

!HRImportSLPostRaceRace categoriesFor: #setAll!public! !

!HRImportSLPostRaceRace categoriesFor: #setNagFrom:!accessing!private! !

!HRImportSLPostRaceRace categoriesFor: #setNonRunners!accessing!private! !

!HRImportSLPostRaceRace categoriesFor: #setPlaced!public! !

!HRImportSLPostRaceRace categoriesFor: #setRawNags!accessing!private! !

HRImportSLPreRaceRace guid: (GUID fromString: '{FE48A7CE-6DCF-4B1E-A41C-3B91B7EB0A63}')!

HRImportSLPreRaceRace guid: (GUID fromString: '{FE48A7CE-6DCF-4B1E-A41C-3B91B7EB0A63}')!
HRImportSLPreRaceRace comment: ''!

HRImportSLPreRaceRace comment:
''!
!HRImportSLPreRaceRace categoriesForClass!Kernel-Objects! !
!HRImportSLPreRaceRace methodsFor!
checkIfAllNagsAreThere
	^self race forecastRunners = self race nags size! !
!HRImportSLPreRaceRace categoriesFor: #checkIfAllNagsAreThere!public! !

!HRImportSLPreRaceRace methodsFor!
lookupOddsFrom: aString

	| sub num den |
	(aString sameAs: 'No Odds') ifTrue: [^0].
	(aString sameAs: 'Evs') ifTrue: [^Fraction numerator: 1 denominator: 1].
	(aString includes: $-) ifTrue: [ 
		sub := aString subStrings: $-.
		num := Number readFrom: (sub first) readStream.
		den := Number readFrom: (sub last) readStream.
		^Fraction numerator: num denominator: den].
	^Fraction numerator: (Number readFrom: aString readStream) denominator: 1.
	! !
!HRImportSLPreRaceRace categoriesFor: #lookupOddsFrom:!public! !

!HRImportSLPreRaceRace methodsFor!
onURL: aURL

"	super onURL: aURL attempt: 1."
	self on: (HRPageFiler storeFromURL: aURL).
	self contentsStream: self contents readStream.
	self url: aURL.
! !
!HRImportSLPreRaceRace categoriesFor: #onURL:!public! !

!HRImportSLPreRaceRace methodsFor!
setAll

	self checkIfAllNagsAreThere ifFalse: [
		self setRawNags;
			setNags].
	self setSLOdds.
! !
!HRImportSLPreRaceRace categoriesFor: #setAll!public! !

!HRImportSLPreRaceRace methodsFor!
setForecastAndFavourite
	"Find forecast and Favourites"

	| stream odds |
	odds := 0.
	stream := self contentsStream reset.
	stream skipToAll: 'Betting Forecast'.
	stream skipToAll: '</b>'.
	[stream atEnd] whileFalse: 
		[1 to: race noOfNags
			do: 
				[:each | 
				| result tmpOdds nag |
				[(stream atEnd not) and: [stream next codePoint < 38]] whileTrue.
				result := ReadStream on: (stream pop upToAll: '</a>,').
				result peek = $& ifFalse: [odds := self lookupOddsFrom: (result upTo: $&)].
				odds = 0 ifTrue: [self noOdds: (self noOdds + 1)].
				result skipTo: $>.
				nag := self race nagNamed: (result upTo: $<).
				nag isNil ifFalse: [
					nag
						noFavourite: each - self noOdds;
						rpForecast: odds.
					odds = 0 ifTrue: 
						[ nag noFavourite: (race noOfNags - self noOdds + 1)]].
				]]! !
!HRImportSLPreRaceRace categoriesFor: #setForecastAndFavourite!public! !

!HRImportSLPreRaceRace methodsFor!
setNagFrom: aString
	| stream nag cdWinner |
	stream := ReadStream on: aString.
	nag := HRNag new.
"racecard no"
	stream skipToAll: '<strong>'.
	nag racecardNo: (stream upTo: $<) trimBlanks.
"form"
	stream skipToAll: '"2">'.
	nag form: (stream upTo: $<) trimBlanks.
"nagName"
	stream skipToAll: 'html">'.
	nag name: (self checkName: (stream upTo: $<)) trimBlanks.
"trainer"
	stream skipToAll: 'trainer'.
	stream skipTo: $>.
	nag trainer: (self checkName: (stream upTo: $<)) trimBlanks.
"jockey"
	stream skipToAll: 'jockey'.
	stream skipTo: $>.
	nag jockey: (self checkName: (stream upTo: $<)) trimBlanks.
"days since last run"
	stream skipToAll: 'border="1"'.
	stream skipToAll: '<td>'.
	nag daysSinceLastRun: (self checkString: (stream upTo: $<)).
"course/distance winner"
	stream skipToAll: '<td>'.
	cdWinner := (stream upTo: $<) trimBlanks.
	nag courseWinner: (cdWinner includes: $C).
	nag distanceWinner: (cdWinner includes: $D).
"find nag"
	(self race includesNagNamed: nag name) ifFalse:
		[ self race addNag: nag ]
! !
!HRImportSLPreRaceRace categoriesFor: #setNagFrom:!public! !

!HRImportSLPreRaceRace methodsFor!
setRawNags
	| stream |
	stream := self contentsStream reset.
"start of card"
	stream skipToAll: 'RACING RACECARDS'.
"raw nags"
	[stream skipToAll: '<img align="left"'.
	stream atEnd] whileFalse: [ | result | 
		result := stream upToAll: '</em>'.
		result isEmpty ifFalse: [self rawNags addLast: result].
		].
! !
!HRImportSLPreRaceRace categoriesFor: #setRawNags!public! !

!HRImportSLPreRaceRace methodsFor!
setSLForecastOfRemainingNagsTo: odds

	self race nags do: [ :each |
		each slForecast isZero ifTrue: [ each slForecast: odds ]]! !
!HRImportSLPreRaceRace categoriesFor: #setSLForecastOfRemainingNagsTo:!public! !

!HRImportSLPreRaceRace methodsFor!
setSLOdds

	| substr odds tmpName |
	odds := 0.
	tmpName := ''.
	self contentsStream reset;
		skipToAll: 'FORECAST:'.
	substr := (self contentsStream upToAll: '</b>') subStrings.
	substr do: [ :each | | nag |
		each first isDigit 
			ifTrue: [ odds := self lookupOddsFrom: each ]
			ifFalse: [ tmpName := (tmpName, ' ', each) trimBlanks.
				(#($, $& $.) includes: each last) ifTrue: [
					nag := self race nagNamed: tmpName.
					nag isNil 
						ifFalse: [	nag slForecast: odds]
						ifTrue: [(tmpName soundsLike: 'others.') 
							ifTrue: [ self setSLForecastOfRemainingNagsTo: odds ]].
					tmpName := ''.
					].
				].
		].! !
!HRImportSLPreRaceRace categoriesFor: #setSLOdds!public! !

!HRImportSLPreRaceRace categoriesFor: #checkIfAllNagsAreThere!public! !

!HRImportSLPreRaceRace categoriesFor: #lookupOddsFrom:!public! !

!HRImportSLPreRaceRace categoriesFor: #onURL:!public! !

!HRImportSLPreRaceRace categoriesFor: #setAll!public! !

!HRImportSLPreRaceRace categoriesFor: #setForecastAndFavourite!public! !

!HRImportSLPreRaceRace categoriesFor: #setNagFrom:!accessing!public! !

!HRImportSLPreRaceRace categoriesFor: #setRawNags!accessing!public! !

!HRImportSLPreRaceRace categoriesFor: #setSLForecastOfRemainingNagsTo:!public! !

!HRImportSLPreRaceRace categoriesFor: #setSLOdds!public! !

HRImportSLEarlyResult guid: (GUID fromString: '{9A85AFC6-8DA4-4F87-866E-25018C49B852}')!

HRImportSLEarlyResult guid: (GUID fromString: '{9A85AFC6-8DA4-4F87-866E-25018C49B852}')!
HRImportSLEarlyResult comment: ''!

HRImportSLEarlyResult comment:
''!
!HRImportSLEarlyResult categoriesForClass!Kernel-Objects! !
!HRImportSLEarlyResult methodsFor!
extractResultsFrom: aString for: aRace

	| stream |
	stream := aString readStream.
	[stream skipToAll: '</tr>'.
	stream atEnd] whileFalse: [ | pos no |
		stream skipToAll: '<td>'.
		pos := self numberFrom: (stream upTo: $<).
		stream skipToAll: '<td>'.
		no := self numberFrom: (stream upToAll: ' ').
		(aRace nagNo: no) racePosition: pos.
		].
	aRace setPlaced.
! !
!HRImportSLEarlyResult categoriesFor: #extractResultsFrom:for:!public! !

!HRImportSLEarlyResult methodsFor!
setData
	| stream substream courseName |
	stream := ReadStream on: self contents.

"start of results"
	stream skipToAll: '<!!-- End of Left Nav -->'.
	stream skipToAll: '&nbsp;RACING RESULTS'.
	stream skipToAll: '<span class="heading">Latest results from around the country</span>'.

"races"
	[stream atEnd] whileFalse: [ | time mtg result | 
		stream skipToAll: '<strong>'.
		time := stream upTo: $<.
		stream skipToAll: '<strong>'.
		mtg := (self checkName: (stream upTo: $<)) asUppercase.
		result := stream upToAll: '<!!-- blank line -->'.
		(mtg sameAs: meeting course) ifTrue: [self rawRaces addLast: (time -> result)].
		].
	self setRaceResults! !
!HRImportSLEarlyResult categoriesFor: #setData!public! !

!HRImportSLEarlyResult methodsFor!
setRaceResults

	self rawRaces do: [ :assoc | | race |
		race := self meeting atSLShortTime: assoc key.
		race hasFullResults ifFalse: [ 
			self extractResultsFrom: assoc value for: race.
			race ppValDirty: true ]]! !
!HRImportSLEarlyResult categoriesFor: #setRaceResults!public! !

!HRImportSLEarlyResult categoriesFor: #extractResultsFrom:for:!accessing!public! !

!HRImportSLEarlyResult categoriesFor: #setData!accessing!public! !

!HRImportSLEarlyResult categoriesFor: #setRaceResults!accessing!public! !

HRRPPageFiler guid: (GUID fromString: '{59E81509-B06E-439A-8B3C-96098A5EC404}')!

HRRPPageFiler guid: (GUID fromString: '{59E81509-B06E-439A-8B3C-96098A5EC404}')!
HRRPPageFiler comment: ''!

HRRPPageFiler comment:
''!
!HRRPPageFiler categoriesForClass!Kernel-Objects! !
!HRRPPageFiler methodsFor!
cookieJar

	^HRApplication current rpCookieJar! !
!HRRPPageFiler categoriesFor: #cookieJar!public! !

!HRRPPageFiler methodsFor!
sptHTTPGet: aURL toFile: fileName

	| request myStream |
	(request := SptHTTPRequest new)
		cookieJar: self cookieJar;
		openGetTo: aURL;
		addHeader: 'Accept' value: '*/*';
		addHeader: 'Accept-Encoding' value: '';
		proxySettings: HRApplication current rpProxySettings.

	"Create the stream and set it into the request"
	myStream := FileStream 
				write: fileName
				text: false.
	request okBodyStream: myStream.
	
	[request
		send;
		waitOnReady] ensure: [myStream close].! !
!HRRPPageFiler categoriesFor: #sptHTTPGet:toFile:!public! !

!HRRPPageFiler categoriesFor: #cookieJar!public! !

!HRRPPageFiler categoriesFor: #sptHTTPGet:toFile:!public! !

HRApplication guid: (GUID fromString: '{BFA2B730-BEBF-4611-A361-17E79C4028EF}')!

HRApplication guid: (GUID fromString: '{BFA2B730-BEBF-4611-A361-17E79C4028EF}')!
HRApplication comment: ''!

HRApplication comment:
''!
!HRApplication categoriesForClass!MVP-Models! !
!HRApplication methodsFor!
addEarlyLiveDataOption

	| enabled stream |
	stream := FileStream readWrite: HRApplication current paramsPath , 'options.ini'.
	stream setToEnd;
		nextPutAll: '
[EARLY-LIVE-DATA]
LoadEarlyLiveData=false
GenerateEsts=false
'.
	stream
		flush;
		close
! !
!HRApplication categoriesFor: #addEarlyLiveDataOption!public! !

!HRApplication methodsFor!
addGenerateEstsOption

	| enabled stream |
#deprecated.
	stream := FileStream readWrite: HRApplication current paramsPath , 'options.ini'.
	stream setToEnd;
		nextPutAll: '
[GENERATE]
GenerateEsts=false
'.
	stream
		flush;
		close
! !
!HRApplication categoriesFor: #addGenerateEstsOption!public! !

!HRApplication methodsFor!
addLoggingOption

	| enabled stream |
	stream := FileStream readWrite: HRApplication current paramsPath , 'options.ini'.
	stream setToEnd;
		nextPutAll: '
[LOGGING]
FullLogs=false
'.
	stream
		flush;
		close
! !
!HRApplication categoriesFor: #addLoggingOption!public! !

!HRApplication methodsFor!
addMeeting: aMeeting
	self meetings addLast: aMeeting.
	aMeeting 
		scheduleToteURLID; 
		createPPScheduleItems
		scheduleCopyPreviewValues.

	aMeeting races do: [:race | 
		race createScheduleItemForSLLiveShow;
			createScheduleItemForSLResult].
	HRApplication current fullUnlock ifTrue: [
		self wantPreMeetingCSV ifTrue: [aMeeting createPreMeetingCSVOutputScheduleItem].
		aMeeting 
			setBetfairRaceIDs;
			scheduleLoadEarlyLiveData;
			createCSVOutputScheduleItem;
			createDataOutputScheduleItem.
		].
! !
!HRApplication categoriesFor: #addMeeting:!public! !

!HRApplication methodsFor!
addPreMeetingCSVOption

	| enabled stream |
	stream := FileStream readWrite: HRApplication current paramsPath , 'options.ini'.
	stream setToEnd;
		nextPutAll: '
[PRE-MEETING-CSV]
GeneratePreMeetingCSV=false
GenerateEsts=false
'.
	stream
		flush;
		close
! !
!HRApplication categoriesFor: #addPreMeetingCSVOption!public! !

!HRApplication methodsFor!
addProxyOption

	| enabled stream |
	stream := FileStream readWrite: HRApplication current paramsPath , 'options.ini'.
	stream setToEnd;
		nextPutAll: '
[PROXY]
UseProxy=false
Host=localhost
Port=8000
'.
	stream
		flush;
		close
! !
!HRApplication categoriesFor: #addProxyOption!public! !

!HRApplication methodsFor!
addRaceEditOptions

	| enabled stream |
	stream := FileStream readWrite: HRApplication current paramsPath , 'options.ini'.
	stream setToEnd;
		nextPutAll: '
[RACE-EDIT]
RememberSort=false
'.
	stream
		flush;
		close
! !
!HRApplication categoriesFor: #addRaceEditOptions!public! !

!HRApplication methodsFor!
addRestoredMeeting: aMeeting
	self meetings addLast: aMeeting.
! !
!HRApplication categoriesFor: #addRestoredMeeting:!public! !

!HRApplication methodsFor!
addRPProxyOption

	| enabled stream |
	stream := FileStream readWrite: HRApplication current paramsPath , 'options.ini'.
	stream setToEnd;
		nextPutAll: '
[RPPROXY]
UseProxy=false
Host=localhost
Port=8000
'.
	stream
		flush;
		close
! !
!HRApplication categoriesFor: #addRPProxyOption!public! !

!HRApplication methodsFor!
addTargetStakeOption

	| enabled stream |
	stream := FileStream readWrite: HRApplication current paramsPath , 'options.ini'.
	stream setToEnd;
		nextPutAll: '
[STAKE]
UseTargetStake=false
TargetStake=0
'.
	stream
		flush;
		close
! !
!HRApplication categoriesFor: #addTargetStakeOption!public! !

!HRApplication methodsFor!
bfAbbrFor: aCourse

	| result |
	result := self courses at: (aCourse subStrings first asSymbol) ifAbsent: [
				HRLogger current showAlways: ('Unknown course name: ', self course, String lineDelimiter).
				''].
	^result asLowercase capitalized
! !
!HRApplication categoriesFor: #bfAbbrFor:!public! !

!HRApplication methodsFor!
checkProxySettings
#deprecated.
	proxySettings ifNil: [proxySettings := SptProxySettingDialog showModal].
! !
!HRApplication categoriesFor: #checkProxySettings!public! !

!HRApplication methodsFor!
courseNameAt: abbr

	^self courses keyAtValue: abbr ifAbsent: [
		HRLogger current showAlways: 
		('Unknown course abbreviation: ', abbr, String lineDelimiter).
		^'']
! !
!HRApplication categoriesFor: #courseNameAt:!public! !

!HRApplication methodsFor!
courseNames

	^self courses keys! !
!HRApplication categoriesFor: #courseNames!public! !

!HRApplication methodsFor!
courses

	courses ifNil: [self setCourses].
	^courses
! !
!HRApplication categoriesFor: #courses!public! !

!HRApplication methodsFor!
createCoursesIni

	| stream |
	stream := FileStream write: HRApplication current paramsPath , 'courses.ini'.
	stream 
		nextPutAll: '
AINTREE	AINT
ASCOT	ASCOT
AYR	AYR
BANGOR	BANG
BATH	BATH
BEVERLEY	BEV
BRIGHTON	BRIG
CARLISLE	CARL
CARTMEL	CART
CATTERICK	CATT
CHELTENHAM	CHELT
CHEPSTOW	CHEP
CHESTER	CHEST
DONCASTER	DONC
EPSOM	EPSOM
EXETER	EXTR
FAKENHAM	FAKE
FOLKESTONE	FOLK
FONTWELL	FONT
GOODWOOD	GOOD
HAMILTON	HAM
HAYDOCK	HAYD
HEREFORD	HERE
HEXHAM	HEX
HUNTINGDON	HUNT
KELSO	KELSO
KEMPTON	KEMP
LEICESTER	LEIC
LINGFIELD	LING
LUDLOW	LUDL
MARKET	MRKTR
MUSSELBURGH	MUSS
NEWTON	NEWT
NEWBURY	NEWB
NEWCASTLE	NEWC
NEWMARKET	NEWM
NOTTINGHAM	NOTT
PERTH	PERTH
PLUMPTON	PLUMP
PONTEFRACT	PONTE
REDCAR	REDC
RIPON	RIPON
SALISBURY	SALIS
SANDOWN	SAND
SEDGEFIELD	SEDGE
SOUTHWELL	STHL
STRATFORD	STRAT
TAUNTON	TAUN
THIRSK	THIRSK
TOWCESTER	TOWC
UTTOXETER	UTTOX
WARWICK	WARW
WETHERBY	WETH
WINCANTON	WINC
WINDSOR	WIND
WOLVERHAMPTON	WOLV
WORCESTER	WORC
YARMOUTH	YARM
YORK	YORK
'.
	stream
		flush;
		close
! !
!HRApplication categoriesFor: #createCoursesIni!public! !

!HRApplication methodsFor!
createOptionsIni

	| stream |
	stream := FileStream write: HRApplication current paramsPath , 'options.ini'.
	stream flush; close.
	self addEarlyLiveDataOption; addLoggingOption; addPreMeetingCSVOption; addProxyOption; addRPProxyOption; addRaceEditOptions; addTargetStakeOption.
! !
!HRApplication categoriesFor: #createOptionsIni!public! !

!HRApplication methodsFor!
createScheduleItemFor: aDate

	self createScheduleItemFor: aDate time: (Time fromString: '11:00')! !
!HRApplication categoriesFor: #createScheduleItemFor:!public! !

!HRApplication methodsFor!
createScheduleItemFor: aDate runDate: aRunDate time: aTime

	| item |
	item := HRScheduleItem new 
		date: aRunDate; 
		time: aTime;
		object: self;
		process: #scheduledFindMeetingsFor:;
		params: (Array with: aDate).
	HRScheduler current addScheduleItem: item.
! !
!HRApplication categoriesFor: #createScheduleItemFor:runDate:time:!public! !

!HRApplication methodsFor!
createScheduleItemFor: aDate time: aTime

	| item |
	item := HRScheduleItem new 
		date: aDate; 
		time: aTime;
		object: self;
		process: #scheduledFindMeetingsFor:;
		params: (Array with: aDate).
	HRScheduler current addScheduleItem: item.
! !
!HRApplication categoriesFor: #createScheduleItemFor:time:!public! !

!HRApplication methodsFor!
dataPath
	"for file-outs"
	(File exists: (SessionManager current imageBase, 'data')) ifFalse: 
		[File createDirectory: (SessionManager current imageBase, 'data')].
	^SessionManager current imageBase, 'data\'.
! !
!HRApplication categoriesFor: #dataPath!public! !

!HRApplication methodsFor!
detailLogging
	detailLogging ifNil: [detailLogging := self readTagForLogging].
	^detailLogging! !
!HRApplication categoriesFor: #detailLogging!public! !

!HRApplication methodsFor!
fileInAll
	| root result counter |
	counter := 0.
"	root := HRApplication current dataPath."
	root := (BrowseFolderDialog showModal) ifNil: [^self].
	result := (File find: root, '\*.dat') collect: [:s | s path].
	result notNil 
		ifTrue: 
			[ProgressDialog showModal: 'No cancel view'
				while: 
					[:progress | 
					(1 to: result size) do: 
							[:i | 
							| file meeting stream |
							progress value: i.
							file := result at: i.
							stream := FileStream read: file text: false.
							meeting := Object binaryReadFrom: stream.
							stream close.
							meeting ifNotNil: 
									[:each | 
									self addRestoredMeeting: each.
									counter := counter + 1]]]].
	MessageBox notify: counter displayString , ' meetings loaded.'! !
!HRApplication categoriesFor: #fileInAll!public! !

!HRApplication methodsFor!
fileInPrompt

	| file meeting stream |
	file := FileOpenDialog new
		fileTypes: #(('Data files (*.dat)' '*.dat') ('All Files (*.*)' '*.*') );
		defaultExtension: 'dat';
		showModal.
	file notNil ifTrue: [
		stream := FileStream read: file text: false.
		meeting := Object binaryReadFrom: stream.
		stream close ]. 
	meeting ifNotNil: [ :each | self addRestoredMeeting: each ].
! !
!HRApplication categoriesFor: #fileInPrompt!public! !

!HRApplication methodsFor!
findMeetingsFor: aDate
	| day month url import | 
"http://www.racingpost.co.uk/horses/a_days_racing.sd?r_date=2004-7-09&flag=1&cards=1"
	HRLogger current showAlways: 
		(Time now displayString, ' Finding meetings for: ', aDate displayString, String lineDelimiter).
	day := (aDate dayOfMonth < 10 ifTrue: ['0'] ifFalse:['']), aDate dayOfMonth printString.
	month := aDate monthName first: 3.
"	url := 'http://www.racingpost.co.uk/horses/?MIval=v2_a_days_racing&day=', day, '&month=',
 		month, '&year=',aDate year printString, '&flag=1'."
	url := 'http://www.racingpost.co.uk/horses/a_days_racing.sd?r_date=', aDate year printString, '-', aDate monthIndex printString, '-', day, '&flag=1&cards=1'.
HRLogger current showFull: ('URL: ', url, String lineDelimiter).
	(WinInetLibrary default ping: url) 
		ifTrue: [
			import := HRImportRPPreRaceDay onURL: url.
			import setMeetingURLs.
HRLogger current showFull: ('Meeting URLs: ', String lineDelimiter).
			import meetingURLs do: [ :each | | importMeeting |
HRLogger current showFull: ('URL: ', url, String lineDelimiter).
				importMeeting := HRImportRPPreRaceMeeting onURL: each.
				importMeeting setMeetingAndRaceURLs.
				(importMeeting raceURLs size > 5) ifTrue: [
					HRLogger current showAlways: 
						(importMeeting meeting course, String lineDelimiter).
					importMeeting importRaceData.
					((importMeeting meeting startTime > (Time now subtractTime: 
						(Time fromSeconds: ##(3*60*60)))) or: 
						[importMeeting meeting date > Date today]) ifTrue: 
							[self addMeeting: importMeeting meeting].
				 	]
]]
		ifFalse: [ HRLogger current showError: ('Could not connect to ', url, String lineDelimiter)].

	(self meetingsFor: aDate) isEmpty 
		ifTrue: [ (aDate = Date today and: [Time now > (Time fromString: '21.00')])
			ifFalse: [ self createScheduleItemFor: aDate runDate: Date today time: (Time now addTime: (Time fromString: '0.05')) ]
			ifTrue: [ self createScheduleItemFor: (aDate addDays: 1)]]
		ifFalse: [
"			self fullUnlock ifTrue: [
				self scheduleFindBetfairRaceIDsFor: aDate.
				self wantLoadEarlyLiveData ifTrue: [self scheduleLoadEarlyLiveData]]."
			"self scheduleTotePPURLFor: aDate."
			"self scheduleCopyPreviewValuesFor: aDate."
			self createScheduleItemFor: (aDate addDays: 1).
			].
! !
!HRApplication categoriesFor: #findMeetingsFor:!public! !

!HRApplication methodsFor!
findPreMeetingNRs
	| url import |
#deprecated.
	url := 'http://www.sportinglife.com/racing/nonrunners1.html'.
	(WinInetLibrary default ping: url) 
		ifTrue: 
			[import := HRImportSLPreMeetingNR onURL: url meetings: self meetingsForToday.
HRLogger current showFull: ('Find pre-meeting non-runners', String lineDelimiter).
			import setPreMeetingNRs.
			]
		ifFalse: 
			[HRLogger current
				showError: ('Could not connect to ', url, String lineDelimiter)]! !
!HRApplication categoriesFor: #findPreMeetingNRs!public! !

!HRApplication methodsFor!
firstRaceTime
#deprecated.
	"self meetings isEmpty ifTrue: [ ^Time fromString: '12.00']."
	^self meetings inject: (Time fromString: '14.00') into: [ :min :each | min min: (each races first time)]! !
!HRApplication categoriesFor: #firstRaceTime!public! !

!HRApplication methodsFor!
fullUnlock

	fullUnlock ifNil: [fullUnlock := false].
	^fullUnlock! !
!HRApplication categoriesFor: #fullUnlock!public! !

!HRApplication methodsFor!
fullUnlock: anObject
	fullUnlock := anObject! !
!HRApplication categoriesFor: #fullUnlock:!public! !

!HRApplication methodsFor!
generateEsts

#deprecated.
	^self readTagForGenerateEsts! !
!HRApplication categoriesFor: #generateEsts!public! !

!HRApplication methodsFor!
initialize

"	self checkProxySettings."
	^super initialize! !
!HRApplication categoriesFor: #initialize!public! !

!HRApplication methodsFor!
isLoggedOnToRP

	^rpCookieJar notNil! !
!HRApplication categoriesFor: #isLoggedOnToRP!public! !

!HRApplication methodsFor!
loadEarlyLiveData

	self meetings do: [ :each | each loadEarlyLiveData ]! !
!HRApplication categoriesFor: #loadEarlyLiveData!public! !

!HRApplication methodsFor!
logonToRP

	| logon |
	HRLogger current showAlways: 
		(Time now displayString, ' Logging on to Racingpost ... ', String lineDelimiter).
	(self rpUsername isNil or: [self rpPassword isNil]) ifTrue: [self setRPNamePwd].
	logon := HRRPLogon username: self rpUsername password: self rpPassword.
	rpCookieJar := logon cookieJar.
	HRLogger current showAlways: 
		(Time now displayString, ' ', self rpUsername, ' logged on to Racingpost ', String lineDelimiter).
! !
!HRApplication categoriesFor: #logonToRP!public! !

!HRApplication methodsFor!
logPath

	(File exists: (SessionManager current imageBase, 'logs')) ifFalse: 
		[File createDirectory: (SessionManager current imageBase, 'logs')].
	^SessionManager current imageBase, 'logs\'.
! !
!HRApplication categoriesFor: #logPath!public! !

!HRApplication methodsFor!
meetingAt: aCourseAbbr

	^self meetings detect: [ :each | 
			each course subStrings first soundsLike: (self courseNameAt: aCourseAbbr)] 
		ifNone: [HRMeeting new]
! !
!HRApplication categoriesFor: #meetingAt:!public! !

!HRApplication methodsFor!
meetings
	meetings ifNil: [meetings := OrderedCollection new].
	^meetings! !
!HRApplication categoriesFor: #meetings!public! !

!HRApplication methodsFor!
meetingsFor: aDate

	^self meetings select: [ :meeting | meeting date = aDate ]! !
!HRApplication categoriesFor: #meetingsFor:!public! !

!HRApplication methodsFor!
meetingsForToday

	^self meetingsFor: Date today! !
!HRApplication categoriesFor: #meetingsForToday!public! !

!HRApplication methodsFor!
meetingsForYesterday

	^self meetingsFor: (Date today subtractDays: 1)! !
!HRApplication categoriesFor: #meetingsForYesterday!public! !

!HRApplication methodsFor!
multipleFileInPrompt
	| result |
	result := (MultipleFileOpenDialog new)
				fileTypes: #(#('Data files (*.dat)' '*.dat') #('All Files (*.*)' '*.*'));
				defaultExtension: 'dat';
				showModal.
	result notNil 
		ifTrue: 
			[result do: 
					[:file | 
					| meeting stream |
					stream := FileStream read: file text: false.
					meeting := Object binaryReadFrom: stream.
					stream close.
					meeting ifNotNil: [:each | self addRestoredMeeting: each]]]! !
!HRApplication categoriesFor: #multipleFileInPrompt!public! !

!HRApplication methodsFor!
outputAllAsCsv

#deprecated.
	self save: self meetings asCsvFileWith: HRMeeting defaultOutputArray
! !
!HRApplication categoriesFor: #outputAllAsCsv!public! !

!HRApplication methodsFor!
outputAndMailTodayAsCsv

#deprecated.
	^HRMailer mailTodayCsvFile: (self outputTodayAsCsv).
! !
!HRApplication categoriesFor: #outputAndMailTodayAsCsv!public! !

!HRApplication methodsFor!
outputPath

	(File exists: (SessionManager current imageBase, 'output')) ifFalse: 
		[File createDirectory: (SessionManager current imageBase, 'output')].
	^SessionManager current imageBase, 'output\'.
! !
!HRApplication categoriesFor: #outputPath!public! !

!HRApplication methodsFor!
outputTodayAsCsv

	| filename |
#deprecated.
	filename := self save: self meetingsForToday asCsvFileWith: HRMeeting defaultOutputArray.
	HRLogger current showAlways: 
		(Time now displayString, ' Written CSV for: ', (Date today displayUsingFormat: 'dd-MM-yy'), String lineDelimiter).
	^filename
! !
!HRApplication categoriesFor: #outputTodayAsCsv!public! !

!HRApplication methodsFor!
pagesPath
	"for file-outs"
	(File exists: (SessionManager current imageBase, 'pages')) ifFalse: 
		[File createDirectory: (SessionManager current imageBase,  'pages')].
	^SessionManager current imageBase, 'pages\'.
! !
!HRApplication categoriesFor: #pagesPath!public! !

!HRApplication methodsFor!
paramsPath
	"for parameters"
	(File exists: (SessionManager current imageBase, 'params')) ifFalse: 
		[File createDirectory: (SessionManager current imageBase, 'params')].
	^SessionManager current imageBase, 'params\'.
! !
!HRApplication categoriesFor: #paramsPath!public! !

!HRApplication methodsFor!
proxySettings

	proxySettings ifNil: [self readTagForProxySettings].
	^proxySettings
! !
!HRApplication categoriesFor: #proxySettings!public! !

!HRApplication methodsFor!
proxySettings: aSptHTTPProxySettings 
	proxySettings := aSptHTTPProxySettings! !
!HRApplication categoriesFor: #proxySettings:!public! !

!HRApplication methodsFor!
readTagForEarlyLiveData

	| result enabled stream |
	result := Array new: 2.
	(File exists: (HRApplication current paramsPath, 'options.ini')) ifFalse: [self createOptionsIni].
	stream := FileStream read: (HRApplication current paramsPath, 'options.ini').
	stream reset; skipToAll: '[EARLY-LIVE-DATA]'. 
	stream atEnd ifTrue: 
		[stream close.
		self addEarlyLiveDataOption.
		stream := FileStream read: (HRApplication current paramsPath, 'options.ini').].
	stream reset; skipToAll: '[EARLY-LIVE-DATA]'; skipToAll: 'LoadEarlyLiveData='.
	enabled := (stream upToAll: String lineDelimiter) trimBlanks asSymbol.
	result at: 1 put: (enabled sameAs: 'true').
	stream reset; skipToAll: '[EARLY-LIVE-DATA]'; skipToAll: 'GenerateEsts='.
	enabled := (stream upToAll: String lineDelimiter) trimBlanks asSymbol.
	result at: 2 put: (enabled sameAs: 'true').
	stream close.
	^result! !
!HRApplication categoriesFor: #readTagForEarlyLiveData!public! !

!HRApplication methodsFor!
readTagForGenerateEsts

	| result enabled stream |
#deprecated.
	(File exists: (HRApplication current paramsPath, 'options.ini')) ifFalse: [self createOptionsIni].
	stream := FileStream read: (HRApplication current paramsPath, 'options.ini').
	stream reset; skipToAll: '[GENERATE]'. 
	stream atEnd ifTrue: 
		[stream close.
		self addGenerateEstsOption.
		stream := FileStream read: (HRApplication current paramsPath, 'options.ini').].
	stream reset; skipToAll: '[GENERATE]'; skipToAll: 'GenerateEsts='.
	enabled := (stream upToAll: String lineDelimiter) trimBlanks asSymbol.
	result := (enabled sameAs: 'true').
	stream close.
	^result! !
!HRApplication categoriesFor: #readTagForGenerateEsts!public! !

!HRApplication methodsFor!
readTagForLogging

	| result enabled stream |
	(File exists: (HRApplication current paramsPath, 'options.ini')) ifFalse: [self createOptionsIni].
	stream := FileStream read: (HRApplication current paramsPath, 'options.ini').
	stream reset; skipToAll: '[LOGGING]'. 
	stream atEnd ifTrue: 
		[stream close.
		self addLoggingOption.
		stream := FileStream read: (HRApplication current paramsPath, 'options.ini').].
	stream reset; skipToAll: '[LOGGING]'; skipToAll: 'FullLogs='.
	enabled := (stream upToAll: String lineDelimiter) trimBlanks asSymbol.
	result := (enabled sameAs: 'true').
	stream close.
	^result! !
!HRApplication categoriesFor: #readTagForLogging!public! !

!HRApplication methodsFor!
readTagForPreMeetingCSV

	| result enabled stream |
	result := Array new: 2.
	(File exists: (HRApplication current paramsPath, 'options.ini')) ifFalse: [self createOptionsIni].
	stream := FileStream read: (HRApplication current paramsPath, 'options.ini').
	stream reset; skipToAll: '[PRE-MEETING-CSV]'. 
	stream atEnd ifTrue: 
		[stream close.
		self addPreMeetingCSVOption.
		stream := FileStream read: (HRApplication current paramsPath, 'options.ini').].
	stream reset; skipToAll: '[PRE-MEETING-CSV]'; skipToAll: 'GeneratePreMeetingCSV='.
	enabled := (stream upToAll: String lineDelimiter) trimBlanks asSymbol.
	result at: 1 put: (enabled sameAs: 'true').
	stream reset; skipToAll: '[PRE-MEETING-CSV]'; skipToAll: 'GenerateEsts='.
	enabled := (stream upToAll: String lineDelimiter) trimBlanks asSymbol.
	result at: 2 put: (enabled sameAs: 'true').
	stream close.
	^result! !
!HRApplication categoriesFor: #readTagForPreMeetingCSV!public! !

!HRApplication methodsFor!
readTagForProxySettings

	| stream field enabled host port |
	(File exists: (HRApplication current paramsPath, 'options.ini')) ifFalse: [self createOptionsIni].
	stream := FileStream read: (HRApplication current paramsPath, 'options.ini').
	stream reset; skipToAll: '[PROXY]'. 
	stream atEnd ifTrue: 
		[stream close.
		self addProxyOption.
		stream := FileStream read: (HRApplication current paramsPath, 'options.ini').].
	stream reset; 
		skipToAll: '[PROXY]'; 
		skipToAll: 'UseProxy='.
	field := (stream upToAll: String lineDelimiter) trimBlanks asSymbol.
	enabled := (field sameAs: 'true').
	stream skipToAll: 'Host='.
	host := (stream upToAll: String lineDelimiter) trimBlanks asSymbol.
	stream skipToAll: 'Port='.
	port := Number fromString: (stream upToAll: String lineDelimiter) trimBlanks.
	stream close.
	self proxySettings: (SptHTTPProxySettings useHost: host port: port).
	self proxySettings useProxy: enabled.! !
!HRApplication categoriesFor: #readTagForProxySettings!public! !

!HRApplication methodsFor!
readTagForRaceEdit

	| result enabled stream |
	result := Dictionary new.
	(File exists: (HRApplication current paramsPath, 'options.ini')) ifFalse: [self createOptionsIni].
	stream := FileStream read: (HRApplication current paramsPath, 'options.ini').
	stream reset; skipToAll: '[RACE-EDIT]'. 
	stream atEnd ifTrue: 
		[stream close.
		self addRaceEditOptions.
		stream := FileStream read: (HRApplication current paramsPath, 'options.ini').].
	stream reset; skipToAll: '[RACE-EDIT]'; skipToAll: 'RememberSort='.
	enabled := (stream upToAll: String lineDelimiter) trimBlanks asSymbol.
	rememberSort := (enabled sameAs: 'true').
	stream close.
! !
!HRApplication categoriesFor: #readTagForRaceEdit!public! !

!HRApplication methodsFor!
readTagForRPProxySettings

	| stream field enabled host port |
	(File exists: (HRApplication current paramsPath, 'options.ini')) ifFalse: [self createOptionsIni].
	stream := FileStream read: (HRApplication current paramsPath, 'options.ini').
	stream reset; skipToAll: '[RPPROXY]'. 
	stream atEnd ifTrue: 
		[stream close.
		self addRPProxyOption.
		stream := FileStream read: (HRApplication current paramsPath, 'options.ini').].
	stream reset; 
		skipToAll: '[RPPROXY]'; 
		skipToAll: 'UseProxy='.
	field := (stream upToAll: String lineDelimiter) trimBlanks asSymbol.
	enabled := (field sameAs: 'true').
	stream skipToAll: 'Host='.
	host := (stream upToAll: String lineDelimiter) trimBlanks asSymbol.
	stream skipToAll: 'Port='.
	port := Number fromString: (stream upToAll: String lineDelimiter) trimBlanks.
	stream close.
	self rpProxySettings: (SptHTTPProxySettings useHost: host port: port).
	self rpProxySettings useProxy: enabled.! !
!HRApplication categoriesFor: #readTagForRPProxySettings!public! !

!HRApplication methodsFor!
readTagForTargetStake
	| result enabled stream targetStake |
	targetStake := 0.
	(File exists: HRApplication current paramsPath , 'options.ini') 
		ifFalse: [self createOptionsIni].
	stream := FileStream read: HRApplication current paramsPath , 'options.ini'.
	stream
		reset;
		skipToAll: '[STAKE]'.
	stream atEnd 
		ifTrue: 
			[stream close.
			self addTargetStakeOption.
			stream := FileStream read: HRApplication current paramsPath , 'options.ini'].
	stream
		reset;
		skipToAll: '[STAKE]';
		skipToAll: 'UseTargetStake='.
	enabled := (stream upToAll: String lineDelimiter) trimBlanks asSymbol.
	result := enabled sameAs: 'true'.
	result 
		ifTrue: 
			[stream skipToAll: 'TargetStake='.
			targetStake := [Number fromString: (stream upToAll: String lineDelimiter) trimBlanks] 
						on: Error
						do: [:each | 0]].
	stream close.
	^targetStake! !
!HRApplication categoriesFor: #readTagForTargetStake!public! !

!HRApplication methodsFor!
rememberSort

	self readTagForRaceEdit.
	^rememberSort! !
!HRApplication categoriesFor: #rememberSort!public! !

!HRApplication methodsFor!
removeAllMeetings

	meetings isNil ifFalse: [ 
		meetings removeAll.
		meetings := OrderedCollection new.
		]! !
!HRApplication categoriesFor: #removeAllMeetings!public! !

!HRApplication methodsFor!
removeMeeting: aMeeting

	self meetings remove: aMeeting ifAbsent: [nil].
! !
!HRApplication categoriesFor: #removeMeeting:!public! !

!HRApplication methodsFor!
reorganiseMeetings

	|tmp|
	tmp := OrderedCollection new.
	meetings do: [ :each | tmp addLast: each ].
	meetings := tmp! !
!HRApplication categoriesFor: #reorganiseMeetings!public! !

!HRApplication methodsFor!
rpCookieJar

"	rpCookieJar ifNil: [self logonToRP]."
	^rpCookieJar! !
!HRApplication categoriesFor: #rpCookieJar!public! !

!HRApplication methodsFor!
rpPassword

"	rpPassword ifNil: [self setRPNamePwd ]."
	^rpPassword! !
!HRApplication categoriesFor: #rpPassword!public! !

!HRApplication methodsFor!
rpPassword: aPassword

	rpPassword := aPassword! !
!HRApplication categoriesFor: #rpPassword:!public! !

!HRApplication methodsFor!
rpProxySettings

	rpProxySettings ifNil: [self readTagForRPProxySettings].
	^rpProxySettings
! !
!HRApplication categoriesFor: #rpProxySettings!public! !

!HRApplication methodsFor!
rpProxySettings: aSptHTTPProxySettings 
	rpProxySettings := aSptHTTPProxySettings! !
!HRApplication categoriesFor: #rpProxySettings:!public! !

!HRApplication methodsFor!
rpUsername

"	rpUsername ifNil: [self setRPNamePwd ]."
	^rpUsername! !
!HRApplication categoriesFor: #rpUsername!public! !

!HRApplication methodsFor!
rpUsername: aUsername

	rpUsername := aUsername! !
!HRApplication categoriesFor: #rpUsername:!public! !

!HRApplication methodsFor!
save: someMeetings asCsvFileWith: anArray

	| file fileName size |
#deprecated.
	fileName := (HRApplication current outputPath, Date today displayString, '-full.csv').
	[file := FileStream write: fileName.
	(someMeetings isNil or: [someMeetings isEmpty]) ifTrue: [^nil].
	file nextPutAll: (someMeetings first csvStringHeaderWith: anArray 
			decorators: someMeetings first strategies), 
		String lineDelimiter.
	size := someMeetings size.
	ProgressDialog showModalWhile: [:progress | 
		(1 to: size) do: [:i | 
			progress text: 'Output ', i displayString , ' meeting(s) of ', size displayString.
			progress value: (i * 100 / size) truncated.
			file nextPutAll: ((self meetings at: i) allRacesAndNagsCsvWith: anArray 
				decorators: (self meetings at: i) strategies).
			file flush]].
	file flush] ensure: [file close].
	^fileName
! !
!HRApplication categoriesFor: #save:asCsvFileWith:!public! !

!HRApplication methodsFor!
scheduleCopyPreviewValues
#deprecated.
	self meetingsForToday do: [ :each |
		each scheduleCopyPreviewValues ]! !
!HRApplication categoriesFor: #scheduleCopyPreviewValues!public! !

!HRApplication methodsFor!
scheduleCopyPreviewValuesFor: aDate
#deprecated.
	(self meetingsFor: aDate) do: [ :each |
		each scheduleCopyPreviewValues ]! !
!HRApplication categoriesFor: #scheduleCopyPreviewValuesFor:!public! !

!HRApplication methodsFor!
scheduledFindMeetingsFor: aDate
	[self logonToRP.
	(Delay forSeconds: 5) wait. self isLoggedOnToRP] whileFalse.
	self findMeetingsFor: aDate.
! !
!HRApplication categoriesFor: #scheduledFindMeetingsFor:!public! !

!HRApplication methodsFor!
scheduledFindTodaysMeetings
#deprecated.
	[self logonToRP.
	(Delay forSeconds: 5) wait. self isLoggedOnToRP] whileFalse.
	self findMeetingsFor: Date today.
! !
!HRApplication categoriesFor: #scheduledFindTodaysMeetings!public! !

!HRApplication methodsFor!
scheduleFindBetfairRaceIDs

	| item |
#deprecated.
	item := HRScheduleItem new 
		date: Date today; 
		time: (Time now addTime: (Time fromSeconds: 600));
		object: self;
		process: #setBetfairRaceIDs.
	HRScheduler current addScheduleItem: item.
! !
!HRApplication categoriesFor: #scheduleFindBetfairRaceIDs!public! !

!HRApplication methodsFor!
scheduleFindBetfairRaceIDsFor: aDate

	| item runDate runTime |
#deprecated.
	runDate := aDate.
	runTime := Time fromString: '11.00'.
	(aDate = Date today or: [
		(aDate = (Date today addDays: 1)) and: [Time now > (Time fromString: '21.00')]])
			 ifTrue: [runDate := Date today. runTime := (Time now addTime: (Time fromSeconds: 600))].
	item := HRScheduleItem new 
		date: runDate; 
		time: runTime;
		object: self;
		process: #setBetfairRaceIDsFor:;
		params: (Array with: aDate).
	HRScheduler current addScheduleItem: item.
! !
!HRApplication categoriesFor: #scheduleFindBetfairRaceIDsFor:!public! !

!HRApplication methodsFor!
scheduleLoadEarlyLiveData

	| item |
#deprecated.
	item := HRScheduleItem new 
		date: Date today; 
		time: (Time now addTime: (Time fromSeconds: 720));
		object: self;
		process: #loadEarlyLiveData.
	HRScheduler current addScheduleItem: item.
! !
!HRApplication categoriesFor: #scheduleLoadEarlyLiveData!public! !

!HRApplication methodsFor!
scheduleOutputTodayCsv

	| item |
#deprecated.
	item := HRScheduleItem new 
		date: Date today; 
		time: (Time fromString: '23.00');
		object: self;
		process: #outputAndMailTodayAsCsv.
	HRScheduler current addScheduleItem: item.
! !
!HRApplication categoriesFor: #scheduleOutputTodayCsv!public! !

!HRApplication methodsFor!
setBetfairRaceIDs
	| url import |
#deprecated.
	(self meetingsForToday isEmpty and: [Time now < (Time fromString: '20.00') ]) ifTrue: 
		[^self scheduleFindBetfairRaceIDs].
	self setCourses.
	url := 'http://www.betfair.com/includes/MenuData.asp?action=specific&parent=13&write=undefined&region=1'.
	(WinInetLibrary default ping: url) 
		ifTrue: 
			[import := HRImportBetfairDay onURL: url.
HRLogger current showAlways: ('Find Betfair meeting IDs on: ', url, String lineDelimiter).
			import setAll]
		ifFalse: 
			[HRLogger current
				showAlways: ('Could not connect to ', url, String lineDelimiter)]! !
!HRApplication categoriesFor: #setBetfairRaceIDs!public! !

!HRApplication methodsFor!
setBetfairRaceIDsFor: aDate
	| url import |
#deprecated.
	((self meetingsFor: aDate) isEmpty and: [Date today <= aDate ]) ifTrue: 
		[^self scheduleFindBetfairRaceIDsFor: aDate].
	self setCourses.
	"url := 'http://www.betfair.com/includes/MenuData.asp?action=specific&parent=13&write=undefined&region=1'."

"	url := 'http://www.betfair.com/Menu.do?timeZone=Europe/London&region=GBR_IRL&locale=en_GB&brand=betfair'."
	url := 'http://www.betfair.com/menu/LoadMenuNodesAction.do?sReturnPath=parent.frames[''menu'']&method=getMenuEvents&menuNodeId=13&strArrayName=allSkeletonArray&iParentID=13&layerName=allMarketsTreeContainer&strMenuPathArrayName=allPathArray&menuPathLayer=menuParents1&locale=en_GB'.
	(WinInetLibrary default ping: url) 
		ifTrue: 
			[import := HRImportBetfairDay onURL: url.
HRLogger current showFull: ('Find Betfair meeting IDs on: ', url, String lineDelimiter).
			import setAll]
		ifFalse: 
			[HRLogger current
				showError: ('Could not connect to ', url, String lineDelimiter)]! !
!HRApplication categoriesFor: #setBetfairRaceIDsFor:!public! !

!HRApplication methodsFor!
setCourses

	| stream string|
	courses := IdentityDictionary new.
	(File exists: (HRApplication current paramsPath, 'courses.ini')) ifFalse: [self createCoursesIni].
	stream := FileStream read: (HRApplication current paramsPath, 'courses.ini').
	[stream atEnd] whileFalse:
		[string := stream nextLine.
		(string subStrings size = 2) ifTrue: [
			courses 
				at: (string subStrings first) asUppercase asSymbol 
				put:(string subStrings second) asUppercase asSymbol]].
	stream close.! !
!HRApplication categoriesFor: #setCourses!public! !

!HRApplication methodsFor!
setOptions

	| stream string|
#deprecated.
	(File exists: (HRApplication current paramsPath, 'options.ini')) ifFalse: [self createOptionsIni].
	stream := FileStream read: (HRApplication current paramsPath, 'options.ini').
	[stream atEnd] whileFalse:
		[string := stream nextLine.
		(string subStrings size = 2) ifTrue: [
			courses 
				at: (string subStrings first) asUppercase asSymbol 
				put:(string subStrings second) asUppercase asSymbol]].
	stream close.! !
!HRApplication categoriesFor: #setOptions!public! !

!HRApplication methodsFor!
setRPNamePwd

	HRRPLogonDialog showModalOn: self! !
!HRApplication categoriesFor: #setRPNamePwd!public! !

!HRApplication methodsFor!
targetStake
	^self readTagForTargetStake! !
!HRApplication categoriesFor: #targetStake!public! !

!HRApplication methodsFor!
wantLoadEarlyLiveData

	^self readTagForEarlyLiveData at: 1.! !
!HRApplication categoriesFor: #wantLoadEarlyLiveData!public! !

!HRApplication methodsFor!
wantLoadEarlyLiveDataWithEsts

	| array |
	array := self readTagForEarlyLiveData.
	^(array at: 1) and: [array at: 2]
! !
!HRApplication categoriesFor: #wantLoadEarlyLiveDataWithEsts!public! !

!HRApplication methodsFor!
wantPreMeetingCSV

	^self readTagForPreMeetingCSV at: 1! !
!HRApplication categoriesFor: #wantPreMeetingCSV!public! !

!HRApplication methodsFor!
wantPreMeetingCSVWithEsts

	| array |
	array := self readTagForPreMeetingCSV.
	^(array at: 1) and: [array at: 2]! !
!HRApplication categoriesFor: #wantPreMeetingCSVWithEsts!public! !

!HRApplication categoriesFor: #addEarlyLiveDataOption!public! !

!HRApplication categoriesFor: #addGenerateEstsOption!public! !

!HRApplication categoriesFor: #addLoggingOption!public! !

!HRApplication categoriesFor: #addMeeting:!accessing!private! !

!HRApplication categoriesFor: #addPreMeetingCSVOption!public! !

!HRApplication categoriesFor: #addProxyOption!public! !

!HRApplication categoriesFor: #addRaceEditOptions!public! !

!HRApplication categoriesFor: #addRestoredMeeting:!accessing!private! !

!HRApplication categoriesFor: #addRPProxyOption!public! !

!HRApplication categoriesFor: #addTargetStakeOption!public! !

!HRApplication categoriesFor: #bfAbbrFor:!public! !

!HRApplication categoriesFor: #checkProxySettings!public! !

!HRApplication categoriesFor: #courseNameAt:!public! !

!HRApplication categoriesFor: #courseNames!public! !

!HRApplication categoriesFor: #courses!public! !

!HRApplication categoriesFor: #createCoursesIni!public! !

!HRApplication categoriesFor: #createOptionsIni!public! !

!HRApplication categoriesFor: #createScheduleItemFor:!public! !

!HRApplication categoriesFor: #createScheduleItemFor:runDate:time:!public! !

!HRApplication categoriesFor: #createScheduleItemFor:time:!public! !

!HRApplication categoriesFor: #dataPath!public! !

!HRApplication categoriesFor: #detailLogging!public! !

!HRApplication categoriesFor: #fileInAll!public! !

!HRApplication categoriesFor: #fileInPrompt!public! !

!HRApplication categoriesFor: #findMeetingsFor:!accessing!public! !

!HRApplication categoriesFor: #findPreMeetingNRs!accessing!public! !

!HRApplication categoriesFor: #firstRaceTime!public! !

!HRApplication categoriesFor: #fullUnlock!accessing!private! !

!HRApplication categoriesFor: #fullUnlock:!accessing!private! !

!HRApplication categoriesFor: #generateEsts!accessing!private! !

!HRApplication categoriesFor: #initialize!public! !

!HRApplication categoriesFor: #isLoggedOnToRP!public! !

!HRApplication categoriesFor: #loadEarlyLiveData!public! !

!HRApplication categoriesFor: #logonToRP!public! !

!HRApplication categoriesFor: #logPath!public! !

!HRApplication categoriesFor: #meetingAt:!public! !

!HRApplication categoriesFor: #meetings!accessing!public! !

!HRApplication categoriesFor: #meetingsFor:!accessing!public! !

!HRApplication categoriesFor: #meetingsForToday!accessing!public! !

!HRApplication categoriesFor: #meetingsForYesterday!accessing!public! !

!HRApplication categoriesFor: #multipleFileInPrompt!public! !

!HRApplication categoriesFor: #outputAllAsCsv!custCsv!public! !

!HRApplication categoriesFor: #outputAndMailTodayAsCsv!custCsv!public! !

!HRApplication categoriesFor: #outputPath!public! !

!HRApplication categoriesFor: #outputTodayAsCsv!custCsv!public! !

!HRApplication categoriesFor: #pagesPath!public! !

!HRApplication categoriesFor: #paramsPath!public! !

!HRApplication categoriesFor: #proxySettings!public! !

!HRApplication categoriesFor: #proxySettings:!public! !

!HRApplication categoriesFor: #readTagForEarlyLiveData!public! !

!HRApplication categoriesFor: #readTagForGenerateEsts!public! !

!HRApplication categoriesFor: #readTagForLogging!public! !

!HRApplication categoriesFor: #readTagForPreMeetingCSV!public! !

!HRApplication categoriesFor: #readTagForProxySettings!public! !

!HRApplication categoriesFor: #readTagForRaceEdit!public! !

!HRApplication categoriesFor: #readTagForRPProxySettings!public! !

!HRApplication categoriesFor: #readTagForTargetStake!public! !

!HRApplication categoriesFor: #rememberSort!accessing!private! !

!HRApplication categoriesFor: #removeAllMeetings!accessing!public! !

!HRApplication categoriesFor: #removeMeeting:!accessing!public! !

!HRApplication categoriesFor: #reorganiseMeetings!accessing!public! !

!HRApplication categoriesFor: #rpCookieJar!public! !

!HRApplication categoriesFor: #rpPassword!public! !

!HRApplication categoriesFor: #rpPassword:!public! !

!HRApplication categoriesFor: #rpProxySettings!public! !

!HRApplication categoriesFor: #rpProxySettings:!public! !

!HRApplication categoriesFor: #rpUsername!public! !

!HRApplication categoriesFor: #rpUsername:!public! !

!HRApplication categoriesFor: #save:asCsvFileWith:!custCsv!public! !

!HRApplication categoriesFor: #scheduleCopyPreviewValues!public! !

!HRApplication categoriesFor: #scheduleCopyPreviewValuesFor:!public! !

!HRApplication categoriesFor: #scheduledFindMeetingsFor:!accessing!public! !

!HRApplication categoriesFor: #scheduledFindTodaysMeetings!accessing!public! !

!HRApplication categoriesFor: #scheduleFindBetfairRaceIDs!public! !

!HRApplication categoriesFor: #scheduleFindBetfairRaceIDsFor:!public! !

!HRApplication categoriesFor: #scheduleLoadEarlyLiveData!public! !

!HRApplication categoriesFor: #scheduleOutputTodayCsv!public! !

!HRApplication categoriesFor: #setBetfairRaceIDs!accessing!public! !

!HRApplication categoriesFor: #setBetfairRaceIDsFor:!accessing!public! !

!HRApplication categoriesFor: #setCourses!public! !

!HRApplication categoriesFor: #setOptions!public! !

!HRApplication categoriesFor: #setRPNamePwd!public! !

!HRApplication categoriesFor: #targetStake!public! !

!HRApplication categoriesFor: #wantLoadEarlyLiveData!accessing!private! !

!HRApplication categoriesFor: #wantLoadEarlyLiveDataWithEsts!accessing!private! !

!HRApplication categoriesFor: #wantPreMeetingCSV!accessing!private! !

!HRApplication categoriesFor: #wantPreMeetingCSVWithEsts!accessing!private! !

!HRApplication class methodsFor!
current

	current ifNil: [current := self new].
	^current! !
!HRApplication class categoriesFor: #current!public! !

!HRApplication class methodsFor!
removeSingleton

	current beFinalizable; finalize.
	current := nil! !
!HRApplication class categoriesFor: #removeSingleton!public! !

!HRApplication class categoriesFor: #current!public! !

!HRApplication class categoriesFor: #removeSingleton!public! !

HRLogger guid: (GUID fromString: '{F73A4A29-58AB-4612-9313-CD4657DAB10B}')!

HRLogger guid: (GUID fromString: '{F73A4A29-58AB-4612-9313-CD4657DAB10B}')!
HRLogger comment: ''!

HRLogger comment:
''!
!HRLogger categoriesForClass!MVP-Models! !
!HRLogger methodsFor!
contents

	^self stream contents! !
!HRLogger categoriesFor: #contents!public! !

!HRLogger methodsFor!
cr
	stream cr.! !
!HRLogger categoriesFor: #cr!public! !

!HRLogger methodsFor!
createScheduleItemFor: aDate

	| item |
	item := HRScheduleItem new 
		date: aDate; 
		time: (Time fromString: '23:50');
		object: self;
		process: #scheduledFileOutLogFor:;
		params: (Array with: aDate).
	HRScheduler current addScheduleItem: item.
! !
!HRLogger categoriesFor: #createScheduleItemFor:!public! !

!HRLogger methodsFor!
initialize

	super initialize.
	stream := String writeStream.! !
!HRLogger categoriesFor: #initialize!public! !

!HRLogger methodsFor!
scheduledFileOutLogFor: aDate

	| file |
	[file := FileStream write: (HRApplication current logPath, (aDate displayUsingFormat: 'dd-MM-yy'), '.log').
	file nextPutAll: self contents.
	file flush] ensure: [file close].
	stream := String writeStream.
	self trigger: #changed.
	self createScheduleItemFor: (Date today addDays: 1).
	HRLogger current showFull: 
		(Time now displayString, ' Written log for: ', (aDate displayUsingFormat: 'dd-MM-yy'), String lineDelimiter).
! !
!HRLogger categoriesFor: #scheduledFileOutLogFor:!public! !

!HRLogger methodsFor!
show: aString
#deprecated.
	HRApplication current detailLogging ifTrue: [
		stream nextPutAll: aString.
		self trigger: #changed.
		].! !
!HRLogger categoriesFor: #show:!public! !

!HRLogger methodsFor!
showAlways: aString
	stream nextPutAll: aString.
	self trigger: #changed.
! !
!HRLogger categoriesFor: #showAlways:!public! !

!HRLogger methodsFor!
showError: aString
	stream nextPutAll: aString.
	self trigger: #changed.
! !
!HRLogger categoriesFor: #showError:!public! !

!HRLogger methodsFor!
showFull: aString
	HRApplication current detailLogging ifTrue: [
		stream nextPutAll: aString.
		self trigger: #changed.
		].! !
!HRLogger categoriesFor: #showFull:!public! !

!HRLogger methodsFor!
stream

	^stream! !
!HRLogger categoriesFor: #stream!public! !

!HRLogger categoriesFor: #contents!public! !

!HRLogger categoriesFor: #cr!public! !

!HRLogger categoriesFor: #createScheduleItemFor:!public! !

!HRLogger categoriesFor: #initialize!public! !

!HRLogger categoriesFor: #scheduledFileOutLogFor:!public! !

!HRLogger categoriesFor: #show:!public! !

!HRLogger categoriesFor: #showAlways:!public! !

!HRLogger categoriesFor: #showError:!public! !

!HRLogger categoriesFor: #showFull:!public! !

!HRLogger categoriesFor: #stream!public! !

!HRLogger class methodsFor!
current

	current ifNil: [current := self new].
	^current! !
!HRLogger class categoriesFor: #current!public! !

!HRLogger class methodsFor!
removeSingleton

	current := nil! !
!HRLogger class categoriesFor: #removeSingleton!public! !

!HRLogger class categoriesFor: #current!public! !

!HRLogger class categoriesFor: #removeSingleton!public! !

HRMeetingAbs guid: (GUID fromString: '{3C27030F-7097-4130-8D55-B98741FADA14}')!

HRMeetingAbs guid: (GUID fromString: '{3C27030F-7097-4130-8D55-B98741FADA14}')!
HRMeetingAbs comment: ''!

HRMeetingAbs comment:
''!
!HRMeetingAbs categoriesForClass!MVP-Models! !
!HRMeetingAbs methodsFor!
allRacesAndNagsAsCsvString
	| result |
	result := String writeStream.
	result 
		nextPutAll: self asCsvString;
		nextPutAll: String lineDelimiter.
	self races do: [ :race |
		result 
			nextPutAll: race asCsvString;
			nextPutAll: String lineDelimiter;
			nextPutAll: race nagsCsvStringHeader;
			nextPutAll: String lineDelimiter;
			nextPutAll: race unnamedFavAsCsvString;
			nextPutAll: String lineDelimiter.
		race nags do: [ :nag | 
			result nextPutAll: nag asCsvString;
				nextPutAll: String lineDelimiter].
		result nextPutAll: String lineDelimiter.
		race leg = 6 ifTrue: [result nextPutAll: race finalPPBFAsCsvString; nextPutAll: String lineDelimiter].
		].
	^result contents! !
!HRMeetingAbs categoriesFor: #allRacesAndNagsAsCsvString!public! !

!HRMeetingAbs methodsFor!
allRacesAndNagsAsCsvStringWith: anArray
	| result |
#deprecated.
	result := String writeStream.
	result 
		nextPutAll: (self class asCsvStringWith: anArray);
		nextPutAll: String lineDelimiter.
	self races do: [ :race |
		race nags do: [ :nag |
			result
				nextPutAll: (nag asCsvStringWith: anArray);
				nextPutAll: String lineDelimiter]].
	^result contents! !
!HRMeetingAbs categoriesFor: #allRacesAndNagsAsCsvStringWith:!public! !

!HRMeetingAbs methodsFor!
allRacesAndNagsCsvWith: anArray
	| result |

	result := String writeStream.
	self races do: [ :race |
		race nags do: [ :nag |
			result
				nextPutAll: (nag asCsvStringWith: anArray);
				nextPutAll: String lineDelimiter]].
	^result contents! !
!HRMeetingAbs categoriesFor: #allRacesAndNagsCsvWith:!public! !

!HRMeetingAbs methodsFor!
allRacesAndNagsCsvWith: anArray decorators: anOC

	| decorator nextOC |
	nextOC := anOC copy.
	nextOC isEmpty ifTrue: [ ^self allRacesAndNagsCsvWith: anArray ].
	decorator := (nextOC removeFirst) predecessor: self.
	decorator setAll.
	^decorator allRacesAndNagsCsvWith: anArray decorators: nextOC.
	! !
!HRMeetingAbs categoriesFor: #allRacesAndNagsCsvWith:decorators:!public! !

!HRMeetingAbs methodsFor!
allRacesAndNagsCsvWithDecorators: anOC

	| decorator nextOC |
	nextOC := anOC copy.
	nextOC isEmpty ifTrue: [ ^self allRacesAndNagsCsv ].
	decorator := (nextOC removeFirst) predecessor: self.
	decorator setAll.
	^decorator allRacesAndNagsCsvWithDecorators: nextOC.
	! !
!HRMeetingAbs categoriesFor: #allRacesAndNagsCsvWithDecorators:!public! !

!HRMeetingAbs methodsFor!
canHaveDashboard

		^true! !
!HRMeetingAbs categoriesFor: #canHaveDashboard!public! !

!HRMeetingAbs methodsFor!
csvStringHeaderWith: anArray

	| result |
	result := String writeStream.
	anArray do: [ :each | result nextPutAll: (self vocabDictionaryAt: each); nextPut: $, ].
	^result contents
! !
!HRMeetingAbs categoriesFor: #csvStringHeaderWith:!public! !

!HRMeetingAbs methodsFor!
csvStringHeaderWith: anArray decorators: anOC

	| decorator nextOC |
	nextOC := anOC copy.
	nextOC isEmpty ifTrue: [ ^self csvStringHeaderWith: anArray ].
	decorator := (nextOC removeFirst) predecessor: self.
	decorator setAll.
	^decorator csvStringHeaderWith: anArray decorators: nextOC.
	! !
!HRMeetingAbs categoriesFor: #csvStringHeaderWith:decorators:!public! !

!HRMeetingAbs methodsFor!
ppRaces

	self races size > 6 ifTrue: [ ^self races first: 6 ].
	^self races! !
!HRMeetingAbs categoriesFor: #ppRaces!public! !

!HRMeetingAbs methodsFor!
saveAndMailMeetingCsvWithDecorators: anOC

"	HRMailer current mailMeetingCsv: (self saveAsMeetingCsvWithDecorators: nextOC).
"
	^self saveAsMeetingCsvWithDecorators: anOC.
	! !
!HRMeetingAbs categoriesFor: #saveAndMailMeetingCsvWithDecorators:!public! !

!HRMeetingAbs methodsFor!
saveAsCsvFileWith: anArray decorators: anOC

	| file fileName |
	fileName := (HRApplication current outputPath, self course, '-', self shortDate, '-Cust.csv').
	file := FileStream write: fileName.
	file nextPutAll: (self csvStringHeaderWith: anArray decorators: anOC), String lineDelimiter.
	file nextPutAll: (self allRacesAndNagsCsvWith: anArray decorators: anOC).
	file flush; close.
	HRLogger current showAlways: 
		(Time now displayString, ' Created CSV file for: ', self course, String lineDelimiter).
	^fileName
! !
!HRMeetingAbs categoriesFor: #saveAsCsvFileWith:decorators:!public! !

!HRMeetingAbs methodsFor!
saveAsMeetingCsv

	| file fileName |
	fileName := (HRApplication current outputPath, self course, '-', self shortDate, '.csv').
	file := FileStream write: fileName.
	file nextPutAll: self allRacesAndNagsAsCsvString.
	file flush; close.
	HRLogger current showAlways: 
		(Time now displayString, ' Created Meeting CSV for: ', self course, String lineDelimiter).
	^fileName
! !
!HRMeetingAbs categoriesFor: #saveAsMeetingCsv!public! !

!HRMeetingAbs methodsFor!
saveAsMeetingCsvWithDecorators: anOC

"	| decorator nextOC |
	nextOC := anOC copy.
	nextOC isEmpty ifTrue: [ ^self saveAsMeetingCsv ].
	decorator := (nextOC removeFirst) predecessor: self.
	decorator setAll.
	^decorator saveAsMeetingCsvWithDecorators: nextOC.
"
	^(self withDecorators: anOC)	 saveAsMeetingCsv! !
!HRMeetingAbs categoriesFor: #saveAsMeetingCsvWithDecorators:!public! !

!HRMeetingAbs methodsFor!
vocabDictionary
	^self class vocabDictionary! !
!HRMeetingAbs categoriesFor: #vocabDictionary!public! !

!HRMeetingAbs methodsFor!
vocabDictionaryAt: aKey

	^self class vocabDictionaryAt: aKey.
! !
!HRMeetingAbs categoriesFor: #vocabDictionaryAt:!public! !

!HRMeetingAbs methodsFor!
withDecorators: anOC

	| decorator nextOC |
	nextOC := anOC copy.
	nextOC isEmpty ifTrue: [ ^self ].
	decorator := (nextOC removeFirst) predecessor: self.
	decorator setAll.
	^decorator withDecorators: nextOC.
	! !
!HRMeetingAbs categoriesFor: #withDecorators:!public! !

!HRMeetingAbs categoriesFor: #allRacesAndNagsAsCsvString!meetingCsv!public! !

!HRMeetingAbs categoriesFor: #allRacesAndNagsAsCsvStringWith:!public! !

!HRMeetingAbs categoriesFor: #allRacesAndNagsCsvWith:!public! !

!HRMeetingAbs categoriesFor: #allRacesAndNagsCsvWith:decorators:!custCsv!public! !

!HRMeetingAbs categoriesFor: #allRacesAndNagsCsvWithDecorators:!meetingCsv!public! !

!HRMeetingAbs categoriesFor: #canHaveDashboard!public! !

!HRMeetingAbs categoriesFor: #csvStringHeaderWith:!public! !

!HRMeetingAbs categoriesFor: #csvStringHeaderWith:decorators:!meetingCsv!public! !

!HRMeetingAbs categoriesFor: #ppRaces!public! !

!HRMeetingAbs categoriesFor: #saveAndMailMeetingCsvWithDecorators:!meetingCsv!public! !

!HRMeetingAbs categoriesFor: #saveAsCsvFileWith:decorators:!custCsv!public! !

!HRMeetingAbs categoriesFor: #saveAsMeetingCsv!meetingCsv!public! !

!HRMeetingAbs categoriesFor: #saveAsMeetingCsvWithDecorators:!meetingCsv!public! !

!HRMeetingAbs categoriesFor: #vocabDictionary!public! !

!HRMeetingAbs categoriesFor: #vocabDictionaryAt:!public! !

!HRMeetingAbs categoriesFor: #withDecorators:!meetingCsv!public! !

!HRMeetingAbs class methodsFor!
vocabDictionary

	vocabDictionary ifNil: [self setVocabDictionary].
	^vocabDictionary! !
!HRMeetingAbs class categoriesFor: #vocabDictionary!public! !

!HRMeetingAbs class categoriesFor: #vocabDictionary!public! !

HRMtgDashboardModel guid: (GUID fromString: '{53053006-2FBE-406D-85DB-804185DDACBF}')!

HRMtgDashboardModel guid: (GUID fromString: '{53053006-2FBE-406D-85DB-804185DDACBF}')!
HRMtgDashboardModel comment: ''!

HRMtgDashboardModel comment:
''!
!HRMtgDashboardModel categoriesForClass!MVP-Models! !
!HRMtgDashboardModel methodsFor!
baseMeeting

	self meeting baseMeeting! !
!HRMtgDashboardModel categoriesFor: #baseMeeting!public! !

!HRMtgDashboardModel methodsFor!
collectRemainingLines

	remainingLinesCollection := self meeting collectRemainingLines! !
!HRMtgDashboardModel categoriesFor: #collectRemainingLines!public! !

!HRMtgDashboardModel methodsFor!
collectRemainingPot

	remainingPotCollection := self meeting collectRemainingPot! !
!HRMtgDashboardModel categoriesFor: #collectRemainingPot!public! !

!HRMtgDashboardModel methodsFor!
collectSlipLines

	slipLinesResult := self meeting collectSlipLines
! !
!HRMtgDashboardModel categoriesFor: #collectSlipLines!public! !

!HRMtgDashboardModel methodsFor!
createDashboardScheduleItemFor: aTime

	| item |
	item := (HRScheduleItem new)
		date: self meeting date;
		time: aTime;
		object: self;
		process: #refresh.
	HRScheduler current addScheduleItem: item.
	self scheduleItems add: item.
! !
!HRMtgDashboardModel categoriesFor: #createDashboardScheduleItemFor:!public! !

!HRMtgDashboardModel methodsFor!
createDashboardScheduleItems

	| times |
	self meeting races isEmpty ifTrue: [^nil].
	times := self meeting races 
		select: [ :each | each time > (Time now subtractTime: (Time fromSeconds: 1800)) ] 
		thenCollect: [ :each | each time ].
	times do: [ :time |
		self createDashboardScheduleItemFor: (time addTime: (Time fromSeconds: 360)).
		self createDashboardScheduleItemFor: (time addTime: (Time fromSeconds: 660)).
		self createDashboardScheduleItemFor: (time addTime: (Time fromSeconds: 960)).
		].! !
!HRMtgDashboardModel categoriesFor: #createDashboardScheduleItems!public! !

!HRMtgDashboardModel methodsFor!
cumOdds

	| accum cumOdds |
	self meeting races size < 6 ifTrue: [^0].
	accum := ((self meeting races first: 6) reject: [ :each | each hasResults ]) inject: 1 into: 
		[ :cum :race | cum * race myPlaceOdds ].
	accum isZero ifTrue: [cumOdds := 0] ifFalse: [cumOdds := ((1-accum)/accum) asFloat].
	^(cumOdds roundTo: 0.1) displayString, ' / ', (self meeting myPlaceOdds roundTo: 0.1) displayString.

	! !
!HRMtgDashboardModel categoriesFor: #cumOdds!public! !

!HRMtgDashboardModel methodsFor!
displayOn: aStream

	^self meeting displayOn: aStream! !
!HRMtgDashboardModel categoriesFor: #displayOn:!public! !

!HRMtgDashboardModel methodsFor!
divi

	^self meeting totePPDivi asScaledDecimal: 2! !
!HRMtgDashboardModel categoriesFor: #divi!public! !

!HRMtgDashboardModel methodsFor!
graphs

	^Array with: self remainingPot with: self remainingLines with: self meeting myLines! !
!HRMtgDashboardModel categoriesFor: #graphs!public! !

!HRMtgDashboardModel methodsFor!
meeting

	meeting ifNil: [meeting := HRMeeting new].
	^meeting! !
!HRMtgDashboardModel categoriesFor: #meeting!public! !

!HRMtgDashboardModel methodsFor!
meeting: anObject
	meeting := anObject! !
!HRMtgDashboardModel categoriesFor: #meeting:!public! !

!HRMtgDashboardModel methodsFor!
payOut

	^(self divi * self winningLines * self unitStake) asScaledDecimal: 2! !
!HRMtgDashboardModel categoriesFor: #payOut!public! !

!HRMtgDashboardModel methodsFor!
pot

	| pot result coll |
	result := String writeStream.
	pot := self meeting totePPPool + self meeting totePPBF.
	coll := self remainingPot.
	coll isEmpty 
		ifTrue: [result nextPutAll: pot displayString] 
		ifFalse: [result nextPutAll: (self meeting leg: coll last key) ppThrough displayString].
	result nextPutAll: ' / ', pot displayString.
	^result contents
	! !
!HRMtgDashboardModel categoriesFor: #pot!public! !

!HRMtgDashboardModel methodsFor!
profit

	^(self payOut - self totalStake) asScaledDecimal: 2! !
!HRMtgDashboardModel categoriesFor: #profit!public! !

!HRMtgDashboardModel methodsFor!
race
	^self meeting races first! !
!HRMtgDashboardModel categoriesFor: #race!public! !

!HRMtgDashboardModel methodsFor!
refresh

	self meeting findEarlyResult.
	self meeting findTotePPData.
	self meeting recalcPlaceValues.
	self meeting setTotePPDivi.
	self meeting setMyPlaceOdds.
	self collectRemainingLines.
	self collectRemainingPot.
	self collectSlipLines.
	self trigger: #allUpdated! !
!HRMtgDashboardModel categoriesFor: #refresh!public! !

!HRMtgDashboardModel methodsFor!
release

	self removeMyScheduleItems.
	meeting := remainingLinesCollection := remainingPotCollection := slipLinesResult := remainingOdds := scheduleItems := nil! !
!HRMtgDashboardModel categoriesFor: #release!public! !

!HRMtgDashboardModel methodsFor!
remainingLines

	remainingLinesCollection ifNil: [^OrderedCollection new].
	^remainingLinesCollection! !
!HRMtgDashboardModel categoriesFor: #remainingLines!public! !

!HRMtgDashboardModel methodsFor!
remainingPot

	remainingPotCollection ifNil: [^OrderedCollection new].
	^remainingPotCollection! !
!HRMtgDashboardModel categoriesFor: #remainingPot!public! !

!HRMtgDashboardModel methodsFor!
removeMyScheduleItems

	self scheduleItems do: [ :each | HRScheduler current removeScheduleItem: each ].
	self scheduleItems removeAll! !
!HRMtgDashboardModel categoriesFor: #removeMyScheduleItems!public! !

!HRMtgDashboardModel methodsFor!
rtfHeader

	^'{\rtf1\ansi\ansicpg1252\uc1\deff0\stshfdbch0\stshfloch0\stshfhich0\stshfbi0\deflang2057\deflangfe2057 {\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}}{\colortbl;\red0\green0\blue0;	\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}'
! !
!HRMtgDashboardModel categoriesFor: #rtfHeader!public! !

!HRMtgDashboardModel methodsFor!
scheduleItems

	scheduleItems ifNil: [scheduleItems := OrderedCollection new].
	^scheduleItems
! !
!HRMtgDashboardModel categoriesFor: #scheduleItems!public! !

!HRMtgDashboardModel methodsFor!
slipLinesResult

	slipLinesResult ifNil: [^OrderedCollection with: nil -> ''].
	^slipLinesResult! !
!HRMtgDashboardModel categoriesFor: #slipLinesResult!public! !

!HRMtgDashboardModel methodsFor!
slipLinesRTF

	| result |
	result := String writeStream.
	result nextPutAll: self rtfHeader.
	self slipLinesResult do: [ :each |
		each key isNil 
			ifTrue: [ each value isEmpty ifFalse: [ result nextPutAll: '{\f1\fs16 ';
					nextPutAll: each value, ' \par }']]
			ifFalse: [each key 
				ifTrue: [ result nextPutAll: '{\highlight4\f1\fs16 '
"insrsid4538108\charrsid4538108 '" ] 
				ifFalse: [ result nextPutAll: '{\highlight6\f1\fs16 '
"insrsid4538108\charrsid4538108 '" ].
			result nextPutAll: each value, ' \par }', String lineDelimiter].
		].
	result nextPut: $}.
	^RichText fromRtf: result contents! !
!HRMtgDashboardModel categoriesFor: #slipLinesRTF!public! !

!HRMtgDashboardModel methodsFor!
totalLines

	| lines result coll |
	result := String writeStream.
	lines := self meeting myLines.
	self remainingLines isEmpty 
		ifTrue: [result nextPutAll: lines displayString] 
		ifFalse: [result nextPutAll: self remainingLines last value displayString].
	result nextPutAll: ' / ', lines displayString.
	^result contents
	! !
!HRMtgDashboardModel categoriesFor: #totalLines!public! !

!HRMtgDashboardModel methodsFor!
totalStake

	^(self meeting myLines * self unitStake) asScaledDecimal: 2! !
!HRMtgDashboardModel categoriesFor: #totalStake!public! !

!HRMtgDashboardModel methodsFor!
unitStake

	^self meeting myStake asScaledDecimal: 2
! !
!HRMtgDashboardModel categoriesFor: #unitStake!public! !

!HRMtgDashboardModel methodsFor!
unitStake: aStake

	self meeting myStake: aStake.
	self trigger: #allUpdated
! !
!HRMtgDashboardModel categoriesFor: #unitStake:!public! !

!HRMtgDashboardModel methodsFor!
winningLines

	self remainingLines isEmpty 
		ifTrue: [^0].
	^self remainingLines last value.
! !
!HRMtgDashboardModel categoriesFor: #winningLines!public! !

!HRMtgDashboardModel categoriesFor: #baseMeeting!public! !

!HRMtgDashboardModel categoriesFor: #collectRemainingLines!public! !

!HRMtgDashboardModel categoriesFor: #collectRemainingPot!public! !

!HRMtgDashboardModel categoriesFor: #collectSlipLines!public! !

!HRMtgDashboardModel categoriesFor: #createDashboardScheduleItemFor:!public! !

!HRMtgDashboardModel categoriesFor: #createDashboardScheduleItems!public! !

!HRMtgDashboardModel categoriesFor: #cumOdds!public! !

!HRMtgDashboardModel categoriesFor: #displayOn:!public! !

!HRMtgDashboardModel categoriesFor: #divi!public! !

!HRMtgDashboardModel categoriesFor: #graphs!public! !

!HRMtgDashboardModel categoriesFor: #meeting!accessing!private! !

!HRMtgDashboardModel categoriesFor: #meeting:!accessing!private! !

!HRMtgDashboardModel categoriesFor: #payOut!public! !

!HRMtgDashboardModel categoriesFor: #pot!public! !

!HRMtgDashboardModel categoriesFor: #profit!public! !

!HRMtgDashboardModel categoriesFor: #race!public! !

!HRMtgDashboardModel categoriesFor: #refresh!public! !

!HRMtgDashboardModel categoriesFor: #release!public! !

!HRMtgDashboardModel categoriesFor: #remainingLines!public! !

!HRMtgDashboardModel categoriesFor: #remainingPot!public! !

!HRMtgDashboardModel categoriesFor: #removeMyScheduleItems!public! !

!HRMtgDashboardModel categoriesFor: #rtfHeader!public! !

!HRMtgDashboardModel categoriesFor: #scheduleItems!public! !

!HRMtgDashboardModel categoriesFor: #slipLinesResult!public! !

!HRMtgDashboardModel categoriesFor: #slipLinesRTF!public! !

!HRMtgDashboardModel categoriesFor: #totalLines!public! !

!HRMtgDashboardModel categoriesFor: #totalStake!public! !

!HRMtgDashboardModel categoriesFor: #unitStake!public! !

!HRMtgDashboardModel categoriesFor: #unitStake:!public! !

!HRMtgDashboardModel categoriesFor: #winningLines!public! !

!HRMtgDashboardModel class methodsFor!
on: aMeeting

	^(self new initialize) meeting: aMeeting! !
!HRMtgDashboardModel class categoriesFor: #on:!public! !

!HRMtgDashboardModel class categoriesFor: #on:!public! !

HRNagAbs guid: (GUID fromString: '{DCFC0B41-D606-4BDF-828D-1D6F10C2F6D9}')!

HRNagAbs guid: (GUID fromString: '{DCFC0B41-D606-4BDF-828D-1D6F10C2F6D9}')!
HRNagAbs comment: ''!

HRNagAbs comment:
''!
!HRNagAbs categoriesForClass!MVP-Models! !
!HRNagAbs methodsFor!
asCsvStringWith: anArray

	| result |
	result := String writeStream.
	anArray do: [ :each | 
		result nextPutAll: (self performVocabDictionaryKey: each) displayString; nextPut: $,].
	^result contents
! !
!HRNagAbs categoriesFor: #asCsvStringWith:!public! !

!HRNagAbs methodsFor!
baseNag

	^self predecessor baseNag! !
!HRNagAbs categoriesFor: #baseNag!public! !

!HRNagAbs methodsFor!
isPreRaceFav

	^self == self race preRaceFav! !
!HRNagAbs categoriesFor: #isPreRaceFav!public! !

!HRNagAbs methodsFor!
vocabDictionary
	^self class vocabDictionary! !
!HRNagAbs categoriesFor: #vocabDictionary!public! !

!HRNagAbs methodsFor!
vocabDictionaryAt: aKey

	^self class vocabDictionaryAt: aKey.
! !
!HRNagAbs categoriesFor: #vocabDictionaryAt:!public! !

!HRNagAbs categoriesFor: #asCsvStringWith:!public! !

!HRNagAbs categoriesFor: #baseNag!public! !

!HRNagAbs categoriesFor: #isPreRaceFav!public! !

!HRNagAbs categoriesFor: #vocabDictionary!public! !

!HRNagAbs categoriesFor: #vocabDictionaryAt:!public! !

!HRNagAbs class methodsFor!
vocabDictionary

	vocabDictionary ifNil: [self setVocabDictionary].
	^vocabDictionary! !
!HRNagAbs class categoriesFor: #vocabDictionary!public! !

!HRNagAbs class methodsFor!
vocabDictionaryAt: aKey

	^(self vocabDictionary) at: aKey ifAbsent: [ '' ]! !
!HRNagAbs class categoriesFor: #vocabDictionaryAt:!public! !

!HRNagAbs class categoriesFor: #vocabDictionary!public! !

!HRNagAbs class categoriesFor: #vocabDictionaryAt:!public! !

HRPPSlipModel guid: (GUID fromString: '{6E02E6CF-7CE8-46E2-8628-DE7E647ABED7}')!

HRPPSlipModel guid: (GUID fromString: '{6E02E6CF-7CE8-46E2-8628-DE7E647ABED7}')!
HRPPSlipModel comment: ''!

HRPPSlipModel comment:
''!
!HRPPSlipModel categoriesForClass!MVP-Models! !
!HRPPSlipModel methodsFor!
divi

	^self meeting totePPDivi asScaledDecimal: 2! !
!HRPPSlipModel categoriesFor: #divi!public! !

!HRPPSlipModel methodsFor!
leg1Picks

	^self picksForLeg: 1
! !
!HRPPSlipModel categoriesFor: #leg1Picks!public! !

!HRPPSlipModel methodsFor!
leg1Picks: aString

	^self setPicksForLeg: 1 from: aString
! !
!HRPPSlipModel categoriesFor: #leg1Picks:!public! !

!HRPPSlipModel methodsFor!
leg2Picks

	^self picksForLeg: 2
! !
!HRPPSlipModel categoriesFor: #leg2Picks!public! !

!HRPPSlipModel methodsFor!
leg2Picks: aString

	^self setPicksForLeg: 2 from: aString
! !
!HRPPSlipModel categoriesFor: #leg2Picks:!public! !

!HRPPSlipModel methodsFor!
leg3Picks

	^self picksForLeg: 3
! !
!HRPPSlipModel categoriesFor: #leg3Picks!public! !

!HRPPSlipModel methodsFor!
leg3Picks: aString

	^self setPicksForLeg: 3 from: aString
! !
!HRPPSlipModel categoriesFor: #leg3Picks:!public! !

!HRPPSlipModel methodsFor!
leg4Picks

	^self picksForLeg: 4
! !
!HRPPSlipModel categoriesFor: #leg4Picks!public! !

!HRPPSlipModel methodsFor!
leg4Picks: aString

	^self setPicksForLeg: 4 from: aString
! !
!HRPPSlipModel categoriesFor: #leg4Picks:!public! !

!HRPPSlipModel methodsFor!
leg5Picks

	^self picksForLeg: 5
! !
!HRPPSlipModel categoriesFor: #leg5Picks!public! !

!HRPPSlipModel methodsFor!
leg5Picks: aString

	^self setPicksForLeg: 5 from: aString
! !
!HRPPSlipModel categoriesFor: #leg5Picks:!public! !

!HRPPSlipModel methodsFor!
leg6Picks

	^self picksForLeg: 6
! !
!HRPPSlipModel categoriesFor: #leg6Picks!public! !

!HRPPSlipModel methodsFor!
leg6Picks: aString

	^self setPicksForLeg: 6 from: aString
! !
!HRPPSlipModel categoriesFor: #leg6Picks:!public! !

!HRPPSlipModel methodsFor!
lines

	^self meeting myLines! !
!HRPPSlipModel categoriesFor: #lines!public! !

!HRPPSlipModel methodsFor!
meeting

	meeting ifNil: [ meeting := HRMyMeeting on: HRMeeting new ].
	^meeting! !
!HRPPSlipModel categoriesFor: #meeting!public! !

!HRPPSlipModel methodsFor!
meeting: aMeeting

	meeting := aMeeting! !
!HRPPSlipModel categoriesFor: #meeting:!public! !

!HRPPSlipModel methodsFor!
payOut

	^(self divi * self winningLines * self unitStake) asScaledDecimal: 2! !
!HRPPSlipModel categoriesFor: #payOut!public! !

!HRPPSlipModel methodsFor!
picksForLeg: leg

	| result |
	result := ''.
	(self meeting leg: leg) myUnnamedFav ifTrue: [ result := result, 'F ' ].
	(self meeting leg: leg) myFavsExUnnamed do: [ :each | result := result, each racecardNo, ' ' ].
	^result

! !
!HRPPSlipModel categoriesFor: #picksForLeg:!public! !

!HRPPSlipModel methodsFor!
profit

	^(self payOut - self totalStake) asScaledDecimal: 2! !
!HRPPSlipModel categoriesFor: #profit!public! !

!HRPPSlipModel methodsFor!
setPicksForLeg: leg from: aString

	| myLeg |
	myLeg := self meeting leg: leg.
	myLeg resetMyFavs. 
	aString subStrings do: [ :each | | no | 
		[no := Number fromString: each] on: Error do: 
			[ :a | 
				(each sameAs: 'F') ifTrue: [myLeg myUnnamedFav: true]
					ifFalse: [MessageBox errorMsg: 'Only the letter ''F'' and numbers separated by spaces are allowed' ]]. 
		(myLeg nagNo: no) mySelect: true].
	myLeg ppValDirty: true.
	self trigger: #anyUpdate! !
!HRPPSlipModel categoriesFor: #setPicksForLeg:from:!public! !

!HRPPSlipModel methodsFor!
totalStake

	^(self lines * self unitStake) asScaledDecimal: 2! !
!HRPPSlipModel categoriesFor: #totalStake!public! !

!HRPPSlipModel methodsFor!
unitStake

	^self meeting myStake asScaledDecimal: 2
! !
!HRPPSlipModel categoriesFor: #unitStake!public! !

!HRPPSlipModel methodsFor!
unitStake: aStake

	self meeting myStake: aStake.
	self trigger: #anyUpdate
! !
!HRPPSlipModel categoriesFor: #unitStake:!public! !

!HRPPSlipModel methodsFor!
winningLines

	^self meeting findMyWinningLines! !
!HRPPSlipModel categoriesFor: #winningLines!public! !

!HRPPSlipModel categoriesFor: #divi!public! !

!HRPPSlipModel categoriesFor: #leg1Picks!public! !

!HRPPSlipModel categoriesFor: #leg1Picks:!public! !

!HRPPSlipModel categoriesFor: #leg2Picks!public! !

!HRPPSlipModel categoriesFor: #leg2Picks:!public! !

!HRPPSlipModel categoriesFor: #leg3Picks!public! !

!HRPPSlipModel categoriesFor: #leg3Picks:!public! !

!HRPPSlipModel categoriesFor: #leg4Picks!public! !

!HRPPSlipModel categoriesFor: #leg4Picks:!public! !

!HRPPSlipModel categoriesFor: #leg5Picks!public! !

!HRPPSlipModel categoriesFor: #leg5Picks:!public! !

!HRPPSlipModel categoriesFor: #leg6Picks!public! !

!HRPPSlipModel categoriesFor: #leg6Picks:!public! !

!HRPPSlipModel categoriesFor: #lines!public! !

!HRPPSlipModel categoriesFor: #meeting!public! !

!HRPPSlipModel categoriesFor: #meeting:!public! !

!HRPPSlipModel categoriesFor: #payOut!public! !

!HRPPSlipModel categoriesFor: #picksForLeg:!public! !

!HRPPSlipModel categoriesFor: #profit!public! !

!HRPPSlipModel categoriesFor: #setPicksForLeg:from:!public! !

!HRPPSlipModel categoriesFor: #totalStake!public! !

!HRPPSlipModel categoriesFor: #unitStake!public! !

!HRPPSlipModel categoriesFor: #unitStake:!public! !

!HRPPSlipModel categoriesFor: #winningLines!public! !

!HRPPSlipModel class methodsFor!
on: aMeeting

	^(self new initialize) meeting: (HRMyMeeting on: (HRMeetingPlaceCalc on: aMeeting))! !
!HRPPSlipModel class categoriesFor: #on:!public! !

!HRPPSlipModel class categoriesFor: #on:!public! !

HRRaceAbs guid: (GUID fromString: '{115E3614-7835-4460-8168-3738E4829258}')!

HRRaceAbs guid: (GUID fromString: '{115E3614-7835-4460-8168-3738E4829258}')!
HRRaceAbs comment: ''!

HRRaceAbs comment:
''!
!HRRaceAbs categoriesForClass!MVP-Models! !
!HRRaceAbs methodsFor!
baseMeeting

	^self meeting baseMeeting! !
!HRRaceAbs categoriesFor: #baseMeeting!public! !

!HRRaceAbs methodsFor!
canHaveDashboard

		^true! !
!HRRaceAbs categoriesFor: #canHaveDashboard!public! !

!HRRaceAbs methodsFor!
nagsClass

	^HRNag! !
!HRRaceAbs categoriesFor: #nagsClass!public! !

!HRRaceAbs methodsFor!
setPreRaceFav

	self preRaceFav: self bestOddsFav
! !
!HRRaceAbs categoriesFor: #setPreRaceFav!public! !

!HRRaceAbs methodsFor!
vocabDictionary

	^self class vocabDictionary! !
!HRRaceAbs categoriesFor: #vocabDictionary!public! !

!HRRaceAbs methodsFor!
vocabDictionaryAt: aKey

	^self class vocabDictionaryAt: aKey.
! !
!HRRaceAbs categoriesFor: #vocabDictionaryAt:!public! !

!HRRaceAbs categoriesFor: #baseMeeting!public! !

!HRRaceAbs categoriesFor: #canHaveDashboard!public! !

!HRRaceAbs categoriesFor: #nagsClass!public! !

!HRRaceAbs categoriesFor: #setPreRaceFav!public! !

!HRRaceAbs categoriesFor: #vocabDictionary!public! !

!HRRaceAbs categoriesFor: #vocabDictionaryAt:!public! !

!HRRaceAbs class methodsFor!
vocabDictionary

	vocabDictionary ifNil: [self setVocabDictionary].
	^vocabDictionary! !
!HRRaceAbs class categoriesFor: #vocabDictionary!public! !

!HRRaceAbs class categoriesFor: #vocabDictionary!public! !

HRScheduleItem guid: (GUID fromString: '{6DE67652-2512-45F8-B4D7-75DD26318746}')!

HRScheduleItem guid: (GUID fromString: '{6DE67652-2512-45F8-B4D7-75DD26318746}')!
HRScheduleItem comment: ''!

HRScheduleItem comment:
''!
!HRScheduleItem categoriesForClass!MVP-Models! !
!HRScheduleItem methodsFor!
< anotherItem
	^self dateAndTime < anotherItem dateAndTime! !
!HRScheduleItem categoriesFor: #<!public! !

!HRScheduleItem methodsFor!
<= anotherItem
	^self dateAndTime <= anotherItem dateAndTime! !
!HRScheduleItem categoriesFor: #<=!public! !

!HRScheduleItem methodsFor!
canEditRace

	^self object class canUnderstand: #race! !
!HRScheduleItem categoriesFor: #canEditRace!public! !

!HRScheduleItem methodsFor!
canFileOut

	^self object class canUnderstand: #saveAsCsvFile! !
!HRScheduleItem categoriesFor: #canFileOut!public! !

!HRScheduleItem methodsFor!
canHaveDashboard

	^self object canHaveDashboard! !
!HRScheduleItem categoriesFor: #canHaveDashboard!public! !

!HRScheduleItem methodsFor!
date
	date ifNil: [self date: Date today].
	^date! !
!HRScheduleItem categoriesFor: #date!public! !

!HRScheduleItem methodsFor!
date: anObject
	date := anObject.
! !
!HRScheduleItem categoriesFor: #date:!public! !

!HRScheduleItem methodsFor!
date: aDate time: aTime
	self date: aDate; time: aTime! !
!HRScheduleItem categoriesFor: #date:time:!public! !

!HRScheduleItem methodsFor!
dateAndTime
	^DateAndTime fromDate: self date time: self time! !
!HRScheduleItem categoriesFor: #dateAndTime!public! !

!HRScheduleItem methodsFor!
editRace

	self canEditRace ifFalse: [^nil].
	HRApplication current fullUnlock 
		ifTrue: [HRRacePresenter showOn: self object race.]
		ifFalse: [HRRacePresenter show: 'Limited view' on: self object race.]

! !
!HRScheduleItem categoriesFor: #editRace!public! !

!HRScheduleItem methodsFor!
execute

	self params isEmpty 
		ifTrue: [[ self object perform: self process ] forkAt: 3]
		ifFalse: [[ self object perform: self process withArguments: self params ] forkAt: 3].
	HRScheduler current removeScheduleItem: self.
! !
!HRScheduleItem categoriesFor: #execute!public! !

!HRScheduleItem methodsFor!
object
	^object! !
!HRScheduleItem categoriesFor: #object!public! !

!HRScheduleItem methodsFor!
object: anObject
	object := anObject! !
!HRScheduleItem categoriesFor: #object:!public! !

!HRScheduleItem methodsFor!
params
	params ifNil: [params := Array new].
	^params! !
!HRScheduleItem categoriesFor: #params!public! !

!HRScheduleItem methodsFor!
params: anObject
	params := anObject! !
!HRScheduleItem categoriesFor: #params:!public! !

!HRScheduleItem methodsFor!
printOn: aStream
	"Overwrite the standard printOn so that the name of the object is shown if the class has a 'name' instance variable"

	aStream 
		basicPrint: self.
		aStream nextPut: $(;
		nextPutAll: self dateAndTime displayString;
		nextPut: $)
! !
!HRScheduleItem categoriesFor: #printOn:!public! !

!HRScheduleItem methodsFor!
process
	^process! !
!HRScheduleItem categoriesFor: #process!public! !

!HRScheduleItem methodsFor!
process: anObject
	process := anObject! !
!HRScheduleItem categoriesFor: #process:!public! !

!HRScheduleItem methodsFor!
saveAsCsvFile

	self canFileOut ifTrue: [self object saveAsCsvFile]! !
!HRScheduleItem categoriesFor: #saveAsCsvFile!public! !

!HRScheduleItem methodsFor!
time
	time ifNil: [self time: Time now].
	^time! !
!HRScheduleItem categoriesFor: #time!public! !

!HRScheduleItem methodsFor!
time: anObject
	time := anObject.
! !
!HRScheduleItem categoriesFor: #time:!public! !

!HRScheduleItem categoriesFor: #<!public! !

!HRScheduleItem categoriesFor: #<=!public! !

!HRScheduleItem categoriesFor: #canEditRace!public! !

!HRScheduleItem categoriesFor: #canFileOut!public! !

!HRScheduleItem categoriesFor: #canHaveDashboard!public! !

!HRScheduleItem categoriesFor: #date!accessing!private! !

!HRScheduleItem categoriesFor: #date:!accessing!private! !

!HRScheduleItem categoriesFor: #date:time:!accessing!private! !

!HRScheduleItem categoriesFor: #dateAndTime!public! !

!HRScheduleItem categoriesFor: #editRace!public! !

!HRScheduleItem categoriesFor: #execute!public! !

!HRScheduleItem categoriesFor: #object!accessing!private! !

!HRScheduleItem categoriesFor: #object:!accessing!private! !

!HRScheduleItem categoriesFor: #params!accessing!private! !

!HRScheduleItem categoriesFor: #params:!accessing!private! !

!HRScheduleItem categoriesFor: #printOn:!displaying!public! !

!HRScheduleItem categoriesFor: #process!accessing!private! !

!HRScheduleItem categoriesFor: #process:!accessing!private! !

!HRScheduleItem categoriesFor: #saveAsCsvFile!public! !

!HRScheduleItem categoriesFor: #time!accessing!private! !

!HRScheduleItem categoriesFor: #time:!accessing!private! !

HRScheduler guid: (GUID fromString: '{BA8C92AE-9689-4C6C-962F-1D25CBCDB79F}')!

HRScheduler guid: (GUID fromString: '{BA8C92AE-9689-4C6C-962F-1D25CBCDB79F}')!
HRScheduler comment: ''!

HRScheduler comment:
''!
!HRScheduler categoriesForClass!MVP-Models! !
!HRScheduler methodsFor!
addScheduleItem: anItem
	
	self scheduleItems add: anItem.
	self trigger: #listChanged.! !
!HRScheduler categoriesFor: #addScheduleItem:!public! !

!HRScheduler methodsFor!
checkForDueItems

	| due now |
	now := DateAndTime now.
	due := self scheduleItems select: [ :each |
		each dateAndTime <= now ].
	due do: [ :item | self executeScheduleItem: item ]! !
!HRScheduler categoriesFor: #checkForDueItems!public! !

!HRScheduler methodsFor!
createReorganiseScheduleItemFor: aDate

	| item |
	item := HRScheduleItem new 
		date: aDate; 
		time: (Time fromString: '23:50');
		object: self;
		process: #reorganiseScheduleItems.
	self addScheduleItem: item.
! !
!HRScheduler categoriesFor: #createReorganiseScheduleItemFor:!public! !

!HRScheduler methodsFor!
date
	^date! !
!HRScheduler categoriesFor: #date!public! !

!HRScheduler methodsFor!
date: aDate

	aDate < Date today ifTrue: [^MessageBox errorMsg: 'The date has to be today or in the future'].
	date := aDate.
	self trigger: #dateChanged! !
!HRScheduler categoriesFor: #date:!public! !

!HRScheduler methodsFor!
executeScheduleItem: aScheduleItem

	aScheduleItem execute! !
!HRScheduler categoriesFor: #executeScheduleItem:!public! !

!HRScheduler methodsFor!
initialize

	super initialize.
	scheduleItems := SortedCollection new.
! !
!HRScheduler categoriesFor: #initialize!public! !

!HRScheduler methodsFor!
initializeScheduleItems

	HRApplication current createScheduleItemFor: Date today.
	HRLogger current createScheduleItemFor: Date today.
	self createReorganiseScheduleItemFor: Date today.
	self trigger: #redrawList.
! !
!HRScheduler categoriesFor: #initializeScheduleItems!public! !

!HRScheduler methodsFor!
initializeScheduleItemsFor: aDate

	HRApplication current createScheduleItemFor: aDate runDate: Date today time: Time now.
	HRLogger current createScheduleItemFor: aDate.
	self createReorganiseScheduleItemFor: aDate.
	self trigger: #redrawList.
! !
!HRScheduler categoriesFor: #initializeScheduleItemsFor:!public! !

!HRScheduler methodsFor!
isRunning

	^self class isRunning! !
!HRScheduler categoriesFor: #isRunning!public! !

!HRScheduler methodsFor!
logon

	HRApplication current setRPNamePwd! !
!HRScheduler categoriesFor: #logon!public! !

!HRScheduler methodsFor!
publishedAspects

	^(super publishedAspects)
		add: (Aspect sequenceableCollection: #scheduleItems);
		yourself! !
!HRScheduler categoriesFor: #publishedAspects!public! !

!HRScheduler methodsFor!
removeMeeting: aMeeting
	
	| coll |
	coll := self scheduleItems select: [ :each | 
		each canHaveDashboard and: 
			[each object meeting baseMeeting == aMeeting ]].
	coll do: [ :item | self removeScheduleItem: item ].
! !
!HRScheduler categoriesFor: #removeMeeting:!public! !

!HRScheduler methodsFor!
removeScheduleItem: anItem
	
	self scheduleItems remove: anItem ifAbsent: [].
	self trigger: #listChanged.! !
!HRScheduler categoriesFor: #removeScheduleItem:!public! !

!HRScheduler methodsFor!
reorganiseScheduleItems

	| tmp |
	tmp := scheduleItems copy.
	scheduleItems do: [ :each | self removeScheduleItem: each ].
	tmp do: [ :each | self addScheduleItem: each ].
	self date: (Date today addDays: 1).
	self createReorganiseScheduleItemFor: self date.
	self trigger: #redrawList.
! !
!HRScheduler categoriesFor: #reorganiseScheduleItems!public! !

!HRScheduler methodsFor!
requireLogon

	^HRApplication current isLoggedOnToRP not! !
!HRScheduler categoriesFor: #requireLogon!public! !

!HRScheduler methodsFor!
restart

	self stop.
	scheduleItems do: [ :each | self removeScheduleItem: each ].
	HRApplication current removeAllMeetings.
	HRLogger current showAlways: ('Application restart at: ', Time now displayString, ' for: ', self date displayString, String lineDelimiter).
	self trigger: #redrawList.
	self startFor: self date.
! !
!HRScheduler categoriesFor: #restart!public! !

!HRScheduler methodsFor!
restartFor: aDate

	self stop.
	scheduleItems do: [ :each | self removeScheduleItem: each ].
	HRApplication current removeAllMeetings.
	HRLogger current showAlways: ('Application restart at: ', Time now displayString, ' for: ', aDate displayString, String lineDelimiter).
	self trigger: #redrawList.
	self startFor: aDate.
! !
!HRScheduler categoriesFor: #restartFor:!public! !

!HRScheduler methodsFor!
scheduleItems
	^scheduleItems! !
!HRScheduler categoriesFor: #scheduleItems!public! !

!HRScheduler methodsFor!
start

	self requireLogon ifTrue: [ self logon ].
	self isRunning ifFalse: [self class start].
! !
!HRScheduler categoriesFor: #start!public! !

!HRScheduler methodsFor!
startFor: aDate

	self requireLogon ifTrue: [ self logon ].
	self isRunning ifFalse: [self class startFor: aDate].
! !
!HRScheduler categoriesFor: #startFor:!public! !

!HRScheduler methodsFor!
status

	^self class processStatus
! !
!HRScheduler categoriesFor: #status!public! !

!HRScheduler methodsFor!
stop

	self isRunning ifTrue: [ self class stop ]! !
!HRScheduler categoriesFor: #stop!public! !

!HRScheduler categoriesFor: #addScheduleItem:!accessing!private! !

!HRScheduler categoriesFor: #checkForDueItems!public! !

!HRScheduler categoriesFor: #createReorganiseScheduleItemFor:!public! !

!HRScheduler categoriesFor: #date!accessing!private! !

!HRScheduler categoriesFor: #date:!accessing!private! !

!HRScheduler categoriesFor: #executeScheduleItem:!public! !

!HRScheduler categoriesFor: #initialize!public! !

!HRScheduler categoriesFor: #initializeScheduleItems!public! !

!HRScheduler categoriesFor: #initializeScheduleItemsFor:!public! !

!HRScheduler categoriesFor: #isRunning!public! !

!HRScheduler categoriesFor: #logon!public! !

!HRScheduler categoriesFor: #publishedAspects!development!must strip!public! !

!HRScheduler categoriesFor: #removeMeeting:!accessing!private! !

!HRScheduler categoriesFor: #removeScheduleItem:!accessing!private! !

!HRScheduler categoriesFor: #reorganiseScheduleItems!public! !

!HRScheduler categoriesFor: #requireLogon!public! !

!HRScheduler categoriesFor: #restart!public! !

!HRScheduler categoriesFor: #restartFor:!public! !

!HRScheduler categoriesFor: #scheduleItems!accessing!private! !

!HRScheduler categoriesFor: #start!public! !

!HRScheduler categoriesFor: #startFor:!public! !

!HRScheduler categoriesFor: #status!public! !

!HRScheduler categoriesFor: #stop!public! !

!HRScheduler class methodsFor!
current

	current ifNil: [current := self new initialize].
	^current! !
!HRScheduler class categoriesFor: #current!public! !

!HRScheduler class methodsFor!
isRunning

	^process notNil! !
!HRScheduler class categoriesFor: #isRunning!public! !

!HRScheduler class methodsFor!
process

	^process! !
!HRScheduler class categoriesFor: #process!public! !

!HRScheduler class methodsFor!
processStatus

	process isNil 
		ifTrue: [^'stopped']
		ifFalse: [^'running']
! !
!HRScheduler class categoriesFor: #processStatus!public! !

!HRScheduler class methodsFor!
removeSingleton

	self stop.
	current := nil.! !
!HRScheduler class categoriesFor: #removeSingleton!public! !

!HRScheduler class methodsFor!
start

	self isRunning ifFalse: [
		self current scheduleItems isEmpty ifTrue: [self current initializeScheduleItems].
		process := [
			[self current checkForDueItems. 
			(Delay forSeconds: 60) wait.] 
			repeat ] 
			forkAt: 4.
		self current trigger: #statusChanged.
		]! !
!HRScheduler class categoriesFor: #start!public! !

!HRScheduler class methodsFor!
startFor: aDate

	self current scheduleItems isEmpty ifTrue: [self current initializeScheduleItemsFor: aDate].
	process := [
		[self current checkForDueItems. 
		(Delay forSeconds: 60) wait.] 
		repeat ] 
		forkAt: 4.
	self current trigger: #statusChanged.
! !
!HRScheduler class categoriesFor: #startFor:!public! !

!HRScheduler class methodsFor!
stop

	self isRunning ifTrue: [
		process terminate.
		process := nil.
		self current trigger: #statusChanged.
		].! !
!HRScheduler class categoriesFor: #stop!public! !

!HRScheduler class categoriesFor: #current!public! !

!HRScheduler class categoriesFor: #isRunning!public! !

!HRScheduler class categoriesFor: #process!public! !

!HRScheduler class categoriesFor: #processStatus!public! !

!HRScheduler class categoriesFor: #removeSingleton!public! !

!HRScheduler class categoriesFor: #start!public! !

!HRScheduler class categoriesFor: #startFor:!public! !

!HRScheduler class categoriesFor: #stop!public! !

HRSMSSlipModel guid: (GUID fromString: '{C5BB30A7-2EFC-43EC-8E36-616346ACD475}')!

HRSMSSlipModel guid: (GUID fromString: '{C5BB30A7-2EFC-43EC-8E36-616346ACD475}')!
HRSMSSlipModel comment: ''!

HRSMSSlipModel comment:
''!
!HRSMSSlipModel categoriesForClass!MVP-Models! !
!HRSMSSlipModel methodsFor!
addresses

	addresses ifNil: [self setAddresses].
	^addresses! !
!HRSMSSlipModel categoriesFor: #addresses!public! !

!HRSMSSlipModel methodsFor!
createMailIni
	| enabled stream |
	stream := FileStream write: HRApplication current paramsPath , 'mail.ini'.
	stream 
		nextPutAll: '
[PREVIEW]
Enabled=false
Description=
Sender=
Destination=
Newsgroups=

[RESULTS]
Enabled=false
Description=
Sender=
Destination=
Newsgroups=

[DATA]
Enabled=false
Description=
Sender=
Destination=
Newsgroups=

[TODAY]
Enabled=false
Description=
Sender=
Destination=
Newsgroups=

[SMS]
Enabled=false
Description=
Sender=
Destination=
Newsgroups=
'.
	stream
		flush;
		close! !
!HRSMSSlipModel categoriesFor: #createMailIni!public! !

!HRSMSSlipModel methodsFor!
file

	file ifNil: [file := ''].
	^file! !
!HRSMSSlipModel categoriesFor: #file!public! !

!HRSMSSlipModel methodsFor!
file: aFile

	file := aFile.! !
!HRSMSSlipModel categoriesFor: #file:!public! !

!HRSMSSlipModel methodsFor!
readTagFor: aString

	| result enabled stream |
	result := Dictionary new.
	(File exists: (HRApplication current paramsPath, 'mail.ini')) ifFalse: [self createMailIni].
	stream := FileStream read: (HRApplication current paramsPath, 'mail.ini').
	stream reset; skipToAll: aString. 
	stream atEnd ifTrue: 
		[stream close.
		self addToMailIni: aString.
		stream := FileStream read: (HRApplication current paramsPath, 'mail.ini').].
	stream reset; skipToAll: aString; skipToAll: 'Description='.
	result at: #mailDescription put: (stream upToAll: String lineDelimiter) trimBlanks.
	stream reset; skipToAll: aString; skipToAll: 'Sender='.
	result at: #mailSender put: (stream upToAll: String lineDelimiter) trimBlanks.
	stream reset; skipToAll: aString; skipToAll: 'Destination='.
	result at: #mailDestination put: (stream upToAll: String lineDelimiter) trimBlanks.
	stream reset; skipToAll: aString; skipToAll: 'Newsgroups='.
	result at: #mailNewsgroups put: (stream upToAll: String lineDelimiter) trimBlanks.
	stream reset; skipToAll: aString; skipToAll: 'Enabled='.
	enabled := (stream upToAll: String lineDelimiter) trimBlanks asSymbol.
	stream close.
	((enabled sameAs: 'true') and: 
		[(result at: #mailSender) notEmpty and: 
			[(result at: #mailDestination) notEmpty]]) 
				ifTrue: [result at: #mailEnabled put: true]
				ifFalse: [result at: #mailEnabled put: false].
	^result! !
!HRSMSSlipModel categoriesFor: #readTagFor:!public! !

!HRSMSSlipModel methodsFor!
setAddresses

	| tag string coll |
	tag := self readTagFor: '[SMS]'.
"	(tag at: #mailEnabled) ifFalse: [^nil]."
	string := tag at: #mailDestination.
	coll := string subStrings: $;.
	addresses := ListModel on: coll asOrderedCollection.! !
!HRSMSSlipModel categoriesFor: #setAddresses!public! !

!HRSMSSlipModel methodsFor!
setAll

	self setAddresses;
		setText! !
!HRSMSSlipModel categoriesFor: #setAll!public! !

!HRSMSSlipModel methodsFor!
setText

	| stream |
	stream := FileStream read: file.
	[text := stream upToEnd] ensure: [stream close].
! !
!HRSMSSlipModel categoriesFor: #setText!public! !

!HRSMSSlipModel methodsFor!
text

	text ifNil: [self setText].
	^text! !
!HRSMSSlipModel categoriesFor: #text!public! !

!HRSMSSlipModel methodsFor!
text: aText

	text := aText.
	self writeTextToFile.! !
!HRSMSSlipModel categoriesFor: #text:!public! !

!HRSMSSlipModel methodsFor!
writeTextToFile

	| newFile |
	newFile := FileStream write: file.
	newFile nextPutAll: self text.
	newFile flush; close.
! !
!HRSMSSlipModel categoriesFor: #writeTextToFile!public! !

!HRSMSSlipModel categoriesFor: #addresses!public! !

!HRSMSSlipModel categoriesFor: #createMailIni!public! !

!HRSMSSlipModel categoriesFor: #file!public! !

!HRSMSSlipModel categoriesFor: #file:!public! !

!HRSMSSlipModel categoriesFor: #readTagFor:!public! !

!HRSMSSlipModel categoriesFor: #setAddresses!public! !

!HRSMSSlipModel categoriesFor: #setAll!public! !

!HRSMSSlipModel categoriesFor: #setText!public! !

!HRSMSSlipModel categoriesFor: #text!public! !

!HRSMSSlipModel categoriesFor: #text:!public! !

!HRSMSSlipModel categoriesFor: #writeTextToFile!public! !

!HRSMSSlipModel class methodsFor!
on: aFile

	^(super new) file: aFile; setAll! !
!HRSMSSlipModel class categoriesFor: #on:!public! !

!HRSMSSlipModel class categoriesFor: #on:!public! !

HRMeeting guid: (GUID fromString: '{457AB089-97FA-44EE-BEAD-401E4C34C3E8}')!

HRMeeting guid: (GUID fromString: '{457AB089-97FA-44EE-BEAD-401E4C34C3E8}')!
HRMeeting comment: ''!

HRMeeting comment:
''!
!HRMeeting categoriesForClass!MVP-Models! !
!HRMeeting methodsFor!
addRace: aRace
	aRace meeting: self.
"	aRace makePersistent."
	self races addLast: aRace.
	aRace leg: self races size.
"	aRace setBlokeSystemFavs"
"	self makePersistent."! !
!HRMeeting categoriesFor: #addRace:!public! !

!HRMeeting methodsFor!
asCsvString
	| result |
	result := String writeStream.
	result 
		nextPutAll: self shortDate;
		nextPut: $,;
		nextPutAll: self course;
		nextPutAll: ',Going:,';
		nextPutAll: self going;
		nextPutAll: ',Tote PP Pool:,';
		nextPutAll: self totePPPool printString;
		nextPutAll: ',Tote PP Divi:,';
		nextPutAll: self totePPDivi printString;
		nextPutAll: ',Complete:,';
		nextPutAll: self checkCompleteness printString;
		nextPutAll: String lineDelimiter;
		nextPutAll: 'Strategy,Lines,Stake,Result,Profit';
		nextPutAll: String lineDelimiter.
	^result contents
! !
!HRMeeting categoriesFor: #asCsvString!public! !

!HRMeeting methodsFor!
atSLShortTime: aSLTime

	^self races detect: [ :each | each slShortTime sameAs: aSLTime ] ifNone: [HRRace new].! !
!HRMeeting categoriesFor: #atSLShortTime:!public! !

!HRMeeting methodsFor!
baseMeeting

	^self! !
!HRMeeting categoriesFor: #baseMeeting!public! !

!HRMeeting methodsFor!
betfairEventName

	^self bfAbbr, ' ', self date displayBetfairFormat! !
!HRMeeting categoriesFor: #betfairEventName!public! !

!HRMeeting methodsFor!
bfAbbr

	(bfAbbr isNil or: [bfAbbr isEmpty]) ifTrue: [bfAbbr := HRApplication current bfAbbrFor: self course].
	^bfAbbr! !
!HRMeeting categoriesFor: #bfAbbr!public! !

!HRMeeting methodsFor!
bfAbbr: anAbbr

	bfAbbr := anAbbr! !
!HRMeeting categoriesFor: #bfAbbr:!public! !

!HRMeeting methodsFor!
checkCompleteness

	^self races allSatisfy: [ :each | each checkCompleteness ]! !
!HRMeeting categoriesFor: #checkCompleteness!public! !

!HRMeeting methodsFor!
collectRemainingLines

	^self ppRaces select: [ :each | each hasResults ] thenCollect: [ :each | each leg -> each myLinesRunning ]! !
!HRMeeting categoriesFor: #collectRemainingLines!public! !

!HRMeeting methodsFor!
collectRemainingPot

	^self ppRaces select: [ :each | each hasResults ] thenCollect: [ :each | each leg -> each ppThroughPerc ]! !
!HRMeeting categoriesFor: #collectRemainingPot!public! !

!HRMeeting methodsFor!
collectSlipLines

	self races size < 6 ifTrue: [^self races inject: OrderedCollection new into: [ :coll :each | coll addAllLast: each collectSlipLines; yourself ]].
	^(self races first: 6) inject: OrderedCollection new into: [ :coll :each | coll addAllLast: each collectSlipLines; yourself ].

! !
!HRMeeting categoriesFor: #collectSlipLines!public! !

!HRMeeting methodsFor!
copyPreviews

	self races do: [ :each | each copyPreviews ]! !
!HRMeeting categoriesFor: #copyPreviews!public! !

!HRMeeting methodsFor!
course
	course ifNil: [self course: ''].
	^course! !
!HRMeeting categoriesFor: #course!public! !

!HRMeeting methodsFor!
course: anObject
	course := anObject asUppercase! !
!HRMeeting categoriesFor: #course:!public! !

!HRMeeting methodsFor!
createCSVOutputScheduleItem

	| item time |
	self races isEmpty ifTrue: [^nil].
	time := races last time addTime: (Time fromString: '1:30').
	item := (HRScheduleItem new)
		date: self date;
		time: time;
		object: self;
		process: #mailResultsCsv.
	HRScheduler current addScheduleItem: item
! !
!HRMeeting categoriesFor: #createCSVOutputScheduleItem!public! !

!HRMeeting methodsFor!
createDataOutputScheduleItem

	| item time |
	self races isEmpty ifTrue: [^nil].
	time := races last time addTime: (Time fromString: '1:35').
	item := (HRScheduleItem new)
		date: self date;
		time: time;
		object: self;
		process: #mailDataFile.
	HRScheduler current addScheduleItem: item
! !
!HRMeeting categoriesFor: #createDataOutputScheduleItem!public! !

!HRMeeting methodsFor!
createPlacepotSlip

	| file fileName |
	fileName := (HRApplication current outputPath, self course, '-', self shortDate, '-slip.txt').
	file := FileStream write: fileName.
	file nextPutAll: self outputMyPPSelections.
	file flush; close.
	HRLogger current showAlways: 
		(Time now displayString, ' Created pp betting slip for: ', self course, String lineDelimiter).
	^fileName

! !
!HRMeeting categoriesFor: #createPlacepotSlip!public! !

!HRMeeting methodsFor!
createPlacepotSMS

	| file fileName |
	fileName := (HRApplication current outputPath, self course, '-', self shortDate, '-SMS.txt').
	file := FileStream write: fileName.
	file nextPutAll: self outputMyPPSelectionsAsSMS.
	file flush; close.
	HRLogger current showAlways: 
		(Time now displayString, ' Created pp SMS for: ', self course, String lineDelimiter).
	^fileName

! !
!HRMeeting categoriesFor: #createPlacepotSMS!public! !

!HRMeeting methodsFor!
createPPScheduleItemFor: aTime 
	| item |
	item := (HRScheduleItem new)
				date: self date;
				time: aTime;
				object: self;
				process: #findTotePPData.
	HRScheduler current addScheduleItem: item! !
!HRMeeting categoriesFor: #createPPScheduleItemFor:!public! !

!HRMeeting methodsFor!
createPPScheduleItems

	| time |
	self races isEmpty ifTrue: [^nil].
	time := self races first time.
	1 to: 24 do: [ :each |
		self createPPScheduleItemFor: (time addTime: (Time fromSeconds: 600 * (each - 1)))]! !
!HRMeeting categoriesFor: #createPPScheduleItems!public! !

!HRMeeting methodsFor!
createPreMeetingCSVOutputScheduleItem
	| item time |
	self races size < 6 ifTrue: [^nil].
	time := races first time subtractTime: (Time fromString: '0:15').
	item := (HRScheduleItem new)
		date: self date;
		time: time;
		object: self;
		process: #mailPreMeetingCsv.
	HRScheduler current addScheduleItem: item! !
!HRMeeting categoriesFor: #createPreMeetingCSVOutputScheduleItem!public! !

!HRMeeting methodsFor!
csvFile
	csvFile ifNil: [ '' ].
	^csvFile! !
!HRMeeting categoriesFor: #csvFile!public! !

!HRMeeting methodsFor!
csvFile: anObject
	csvFile := anObject! !
!HRMeeting categoriesFor: #csvFile:!public! !

!HRMeeting methodsFor!
date
	date ifNil: [self date: Date today].
	^date! !
!HRMeeting categoriesFor: #date!public! !

!HRMeeting methodsFor!
date: anObject
	date := anObject! !
!HRMeeting categoriesFor: #date:!public! !

!HRMeeting methodsFor!
dateString
	dateString ifNil: [self dateString: ''].
	^dateString! !
!HRMeeting categoriesFor: #dateString!public! !

!HRMeeting methodsFor!
dateString: aString
	dateString := aString.
	self setDate! !
!HRMeeting categoriesFor: #dateString:!public! !

!HRMeeting methodsFor!
defaultStake

	^self defaultStakeFor: self myLines! !
!HRMeeting categoriesFor: #defaultStake!public! !

!HRMeeting methodsFor!
defaultStakeFor: lines

	| stake target |
	target := HRApplication current targetStake.
	lines isZero ifTrue: [^0].
	stake := (target * 10 / lines) asInteger * 0.1.
	(stake * lines) > target ifTrue: [stake := stake - 0.1].
	^stake! !
!HRMeeting categoriesFor: #defaultStakeFor:!public! !

!HRMeeting methodsFor!
displayOn: aStream

	self course isEmpty ifFalse: [
		aStream nextPutAll: self shortDate;
		nextPutAll: ', ';
		display: self course
		].
! !
!HRMeeting categoriesFor: #displayOn:!public! !

!HRMeeting methodsFor!
findEarlyResult

	self findSLEarlyResult.
	self findToteEarlyResult.
! !
!HRMeeting categoriesFor: #findEarlyResult!public! !

!HRMeeting methodsFor!
findPreMeetingNRs
	| url import |
	url := 'http://www.sportinglife.com/racing/nonrunners.html'.
	(WinInetLibrary default ping: url) 
		ifTrue: 
			[import := HRImportSLPreMeetingNR onURL: url meeting: self.
HRLogger current showFull: ('Find pre-meeting non-runners', String lineDelimiter).
			import setPreMeetingNRsFor: self.
			]
		ifFalse: 
			[HRLogger current
				showError: ('Could not connect to ', url, String lineDelimiter)]! !
!HRMeeting categoriesFor: #findPreMeetingNRs!public! !

!HRMeeting methodsFor!
findSLEarlyResult
	| url slER race |
	url := 'http://www.sportinglife.com/racing/results/settlers.html'.
	HRLogger current 
		showAlways: Time now displayString , ' Collecting SportingLife early results for: ' , self course, String lineDelimiter.
	slER := HRImportSLEarlyResult onURL: url meeting: self.
	HRLogger current showFull: 'URL: ' , url, String lineDelimiter.
	slER setData! !
!HRMeeting categoriesFor: #findSLEarlyResult!public! !

!HRMeeting methodsFor!
findToteEarlyResult
	| toteER race |
	self toteERURL isEmpty ifTrue: [^nil].
	HRLogger current 
		showAlways: Time now displayString , ' Collecting Tote early results for: ' , self course, String lineDelimiter.
	toteER := HRImportToteEarlyResult onURL: self toteERURL meeting: self.
	HRLogger current showFull: 'URL: ' , self toteERURL , String lineDelimiter.
	toteER setData! !
!HRMeeting categoriesFor: #findToteEarlyResult!public! !

!HRMeeting methodsFor!
findTotePPData
	| totePP race |
	self totePPURL isEmpty ifTrue: [^nil].
	HRLogger current 
		showFull: Time now displayString , ' Collecting placepot data for: ' , self course 
				, String lineDelimiter.
	totePP := HRImportTotePPRace onURL: self totePPURL.
	HRLogger current showFull: 'URL: ' , self totePPURL , String lineDelimiter.
	totePP setData.
	self totePPPool: totePP poolTotal.
	self totePPCF: totePP poolBF.
	race := self races detect: [:each | each leg = totePP leg] ifNone: [nil].
	race isNil ifTrue: [^HRLogger current showError: 'No race found' , String lineDelimiter].
	race hasPPValues ifFalse: [
		HRLogger current showAlways: Time now displayString, ' Collecting placepot data for: ', self course, 
			' leg: ', totePP leg printString, String lineDelimiter.
		race setTotePPDataFrom: totePP.
		race ppValDirty: true
		]! !
!HRMeeting categoriesFor: #findTotePPData!public! !

!HRMeeting methodsFor!
generateEsts

#deprecated.
	^HRApplication current generateEsts
! !
!HRMeeting categoriesFor: #generateEsts!public! !

!HRMeeting methodsFor!
going
	going ifNil: [self going: ''].
	^going! !
!HRMeeting categoriesFor: #going!public! !

!HRMeeting methodsFor!
going: anObject
	going := anObject asUppercase.
	self trigger: #goingUpdated.! !
!HRMeeting categoriesFor: #going:!public! !

!HRMeeting methodsFor!
goingCode
	"lookup table, for now just strip commas"
	| result in |
	in := self going readStream.
	result := String writeStream.
	[ in atEnd ] whileFalse: [ result nextPutAll: (in upTo: $,)].
	^result contents
! !
!HRMeeting categoriesFor: #goingCode!public! !

!HRMeeting methodsFor!
goingStripComma
	"lookup table, for now just strip commas"
	| result in |
	in := self going readStream.
	result := String writeStream.
	[ in atEnd ] whileFalse: [ result nextPutAll: (in upTo: $,)].
	^result contents
! !
!HRMeeting categoriesFor: #goingStripComma!public! !

!HRMeeting methodsFor!
importPPEsts

	| file import |
	file := FileOpenDialog new
		caption: (self shortDate, ' - ', self course);
		fileTypes: #(('CSV files (*.CSV)' '*.csv*') ('All Files (*.*)' '*.*') );
		defaultExtension: 'csv';
		showModal.
	file notNil ifTrue: [
		import := HRImportPPEsts on: file meeting: self.
		import setAll.
		HRLogger current showAlways: 
			(Time now displayString, ' Imported estimates for: ', self course, ' from: ', file, String lineDelimiter).
	].

! !
!HRMeeting categoriesFor: #importPPEsts!public! !

!HRMeeting methodsFor!
lastPPRace

	^self leg: 6! !
!HRMeeting categoriesFor: #lastPPRace!public! !

!HRMeeting methodsFor!
leg: aLeg

	^self races detect: [ :each | each leg = aLeg ] ifNone: [HRRace new].! !
!HRMeeting categoriesFor: #leg:!public! !

!HRMeeting methodsFor!
loadEarlyLiveData

	self findPreMeetingNRs.
	self races do: [ :each | 
		each findBetfairOdds. 
		HRApplication current wantLoadEarlyLiveDataWithEsts ifTrue: [each setEsts]. 
		each lastUpdate: Time now].
! !
!HRMeeting categoriesFor: #loadEarlyLiveData!public! !

!HRMeeting methodsFor!
mailDataFile

	HRMailer mailDataFile: (self outputDataFile).
! !
!HRMeeting categoriesFor: #mailDataFile!public! !

!HRMeeting methodsFor!
mailPlacepotSMS

"	HRMailer mailPlacepotSMS: (self createPlacepotSMS)."
	HRSMSSlipPresenter showOn: (HRSMSSlipModel on: (self createPlacepotSMS))! !
!HRMeeting categoriesFor: #mailPlacepotSMS!public! !

!HRMeeting methodsFor!
mailPreMeetingCsv
	HRMailer mailPreviewFile: self outputPreMeetingCsv! !
!HRMeeting categoriesFor: #mailPreMeetingCsv!public! !

!HRMeeting methodsFor!
mailResultsCsv

	HRMailer mailResultsFile: (self saveAsCsvFile).
! !
!HRMeeting categoriesFor: #mailResultsCsv!public! !

!HRMeeting methodsFor!
meeting

	^self! !
!HRMeeting categoriesFor: #meeting!public! !

!HRMeeting methodsFor!
myLines

	^(self races first: (6 min: self races size)) inject: 1 into: [ :lines :each | lines * each myFavCount ]
! !
!HRMeeting categoriesFor: #myLines!public! !

!HRMeeting methodsFor!
myPlaceOdds

"	| accum |
	self races size < 6 ifTrue: [^0].
	accum := (self races first: 6) inject: 1 into: [ :cum :race | cum * race myPlaceOdds ].
	accum isZero ifTrue: [^0].
	^((1-accum)/accum) asFloat
"
	myPlaceOdds ifNil: [myPlaceOdds := 0].
	^myPlaceOdds! !
!HRMeeting categoriesFor: #myPlaceOdds!public! !

!HRMeeting methodsFor!
myPlaceOdds: aFloat

	myPlaceOdds := aFloat! !
!HRMeeting categoriesFor: #myPlaceOdds:!public! !

!HRMeeting methodsFor!
myPlaceOddsAsPercentage

	^self myPlaceOdds roundTo: 0.1! !
!HRMeeting categoriesFor: #myPlaceOddsAsPercentage!public! !

!HRMeeting methodsFor!
myPPSelectionHeader
	| result |
	result := String writeStream.
	result 
		nextPutAll: self shortDate;
		nextPutAll: ' - ';
		nextPutAll: self course;
		nextPutAll: String lineDelimiter;
		nextPutAll: 'Number of lines: ';
		nextPutAll: self myLines displayString;
		nextPutAll: ' - stake: ';
		nextPutAll: self myStake displayString.
	HRApplication current fullUnlock ifTrue: [
		result
			nextPutAll: ' - cumulative place odds: ';
			nextPutAll: self myPlaceOddsAsPercentage displayString].
	result
		nextPutAll: String lineDelimiter;
		nextPutAll: '=================================================================';
		nextPutAll: String lineDelimiter.
	^result contents
! !
!HRMeeting categoriesFor: #myPPSelectionHeader!public! !

!HRMeeting methodsFor!
myPPSMSFooter
	| result |
	result := String writeStream.
	result 
		nextPutAll: 'Lines: ';
		nextPutAll: self myLines displayString;
		nextPutAll: ' @ ';
		nextPutAll: self myStake displayString;
		nextPutAll: String lineDelimiter.
	^result contents
! !
!HRMeeting categoriesFor: #myPPSMSFooter!public! !

!HRMeeting methodsFor!
myPPSMSHeader
	| result |
	result := String writeStream.
	result 
		nextPutAll: self course;
		nextPut: $ ;
		nextPutAll: self shortDate;
		nextPutAll: String lineDelimiter;
		nextPutAll: 'Start: '.
	self startTime printOn: result format: 'h:mm'.
	result nextPutAll: String lineDelimiter.
	^result contents
! !
!HRMeeting categoriesFor: #myPPSMSHeader!public! !

!HRMeeting methodsFor!
myRemainingPlaceOdds

	| accum remaining |
	self races size < 6 ifTrue: [^0].
	remaining := (self races first: 6) select: [ :each | each hasResults not ].
	accum := remaining inject: 1 into: [ :cum :race | cum * race myPlaceOdds ].
	accum isZero ifTrue: [^0].
	^((1-accum)/accum) asFloat! !
!HRMeeting categoriesFor: #myRemainingPlaceOdds!public! !

!HRMeeting methodsFor!
myStake

	myStake ifNil: [ myStake := self defaultStake ].
	^myStake! !
!HRMeeting categoriesFor: #myStake!public! !

!HRMeeting methodsFor!
myStake: aFloat

	myStake := aFloat! !
!HRMeeting categoriesFor: #myStake:!public! !

!HRMeeting methodsFor!
noOfRaces
	^self races size! !
!HRMeeting categoriesFor: #noOfRaces!public! !

!HRMeeting methodsFor!
outputDataFile

	| file filename |
	filename := HRApplication current dataPath, self course, '-', self shortDate, '.dat'.
	self csvFile: (HRApplication current outputPath, self course, '-', self shortDate, '.csv').
	file := FileStream write: filename text: false.
	[self binaryStoreOn: file] ensure: [file close].
	self removeFromHRApp.
	HRLogger current showAlways: 
		(Time now displayString, ' Created Data file for: ', self course, String lineDelimiter).
	^filename

! !
!HRMeeting categoriesFor: #outputDataFile!public! !

!HRMeeting methodsFor!
outputMyPPSelections
	| result |
	self races size < 6 ifTrue: [^''].
	result := String writeStream.
	result 
		nextPutAll: self myPPSelectionHeader.
	(self races first: 6) do: [ :each | result nextPutAll: each outputMyPPSelections ].
	^result contents
! !
!HRMeeting categoriesFor: #outputMyPPSelections!public! !

!HRMeeting methodsFor!
outputMyPPSelectionsAsSMS
	| result |
	self races size < 6 ifTrue: [^''].
	result := String writeStream.
	result nextPutAll: self myPPSMSHeader.
	(self races first: 6) do: [ :each | result nextPutAll: each outputMyPPSelectionsForSMS ].
	result nextPutAll: self myPPSMSFooter.
	^result contents
! !
!HRMeeting categoriesFor: #outputMyPPSelectionsAsSMS!public! !

!HRMeeting methodsFor!
outputPreMeetingCsv

	self findPreMeetingNRs.
	self races do: [ :each | 
		each findBetfairOdds. 
		HRApplication current wantPreMeetingCSVWithEsts ifTrue: [each setEsts]. 
		each lastUpdate: Time now].
	^self saveAsCsvFile.! !
!HRMeeting categoriesFor: #outputPreMeetingCsv!public! !

!HRMeeting methodsFor!
performVocabDictionaryKey: aKey

	(self vocabDictionary includesKey: aKey) ifTrue: [^self perform: aKey].
	^''! !
!HRMeeting categoriesFor: #performVocabDictionaryKey:!public! !

!HRMeeting methodsFor!
printOn: aStream
	"Overwrite the standard printOn so that the name of the object is shown if the class has a 'name' instance variable"

	aStream 
		basicPrint: self.
	self course isEmpty ifFalse: [
		aStream nextPut: $(;
		display: self course;
		nextPutAll: ', ';
		nextPutAll: self shortDate;
		nextPut: $)
		].
! !
!HRMeeting categoriesFor: #printOn:!public! !

!HRMeeting methodsFor!
publishedAspects

	^(super publishedAspects)
		add: (Aspect string: #course);
		add: (Aspect date: #date);
		add: (Aspect string: #going);
		add: (Aspect sequenceableCollection: #races);
		add: (Aspect number: #totePPPool);
		add: (Aspect number: #totePPDivi);
		yourself! !
!HRMeeting categoriesFor: #publishedAspects!public! !

!HRMeeting methodsFor!
race
	^self races first! !
!HRMeeting categoriesFor: #race!public! !

!HRMeeting methodsFor!
raceAt: aTime

	^self races detect: [ :each | each time = aTime ] ifNone: [HRRace new]! !
!HRMeeting categoriesFor: #raceAt:!public! !

!HRMeeting methodsFor!
raceNo: anInteger 
	^races at: anInteger ifAbsent: []! !
!HRMeeting categoriesFor: #raceNo:!public! !

!HRMeeting methodsFor!
races
	races ifNil: [races := OrderedCollection new].
	^races! !
!HRMeeting categoriesFor: #races!public! !

!HRMeeting methodsFor!
removeFromHRApp

	HRApplication current removeMeeting: self.
	HRScheduler current removeMeeting: self.
	HRLogger current showAlways: 
		(Time now displayString, ' ', self course, ' removed from system', String lineDelimiter).
! !
!HRMeeting categoriesFor: #removeFromHRApp!public! !

!HRMeeting methodsFor!
saveAsCsvFile

"	self races do: [ :each | each calculatePlaceChance ]."
	self setTotePPDivi.
	^self saveAsMeetingCsvWithDecorators: self strategies! !
!HRMeeting categoriesFor: #saveAsCsvFile!public! !

!HRMeeting methodsFor!
saveAsCsvFileWith: anArray

	^self saveAsCsvFileWith: anArray decorators: self strategies! !
!HRMeeting categoriesFor: #saveAsCsvFileWith:!public! !

!HRMeeting methodsFor!
scheduleCopyPreviewValues

	| item |
	item := HRScheduleItem new 
		date: self date; 
		time: self startTime;
		object: self;
		process: #copyPreviews.
	HRScheduler current addScheduleItem: item.

! !
!HRMeeting categoriesFor: #scheduleCopyPreviewValues!public! !

!HRMeeting methodsFor!
scheduleLoadEarlyLiveData

	| item |
	HRApplication current wantLoadEarlyLiveData ifTrue: [
		item := HRScheduleItem new 
			date: Date today; 
			time: (Time now addTime: (Time fromSeconds: 720));
			object: self;
			process: #loadEarlyLiveData.
		HRScheduler current addScheduleItem: item.
		]! !
!HRMeeting categoriesFor: #scheduleLoadEarlyLiveData!public! !

!HRMeeting methodsFor!
scheduleTotePPURL

	| item |
#deprecated. "version 55"
	item := HRScheduleItem new 
		date: self date; 
		time: (self startTime subtractTime: (Time fromSeconds: 1800));
		object: self;
		process: #setTotePPURL.
	HRScheduler current addScheduleItem: item.
! !
!HRMeeting categoriesFor: #scheduleTotePPURL!public! !

!HRMeeting methodsFor!
scheduleToteURLID

	| item |
	item := HRScheduleItem new 
		date: self date; 
		time: (self startTime subtractTime: (Time fromSeconds: 1800));
		object: self;
		process: #setToteURLID.
	HRScheduler current addScheduleItem: item.
! !
!HRMeeting categoriesFor: #scheduleToteURLID!public! !

!HRMeeting methodsFor!
setBetfairRaceIDs

"	| url import |
	url := 'http://www.betfair.com/menu/LoadMenuNodesAction.do?sReturnPath=parent.frames[''menu'']&method=getMenuEvents&menuNodeId=13&strArrayName=allSkeletonArray&iParentID=13&layerName=allMarketsTreeContainer&strMenuPathArrayName=allPathArray&menuPathLayer=menuParents1&locale=en_GB'.
	(WinInetLibrary default ping: url) 
		ifTrue: 
			[import := HRImportBetfairDay onURL: url.
HRLogger current showFull: ('Find Betfair meeting IDs on: ', url, String lineDelimiter).
			import setAll]
		ifFalse: 
			[HRLogger current
				showError: ('Could not connect to ', url, String lineDelimiter)]
"
	| meetingNode meetingMenu |
"	find my menu node in the main BF menu	"
"	main BF menu return me my node	"
	meetingNode := HRImportBetfairMainMenu idForEvent: self betfairEventName.
"	find my own menu	"
"	get the meeting menu	"
	meetingMenu := HRImportBetfairMeetingMenu onID: meetingNode.
"	races do: each find my BF ID	"
	self races do: [ :each | each bfRaceID: (meetingMenu idForTime: each time)]

! !
!HRMeeting categoriesFor: #setBetfairRaceIDs!public! !

!HRMeeting methodsFor!
setBetfairRaceIDsSkip: anInteger

	| meetingNode meetingMenu |
"	find my menu node in the main BF menu	"
"	main BF menu return me my node	"
	meetingNode := HRImportBetfairMainMenu idForEvent: self betfairEventName skip: anInteger.
"	find my own menu	"
"	get the meeting menu	"
	meetingMenu := HRImportBetfairMeetingMenu onID: meetingNode.
"	races do: each find my BF ID	"
	self races do: [ :each | each bfRaceID: (meetingMenu idForTime: each time)]
! !
!HRMeeting categoriesFor: #setBetfairRaceIDsSkip:!public! !

!HRMeeting methodsFor!
setDate
	| array result day |
	self dateString notEmpty ifTrue: [
		array := self dateString subStrings.
		day := array at: 2.
		day := day first: (day size - 2).
		result := day, ' ', (array at: 3), ' ', (Date today year printString).
		self date: (Date fromString: result).
		].
! !
!HRMeeting categoriesFor: #setDate!public! !

!HRMeeting methodsFor!
setMyMeetingPlaceOdds

	| accum |
	self races size < 6 ifTrue: [^0].
	accum := (self races first: 6) inject: 1 into: [ :cum :race | cum * race myPlaceOdds ].
	accum isZero ifTrue: [^self myPlaceOdds: 0].
	self myPlaceOdds: (((1-accum)/accum) asFloat)

! !
!HRMeeting categoriesFor: #setMyMeetingPlaceOdds!public! !

!HRMeeting methodsFor!
setSlCourseName

	| result |
	result := ''.
	self course subStrings do: [ :each |
		each first isLetter ifTrue: [
			result := result, each asLowercase capitalized, '_'.
		]].
	(self course subStrings first soundsLike: 'epsom') ifTrue: [ result := result, 'Downs_' ].
	(self course subStrings first soundsLike: 'bangor') ifTrue: [ result := 'Bangor_' ].
	self slCourseName: (result leftString: (result size - 1))! !
!HRMeeting categoriesFor: #setSlCourseName!public! !

!HRMeeting methodsFor!
setToteERURL

	| url end |
#deprecated. "version 55"
	url := self totePPURL.
	url size < 65 ifTrue: [^toteERURL := ''].
	end := url last: 5.
	url size > 65 ifTrue: [ end := url last: 6 ].
	toteERURL := (url first: 52), 'result', end.! !
!HRMeeting categoriesFor: #setToteERURL!public! !

!HRMeeting methodsFor!
setTotePPDivi

	| finalLeg sum |
	finalLeg := self lastPPRace.
	finalLeg hasResults ifFalse: [^nil].
	sum := 0.
	finalLeg favPlaced ifTrue: [sum := finalLeg ppFav].
	finalLeg nags do: [ :nag | nag placed ifTrue: [sum := sum + nag ppValue]].
	sum >= 1 ifTrue: 
		[self totePPDivi: 
			((((self totePPPool*0.73*10/sum) truncated)/10) asFloat)].
	(sum > 0 and: [sum < 1]) ifTrue: 
		[self totePPDivi: 
			((((self totePPPool*0.73*10) truncated)/10) asFloat)].
"	sum >= 1 ifTrue: 
		[self totePPDivi: 
			(((((self totePPPool + self totePPCF)*0.73*10/sum) truncated)/10) asFloat)].
	(sum > 0 and: [sum < 1]) ifTrue: 
		[self totePPDivi: 
			(((((self totePPPool + self totePPCF)*0.73*10*sum) truncated)/10) asFloat)].
"! !
!HRMeeting categoriesFor: #setTotePPDivi!public! !

!HRMeeting methodsFor!
setTotePPURL
	| url import |
#deprecated. "version 55"
	url := 'http://club.totesport.com/totepoolLiveInfo/LiveData/meet.htm'.

	(WinInetLibrary default ping: url) 
		ifTrue: 
			[import := HRImportTotePPDay onURL: url.
HRLogger current showFull: ('Find pp URLs on: ', url, String lineDelimiter).
			import setMeetingURLs.
			self totePPURL: (import getMeetingURLFor: self course subStrings first).
			self setToteERURL.
			]
		ifFalse: 
			[HRLogger current
				showError: ('Could not connect to ', url, String lineDelimiter)]
! !
!HRMeeting categoriesFor: #setTotePPURL!public! !

!HRMeeting methodsFor!
setToteURLID
	| url import |
	url := 'http://club.totesport.com/totepoolliveinfo/LiveData/meet.htm'.

	(WinInetLibrary default ping: url) 
		ifTrue: 
			[import := HRImportTotePPDay onURL: url.
			HRLogger current showFull: ('Find Tote URL ID on: ', url, ' for: ', self course, String lineDelimiter).
			self toteURLID: (import getURLIDFor: self course subStrings first).
			self toteURLID isEmpty ifTrue: [^HRLogger current
				showError: ('Could not find a Tote ID for: ', self course, String lineDelimiter)].
			HRLogger current showAlways: ('Tote URL ID for: ', self course, ' is: ', self toteURLID, String lineDelimiter).
			]
		ifFalse: 
			[HRLogger current
				showError: ('Could not connect to ', url, String lineDelimiter)]
! !
!HRMeeting categoriesFor: #setToteURLID!public! !

!HRMeeting methodsFor!
shortDate

	| result |
	result := String writeStream.
	self date printOn: result format: 'dd-MM-yy'.
	^result contents! !
!HRMeeting categoriesFor: #shortDate!public! !

!HRMeeting methodsFor!
shortDateNoDash

	| result |
	result := String writeStream.
	self date printOn: result format: 'ddMMyy'.
	^result contents! !
!HRMeeting categoriesFor: #shortDateNoDash!public! !

!HRMeeting methodsFor!
slCourseName
	(slCourseName isNil or: [slCourseName isEmpty]) ifTrue: [self setSlCourseName].
	^slCourseName! !
!HRMeeting categoriesFor: #slCourseName!public! !

!HRMeeting methodsFor!
slCourseName: aName
	slCourseName := aName.
	self trigger: #valueChanged.
! !
!HRMeeting categoriesFor: #slCourseName:!public! !

!HRMeeting methodsFor!
slResultsCourseName

	| result |
#deprecated. "version 55"
	result := ''.
	self course subStrings do: [ :each |
		each first isLetter ifTrue: [
			result := result, each asLowercase capitalized, '_'.
		]].
	(self course subStrings first soundsLike: 'epsom') ifTrue: [ result := result, 'Downs_' ].
	(self course subStrings first soundsLike: 'bangor') ifTrue: [ result := 'Bangor_' ].
	^result leftString: (result size - 1)! !
!HRMeeting categoriesFor: #slResultsCourseName!public! !

!HRMeeting methodsFor!
startTime

	self races isEmpty ifTrue: [ ^Time fromSeconds: 0 ].
	^self races first time! !
!HRMeeting categoriesFor: #startTime!public! !

!HRMeeting methodsFor!
strategies

	^(OrderedCollection with: HRMeetingPlaceCalc with: HRMyMeeting with: HRPumpkin3Meeting with: HRBlokeSystemMeeting)! !
!HRMeeting categoriesFor: #strategies!public! !

!HRMeeting methodsFor!
toteERURL
"	toteERURL ifNil: [toteERURL := ''].
	^toteERURL
"
	"http://club.totesport.com/totepoolliveinfo/LiveData/result3.htm"
	self toteURLID isEmpty ifTrue: [^''].
	^'http://club.totesport.com/totepoolliveinfo/LiveData/result', self toteURLID, '.htm'
! !
!HRMeeting categoriesFor: #toteERURL!public! !

!HRMeeting methodsFor!
toteERURL: anObject
#deprecated. "version 55"
	toteERURL := anObject! !
!HRMeeting categoriesFor: #toteERURL:!public! !

!HRMeeting methodsFor!
totePPBF
	totePPBF ifNil: [self totePPBF: 0].
	^totePPBF! !
!HRMeeting categoriesFor: #totePPBF!public! !

!HRMeeting methodsFor!
totePPBF: anObject
	totePPBF := anObject! !
!HRMeeting categoriesFor: #totePPBF:!public! !

!HRMeeting methodsFor!
totePPCF
	totePPCF ifNil: [ self totePPCF: 0].
	^totePPCF! !
!HRMeeting categoriesFor: #totePPCF!public! !

!HRMeeting methodsFor!
totePPCF: anObject
	totePPCF := anObject! !
!HRMeeting categoriesFor: #totePPCF:!public! !

!HRMeeting methodsFor!
totePPDivi
	totePPDivi ifNil: [self totePPDivi: 0.0].
	totePPDivi isZero ifTrue: [self setTotePPDivi].
	^totePPDivi! !
!HRMeeting categoriesFor: #totePPDivi!public! !

!HRMeeting methodsFor!
totePPDivi: anObject
	totePPDivi := anObject! !
!HRMeeting categoriesFor: #totePPDivi:!public! !

!HRMeeting methodsFor!
totePPPool
	totePPPool ifNil: [self totePPPool: 0].
	^totePPPool! !
!HRMeeting categoriesFor: #totePPPool!public! !

!HRMeeting methodsFor!
totePPPool: anObject
	totePPPool := anObject! !
!HRMeeting categoriesFor: #totePPPool:!public! !

!HRMeeting methodsFor!
totePPURL
"	totePPURL ifNil: [self totePPURL: ''].
	^totePPURL
"
	"http://club.totesport.com/totepoolliveinfo/LiveData/Placepot1.htm"
	self toteURLID isEmpty ifTrue: [^''].
	^'http://club.totesport.com/totepoolliveinfo/LiveData/Placepot', self toteURLID, '.htm'! !
!HRMeeting categoriesFor: #totePPURL!public! !

!HRMeeting methodsFor!
totePPURL: anObject
#deprecated. "version 55"
	totePPURL := anObject! !
!HRMeeting categoriesFor: #totePPURL:!public! !

!HRMeeting methodsFor!
toteURLID
	toteURLID ifNil: [toteURLID := ''].
	^toteURLID
! !
!HRMeeting categoriesFor: #toteURLID!public! !

!HRMeeting methodsFor!
toteURLID: anID
	toteURLID := anID.
	self trigger: #idChanged.! !
!HRMeeting categoriesFor: #toteURLID:!public! !

!HRMeeting methodsFor!
updateAllLiveData

	self races do: [ :each |
		((Time now < each time) or: [self date > Date today]) ifTrue: [ each updateLiveData ]]! !
!HRMeeting categoriesFor: #updateAllLiveData!public! !

!HRMeeting categoriesFor: #addRace:!public! !

!HRMeeting categoriesFor: #asCsvString!public! !

!HRMeeting categoriesFor: #atSLShortTime:!public! !

!HRMeeting categoriesFor: #baseMeeting!public! !

!HRMeeting categoriesFor: #betfairEventName!public! !

!HRMeeting categoriesFor: #bfAbbr!public! !

!HRMeeting categoriesFor: #bfAbbr:!public! !

!HRMeeting categoriesFor: #checkCompleteness!public! !

!HRMeeting categoriesFor: #collectRemainingLines!public! !

!HRMeeting categoriesFor: #collectRemainingPot!public! !

!HRMeeting categoriesFor: #collectSlipLines!public! !

!HRMeeting categoriesFor: #copyPreviews!public! !

!HRMeeting categoriesFor: #course!accessing!private! !

!HRMeeting categoriesFor: #course:!accessing!private! !

!HRMeeting categoriesFor: #createCSVOutputScheduleItem!public! !

!HRMeeting categoriesFor: #createDataOutputScheduleItem!public! !

!HRMeeting categoriesFor: #createPlacepotSlip!public! !

!HRMeeting categoriesFor: #createPlacepotSMS!public! !

!HRMeeting categoriesFor: #createPPScheduleItemFor:!public! !

!HRMeeting categoriesFor: #createPPScheduleItems!public! !

!HRMeeting categoriesFor: #createPreMeetingCSVOutputScheduleItem!public! !

!HRMeeting categoriesFor: #csvFile!accessing!private! !

!HRMeeting categoriesFor: #csvFile:!accessing!private! !

!HRMeeting categoriesFor: #date!accessing!private! !

!HRMeeting categoriesFor: #date:!accessing!private! !

!HRMeeting categoriesFor: #dateString!accessing!private! !

!HRMeeting categoriesFor: #dateString:!accessing!private! !

!HRMeeting categoriesFor: #defaultStake!public! !

!HRMeeting categoriesFor: #defaultStakeFor:!public! !

!HRMeeting categoriesFor: #displayOn:!displaying!public! !

!HRMeeting categoriesFor: #findEarlyResult!public! !

!HRMeeting categoriesFor: #findPreMeetingNRs!accessing!public! !

!HRMeeting categoriesFor: #findSLEarlyResult!public! !

!HRMeeting categoriesFor: #findToteEarlyResult!public! !

!HRMeeting categoriesFor: #findTotePPData!public! !

!HRMeeting categoriesFor: #generateEsts!public! !

!HRMeeting categoriesFor: #going!accessing!private! !

!HRMeeting categoriesFor: #going:!accessing!private! !

!HRMeeting categoriesFor: #goingCode!accessing!private! !

!HRMeeting categoriesFor: #goingStripComma!accessing!private! !

!HRMeeting categoriesFor: #importPPEsts!public! !

!HRMeeting categoriesFor: #lastPPRace!public! !

!HRMeeting categoriesFor: #leg:!public! !

!HRMeeting categoriesFor: #loadEarlyLiveData!public! !

!HRMeeting categoriesFor: #mailDataFile!public! !

!HRMeeting categoriesFor: #mailPlacepotSMS!public! !

!HRMeeting categoriesFor: #mailPreMeetingCsv!public! !

!HRMeeting categoriesFor: #mailResultsCsv!public! !

!HRMeeting categoriesFor: #meeting!public! !

!HRMeeting categoriesFor: #myLines!public! !

!HRMeeting categoriesFor: #myPlaceOdds!public! !

!HRMeeting categoriesFor: #myPlaceOdds:!public! !

!HRMeeting categoriesFor: #myPlaceOddsAsPercentage!public! !

!HRMeeting categoriesFor: #myPPSelectionHeader!public! !

!HRMeeting categoriesFor: #myPPSMSFooter!public! !

!HRMeeting categoriesFor: #myPPSMSHeader!public! !

!HRMeeting categoriesFor: #myRemainingPlaceOdds!public! !

!HRMeeting categoriesFor: #myStake!public! !

!HRMeeting categoriesFor: #myStake:!public! !

!HRMeeting categoriesFor: #noOfRaces!public! !

!HRMeeting categoriesFor: #outputDataFile!public! !

!HRMeeting categoriesFor: #outputMyPPSelections!public! !

!HRMeeting categoriesFor: #outputMyPPSelectionsAsSMS!public! !

!HRMeeting categoriesFor: #outputPreMeetingCsv!public! !

!HRMeeting categoriesFor: #performVocabDictionaryKey:!public! !

!HRMeeting categoriesFor: #printOn:!displaying!public! !

!HRMeeting categoriesFor: #publishedAspects!development!must strip!public! !

!HRMeeting categoriesFor: #race!public! !

!HRMeeting categoriesFor: #raceAt:!public! !

!HRMeeting categoriesFor: #raceNo:!public! !

!HRMeeting categoriesFor: #races!public! !

!HRMeeting categoriesFor: #removeFromHRApp!public! !

!HRMeeting categoriesFor: #saveAsCsvFile!public! !

!HRMeeting categoriesFor: #saveAsCsvFileWith:!public! !

!HRMeeting categoriesFor: #scheduleCopyPreviewValues!public! !

!HRMeeting categoriesFor: #scheduleLoadEarlyLiveData!public! !

!HRMeeting categoriesFor: #scheduleTotePPURL!public! !

!HRMeeting categoriesFor: #scheduleToteURLID!public! !

!HRMeeting categoriesFor: #setBetfairRaceIDs!public! !

!HRMeeting categoriesFor: #setBetfairRaceIDsSkip:!public! !

!HRMeeting categoriesFor: #setDate!accessing!private! !

!HRMeeting categoriesFor: #setMyMeetingPlaceOdds!public! !

!HRMeeting categoriesFor: #setSlCourseName!public! !

!HRMeeting categoriesFor: #setToteERURL!public! !

!HRMeeting categoriesFor: #setTotePPDivi!public! !

!HRMeeting categoriesFor: #setTotePPURL!accessing!public! !

!HRMeeting categoriesFor: #setToteURLID!accessing!public! !

!HRMeeting categoriesFor: #shortDate!public! !

!HRMeeting categoriesFor: #shortDateNoDash!public! !

!HRMeeting categoriesFor: #slCourseName!public! !

!HRMeeting categoriesFor: #slCourseName:!public! !

!HRMeeting categoriesFor: #slResultsCourseName!public! !

!HRMeeting categoriesFor: #startTime!public! !

!HRMeeting categoriesFor: #strategies!public! !

!HRMeeting categoriesFor: #toteERURL!accessing!private! !

!HRMeeting categoriesFor: #toteERURL:!accessing!private! !

!HRMeeting categoriesFor: #totePPBF!accessing!private! !

!HRMeeting categoriesFor: #totePPBF:!accessing!private! !

!HRMeeting categoriesFor: #totePPCF!accessing!private! !

!HRMeeting categoriesFor: #totePPCF:!accessing!private! !

!HRMeeting categoriesFor: #totePPDivi!accessing!private! !

!HRMeeting categoriesFor: #totePPDivi:!accessing!private! !

!HRMeeting categoriesFor: #totePPPool!accessing!private! !

!HRMeeting categoriesFor: #totePPPool:!accessing!private! !

!HRMeeting categoriesFor: #totePPURL!accessing!private! !

!HRMeeting categoriesFor: #totePPURL:!accessing!private! !

!HRMeeting categoriesFor: #toteURLID!accessing!private! !

!HRMeeting categoriesFor: #toteURLID:!accessing!private! !

!HRMeeting categoriesFor: #updateAllLiveData!public! !

!HRMeeting class methodsFor!
defaultOutputArray

	^#(shortDate course raceType goingStripComma leg short24Time distance raceName forecastRunners actualRunners ageOfNagsStripped racecardNo drawAsNumber nagName jockey trainer formWithQuotes fineformRating rpSpotlightMention priceWise courseWinner distanceWinner daysSinceLastRunAsNumber postmark preRaceShow1AsDecimal preRaceShow2AsDecimal preRaceShow3AsDecimal preRaceShow4AsDecimal preRaceShow5AsDecimal preRaceShow6AsDecimal preRaceShowMaxAsDecimal preRaceShowMinAsDecimal rpForecastAsDecimal slForecastAsDecimal slFinalOddsAsDecimal noFavourite racePosition placed ppValue ppPercentage totePPPool totePPDivi ppCarriedForward 
blokeSystemResult bsFav bsPlaced
badP3Meeting pumpkin3Result findAllPlacedP3Nags p3Lines favP3Count p3Fav p3Placed).! !
!HRMeeting class categoriesFor: #defaultOutputArray!public! !

!HRMeeting class methodsFor!
setVocabDictionary

	vocabDictionary := Dictionary new.
	vocabDictionary 
"		at: #blokeSystemResult put: 'Blokesystem result';
"		at: #course put: 'Course';
		at: #goingCode put: 'Going (code)';
		at: #goingStripComma put: 'Going (text)';
		at: #shortDate put: 'Date';
		at: #totePPPool put: 'PP Pool';
		at: #totePPCF put: 'PP Carried forward';
		at: #totePPDivi put: 'PP Divi';
		at: #totePPBF put: 'PP Brought forward'.
! !
!HRMeeting class categoriesFor: #setVocabDictionary!public! !

!HRMeeting class methodsFor!
stbConvertFrom: anSTBClassFormat
	"Convert from earlier version models.
	1: see Model.
	2: Added 'toteERURL'.
	3: added myStake
	4: added myPlaceOdds
	5: package 55 added toteURLID
	6: package 55 added slCourseName bfAbbr
	"

	^[:data | | newInst |
		newInst := self basicNew.
		1 to: data size do: [ :i | newInst instVarAt: i put: (data at: i)].
		newInst]
! !
!HRMeeting class categoriesFor: #stbConvertFrom:!public! !

!HRMeeting class methodsFor!
stbVersion
	"Answer the current binary filer version number for instances of the receiver."

	^6! !
!HRMeeting class categoriesFor: #stbVersion!public! !

!HRMeeting class methodsFor!
vocabDictionaryAt: aKey

	^(self vocabDictionary) at: aKey ifAbsent: [ HRRace vocabDictionaryAt: aKey ]! !
!HRMeeting class categoriesFor: #vocabDictionaryAt:!public! !

!HRMeeting class categoriesFor: #defaultOutputArray!public! !

!HRMeeting class categoriesFor: #setVocabDictionary!public! !

!HRMeeting class categoriesFor: #stbConvertFrom:!public! !

!HRMeeting class categoriesFor: #stbVersion!public! !

!HRMeeting class categoriesFor: #vocabDictionaryAt:!public! !

HRMeetingStrat guid: (GUID fromString: '{26581E9C-C9F1-452A-8F79-F54967C9B882}')!

HRMeetingStrat guid: (GUID fromString: '{26581E9C-C9F1-452A-8F79-F54967C9B882}')!
HRMeetingStrat comment: ''!

HRMeetingStrat comment:
''!
!HRMeetingStrat categoriesForClass!MVP-Models! !
!HRMeetingStrat methodsFor!
asCsvString
	| result |
	result := String writeStream.
	result 
		nextPutAll: self predecessor asCsvString;
		nextPut: $,.
"	result nextPutAll: ',Decorator specific meeting label:,';
		nextPutAll: self decoratorSpecificInfo printString."
	^result contents
! !
!HRMeetingStrat categoriesFor: #asCsvString!public! !

!HRMeetingStrat methodsFor!
displayOn: aStream

	self course isEmpty ifFalse: [
		aStream nextPutAll: self shortDate;
		nextPutAll: ', ';
		display: self course;
		nextPutAll: ' (Decorator)'.
		].
! !
!HRMeetingStrat categoriesFor: #displayOn:!public! !

!HRMeetingStrat methodsFor!
doesNotUnderstand: aMessage
	"The receiver has not understood aMessage. Most likely this is because it was intended for
	the originator so we forward it up the chain."

	^aMessage forwardTo: predecessor! !
!HRMeetingStrat categoriesFor: #doesNotUnderstand:!public! !

!HRMeetingStrat methodsFor!
findAllPlacedNags
	| score |
	score := #(0 0 0 0 0 0).
	self races 
		do: [:each | each leg <= 6 ifTrue: [score at: each leg put: each findPlacedNags]].
	^score! !
!HRMeetingStrat categoriesFor: #findAllPlacedNags!public! !

!HRMeetingStrat methodsFor!
leg: aLeg

	^self races detect: [ :each | each leg = aLeg ] ifNone: [HRRace new].! !
!HRMeetingStrat categoriesFor: #leg:!public! !

!HRMeetingStrat methodsFor!
maxValue

	^(self races inject: 1 into: [ :val :each | val * each maxValue ])*0.73-1! !
!HRMeetingStrat categoriesFor: #maxValue!public! !

!HRMeetingStrat methodsFor!
minValue

	^(self races inject: 1 into: [ :val :each | val * each minValue ])*0.73-1! !
!HRMeetingStrat categoriesFor: #minValue!public! !

!HRMeetingStrat methodsFor!
performVocabDictionaryKey: aKey

	(self vocabDictionary includesKey: aKey) ifTrue: [^self perform: aKey].
	^self predecessor performVocabDictionaryKey: aKey.
! !
!HRMeetingStrat categoriesFor: #performVocabDictionaryKey:!public! !

!HRMeetingStrat methodsFor!
predecessor
	^predecessor! !
!HRMeetingStrat categoriesFor: #predecessor!public! !

!HRMeetingStrat methodsFor!
predecessor: anObject
	predecessor := anObject! !
!HRMeetingStrat categoriesFor: #predecessor:!public! !

!HRMeetingStrat methodsFor!
printOn: aStream
	"Overwrite the standard printOn so that the name of the object is shown if the class has a 'name' instance variable"

	aStream 
		basicPrint: self.
	self course isEmpty ifFalse: [
		aStream nextPut: $(;
		display: self course;
		nextPutAll: ', ';
		nextPutAll: self shortDate;
		nextPut: $)
		].
! !
!HRMeetingStrat categoriesFor: #printOn:!public! !

!HRMeetingStrat methodsFor!
races

	^self subclassResponsibility
"	races ifNil: [races := self predecessor races collect: [ :each | 
		(HRWhateverRace predecessor: each) meeting: self ]].
	^races
"! !
!HRMeetingStrat categoriesFor: #races!public! !

!HRMeetingStrat methodsFor!
setAll

	^self subclassResponsibility
"	self doWhateverIsNeeded
"! !
!HRMeetingStrat categoriesFor: #setAll!public! !

!HRMeetingStrat methodsFor!
vocabDictionaryAt: aKey

	| result |
	result := self class vocabDictionaryAt: aKey.
	(result = '') ifTrue: [ result := self predecessor vocabDictionaryAt: aKey ].
	^result! !
!HRMeetingStrat categoriesFor: #vocabDictionaryAt:!public! !

!HRMeetingStrat categoriesFor: #asCsvString!public! !

!HRMeetingStrat categoriesFor: #displayOn:!displaying!public! !

!HRMeetingStrat categoriesFor: #doesNotUnderstand:!exceptions!public! !

!HRMeetingStrat categoriesFor: #findAllPlacedNags!public! !

!HRMeetingStrat categoriesFor: #leg:!public! !

!HRMeetingStrat categoriesFor: #maxValue!public! !

!HRMeetingStrat categoriesFor: #minValue!public! !

!HRMeetingStrat categoriesFor: #performVocabDictionaryKey:!public! !

!HRMeetingStrat categoriesFor: #predecessor!accessing!private! !

!HRMeetingStrat categoriesFor: #predecessor:!accessing!private! !

!HRMeetingStrat categoriesFor: #printOn:!displaying!public! !

!HRMeetingStrat categoriesFor: #races!public! !

!HRMeetingStrat categoriesFor: #setAll!public! !

!HRMeetingStrat categoriesFor: #vocabDictionaryAt:!public! !

!HRMeetingStrat class methodsFor!
on: aPredecessor

	^self new predecessor: aPredecessor! !
!HRMeetingStrat class categoriesFor: #on:!public! !

!HRMeetingStrat class methodsFor!
predecessor: aPredecessor

	^self new predecessor: aPredecessor! !
!HRMeetingStrat class categoriesFor: #predecessor:!public! !

!HRMeetingStrat class categoriesFor: #on:!public! !

!HRMeetingStrat class categoriesFor: #predecessor:!public! !

HRBlokeSystemMeeting guid: (GUID fromString: '{C8281A17-1C4E-4B6F-BACE-316F46B9252C}')!

HRBlokeSystemMeeting guid: (GUID fromString: '{C8281A17-1C4E-4B6F-BACE-316F46B9252C}')!
HRBlokeSystemMeeting comment: ''!

HRBlokeSystemMeeting comment:
''!
!HRBlokeSystemMeeting categoriesForClass!MVP-Models! !
!HRBlokeSystemMeeting methodsFor!
asCsvString
	| result |
	result := String writeStream.
	result 
		nextPutAll: self predecessor asCsvString;
		nextPutAll: 'Blokesystem,60,';
		nextPutAll: self bsStake displayString;
		nextPut: $,;
		nextPutAll: self blokeSystemResult displayString;
		nextPut: $,;
		nextPutAll: (((self blokeSystemResult*self totePPDivi)-60) * self bsStake) displayString;
		nextPutAll: ',Max value:,';
		nextPutAll: ((self maxValue * 100) asInteger) displayString;
		nextPutAll: ',Min value:,';
		nextPutAll: ((self minValue * 100) asInteger) displayString;
		nextPutAll: String lineDelimiter.
	^result contents
! !
!HRBlokeSystemMeeting categoriesFor: #asCsvString!public! !

!HRBlokeSystemMeeting methodsFor!
blokeSystemResult

	^(self findWinningBSLines) size! !
!HRBlokeSystemMeeting categoriesFor: #blokeSystemResult!public! !

!HRBlokeSystemMeeting methodsFor!
bsStake

	^self defaultStakeFor: 60! !
!HRBlokeSystemMeeting categoriesFor: #bsStake!public! !

!HRBlokeSystemMeeting methodsFor!
findAllPlacedBSNags

	^self findAllPlacedNags! !
!HRBlokeSystemMeeting categoriesFor: #findAllPlacedBSNags!public! !

!HRBlokeSystemMeeting methodsFor!
findWinningBSLines
	| score lines |
	score := self findAllPlacedNags.
	lines := Bag new.
	(score at: 1) do: 
		[:a | (score at: 2) do: 
			[:b | (score at: 3) do: 
				[:c | (score at: 4) do: 
					[:d | (score at: 5) do: 
						[:e | (score at: 6) do: 
							[:f | | line |
								line := Array new: 6.
								line
										at: 1 put: a;
										at: 2 put: b;
										at: 3 put: c;
										at: 4 put: d;
										at: 5 put: e;
										at: 6 put: f.
								lines add: line]]]]]].
	^lines select: 
			[:each | 
			(each occurrencesOf: 1) = 3 
				and: [(each occurrencesOf: 2) = 2 and: [(each occurrencesOf: 3) = 1]]]! !
!HRBlokeSystemMeeting categoriesFor: #findWinningBSLines!public! !

!HRBlokeSystemMeeting methodsFor!
races

	races ifNil: [races := self predecessor races collect: [ :each | 
		(HRBlokeSystemRace predecessor: each) meeting: self ]].
	^races! !
!HRBlokeSystemMeeting categoriesFor: #races!public! !

!HRBlokeSystemMeeting methodsFor!
setAll

	self setBlokeSystemFavs.
! !
!HRBlokeSystemMeeting categoriesFor: #setAll!public! !

!HRBlokeSystemMeeting methodsFor!
setBlokeSystemFavs

	self races do: [ :race | race setBlokeSystemFavs ]! !
!HRBlokeSystemMeeting categoriesFor: #setBlokeSystemFavs!public! !

!HRBlokeSystemMeeting categoriesFor: #asCsvString!public! !

!HRBlokeSystemMeeting categoriesFor: #blokeSystemResult!public! !

!HRBlokeSystemMeeting categoriesFor: #bsStake!public! !

!HRBlokeSystemMeeting categoriesFor: #findAllPlacedBSNags!public! !

!HRBlokeSystemMeeting categoriesFor: #findWinningBSLines!public! !

!HRBlokeSystemMeeting categoriesFor: #races!public! !

!HRBlokeSystemMeeting categoriesFor: #setAll!public! !

!HRBlokeSystemMeeting categoriesFor: #setBlokeSystemFavs!public! !

!HRBlokeSystemMeeting class methodsFor!
setVocabDictionary

	vocabDictionary := Dictionary new.
	vocabDictionary 
		at: #blokeSystemResult put: 'Blokesystem Result';
		at: #findAllPlacedBSNags put: 'Placed BS Nags'.
! !
!HRBlokeSystemMeeting class categoriesFor: #setVocabDictionary!public! !

!HRBlokeSystemMeeting class methodsFor!
vocabDictionaryAt: aKey

	^(self vocabDictionary) at: aKey ifAbsent: [ HRBlokeSystemRace vocabDictionaryAt: aKey ]! !
!HRBlokeSystemMeeting class categoriesFor: #vocabDictionaryAt:!public! !

!HRBlokeSystemMeeting class categoriesFor: #setVocabDictionary!public! !

!HRBlokeSystemMeeting class categoriesFor: #vocabDictionaryAt:!public! !

HRMeetingPlaceCalc guid: (GUID fromString: '{C33F3E48-5B50-4BD4-A3C7-DAB00DCDBBF5}')!

HRMeetingPlaceCalc guid: (GUID fromString: '{C33F3E48-5B50-4BD4-A3C7-DAB00DCDBBF5}')!
HRMeetingPlaceCalc comment: ''!

HRMeetingPlaceCalc comment:
''!
!HRMeetingPlaceCalc categoriesForClass!MVP-Models! !
!HRMeetingPlaceCalc methodsFor!
asCsvString
	| result |
	result := String writeStream.
	result 
		nextPutAll: self predecessor asCsvString.
	^result contents
! !
!HRMeetingPlaceCalc categoriesFor: #asCsvString!public! !

!HRMeetingPlaceCalc methodsFor!
races

	races ifNil: [races := self predecessor races collect: [ :each | 
		(HRRacePlaceCalc predecessor: each) meeting: self ]].
	^races
! !
!HRMeetingPlaceCalc categoriesFor: #races!public! !

!HRMeetingPlaceCalc methodsFor!
recalcPlaceValues

	self setAll.
! !
!HRMeetingPlaceCalc categoriesFor: #recalcPlaceValues!public! !

!HRMeetingPlaceCalc methodsFor!
setAll

	self races do: [ :each | each calculatePPValue ].
	self setMyPlaceOdds.
! !
!HRMeetingPlaceCalc categoriesFor: #setAll!public! !

!HRMeetingPlaceCalc methodsFor!
setMyPlaceOdds

	(self ppRaces allSatisfy: [ :each | each myFavCount > 0 ]) ifTrue: [
		self ppRaces do: [ :each | each setMyRacePlaceOdds ].
		self setMyMeetingPlaceOdds
		].! !
!HRMeetingPlaceCalc categoriesFor: #setMyPlaceOdds!public! !

!HRMeetingPlaceCalc categoriesFor: #asCsvString!public! !

!HRMeetingPlaceCalc categoriesFor: #races!public! !

!HRMeetingPlaceCalc categoriesFor: #recalcPlaceValues!public! !

!HRMeetingPlaceCalc categoriesFor: #setAll!public! !

!HRMeetingPlaceCalc categoriesFor: #setMyPlaceOdds!public! !

HRMyMeeting guid: (GUID fromString: '{0A35BC30-09C4-439C-A487-7D7B5C886C06}')!

HRMyMeeting guid: (GUID fromString: '{0A35BC30-09C4-439C-A487-7D7B5C886C06}')!
HRMyMeeting comment: ''!

HRMyMeeting comment:
''!
!HRMyMeeting categoriesForClass!MVP-Models! !
!HRMyMeeting methodsFor!
asCsvString
	| result |
	result := String writeStream.
	result 
		nextPutAll: self predecessor asCsvString;
		nextPutAll: 'My selection,';
		nextPutAll: self myLines displayString;
		nextPut: $,;
		nextPutAll: self myStake displayString;
		nextPut: $,;
		nextPutAll: self myResult displayString;
		nextPut: $,;
		nextPutAll: (((self myResult*self totePPDivi)-self myLines) * self myStake) displayString;
		nextPutAll: ',Max value:,';
		nextPutAll: ((self maxValue * 100) asInteger) displayString;
		nextPutAll: ',Min value:,';
		nextPutAll: ((self minValue * 100) asInteger) displayString;
		nextPutAll: ',Cumulative place odds:,';
		nextPutAll: self myPlaceOddsAsPercentage displayString.
	result nextPutAll: String lineDelimiter.
	^result contents
! !
!HRMyMeeting categoriesFor: #asCsvString!public! !

!HRMyMeeting methodsFor!
estimateResult

	self findTotePPData.
	^(self leg: 6) estimateResult! !
!HRMyMeeting categoriesFor: #estimateResult!public! !

!HRMyMeeting methodsFor!
findMyWinningLines

	^self findAllPlacedNags inject: 1 into: [ :lines :each | lines * each ].
! !
!HRMyMeeting categoriesFor: #findMyWinningLines!public! !

!HRMyMeeting methodsFor!
myMaxValue

	^self maxValue! !
!HRMyMeeting categoriesFor: #myMaxValue!public! !

!HRMyMeeting methodsFor!
myMinValue

	^self minValue! !
!HRMyMeeting categoriesFor: #myMinValue!public! !

!HRMyMeeting methodsFor!
myResult

	^self findMyWinningLines! !
!HRMyMeeting categoriesFor: #myResult!public! !

!HRMyMeeting methodsFor!
races

	races ifNil: [races := self predecessor races collect: [ :each | 
		(HRMyRace predecessor: each) meeting: self ]].
	^races! !
!HRMyMeeting categoriesFor: #races!public! !

!HRMyMeeting methodsFor!
setAll

	"nothing to do here"! !
!HRMyMeeting categoriesFor: #setAll!public! !

!HRMyMeeting categoriesFor: #asCsvString!public! !

!HRMyMeeting categoriesFor: #estimateResult!public! !

!HRMyMeeting categoriesFor: #findMyWinningLines!public! !

!HRMyMeeting categoriesFor: #myMaxValue!public! !

!HRMyMeeting categoriesFor: #myMinValue!public! !

!HRMyMeeting categoriesFor: #myResult!public! !

!HRMyMeeting categoriesFor: #races!public! !

!HRMyMeeting categoriesFor: #setAll!public! !

HRPumpkin3Meeting guid: (GUID fromString: '{019155AA-8BAD-4050-8386-63A41FDEBE6C}')!

HRPumpkin3Meeting guid: (GUID fromString: '{019155AA-8BAD-4050-8386-63A41FDEBE6C}')!
HRPumpkin3Meeting comment: ''!

HRPumpkin3Meeting comment:
''!
!HRPumpkin3Meeting categoriesForClass!MVP-Models! !
!HRPumpkin3Meeting methodsFor!
asCsvString
	| result |
	result := String writeStream.
	result 
		nextPutAll: self predecessor asCsvString;
		nextPutAll: 'Pumpkin3,';
		nextPutAll: self p3Lines displayString;
		nextPut: $,;
		nextPutAll: self p3Stake displayString;
		nextPut: $,;
		nextPutAll: self pumpkin3Result displayString;
		nextPut: $,;
		nextPutAll: (((self pumpkin3Result*self totePPDivi)-self p3Lines) * self p3Stake) displayString;
		nextPutAll: ',Max value:,';
		nextPutAll: ((self maxValue * 100) asInteger) displayString;
		nextPutAll: ',Min value:,';
		nextPutAll: ((self minValue * 100) asInteger) displayString.
	self badMeeting ifTrue: [ result nextPutAll: ',Bad Meeting' ].
	result nextPutAll: String lineDelimiter.
	^result contents
! !
!HRPumpkin3Meeting categoriesFor: #asCsvString!public! !

!HRPumpkin3Meeting methodsFor!
badMeeting

	badMeeting ifNil: [ badMeeting := false].
	^badMeeting! !
!HRPumpkin3Meeting categoriesFor: #badMeeting!public! !

!HRPumpkin3Meeting methodsFor!
badP3Meeting

	^self badMeeting! !
!HRPumpkin3Meeting categoriesFor: #badP3Meeting!public! !

!HRPumpkin3Meeting methodsFor!
findAllPlacedP3Nags

	^self findAllPlacedNags! !
!HRPumpkin3Meeting categoriesFor: #findAllPlacedP3Nags!public! !

!HRPumpkin3Meeting methodsFor!
findWinningP3Lines

	^self findAllPlacedNags inject: 1 into: [ :lines :each | lines * each ].
! !
!HRPumpkin3Meeting categoriesFor: #findWinningP3Lines!public! !

!HRPumpkin3Meeting methodsFor!
p3Lines

	self badMeeting ifFalse: [^(self races first: 6) inject: 1 into: [ :lines :each | 
		lines * each favCount ]].
	^0! !
!HRPumpkin3Meeting categoriesFor: #p3Lines!public! !

!HRPumpkin3Meeting methodsFor!
p3Stake

	^self defaultStakeFor: self p3Lines! !
!HRPumpkin3Meeting categoriesFor: #p3Stake!public! !

!HRPumpkin3Meeting methodsFor!
pumpkin3Result

	^self findWinningP3Lines! !
!HRPumpkin3Meeting categoriesFor: #pumpkin3Result!public! !

!HRPumpkin3Meeting methodsFor!
races

	races ifNil: [races := self predecessor races collect: [ :each | 
		(HRPumpkin3Race predecessor: each) meeting: self ]].
	^races! !
!HRPumpkin3Meeting categoriesFor: #races!public! !

!HRPumpkin3Meeting methodsFor!
setAll
	self setPumpkin3Favs.
	badMeeting := (self races size < 6) or: 
		[(self races first: 6) anySatisfy: [:each | each badRace]].
	sumValue := self races inject: 0 into: [:sum :each | sum + each sumValue]! !
!HRPumpkin3Meeting categoriesFor: #setAll!public! !

!HRPumpkin3Meeting methodsFor!
setPumpkin3Favs

	self races do: [ :race | race pickP3Candidates ]! !
!HRPumpkin3Meeting categoriesFor: #setPumpkin3Favs!public! !

!HRPumpkin3Meeting methodsFor!
sumValue

	sumValue ifNil: [sumValue := 0].
	^sumValue! !
!HRPumpkin3Meeting categoriesFor: #sumValue!public! !

!HRPumpkin3Meeting categoriesFor: #asCsvString!public! !

!HRPumpkin3Meeting categoriesFor: #badMeeting!public! !

!HRPumpkin3Meeting categoriesFor: #badP3Meeting!public! !

!HRPumpkin3Meeting categoriesFor: #findAllPlacedP3Nags!public! !

!HRPumpkin3Meeting categoriesFor: #findWinningP3Lines!public! !

!HRPumpkin3Meeting categoriesFor: #p3Lines!public! !

!HRPumpkin3Meeting categoriesFor: #p3Stake!public! !

!HRPumpkin3Meeting categoriesFor: #pumpkin3Result!public! !

!HRPumpkin3Meeting categoriesFor: #races!public! !

!HRPumpkin3Meeting categoriesFor: #setAll!public! !

!HRPumpkin3Meeting categoriesFor: #setPumpkin3Favs!public! !

!HRPumpkin3Meeting categoriesFor: #sumValue!public! !

!HRPumpkin3Meeting class methodsFor!
setVocabDictionary

	vocabDictionary := Dictionary new.
	vocabDictionary 
		at: #badP3Meeting put: 'Bad P3 Meeting';
		at: #pumpkin3Result put: 'P3 Result';
		at: #findAllPlacedP3Nags put: 'Placed P3 Nags';
		at: #p3Lines put: 'P3 Lines'.
! !
!HRPumpkin3Meeting class categoriesFor: #setVocabDictionary!public! !

!HRPumpkin3Meeting class methodsFor!
vocabDictionaryAt: aKey

	^(self vocabDictionary) at: aKey ifAbsent: [ HRPumpkin3Race vocabDictionaryAt: aKey ]! !
!HRPumpkin3Meeting class categoriesFor: #vocabDictionaryAt:!public! !

!HRPumpkin3Meeting class categoriesFor: #setVocabDictionary!public! !

!HRPumpkin3Meeting class categoriesFor: #vocabDictionaryAt:!public! !

HRNag guid: (GUID fromString: '{BC0B355A-176E-4B62-B287-751314147513}')!

HRNag guid: (GUID fromString: '{BC0B355A-176E-4B62-B287-751314147513}')!
HRNag comment: ''!

HRNag comment:
''!
!HRNag categoriesForClass!MVP-Models! !
!HRNag methodsFor!
addBFPlace: odds at: time
	odds isZero ifFalse: [self race resetPreRaceFav].
	(self bfPlace at: time) back: (odds + 1); lay: (odds + 1)
! !
!HRNag categoriesFor: #addBFPlace:at:!public! !

!HRNag methodsFor!
addBFWin: odds at: time
	odds isZero ifFalse: [self race resetPreRaceFav].
	(self bfWin at: time) back: (odds + 1); lay: (odds + 1)
! !
!HRNag categoriesFor: #addBFWin:at:!public! !

!HRNag methodsFor!
asCsvString
	| result |
	result := String writeStream.
	result 
		nextPutAll: self racecardNo;
		nextPut: $,;
		nextPutAll: self name;
		nextPut: $,;
		nextPutAll: self jockey;
		nextPut: $,;
		nextPutAll: self trainer;
		nextPut: $,;
		nextPutAll: self form printString;
		nextPut: $,;
		nextPutAll: self rpSpotlightMention printString;
		nextPut: $,;
		nextPutAll: self noFavourite printString;
		nextPut: $,;
		nextPutAll: self rpForecast printString;
		nextPut: $,;
		nextPutAll: self slForecast printString;
		nextPut: $,;
		nextPutAll: (self bfWinOddsAtPPOff asScaledDecimal: 2) displayString;
		nextPut: $,;
		nextPutAll: (self rpBfDiff asScaledDecimal: 2) displayString;
		nextPut: $,;
		nextPutAll: self preRaceShow printString;
		nextPut: $,;
		nextPutAll: self slFinalOdds printString;
		nextPut: $,;
		nextPutAll: self preRaceNR printTrueOrBlank;
		nextPut: $,;
		nextPutAll: self racePosition printString;
		nextPut: $,;
		nextPutAll: self placed printTrueOrBlank;
		nextPut: $,;
		nextPutAll: (self ppValue asScaledDecimal: 2) displayString;
		nextPut: $,;
		nextPutAll: self ppPercentageAsPercentage displayString;
		nextPut: $,;
		nextPutAll: self ppEst displayString;
		nextPut: $,;
		nextPutAll: (self rpChanceRoundedPercentage asScaledDecimal: 1) displayString;
		nextPut: $,;
		nextPutAll: self rpValueOnPP displayString;
		nextPut: $,;
		nextPutAll: (self previewPlaceChanceRoundedPercentage asScaledDecimal: 1) displayString;
		nextPut: $,;
		nextPutAll: self previewPPPlaceValue displayString;
		nextPut: $,;
		nextPutAll: self mySelect printTrueOrBlank.
	^result contents
! !
!HRNag categoriesFor: #asCsvString!public! !

!HRNag methodsFor!
asCsvStringAll

	| result |
	result := String writeStream.
	result nextPutAll: self keyAsCsvString.
	self class vocabDictionary associationsDo: [ :each | result nextPutAll: (self perform: each key) printString; nextPut: $, ].
	^result contents
! !
!HRNag categoriesFor: #asCsvStringAll!public! !

!HRNag methodsFor!
baseNag

	^self! !
!HRNag categoriesFor: #baseNag!public! !

!HRNag methodsFor!
bestOdds
	self nonRunner ifTrue: [ ^0 ].
	self race hasFinalOdds ifTrue: [ ^self slFinalOdds ].
	self hasLiveShow ifTrue: [ ^self preRaceShow last ].
	self race hasBFOdds ifTrue: [ ^self bfOdds ].
	^self rpForecast! !
!HRNag categoriesFor: #bestOdds!public! !

!HRNag methodsFor!
betfairSummary

	^ 'Betfair win', String lineDelimiter, 'Race TO: ', self bfWinRaceTO printString, ' Nag TO: ', self bfWinNagTO printString, String lineDelimiter, 'Back: ', self bfWinPut printString, ' Lay: ', self bfWinLay printString, ' Direction: ', self bfWinDirection, String lineDelimiter, String lineDelimiter, 'Betfair place', String lineDelimiter, 'Race TO: ', self bfPlaceRaceTO printString, ' Nag TO: ', self bfPlaceNagTO printString, String lineDelimiter, 'Back: ', self bfPlacePut printString, ' Lay: ', self bfPlaceLay printString, ' Direction: ', self bfPlaceDirection.! !
!HRNag categoriesFor: #betfairSummary!public! !

!HRNag methodsFor!
betterValueThan: anotherNag

	anotherNag nonRunner ifTrue: [^true].
	self nonRunner ifTrue: [^false].
	^self rpValueOnPP > anotherNag rpValueOnPP
! !
!HRNag categoriesFor: #betterValueThan:!public! !

!HRNag methodsFor!
bfID
	bfID ifNil: [bfID := ''].
	^bfID! !
!HRNag categoriesFor: #bfID!public! !

!HRNag methodsFor!
bfID: anObject
	bfID := anObject! !
!HRNag categoriesFor: #bfID:!public! !

!HRNag methodsFor!
bfLay
"	bfLay ifNil: [bfLay := 0].
	^bfLay
"
	^self bfWin lastLaid! !
!HRNag categoriesFor: #bfLay!public! !

!HRNag methodsFor!
bfLay: anObject
#deprecated.
	anObject isZero ifFalse: [self race resetPreRaceFav].
	bfLay := anObject! !
!HRNag categoriesFor: #bfLay:!public! !

!HRNag methodsFor!
bfLayOdds
	^self bfLay - 1! !
!HRNag categoriesFor: #bfLayOdds!public! !

!HRNag methodsFor!
bfMiddle

	self bfPut isZero ifTrue: [^self bfLay].
	self bfLay isZero ifTrue: [^self bfPut].
	^((self bfPut + self bfLay)/2) asFloat roundTo: 0.01! !
!HRNag categoriesFor: #bfMiddle!public! !

!HRNag methodsFor!
bfMiddle: aFloat

"	self bfLay: aFloat. 
	self bfPut: aFloat."
	self bfWin addOdds: (aFloat - 1) time: (Time now)! !
!HRNag categoriesFor: #bfMiddle:!public! !

!HRNag methodsFor!
bfNagTO
"	bfNagTO ifNil: [bfNagTO := 0].
	^bfNagTO
"
	^self bfWin lastTurnover! !
!HRNag categoriesFor: #bfNagTO!public! !

!HRNag methodsFor!
bfNagTO: anObject
	bfNagTO := anObject! !
!HRNag categoriesFor: #bfNagTO:!public! !

!HRNag methodsFor!
bfOdds

"	self bfLayOdds isZero ifTrue: [^self bfPutOdds].
	^((self bfPutOdds + self bfLayOdds)/2) asFloat roundTo: 0.01
"
	^self bfWin lastOdds asScaledDecimal: 2
! !
!HRNag categoriesFor: #bfOdds!public! !

!HRNag methodsFor!
bfPlace
	bfPlace ifNil: [bfPlace := HROddsSeries new].
	^bfPlace! !
!HRNag categoriesFor: #bfPlace!public! !

!HRNag methodsFor!
bfPlaceDirection
	self bfPlace direction > 0 ifTrue: [ ^'Up' ].
	self bfPlace direction < 0 ifTrue: [ ^'Down' ].
	^'Neutral'! !
!HRNag categoriesFor: #bfPlaceDirection!public! !

!HRNag methodsFor!
bfPlaceID
	bfPlaceID ifNil: [bfPlaceID := ''].
	^bfPlaceID! !
!HRNag categoriesFor: #bfPlaceID!public! !

!HRNag methodsFor!
bfPlaceID: anObject
	^bfPlaceID := anObject! !
!HRNag categoriesFor: #bfPlaceID:!public! !

!HRNag methodsFor!
bfPlaceLay
	^self bfPlace lastLaid! !
!HRNag categoriesFor: #bfPlaceLay!public! !

!HRNag methodsFor!
bfPlaceLayOdds
	self bfPlaceLay isZero ifTrue: [^0].
	^(self bfPlaceLay - 1) asScaledDecimal: 2
! !
!HRNag categoriesFor: #bfPlaceLayOdds!public! !

!HRNag methodsFor!
bfPlaceMiddle

	^((self bfPlaceLay + self bfPlacePut) / 2.0) roundTo: 0.01! !
!HRNag categoriesFor: #bfPlaceMiddle!public! !

!HRNag methodsFor!
bfPlaceNagTO
	^self bfPlace lastTurnover! !
!HRNag categoriesFor: #bfPlaceNagTO!public! !

!HRNag methodsFor!
bfPlaceOdds

	^self bfPlace lastOdds asScaledDecimal: 2
! !
!HRNag categoriesFor: #bfPlaceOdds!public! !

!HRNag methodsFor!
bfPlacePut
	^self bfPlace lastBacked! !
!HRNag categoriesFor: #bfPlacePut!public! !

!HRNag methodsFor!
bfPlacePutOdds
	self bfPlacePut isZero ifTrue: [^0].
	^(self bfPlacePut - 1) asScaledDecimal: 2
! !
!HRNag categoriesFor: #bfPlacePutOdds!public! !

!HRNag methodsFor!
bfPlaceRaceTO
	^self bfPlace lastTotalTurnover! !
!HRNag categoriesFor: #bfPlaceRaceTO!public! !

!HRNag methodsFor!
bfPut
"	bfPut ifNil: [bfPut := 0].
	^bfPut
"
	^self bfWin lastBacked! !
!HRNag categoriesFor: #bfPut!public! !

!HRNag methodsFor!
bfPut: anObject
#deprecated.
	anObject isZero ifFalse: [self race resetPreRaceFav].
	bfPut := anObject! !
!HRNag categoriesFor: #bfPut:!public! !

!HRNag methodsFor!
bfPutOdds
	^self bfPut - 1! !
!HRNag categoriesFor: #bfPutOdds!public! !

!HRNag methodsFor!
bfRaceTO
"	^self race bfRaceTO
"
	^self bfWin lastTotalTurnover! !
!HRNag categoriesFor: #bfRaceTO!public! !

!HRNag methodsFor!
bfRaceTO: anObject
	self race bfRaceTO: anObject! !
!HRNag categoriesFor: #bfRaceTO:!public! !

!HRNag methodsFor!
bfWin
	bfWin ifNil: [bfWin := HROddsSeries new].
	^bfWin! !
!HRNag categoriesFor: #bfWin!public! !

!HRNag methodsFor!
bfWinDirection
	self bfWin direction > 0 ifTrue: [ ^'Up' ].
	self bfWin direction < 0 ifTrue: [ ^'Down' ].
	^'Neutral'! !
!HRNag categoriesFor: #bfWinDirection!public! !

!HRNag methodsFor!
bfWinID
	bfWinID ifNil: [bfWinID := ''].
	^bfWinID! !
!HRNag categoriesFor: #bfWinID!public! !

!HRNag methodsFor!
bfWinID: anObject
	^bfWinID := anObject! !
!HRNag categoriesFor: #bfWinID:!public! !

!HRNag methodsFor!
bfWinLay
	^self bfWin lastLaid! !
!HRNag categoriesFor: #bfWinLay!public! !

!HRNag methodsFor!
bfWinLayOdds
	^self bfWinLay - 1! !
!HRNag categoriesFor: #bfWinLayOdds!public! !

!HRNag methodsFor!
bfWinMiddle

	^((self bfWinLay + self bfWinPut) / 2.0) roundTo: 0.01! !
!HRNag categoriesFor: #bfWinMiddle!public! !

!HRNag methodsFor!
bfWinNagTO
	^self bfWin lastTurnover! !
!HRNag categoriesFor: #bfWinNagTO!public! !

!HRNag methodsFor!
bfWinOdds

	^self bfWin lastOdds asScaledDecimal: 2
! !
!HRNag categoriesFor: #bfWinOdds!public! !

!HRNag methodsFor!
bfWinOddsAtPPOff

	| ppOff |
	ppOff := self race meeting startTime.
	^self bfWin oddsAt: ppOff! !
!HRNag categoriesFor: #bfWinOddsAtPPOff!public! !

!HRNag methodsFor!
bfWinPut
	^self bfWin lastBacked! !
!HRNag categoriesFor: #bfWinPut!public! !

!HRNag methodsFor!
bfWinPutOdds
	^self bfWinPut - 1! !
!HRNag categoriesFor: #bfWinPutOdds!public! !

!HRNag methodsFor!
bfWinRaceTO
	^self bfWin lastTotalTurnover! !
!HRNag categoriesFor: #bfWinRaceTO!public! !

!HRNag methodsFor!
blokeSystemFav
	blokeSystemFav ifNil: [self blokeSystemFav: 0].
	^blokeSystemFav! !
!HRNag categoriesFor: #blokeSystemFav!public! !

!HRNag methodsFor!
blokeSystemFav: anObject
	blokeSystemFav := anObject! !
!HRNag categoriesFor: #blokeSystemFav:!public! !

!HRNag methodsFor!
compareBestOddsWith: aNag

	self preRaceNR ifTrue: [^false].
	self bestOdds = aNag bestOdds ifTrue: [ ^(self noFavourite < aNag noFavourite)].
	self bestOdds = 0 ifTrue: [ ^false ].
	aNag bestOdds = 0 ifTrue: [ ^true ].
	^(self bestOdds < aNag bestOdds)! !
!HRNag categoriesFor: #compareBestOddsWith:!public! !

!HRNag methodsFor!
compareBFOddsWith: aNag

	self preRaceNR ifTrue: [^false].
	self bfOdds = aNag bfOdds ifTrue: [ ^(self noFavourite < aNag noFavourite)].
	self bfOdds = 0 ifTrue: [ ^false ].
	aNag bfOdds = 0 ifTrue: [ ^true ].
	^(self bfOdds < aNag bfOdds)! !
!HRNag categoriesFor: #compareBFOddsWith:!public! !

!HRNag methodsFor!
compareRpForecastWith: aNag

	self preRaceNR ifTrue: [^false].
	self rpForecast = aNag rpForecast ifTrue: [ ^(self noFavourite < aNag noFavourite)].
	self rpForecast = 0 ifTrue: [ ^false ].
	aNag rpForecast = 0 ifTrue: [ ^true ].
	^(self rpForecast < aNag rpForecast)! !
!HRNag categoriesFor: #compareRpForecastWith:!public! !

!HRNag methodsFor!
compareSlFinalOddsWith: aNag

	self preRaceNR ifTrue: [^false].
	self slFinalOdds = aNag slFinalOdds ifTrue: [ ^(self noFavourite < aNag noFavourite)].
	self slFinalOdds = 0 ifTrue: [ ^false ].
	aNag slFinalOdds = 0 ifTrue: [ ^true ].
	^(self slFinalOdds < aNag slFinalOdds)! !
!HRNag categoriesFor: #compareSlFinalOddsWith:!public! !

!HRNag methodsFor!
copyPreviews

	previewPlaceChance := self rpPlaceChance.
	previewPPPlaceValue := self rpValueOnPP.
! !
!HRNag categoriesFor: #copyPreviews!public! !

!HRNag methodsFor!
courseWinner
	courseWinner ifNil: [self courseWinner: false].
	^courseWinner! !
!HRNag categoriesFor: #courseWinner!public! !

!HRNag methodsFor!
courseWinner: anObject
	courseWinner := anObject! !
!HRNag categoriesFor: #courseWinner:!public! !

!HRNag methodsFor!
daysSinceLastRun
	daysSinceLastRun ifNil: [self daysSinceLastRun: ''].
	^daysSinceLastRun! !
!HRNag categoriesFor: #daysSinceLastRun!public! !

!HRNag methodsFor!
daysSinceLastRun: anObject
	daysSinceLastRun := anObject! !
!HRNag categoriesFor: #daysSinceLastRun:!public! !

!HRNag methodsFor!
daysSinceLastRunAsNumber
	^Number fromString: ((self daysSinceLastRun readStream upTo: $() trimBlanks)! !
!HRNag categoriesFor: #daysSinceLastRunAsNumber!public! !

!HRNag methodsFor!
distanceWinner
	distanceWinner ifNil: [self distanceWinner: false].
	^distanceWinner! !
!HRNag categoriesFor: #distanceWinner!public! !

!HRNag methodsFor!
distanceWinner: anObject
	distanceWinner := anObject! !
!HRNag categoriesFor: #distanceWinner:!public! !

!HRNag methodsFor!
draw
	draw ifNil: [self draw: '0'].
	^draw! !
!HRNag categoriesFor: #draw!public! !

!HRNag methodsFor!
draw: anObject
	draw := anObject! !
!HRNag categoriesFor: #draw:!public! !

!HRNag methodsFor!
drawAsNumber
	| number |
	number := String writeStream.
	self draw displayString do: [:i | i isDigit ifTrue: [number nextPut: i]].
	number isEmpty ifFalse: [^number contents asNumber].
	^0! !
!HRNag categoriesFor: #drawAsNumber!public! !

!HRNag methodsFor!
earlyOdds
	earlyOdds ifNil: [self earlyOdds: 0].
	^earlyOdds! !
!HRNag categoriesFor: #earlyOdds!public! !

!HRNag methodsFor!
earlyOdds: anObject
	earlyOdds := anObject! !
!HRNag categoriesFor: #earlyOdds:!public! !

!HRNag methodsFor!
earlyOddsAsDecimal
	^self earlyOdds asFloat roundTo: 0.005
! !
!HRNag categoriesFor: #earlyOddsAsDecimal!public! !

!HRNag methodsFor!
estRatio

	| oddsFactor ffFactor bfBackedFactor result |
	self rpForecast isZero ifTrue: [^0]. 
	oddsFactor := 1/((self rpForecast + self bfOdds + 0.0000001) raisedTo: 2).
	ffFactor := 1 + (self formPoints * 0.05).
	bfBackedFactor := 1.
	(self rpForecast isZero not and: [self bfOdds isZero not]) ifTrue: 
		[bfBackedFactor := 1 - (((self bfOdds - self rpForecast) / self bfOdds) * 0.3)].
	result := oddsFactor * ffFactor * bfBackedFactor.
	self nonRunner ifTrue: [^0 "result/2"].
	^result
! !
!HRNag categoriesFor: #estRatio!public! !

!HRNag methodsFor!
fineformRating
	fineformRating ifNil: [self fineformRating: 0].
	^fineformRating! !
!HRNag categoriesFor: #fineformRating!public! !

!HRNag methodsFor!
fineformRating: anObject
	fineformRating := anObject! !
!HRNag categoriesFor: #fineformRating:!public! !

!HRNag methodsFor!
form
	form ifNil: [self form: ''].
	^form! !
!HRNag categoriesFor: #form!public! !

!HRNag methodsFor!
form: anObject
	form := anObject.
	self fineformRating: self formPoints.! !
!HRNag categoriesFor: #form:!public! !

!HRNag methodsFor!
formPoints

	|points last oneBut result formThisSeason|
	points := #(5 3 2 1).
	last := 0. oneBut := 0. result := 0.
	formThisSeason := self form reverse readStream upTo: $/.
	formThisSeason := formThisSeason readStream upTo: $-.
	formThisSeason isEmpty ifFalse: [formThisSeason first isDigit ifTrue: [last := formThisSeason first asString asNumber]].
	formThisSeason size > 1 ifTrue: [
		oneBut := formThisSeason at: 2.
		oneBut isDigit ifTrue: [oneBut := oneBut asString asNumber] ifFalse: [oneBut := 0]].
	((last < 5) and: [last isZero not]) ifTrue: [result := result + (points at: last)].
	((oneBut < 5) and: [oneBut isZero not]) ifTrue: [result := result + (points at: oneBut)].
"	self courseWinner ifTrue: [result := result + 1].
	self distanceWinner ifTrue: [result := result + 2].
"	^result! !
!HRNag categoriesFor: #formPoints!public! !

!HRNag methodsFor!
formWithQuotes
	"for csv output, make sure it's a string"
	^'''', self form! !
!HRNag categoriesFor: #formWithQuotes!public! !

!HRNag methodsFor!
hasLiveShow

	^self preRaceShow isEmpty not! !
!HRNag categoriesFor: #hasLiveShow!public! !

!HRNag methodsFor!
jockey
	jockey ifNil: [self jockey: ''].
	^jockey! !
!HRNag categoriesFor: #jockey!public! !

!HRNag methodsFor!
jockey: anObject
	jockey := anObject asUppercase! !
!HRNag categoriesFor: #jockey:!public! !

!HRNag methodsFor!
keyAsCsvString

	| result |
	result := String writeStream.
	result
		nextPutAll: self race meeting shortDate;
		nextPut: $,;
		nextPutAll: self race meeting course;
		nextPut: $,;
		nextPutAll: self race shortTime;
		nextPut: $,.
	^result contents
! !
!HRNag categoriesFor: #keyAsCsvString!public! !

!HRNag methodsFor!
liveShow

	^self preRaceShow! !
!HRNag categoriesFor: #liveShow!public! !

!HRNag methodsFor!
myPlaced

	^(self placed and: [self fav])! !
!HRNag categoriesFor: #myPlaced!public! !

!HRNag methodsFor!
mySelect
	mySelect ifNil: [mySelect := false].
	^mySelect! !
!HRNag categoriesFor: #mySelect!public! !

!HRNag methodsFor!
mySelect: anObject
	mySelect := anObject! !
!HRNag categoriesFor: #mySelect:!public! !

!HRNag methodsFor!
nagName
	^self name! !
!HRNag categoriesFor: #nagName!public! !

!HRNag methodsFor!
name
	name ifNil: [self name: ''].
	^name! !
!HRNag categoriesFor: #name!public! !

!HRNag methodsFor!
name: anObject
	name := anObject asUppercase! !
!HRNag categoriesFor: #name:!public! !

!HRNag methodsFor!
nameNoQuotes

	| in out |
	in := self name readStream.
	out := WriteStream on: String new.
	in do: [ :char |
		char isPunctuation ifFalse: [out nextPut: char]].
	^out contents! !
!HRNag categoriesFor: #nameNoQuotes!public! !

!HRNag methodsFor!
noFavourite
	noFavourite ifNil: [self noFavourite: 0].
	^noFavourite! !
!HRNag categoriesFor: #noFavourite!public! !

!HRNag methodsFor!
noFavourite: anObject
	noFavourite := anObject! !
!HRNag categoriesFor: #noFavourite:!public! !

!HRNag methodsFor!
nonRunner

	^self preRaceNR or: [self racePosition displayString sameAs: 'Non runner']
! !
!HRNag categoriesFor: #nonRunner!public! !

!HRNag methodsFor!
outputMyPPSelections
	| result |
	result := String writeStream.
	result 
		nextPutAll: 'No: ';
		nextPutAll: self racecardNo displayString;
		nextPutAll: ' - ';
		nextPutAll: self name.
	HRApplication current fullUnlock ifTrue: [
		result
			padTo: 30 put: $ ;
			nextPutAll: 'odds: ';
			nextPutAll: self bestOdds displayString;
			padTo: 42 put: $ ;
			nextPutAll: 'pp est: ';
			nextPutAll: self ppEst displayString;
			padTo: 54 put: $ ;
			nextPutAll: 'pp val: ';
			nextPutAll: self ppPlaceValueRoundedPercentage displayString].
	result
		nextPutAll: String lineDelimiter.
	^result contents
! !
!HRNag categoriesFor: #outputMyPPSelections!public! !

!HRNag methodsFor!
performVocabDictionaryKey: aKey

	(self vocabDictionary includesKey: aKey) ifTrue: [^self perform: aKey].
	^self race performVocabDictionaryKey: aKey.! !
!HRNag categoriesFor: #performVocabDictionaryKey:!public! !

!HRNag methodsFor!
placeChance
	^self rpPlaceChance! !
!HRNag categoriesFor: #placeChance!public! !

!HRNag methodsFor!
placeChance: anObject
	rpPlaceChance := anObject! !
!HRNag categoriesFor: #placeChance:!public! !

!HRNag methodsFor!
placeChanceBasis

	^self rpGrossChance asFloat roundTo: 0.000001
! !
!HRNag categoriesFor: #placeChanceBasis!public! !

!HRNag methodsFor!
placed
	placed ifNil: [self placed: false].
	^placed! !
!HRNag categoriesFor: #placed!public! !

!HRNag methodsFor!
placed: anObject
	placed := anObject! !
!HRNag categoriesFor: #placed:!public! !

!HRNag methodsFor!
placeOdds
	self placeChance isZero ifTrue: [^0].
	^(((1 - self placeChance) / self placeChance + 1) - 1) asScaledDecimal: 2
! !
!HRNag categoriesFor: #placeOdds!public! !

!HRNag methodsFor!
postmark
	postmark ifNil: [self postmark: 0].
	^postmark! !
!HRNag categoriesFor: #postmark!public! !

!HRNag methodsFor!
postmark: anObject
	postmark := anObject! !
!HRNag categoriesFor: #postmark:!public! !

!HRNag methodsFor!
ppEst
	ppEst ifNil: [ppEst := 0].
	^ppEst! !
!HRNag categoriesFor: #ppEst!public! !

!HRNag methodsFor!
ppEst: anObject
	ppEst := anObject.
! !
!HRNag categoriesFor: #ppEst:!public! !

!HRNag methodsFor!
ppPercentage
	"bug in Omnibase? therefore calculate on the fly"
"	ppPercentage ifNil: [self ppPercentage: 0].
	^ppPercentage
"
	| denom ppVal |
	denom := self race ppCarriedForward.
	(denom == 0) ifTrue: [^0].
	ppVal := self ppValue + (self race favValueFor: self).
	^((self ppValue / denom) asFloat roundTo: 0.000001)
! !
!HRNag categoriesFor: #ppPercentage!public! !

!HRNag methodsFor!
ppPercentage: anObject
	ppPercentage := anObject! !
!HRNag categoriesFor: #ppPercentage:!public! !

!HRNag methodsFor!
ppPercentageAsPercentage
	^(self ppPercentage * 100) asInteger! !
!HRNag categoriesFor: #ppPercentageAsPercentage!public! !

!HRNag methodsFor!
ppPlaceValue
"	ppPlaceValue ifNil: [self setPPPlaceValue]."
	ppPlaceValue ifNil: [self ppPlaceValue: 0].
	^ppPlaceValue! !
!HRNag categoriesFor: #ppPlaceValue!public! !

!HRNag methodsFor!
ppPlaceValue: anObject
	ppPlaceValue := anObject.
! !
!HRNag categoriesFor: #ppPlaceValue:!public! !

!HRNag methodsFor!
ppPlaceValueRoundedPercentage
	^(self ppPlaceValue * 100) asInteger! !
!HRNag categoriesFor: #ppPlaceValueRoundedPercentage!public! !

!HRNag methodsFor!
ppValue
	ppValue ifNil: [self ppValue: 0].
	^ppValue! !
!HRNag categoriesFor: #ppValue!public! !

!HRNag methodsFor!
ppValue: anObject
	ppValue := anObject.
	self setPPPercentage.! !
!HRNag categoriesFor: #ppValue:!public! !

!HRNag methodsFor!
ppValueIncFav

	self isPreRaceFav ifTrue: [^self ppValue + self race ppFav].
	^self ppValue! !
!HRNag categoriesFor: #ppValueIncFav!public! !

!HRNag methodsFor!
preRaceNR
	preRaceNR ifNil: [self preRaceNR: false].
	^preRaceNR! !
!HRNag categoriesFor: #preRaceNR!public! !

!HRNag methodsFor!
preRaceNR: aBool
	preRaceNR := aBool.
	aBool ifTrue: [
		self bfWin addBack: 0 addLay: 0 time: Time now.
		self bfPlace addBack: 0 addLay: 0 time: Time now.
		].! !
!HRNag categoriesFor: #preRaceNR:!public! !

!HRNag methodsFor!
preRaceShow
	preRaceShow ifNil: [self preRaceShow: Array new].
	^preRaceShow! !
!HRNag categoriesFor: #preRaceShow!public! !

!HRNag methodsFor!
preRaceShow: anObject
	anObject isEmpty ifFalse: [self race resetPreRaceFav].
	preRaceShow := anObject! !
!HRNag categoriesFor: #preRaceShow:!public! !

!HRNag methodsFor!
preRaceShow1AsDecimal
	self preRaceShow size < 1 ifTrue: [^''].
	^self preRaceShow first asFloat roundTo: 0.005
! !
!HRNag categoriesFor: #preRaceShow1AsDecimal!public! !

!HRNag methodsFor!
preRaceShow2AsDecimal
	self preRaceShow size < 2 ifTrue: [^''].
	^(self preRaceShow at: 2) asFloat roundTo: 0.005
! !
!HRNag categoriesFor: #preRaceShow2AsDecimal!public! !

!HRNag methodsFor!
preRaceShow3AsDecimal
	self preRaceShow size < 3 ifTrue: [^''].
	^(self preRaceShow at: 3) asFloat roundTo: 0.005
! !
!HRNag categoriesFor: #preRaceShow3AsDecimal!public! !

!HRNag methodsFor!
preRaceShow4AsDecimal
	self preRaceShow size < 4 ifTrue: [^''].
	^(self preRaceShow at: 4) asFloat roundTo: 0.005
! !
!HRNag categoriesFor: #preRaceShow4AsDecimal!public! !

!HRNag methodsFor!
preRaceShow5AsDecimal
	self preRaceShow size < 5 ifTrue: [^''].
	^(self preRaceShow at: 5) asFloat roundTo: 0.005
! !
!HRNag categoriesFor: #preRaceShow5AsDecimal!public! !

!HRNag methodsFor!
preRaceShow6AsDecimal
	self preRaceShow size < 6 ifTrue: [^''].
	^(self preRaceShow at: 6) asFloat roundTo: 0.005
! !
!HRNag categoriesFor: #preRaceShow6AsDecimal!public! !

!HRNag methodsFor!
preRaceShowAsDecimals
	self preRaceShow isEmpty ifTrue: [^0].
	^self preRaceShow collect: [ :each | each asFloat roundTo: 0.005 ]
! !
!HRNag categoriesFor: #preRaceShowAsDecimals!public! !

!HRNag methodsFor!
preRaceShowMaxAsDecimal
	self preRaceShow size < 1 ifTrue: [^''].
	^(self preRaceShow inject: 0 into: [ :max :each | max max: each ]) asFloat roundTo: 0.005
! !
!HRNag categoriesFor: #preRaceShowMaxAsDecimal!public! !

!HRNag methodsFor!
preRaceShowMinAsDecimal
	self preRaceShow size < 1 ifTrue: [^''].
	^(self preRaceShow inject: 9999 into: [ :min :each | min min: each ]) asFloat roundTo: 0.005
! !
!HRNag categoriesFor: #preRaceShowMinAsDecimal!public! !

!HRNag methodsFor!
previewPlaceChance

	previewPlaceChance ifNil: [previewPlaceChance:= 0].
	^previewPlaceChance! !
!HRNag categoriesFor: #previewPlaceChance!public! !

!HRNag methodsFor!
previewPlaceChanceRoundedPercentage
	^(self previewPlaceChance * 100) roundTo: 0.1! !
!HRNag categoriesFor: #previewPlaceChanceRoundedPercentage!public! !

!HRNag methodsFor!
previewPPPlaceValue

	previewPPPlaceValue ifNil: [ previewPPPlaceValue := 0 ].
	^previewPPPlaceValue! !
!HRNag categoriesFor: #previewPPPlaceValue!public! !

!HRNag methodsFor!
priceWise
	priceWise ifNil: [self priceWise: false].
	^priceWise! !
!HRNag categoriesFor: #priceWise!public! !

!HRNag methodsFor!
priceWise: anObject
	priceWise := anObject! !
!HRNag categoriesFor: #priceWise:!public! !

!HRNag methodsFor!
printOn: aStream
	"Overwrite the standard printOn so that the name of the object is shown if the class has a 'name' instance variable"

	aStream 
		basicPrint: self.
	self name isEmpty ifFalse: [
		aStream nextPut: $(;
		display: self name;
		nextPut: $) ].
! !
!HRNag categoriesFor: #printOn:!public! !

!HRNag methodsFor!
proxToFav
	proxToFav ifNil: [self proxToFav: 0].
	^proxToFav! !
!HRNag categoriesFor: #proxToFav!public! !

!HRNag methodsFor!
proxToFav: anObject
	proxToFav := anObject! !
!HRNag categoriesFor: #proxToFav:!public! !

!HRNag methodsFor!
publishedAspects

	^(super publishedAspects)
		add: (Aspect string: #name);
		add: (Aspect string: #jockey);
		add: (Aspect string: #trainer);
		add: (Aspect string: #form);
		add: (Aspect boolean: #rpSpotlightMention);
		add: (Aspect integer: #racecardNo);
		add: (Aspect integer: #racecardPos);
		add: (Aspect boolean: #courseWinner);
		add: (Aspect boolean: #distanceWinner);
		add: (Aspect integer: #daysSinceLastRun);
		add: (Aspect integer: #draw);
		add: (Aspect number: #earlyOdds);
		add: (Aspect number: #rpForecast);
		add: (Aspect number: #slForecast);
		add: (Aspect integer: #noFavourite);
		add: (Aspect integer: #blokeSystemFav);
		add: (Aspect integer: #racePosition);
		add: (Aspect boolean: #placed);
		add: (Aspect float: #ppPercentage);
		add: (Aspect float: #ppValue);
		add: (Aspect number: #slFinalOdds);
		yourself! !
!HRNag categoriesFor: #publishedAspects!public! !

!HRNag methodsFor!
race
	race ifNil: [self race: HRRace new].
	^race! !
!HRNag categoriesFor: #race!public! !

!HRNag methodsFor!
race: anObject
	race := anObject! !
!HRNag categoriesFor: #race:!public! !

!HRNag methodsFor!
racecardNo
	racecardNo ifNil: [self racecardNo: ''].
	^racecardNo! !
!HRNag categoriesFor: #racecardNo!public! !

!HRNag methodsFor!
racecardNo: anObject
	racecardNo := anObject! !
!HRNag categoriesFor: #racecardNo:!public! !

!HRNag methodsFor!
racecardNoAsNumber
	self racecardNo isEmpty ifTrue: [^99].
	self racecardNo first isLetter ifTrue: [^Number fromString: (self racecardNo copyFrom: 2 to: self racecardNo size)].
	^Number fromString: self racecardNo! !
!HRNag categoriesFor: #racecardNoAsNumber!public! !

!HRNag methodsFor!
racecardPos
	racecardPos ifNil: [self racecardPos: 0].
	^racecardPos! !
!HRNag categoriesFor: #racecardPos!public! !

!HRNag methodsFor!
racecardPos: anObject
	racecardPos := anObject! !
!HRNag categoriesFor: #racecardPos:!public! !

!HRNag methodsFor!
racePosIsNum
	^self racePosition understandsArithmetic
! !
!HRNag categoriesFor: #racePosIsNum!public! !

!HRNag methodsFor!
racePosition
	racePosition ifNil: [self racePosition: 0].
	^racePosition! !
!HRNag categoriesFor: #racePosition!public! !

!HRNag methodsFor!
racePosition: anObject
	racePosition := anObject! !
!HRNag categoriesFor: #racePosition:!public! !

!HRNag methodsFor!
racePosNoFinish
	self racePosIsNum ifTrue: [^''].
	^self racePosition! !
!HRNag categoriesFor: #racePosNoFinish!public! !

!HRNag methodsFor!
racePosNum
	self racePosIsNum ifFalse: [^0].
	^self racePosition! !
!HRNag categoriesFor: #racePosNum!public! !

!HRNag methodsFor!
rpBfDiff

	self rpForecast isZero ifTrue: [ ^0].
	self bfOdds isZero ifTrue: [ ^0].
	^(self bfOdds - self rpForecastAsDecimal) roundTo: 0.01! !
!HRNag categoriesFor: #rpBfDiff!public! !

!HRNag methodsFor!
rpChance
	"chance based on rpForecast"
"	^self rpNetChance"
	^self rpPlaceChance! !
!HRNag categoriesFor: #rpChance!public! !

!HRNag methodsFor!
rpChanceRoundedPercentage
	^(self rpChance * 100) roundTo: 0.1! !
!HRNag categoriesFor: #rpChanceRoundedPercentage!public! !

!HRNag methodsFor!
rpForecast
	rpForecast ifNil: [self rpForecast: 0].
	^rpForecast! !
!HRNag categoriesFor: #rpForecast!public! !

!HRNag methodsFor!
rpForecast: anObject
	anObject isZero ifFalse: [self race resetPreRaceFav].
	rpForecast := anObject! !
!HRNag categoriesFor: #rpForecast:!public! !

!HRNag methodsFor!
rpForecastAsDecimal
	rpForecast ifNil: [self rpForecast: 0].
	^rpForecast asFloat roundTo: 0.005
! !
!HRNag categoriesFor: #rpForecastAsDecimal!public! !

!HRNag methodsFor!
rpGrossChance
	"chance based on rpForecast"
	self rpForecast isZero ifTrue: [^0].
	^1/(1 + self rpForecast)! !
!HRNag categoriesFor: #rpGrossChance!public! !

!HRNag methodsFor!
rpNetChance
	"chance based on rpForecast"
	^(self rpGrossChance) / (1 + self race rpMargin)! !
!HRNag categoriesFor: #rpNetChance!public! !

!HRNag methodsFor!
rpPlaceChance
"	rpPlaceChance ifNil: [self race setRPPlaceChanceAndPPPlaceValue]."
	rpPlaceChance ifNil: [self rpPlaceChance: 0].
	^rpPlaceChance! !
!HRNag categoriesFor: #rpPlaceChance!public! !

!HRNag methodsFor!
rpPlaceChance: anObject
	rpPlaceChance := anObject! !
!HRNag categoriesFor: #rpPlaceChance:!public! !

!HRNag methodsFor!
rpSpotlightMention
	rpSpotlightMention ifNil: [self rpSpotlightMention: 0].
	^rpSpotlightMention! !
!HRNag categoriesFor: #rpSpotlightMention!public! !

!HRNag methodsFor!
rpSpotlightMention: anObject
	rpSpotlightMention := anObject! !
!HRNag categoriesFor: #rpSpotlightMention:!public! !

!HRNag methodsFor!
rpValueOnPP

"	^(self rpChance - self ppPercentage) asFloat * 100"
	^(self ppPlaceValue * 100) asInteger! !
!HRNag categoriesFor: #rpValueOnPP!public! !

!HRNag methodsFor!
setPPPercentage
	| denom |
	denom := self race ppCarriedForward.
	(denom == 0) 
		ifTrue: [self ppPercentage: 0]
		ifFalse: [self ppPercentage: ((self ppValue / denom) asFloat roundTo: 0.0005)].! !
!HRNag categoriesFor: #setPPPercentage!public! !

!HRNag methodsFor!
setPPPercentageToZero
	"bug in Omnibase? Can't handle floats?"
	ppPercentage := 0
! !
!HRNag categoriesFor: #setPPPercentageToZero!public! !

!HRNag methodsFor!
setPPPlaceValue
	^self race setRPPlaceChanceAndPPPlaceValue! !
!HRNag categoriesFor: #setPPPlaceValue!public! !

!HRNag methodsFor!
setRPPlaceChance
	^self race setRPPlaceChanceAndPPPlaceValue! !
!HRNag categoriesFor: #setRPPlaceChance!public! !

!HRNag methodsFor!
slFinalOdds
	slFinalOdds ifNil: [self slFinalOdds: 0].
	^slFinalOdds! !
!HRNag categoriesFor: #slFinalOdds!public! !

!HRNag methodsFor!
slFinalOdds: anObject
	slFinalOdds := anObject! !
!HRNag categoriesFor: #slFinalOdds:!public! !

!HRNag methodsFor!
slFinalOddsAsDecimal
	slFinalOdds ifNil: [self slFinalOdds: 0].
	^slFinalOdds asFloat roundTo: 0.005
! !
!HRNag categoriesFor: #slFinalOddsAsDecimal!public! !

!HRNag methodsFor!
slForecast
	slForecast ifNil: [self slForecast: 0].
	^slForecast! !
!HRNag categoriesFor: #slForecast!public! !

!HRNag methodsFor!
slForecast: anObject
	anObject isZero ifFalse: [self race resetPreRaceFav].
	slForecast := anObject! !
!HRNag categoriesFor: #slForecast:!public! !

!HRNag methodsFor!
slForecastAsDecimal
	slForecast ifNil: [self slForecast: 0].
	^slForecast asFloat roundTo: 0.005
! !
!HRNag categoriesFor: #slForecastAsDecimal!public! !

!HRNag methodsFor!
stopwatchRating
	stopwatchRating ifNil: [self stopwatchRating: 0].
	^stopwatchRating! !
!HRNag categoriesFor: #stopwatchRating!public! !

!HRNag methodsFor!
stopwatchRating: anObject
	stopwatchRating := anObject! !
!HRNag categoriesFor: #stopwatchRating:!public! !

!HRNag methodsFor!
totePlaceDivi
	totePlaceDivi ifNil: [self totePlaceDivi: 0].
	^totePlaceDivi! !
!HRNag categoriesFor: #totePlaceDivi!public! !

!HRNag methodsFor!
totePlaceDivi: anObject
	totePlaceDivi := anObject! !
!HRNag categoriesFor: #totePlaceDivi:!public! !

!HRNag methodsFor!
toteWinDivi
	toteWinDivi ifNil: [self toteWinDivi: 0].
	^toteWinDivi! !
!HRNag categoriesFor: #toteWinDivi!public! !

!HRNag methodsFor!
toteWinDivi: anObject
	toteWinDivi := anObject! !
!HRNag categoriesFor: #toteWinDivi:!public! !

!HRNag methodsFor!
trainer
	trainer ifNil: [self trainer: ''].
	^trainer! !
!HRNag categoriesFor: #trainer!public! !

!HRNag methodsFor!
trainer: anObject
	trainer := anObject asUppercase! !
!HRNag categoriesFor: #trainer:!public! !

!HRNag methodsFor!
value

"	self nonRunner ifTrue: [ ^-999999]."
	^self rpValueOnPP
! !
!HRNag categoriesFor: #value!public! !

!HRNag categoriesFor: #addBFPlace:at:!public! !

!HRNag categoriesFor: #addBFWin:at:!public! !

!HRNag categoriesFor: #asCsvString!public! !

!HRNag categoriesFor: #asCsvStringAll!public! !

!HRNag categoriesFor: #baseNag!public! !

!HRNag categoriesFor: #bestOdds!public! !

!HRNag categoriesFor: #betfairSummary!public! !

!HRNag categoriesFor: #betterValueThan:!public! !

!HRNag categoriesFor: #bfID!accessing!private! !

!HRNag categoriesFor: #bfID:!accessing!private! !

!HRNag categoriesFor: #bfLay!accessing!private! !

!HRNag categoriesFor: #bfLay:!accessing!private! !

!HRNag categoriesFor: #bfLayOdds!accessing!private! !

!HRNag categoriesFor: #bfMiddle!public! !

!HRNag categoriesFor: #bfMiddle:!public! !

!HRNag categoriesFor: #bfNagTO!accessing!private! !

!HRNag categoriesFor: #bfNagTO:!accessing!private! !

!HRNag categoriesFor: #bfOdds!public! !

!HRNag categoriesFor: #bfPlace!accessing!private! !

!HRNag categoriesFor: #bfPlaceDirection!accessing!private! !

!HRNag categoriesFor: #bfPlaceID!accessing!private! !

!HRNag categoriesFor: #bfPlaceID:!accessing!private! !

!HRNag categoriesFor: #bfPlaceLay!accessing!private! !

!HRNag categoriesFor: #bfPlaceLayOdds!accessing!private! !

!HRNag categoriesFor: #bfPlaceMiddle!public! !

!HRNag categoriesFor: #bfPlaceNagTO!accessing!private! !

!HRNag categoriesFor: #bfPlaceOdds!public! !

!HRNag categoriesFor: #bfPlacePut!accessing!private! !

!HRNag categoriesFor: #bfPlacePutOdds!accessing!private! !

!HRNag categoriesFor: #bfPlaceRaceTO!accessing!private! !

!HRNag categoriesFor: #bfPut!accessing!private! !

!HRNag categoriesFor: #bfPut:!accessing!private! !

!HRNag categoriesFor: #bfPutOdds!accessing!private! !

!HRNag categoriesFor: #bfRaceTO!accessing!private! !

!HRNag categoriesFor: #bfRaceTO:!accessing!private! !

!HRNag categoriesFor: #bfWin!accessing!private! !

!HRNag categoriesFor: #bfWinDirection!accessing!private! !

!HRNag categoriesFor: #bfWinID!accessing!private! !

!HRNag categoriesFor: #bfWinID:!accessing!private! !

!HRNag categoriesFor: #bfWinLay!accessing!private! !

!HRNag categoriesFor: #bfWinLayOdds!accessing!private! !

!HRNag categoriesFor: #bfWinMiddle!public! !

!HRNag categoriesFor: #bfWinNagTO!accessing!private! !

!HRNag categoriesFor: #bfWinOdds!public! !

!HRNag categoriesFor: #bfWinOddsAtPPOff!public! !

!HRNag categoriesFor: #bfWinPut!accessing!private! !

!HRNag categoriesFor: #bfWinPutOdds!accessing!private! !

!HRNag categoriesFor: #bfWinRaceTO!accessing!private! !

!HRNag categoriesFor: #blokeSystemFav!accessing!private! !

!HRNag categoriesFor: #blokeSystemFav:!accessing!private! !

!HRNag categoriesFor: #compareBestOddsWith:!public! !

!HRNag categoriesFor: #compareBFOddsWith:!public! !

!HRNag categoriesFor: #compareRpForecastWith:!public! !

!HRNag categoriesFor: #compareSlFinalOddsWith:!public! !

!HRNag categoriesFor: #copyPreviews!public! !

!HRNag categoriesFor: #courseWinner!accessing!private! !

!HRNag categoriesFor: #courseWinner:!accessing!private! !

!HRNag categoriesFor: #daysSinceLastRun!accessing!public! !

!HRNag categoriesFor: #daysSinceLastRun:!accessing!private! !

!HRNag categoriesFor: #daysSinceLastRunAsNumber!accessing!private! !

!HRNag categoriesFor: #distanceWinner!accessing!private! !

!HRNag categoriesFor: #distanceWinner:!accessing!private! !

!HRNag categoriesFor: #draw!accessing!public! !

!HRNag categoriesFor: #draw:!accessing!private! !

!HRNag categoriesFor: #drawAsNumber!accessing!public! !

!HRNag categoriesFor: #earlyOdds!accessing!private! !

!HRNag categoriesFor: #earlyOdds:!accessing!private! !

!HRNag categoriesFor: #earlyOddsAsDecimal!accessing!private! !

!HRNag categoriesFor: #estRatio!public! !

!HRNag categoriesFor: #fineformRating!accessing!private! !

!HRNag categoriesFor: #fineformRating:!accessing!private! !

!HRNag categoriesFor: #form!accessing!private! !

!HRNag categoriesFor: #form:!accessing!private! !

!HRNag categoriesFor: #formPoints!public! !

!HRNag categoriesFor: #formWithQuotes!accessing!private! !

!HRNag categoriesFor: #hasLiveShow!public! !

!HRNag categoriesFor: #jockey!accessing!private! !

!HRNag categoriesFor: #jockey:!accessing!private! !

!HRNag categoriesFor: #keyAsCsvString!public! !

!HRNag categoriesFor: #liveShow!public! !

!HRNag categoriesFor: #myPlaced!public! !

!HRNag categoriesFor: #mySelect!accessing!private! !

!HRNag categoriesFor: #mySelect:!accessing!private! !

!HRNag categoriesFor: #nagName!accessing!private! !

!HRNag categoriesFor: #name!accessing!private! !

!HRNag categoriesFor: #name:!accessing!private! !

!HRNag categoriesFor: #nameNoQuotes!public! !

!HRNag categoriesFor: #noFavourite!accessing!private! !

!HRNag categoriesFor: #noFavourite:!accessing!private! !

!HRNag categoriesFor: #nonRunner!public! !

!HRNag categoriesFor: #outputMyPPSelections!public! !

!HRNag categoriesFor: #performVocabDictionaryKey:!public! !

!HRNag categoriesFor: #placeChance!public! !

!HRNag categoriesFor: #placeChance:!public! !

!HRNag categoriesFor: #placeChanceBasis!public! !

!HRNag categoriesFor: #placed!accessing!private! !

!HRNag categoriesFor: #placed:!accessing!private! !

!HRNag categoriesFor: #placeOdds!public! !

!HRNag categoriesFor: #postmark!accessing!private! !

!HRNag categoriesFor: #postmark:!accessing!private! !

!HRNag categoriesFor: #ppEst!accessing!private! !

!HRNag categoriesFor: #ppEst:!accessing!private! !

!HRNag categoriesFor: #ppPercentage!accessing!public! !

!HRNag categoriesFor: #ppPercentage:!accessing!private! !

!HRNag categoriesFor: #ppPercentageAsPercentage!accessing!private! !

!HRNag categoriesFor: #ppPlaceValue!public! !

!HRNag categoriesFor: #ppPlaceValue:!public! !

!HRNag categoriesFor: #ppPlaceValueRoundedPercentage!public! !

!HRNag categoriesFor: #ppValue!accessing!private! !

!HRNag categoriesFor: #ppValue:!accessing!private! !

!HRNag categoriesFor: #ppValueIncFav!accessing!private! !

!HRNag categoriesFor: #preRaceNR!accessing!private! !

!HRNag categoriesFor: #preRaceNR:!accessing!private! !

!HRNag categoriesFor: #preRaceShow!accessing!private! !

!HRNag categoriesFor: #preRaceShow:!accessing!private! !

!HRNag categoriesFor: #preRaceShow1AsDecimal!accessing!private! !

!HRNag categoriesFor: #preRaceShow2AsDecimal!accessing!private! !

!HRNag categoriesFor: #preRaceShow3AsDecimal!accessing!private! !

!HRNag categoriesFor: #preRaceShow4AsDecimal!accessing!private! !

!HRNag categoriesFor: #preRaceShow5AsDecimal!accessing!private! !

!HRNag categoriesFor: #preRaceShow6AsDecimal!accessing!private! !

!HRNag categoriesFor: #preRaceShowAsDecimals!accessing!private! !

!HRNag categoriesFor: #preRaceShowMaxAsDecimal!accessing!private! !

!HRNag categoriesFor: #preRaceShowMinAsDecimal!accessing!private! !

!HRNag categoriesFor: #previewPlaceChance!public! !

!HRNag categoriesFor: #previewPlaceChanceRoundedPercentage!public! !

!HRNag categoriesFor: #previewPPPlaceValue!public! !

!HRNag categoriesFor: #priceWise!accessing!private! !

!HRNag categoriesFor: #priceWise:!accessing!private! !

!HRNag categoriesFor: #printOn:!displaying!public! !

!HRNag categoriesFor: #proxToFav!accessing!private! !

!HRNag categoriesFor: #proxToFav:!accessing!private! !

!HRNag categoriesFor: #publishedAspects!development!must strip!public! !

!HRNag categoriesFor: #race!accessing!private! !

!HRNag categoriesFor: #race:!accessing!private! !

!HRNag categoriesFor: #racecardNo!accessing!public! !

!HRNag categoriesFor: #racecardNo:!accessing!private! !

!HRNag categoriesFor: #racecardNoAsNumber!accessing!public! !

!HRNag categoriesFor: #racecardPos!accessing!private! !

!HRNag categoriesFor: #racecardPos:!accessing!private! !

!HRNag categoriesFor: #racePosIsNum!accessing!private! !

!HRNag categoriesFor: #racePosition!accessing!private! !

!HRNag categoriesFor: #racePosition:!accessing!private! !

!HRNag categoriesFor: #racePosNoFinish!accessing!private! !

!HRNag categoriesFor: #racePosNum!accessing!private! !

!HRNag categoriesFor: #rpBfDiff!public! !

!HRNag categoriesFor: #rpChance!public! !

!HRNag categoriesFor: #rpChanceRoundedPercentage!public! !

!HRNag categoriesFor: #rpForecast!accessing!private! !

!HRNag categoriesFor: #rpForecast:!accessing!private! !

!HRNag categoriesFor: #rpForecastAsDecimal!accessing!private! !

!HRNag categoriesFor: #rpGrossChance!public! !

!HRNag categoriesFor: #rpNetChance!public! !

!HRNag categoriesFor: #rpPlaceChance!public! !

!HRNag categoriesFor: #rpPlaceChance:!public! !

!HRNag categoriesFor: #rpSpotlightMention!accessing!private! !

!HRNag categoriesFor: #rpSpotlightMention:!accessing!private! !

!HRNag categoriesFor: #rpValueOnPP!public! !

!HRNag categoriesFor: #setPPPercentage!public! !

!HRNag categoriesFor: #setPPPercentageToZero!public! !

!HRNag categoriesFor: #setPPPlaceValue!public! !

!HRNag categoriesFor: #setRPPlaceChance!public! !

!HRNag categoriesFor: #slFinalOdds!accessing!private! !

!HRNag categoriesFor: #slFinalOdds:!accessing!private! !

!HRNag categoriesFor: #slFinalOddsAsDecimal!accessing!private! !

!HRNag categoriesFor: #slForecast!accessing!private! !

!HRNag categoriesFor: #slForecast:!accessing!private! !

!HRNag categoriesFor: #slForecastAsDecimal!accessing!private! !

!HRNag categoriesFor: #stopwatchRating!accessing!private! !

!HRNag categoriesFor: #stopwatchRating:!accessing!private! !

!HRNag categoriesFor: #totePlaceDivi!accessing!private! !

!HRNag categoriesFor: #totePlaceDivi:!accessing!private! !

!HRNag categoriesFor: #toteWinDivi!accessing!private! !

!HRNag categoriesFor: #toteWinDivi:!accessing!private! !

!HRNag categoriesFor: #trainer!accessing!private! !

!HRNag categoriesFor: #trainer:!accessing!private! !

!HRNag categoriesFor: #value!public! !

!HRNag class methodsFor!
asCsvStringWith: anArray

	| result |
	result := String writeStream.
	anArray do: [ :each | result nextPutAll: (self vocabDictionaryAt: each); nextPut: $, ].
	^result contents
! !
!HRNag class categoriesFor: #asCsvStringWith:!public! !

!HRNag class methodsFor!
csvStringHeader

^'no,name,jockey,trainer,form,SpotlightMention,noFavourite,rpForecast,slForecast,betfair,bf-rp,live shows,sp,pre-race n/r,racePosition,placed,ppValue,ppPerc,ppEst,Place %,PP Value,Orig Place %,Orig PP Value,My Picks'! !
!HRNag class categoriesFor: #csvStringHeader!public! !

!HRNag class methodsFor!
csvStringHeaderAll

	| result |
	result := String writeStream.
	result nextPutAll: self keyHeaderAsCsvString.
	self vocabDictionary associationsDo: [ :each | result nextPutAll: each value; nextPut: $, ].
	^result contents! !
!HRNag class categoriesFor: #csvStringHeaderAll!public! !

!HRNag class methodsFor!
keyHeaderAsCsvString

	^'Date,Course,Tme,'! !
!HRNag class categoriesFor: #keyHeaderAsCsvString!public! !

!HRNag class methodsFor!
setVocabDictionary

	vocabDictionary := Dictionary new.
	vocabDictionary 
		at: #courseWinner put: 'Course winner';
		at: #daysSinceLastRunAsNumber put: 'Days since last run';
		at: #distanceWinner put: 'Distance winner';
		at: #drawAsNumber put: 'Draw';
		at: #earlyOdds put: 'Early odds';
		at: #earlyOddsAsDecimal put: 'Early odds (dec)';
		at: #fineformRating put: 'Fineform rating';
		at: #formWithQuotes put: 'Form';
		at: #jockey put: 'Jockey';
		at: #nagName put: 'Nag name';
		at: #noFavourite put: 'Number favourite';
		at: #placed put: 'Placed';
		at: #postmark put: 'Postmark';
		at: #ppPercentage put: 'PP percentage';
		at: #ppPercentageAsPercentage put: 'PP percentage (as %age)';
		at: #ppValue put: 'PP value';
		at: #preRaceShow put: 'Pre-race show';
		at: #preRaceShowAsDecimals put: 'Pre-race show (dec)';
		at: #preRaceShow1AsDecimal put: 'Pre-race show 1 (dec)';
		at: #preRaceShow2AsDecimal put: 'Pre-race show 2 (dec)';
		at: #preRaceShow3AsDecimal put: 'Pre-race show 3 (dec)';
		at: #preRaceShow4AsDecimal put: 'Pre-race show 4 (dec)';
		at: #preRaceShow5AsDecimal put: 'Pre-race show 5 (dec)';
		at: #preRaceShow6AsDecimal put: 'Pre-race show 6 (dec)';
		at: #preRaceShowMaxAsDecimal put: 'Max Pre-race show (dec)';
		at: #preRaceShowMinAsDecimal put: 'Min Pre-race show (dec)';
		at: #preRaceNR put: 'Pre-race N/R';
		at: #priceWise put: 'Pricewise horse';
		at: #proxToFav put: 'Proximity to Favourite';
		at: #racecardNo put: 'Racecard number';
		at: #racecardPos put: 'Racecard position';
		at: #racePosition put: 'Race position';
		at: #rpForecast put: 'RP Forecast';
		at: #rpForecastAsDecimal put: 'RP Forecast (dec)';
		at: #rpSpotlightMention put: 'Spotlight mention';
		at: #slFinalOdds put: 'SP';
		at: #slFinalOddsAsDecimal put: 'SP (dec)';
		at: #slForecast put: 'SL Forecast';
		at: #slForecastAsDecimal put: 'SL Forecast (dec)';
		at: #stopwatchRating put: 'Stopwatch rating';
		at: #totePlaceDivi put: 'Tote place divi';
		at: #toteWinDivi put: 'Tote win divi';
		at: #trainer put: 'Trainer';
		at: #rpChanceRoundedPercentage put: 'RP Chance';
		at: #rpValueOnPP put: 'RP value';
		at: #ppEst put: 'PP estimate';
		at: #mySelect put: 'My selection'.
! !
!HRNag class categoriesFor: #setVocabDictionary!public! !

!HRNag class methodsFor!
stbConvertFrom: anSTBClassFormat
	"Convert from earlier version models.
	1: see Model.
	2: Added 'preRaceNR'.
	3: Added 'rpPlaceChance' and 'ppPlaceValue'.
	4: Added ppEst and mySelect. 
	5: Added bfNagTO
	6: Added previewPlaceChance and previewPPPlaceValue
	7: Added bfWin bfPlace bfWinID bfPlaceID"

	^[:data | | newInst |
		newInst := self basicNew.
		1 to: data size do: [ :i | newInst instVarAt: i put: (data at: i)].
		newInst]
! !
!HRNag class categoriesFor: #stbConvertFrom:!public! !

!HRNag class methodsFor!
stbVersion
	"Answer the current binary filer version number for instances of the receiver."

	^7! !
!HRNag class categoriesFor: #stbVersion!public! !

!HRNag class categoriesFor: #asCsvStringWith:!public! !

!HRNag class categoriesFor: #csvStringHeader!public! !

!HRNag class categoriesFor: #csvStringHeaderAll!public! !

!HRNag class categoriesFor: #keyHeaderAsCsvString!public! !

!HRNag class categoriesFor: #setVocabDictionary!public! !

!HRNag class categoriesFor: #stbConvertFrom:!public! !

!HRNag class categoriesFor: #stbVersion!public! !

HRNagStrat guid: (GUID fromString: '{8DBD16CF-0EDF-41AC-9D3E-597C89E59944}')!

HRNagStrat guid: (GUID fromString: '{8DBD16CF-0EDF-41AC-9D3E-597C89E59944}')!
HRNagStrat comment: ''!

HRNagStrat comment:
''!
!HRNagStrat categoriesForClass!MVP-Models! !
!HRNagStrat methodsFor!
asCsvString
	| result |
	result := String writeStream.
	result 
		nextPutAll: self predecessor asCsvString;
		nextPut: $,.
	result nextPutAll: self favOrBlank;
		nextPut: $,;
		nextPutAll: self stratPlacedOrBlank.
"	result nextPut: $,;
		nextPutAll: self decoratorSpecificStuff;
		nextPut: $,;
		nextPutAll: self moreDecoratorSpecificStuff displayString."
	^result contents
! !
!HRNagStrat categoriesFor: #asCsvString!public! !

!HRNagStrat methodsFor!
doesNotUnderstand: aMessage
	"The receiver has not understood aMessage. Most likely this is because it was intended for
	the originator so we forward it up the chain."

	^aMessage forwardTo: predecessor! !
!HRNagStrat categoriesFor: #doesNotUnderstand:!public! !

!HRNagStrat methodsFor!
fav
	^fav! !
!HRNagStrat categoriesFor: #fav!public! !

!HRNagStrat methodsFor!
fav: anObject
	fav := anObject! !
!HRNagStrat categoriesFor: #fav:!public! !

!HRNagStrat methodsFor!
favOrBlank
	fav isNil ifTrue: [^''].
	^fav displayString! !
!HRNagStrat categoriesFor: #favOrBlank!public! !

!HRNagStrat methodsFor!
isPreRaceFav

	^self predecessor isPreRaceFav! !
!HRNagStrat categoriesFor: #isPreRaceFav!public! !

!HRNagStrat methodsFor!
performVocabDictionaryKey: aKey

	| result |
	(self vocabDictionary includesKey: aKey) ifTrue: [^self perform: aKey].
	result := self race performVocabDictionaryKey: aKey.
	(result = '') ifTrue: [result := self predecessor performVocabDictionaryKey: aKey].
	^result! !
!HRNagStrat categoriesFor: #performVocabDictionaryKey:!public! !

!HRNagStrat methodsFor!
predecessor
	^predecessor! !
!HRNagStrat categoriesFor: #predecessor!public! !

!HRNagStrat methodsFor!
predecessor: anObject
	predecessor := anObject! !
!HRNagStrat categoriesFor: #predecessor:!public! !

!HRNagStrat methodsFor!
race
	^race! !
!HRNagStrat categoriesFor: #race!public! !

!HRNagStrat methodsFor!
race: anObject
	race := anObject! !
!HRNagStrat categoriesFor: #race:!public! !

!HRNagStrat methodsFor!
stratPlaced

	^(self placed and: [self fav notNil])! !
!HRNagStrat categoriesFor: #stratPlaced!public! !

!HRNagStrat methodsFor!
stratPlacedOrBlank

	self stratPlaced ifTrue: [^true displayString].
	^''! !
!HRNagStrat categoriesFor: #stratPlacedOrBlank!public! !

!HRNagStrat methodsFor!
vocabDictionaryAt: aKey

	| result |
	result := self class vocabDictionaryAt: aKey.
	(result = '') ifTrue: [ result := self predecessor vocabDictionaryAt: aKey ].
	^result! !
!HRNagStrat categoriesFor: #vocabDictionaryAt:!public! !

!HRNagStrat categoriesFor: #asCsvString!public! !

!HRNagStrat categoriesFor: #doesNotUnderstand:!exceptions!public! !

!HRNagStrat categoriesFor: #fav!accessing!private! !

!HRNagStrat categoriesFor: #fav:!accessing!private! !

!HRNagStrat categoriesFor: #favOrBlank!accessing!private! !

!HRNagStrat categoriesFor: #isPreRaceFav!public! !

!HRNagStrat categoriesFor: #performVocabDictionaryKey:!public! !

!HRNagStrat categoriesFor: #predecessor!accessing!private! !

!HRNagStrat categoriesFor: #predecessor:!accessing!private! !

!HRNagStrat categoriesFor: #race!accessing!private! !

!HRNagStrat categoriesFor: #race:!accessing!private! !

!HRNagStrat categoriesFor: #stratPlaced!public! !

!HRNagStrat categoriesFor: #stratPlacedOrBlank!public! !

!HRNagStrat categoriesFor: #vocabDictionaryAt:!public! !

!HRNagStrat class methodsFor!
csvStringHeader

	^'' "this class specific nag header"! !
!HRNagStrat class categoriesFor: #csvStringHeader!public! !

!HRNagStrat class methodsFor!
on: aPredecessor

	^self new predecessor: aPredecessor! !
!HRNagStrat class categoriesFor: #on:!public! !

!HRNagStrat class methodsFor!
predecessor: aPredecessor

	^self new predecessor: aPredecessor! !
!HRNagStrat class categoriesFor: #predecessor:!public! !

!HRNagStrat class categoriesFor: #csvStringHeader!public! !

!HRNagStrat class categoriesFor: #on:!public! !

!HRNagStrat class categoriesFor: #predecessor:!public! !

HRBlokeSystemNag guid: (GUID fromString: '{2FBEBB44-91BA-4EED-B6C2-B3E097D2F741}')!

HRBlokeSystemNag guid: (GUID fromString: '{2FBEBB44-91BA-4EED-B6C2-B3E097D2F741}')!
HRBlokeSystemNag comment: ''!

HRBlokeSystemNag comment:
''!
!HRBlokeSystemNag categoriesForClass!MVP-Models! !
!HRBlokeSystemNag methodsFor!
bsFav

	^self favOrBlank! !
!HRBlokeSystemNag categoriesFor: #bsFav!public! !

!HRBlokeSystemNag methodsFor!
bsPlaced

	^self stratPlacedOrBlank! !
!HRBlokeSystemNag categoriesFor: #bsPlaced!public! !

!HRBlokeSystemNag categoriesFor: #bsFav!public! !

!HRBlokeSystemNag categoriesFor: #bsPlaced!public! !

!HRBlokeSystemNag class methodsFor!
csvStringHeader

	^',BS Fav,BS Placed' "this class specific nag header"! !
!HRBlokeSystemNag class categoriesFor: #csvStringHeader!public! !

!HRBlokeSystemNag class methodsFor!
setVocabDictionary

	vocabDictionary := Dictionary new.
	vocabDictionary 
		at: #bsFav put: 'Bloke system Fav';
		at: #bsPlaced put: 'Bloke system Placed'.
! !
!HRBlokeSystemNag class categoriesFor: #setVocabDictionary!public! !

!HRBlokeSystemNag class categoriesFor: #csvStringHeader!public! !

!HRBlokeSystemNag class categoriesFor: #setVocabDictionary!public! !

HRMyNag guid: (GUID fromString: '{5B8E115A-0757-4023-B26F-D2009A711D09}')!

HRMyNag guid: (GUID fromString: '{5B8E115A-0757-4023-B26F-D2009A711D09}')!
HRMyNag comment: ''!

HRMyNag comment:
''!
!HRMyNag categoriesForClass!MVP-Models! !
!HRMyNag methodsFor!
asCsvString
	| result |
	result := String writeStream.
	result 
		nextPutAll: self predecessor asCsvString;
		nextPut: $,.
	result nextPutAll: self stratPlacedOrBlank.
	^result contents
! !
!HRMyNag categoriesFor: #asCsvString!public! !

!HRMyNag methodsFor!
fav
	^self mySelect! !
!HRMyNag categoriesFor: #fav!public! !

!HRMyNag methodsFor!
stratPlaced

	^(self placed and: [self fav])! !
!HRMyNag categoriesFor: #stratPlaced!public! !

!HRMyNag categoriesFor: #asCsvString!public! !

!HRMyNag categoriesFor: #fav!public! !

!HRMyNag categoriesFor: #stratPlaced!public! !

!HRMyNag class methodsFor!
csvStringHeader

	^',My Placed' "this class specific nag header"! !
!HRMyNag class categoriesFor: #csvStringHeader!public! !

!HRMyNag class categoriesFor: #csvStringHeader!public! !

HRNagPlaceCalc guid: (GUID fromString: '{0D3FE344-E94D-4B48-860C-2F30E8ECCC8A}')!

HRNagPlaceCalc guid: (GUID fromString: '{0D3FE344-E94D-4B48-860C-2F30E8ECCC8A}')!
HRNagPlaceCalc comment: ''!

HRNagPlaceCalc comment:
''!
!HRNagPlaceCalc categoriesForClass!MVP-Models! !
!HRNagPlaceCalc methodsFor!
asCsvString
	| result |
	result := String writeStream.
	result 
		nextPutAll: self predecessor asCsvString.
	^result contents
! !
!HRNagPlaceCalc categoriesFor: #asCsvString!public! !

!HRNagPlaceCalc methodsFor!
placeChance
	placeChance ifNil: [self placeChance: 0].
	^placeChance! !
!HRNagPlaceCalc categoriesFor: #placeChance!public! !

!HRNagPlaceCalc methodsFor!
placeChance: aFloat
	placeChance := aFloat! !
!HRNagPlaceCalc categoriesFor: #placeChance:!public! !

!HRNagPlaceCalc methodsFor!
placeChanceBasis

	placeChanceBasis ifNil: [ self setPlaceChanceBasis ].
	^placeChanceBasis
! !
!HRNagPlaceCalc categoriesFor: #placeChanceBasis!public! !

!HRNagPlaceCalc methodsFor!
placeChanceBasis: aFloat

	placeChanceBasis := aFloat! !
!HRNagPlaceCalc categoriesFor: #placeChanceBasis:!public! !

!HRNagPlaceCalc methodsFor!
placeChanceRoundedPercentage
	^(self placeChance * 100) roundTo: 0.1! !
!HRNagPlaceCalc categoriesFor: #placeChanceRoundedPercentage!public! !

!HRNagPlaceCalc methodsFor!
ppLeg1Est

	ppLeg1Est ifNil: [ppLeg1Est := 0].
	^ppLeg1Est! !
!HRNagPlaceCalc categoriesFor: #ppLeg1Est!public! !

!HRNagPlaceCalc methodsFor!
ppLeg1Est: anObject
	ppLeg1Est := anObject! !
!HRNagPlaceCalc categoriesFor: #ppLeg1Est:!public! !

!HRNagPlaceCalc methodsFor!
ppPercentage
	ppPercentage ifNil: [self setPPPercentage].
	^ppPercentage
! !
!HRNagPlaceCalc categoriesFor: #ppPercentage!public! !

!HRNagPlaceCalc methodsFor!
ppPercentage: anObject
	ppPercentage := anObject! !
!HRNagPlaceCalc categoriesFor: #ppPercentage:!public! !

!HRNagPlaceCalc methodsFor!
ppPercIncFav

	ppPercIncFav ifNil: [self setPPPercIncFav].
	^ppPercIncFav! !
!HRNagPlaceCalc categoriesFor: #ppPercIncFav!public! !

!HRNagPlaceCalc methodsFor!
ppPercIncFav: aValue

	ppPercIncFav := aValue
! !
!HRNagPlaceCalc categoriesFor: #ppPercIncFav:!public! !

!HRNagPlaceCalc methodsFor!
ppPlaceValue
	ppPlaceValue ifNil: [self ppPlaceValue: 0].
	^ppPlaceValue! !
!HRNagPlaceCalc categoriesFor: #ppPlaceValue!public! !

!HRNagPlaceCalc methodsFor!
ppPlaceValue: anObject
	ppPlaceValue := anObject.
! !
!HRNagPlaceCalc categoriesFor: #ppPlaceValue:!public! !

!HRNagPlaceCalc methodsFor!
ppValueChksum

	self nonRunner ifTrue: [^0].
	^(self ppPercIncFav*(self ppPlaceValue - 1)*100) asFloat roundTo: 0.01! !
!HRNagPlaceCalc categoriesFor: #ppValueChksum!public! !

!HRNagPlaceCalc methodsFor!
setEstPPPercIncFav

	| denom |
	denom := self race totalPPEst.
	(denom == 0) 
		ifTrue: [^ppPercIncFav := 0].
	self isPreRaceFav 
		ifFalse: [ppPercIncFav := ((self ppEst / denom) asFloat roundTo: 0.000001)]
		ifTrue: [ppPercIncFav := (((self ppEst + self race ppFavEst + self race ppNREst) / 
			denom) asFloat roundTo: 0.000001)].


! !
!HRNagPlaceCalc categoriesFor: #setEstPPPercIncFav!public! !

!HRNagPlaceCalc methodsFor!
setLeg1EstPPPercIncFav

	| denom |
	denom := self race totalPPLeg1Est.
	(denom == 0) 
		ifTrue: [^ppPercIncFav := 0].
	self isPreRaceFav 
		ifFalse: [ppPercIncFav := ((self ppLeg1Est / denom) asFloat roundTo: 0.000001)]
		ifTrue: [ppPercIncFav := (((self ppLeg1Est + self race ppNRLeg1Est) / 
			denom) asFloat roundTo: 0.000001)].


! !
!HRNagPlaceCalc categoriesFor: #setLeg1EstPPPercIncFav!public! !

!HRNagPlaceCalc methodsFor!
setPlaceChanceBasis

	self race hasFinalOdds 
		ifTrue: [
			self slFinalOdds isZero ifTrue: [^self placeChanceBasis: 0].
			^self placeChanceBasis: ((1/(1 + self slFinalOdds)) asFloat roundTo: 0.000001)].
	self race hasLiveShows
		ifTrue: [
			self preRaceShow isEmpty ifTrue: [^self placeChanceBasis: 0].
			^self placeChanceBasis: ((1/(1 + self preRaceShow last)) asFloat 
				roundTo: 0.000001)].
	self race hasBFOdds
		ifTrue: [
			self bfOdds isZero ifTrue: [^self placeChanceBasis: 0].
			^self placeChanceBasis: ((1/(1 + self bfOdds)) asFloat roundTo: 0.000001)].
	self rpForecast isZero ifTrue: [^self placeChanceBasis: 0].
	self placeChanceBasis: ((1/(1 + self rpForecast)) asFloat roundTo: 0.000001)
! !
!HRNagPlaceCalc categoriesFor: #setPlaceChanceBasis!public! !

!HRNagPlaceCalc methodsFor!
setPPPercentage
	| denom |
	denom := self race ppCarriedForward.
	(denom == 0) 
		ifTrue: [self ppPercentage: 0]
		ifFalse: [self ppPercentage: ((self ppValue / denom) asFloat roundTo: 0.000001)].
! !
!HRNagPlaceCalc categoriesFor: #setPPPercentage!public! !

!HRNagPlaceCalc methodsFor!
setPPPercIncFav

	| denom |
	self isPreRaceFav ifFalse: [^ppPercIncFav := self ppPercentage].
	denom := self race ppCarriedForward.
	(denom == 0) 
		ifTrue: [^ppPercIncFav := 0].
	ppPercIncFav := (((self ppValue + self race ppFav + self race ppNR) / denom) 
		asFloat roundTo: 0.000001)
! !
!HRNagPlaceCalc categoriesFor: #setPPPercIncFav!public! !

!HRNagPlaceCalc categoriesFor: #asCsvString!public! !

!HRNagPlaceCalc categoriesFor: #placeChance!public! !

!HRNagPlaceCalc categoriesFor: #placeChance:!public! !

!HRNagPlaceCalc categoriesFor: #placeChanceBasis!public! !

!HRNagPlaceCalc categoriesFor: #placeChanceBasis:!public! !

!HRNagPlaceCalc categoriesFor: #placeChanceRoundedPercentage!public! !

!HRNagPlaceCalc categoriesFor: #ppLeg1Est!accessing!private! !

!HRNagPlaceCalc categoriesFor: #ppLeg1Est:!accessing!private! !

!HRNagPlaceCalc categoriesFor: #ppPercentage!accessing!public! !

!HRNagPlaceCalc categoriesFor: #ppPercentage:!accessing!private! !

!HRNagPlaceCalc categoriesFor: #ppPercIncFav!accessing!private! !

!HRNagPlaceCalc categoriesFor: #ppPercIncFav:!accessing!private! !

!HRNagPlaceCalc categoriesFor: #ppPlaceValue!public! !

!HRNagPlaceCalc categoriesFor: #ppPlaceValue:!public! !

!HRNagPlaceCalc categoriesFor: #ppValueChksum!public! !

!HRNagPlaceCalc categoriesFor: #setEstPPPercIncFav!accessing!private! !

!HRNagPlaceCalc categoriesFor: #setLeg1EstPPPercIncFav!accessing!private! !

!HRNagPlaceCalc categoriesFor: #setPlaceChanceBasis!public! !

!HRNagPlaceCalc categoriesFor: #setPPPercentage!public! !

!HRNagPlaceCalc categoriesFor: #setPPPercIncFav!accessing!private! !

!HRNagPlaceCalc class methodsFor!
setVocabDictionary

	vocabDictionary := Dictionary new.
	vocabDictionary 
		at: #placeChanceRoundedPercentage put: 'Place %';
		at: #ppPlaceValueRoundedPercentage put: 'PP Place Value';
		at: #ppValueChksum put: 'Check'.

! !
!HRNagPlaceCalc class categoriesFor: #setVocabDictionary!public! !

!HRNagPlaceCalc class categoriesFor: #setVocabDictionary!public! !

HRPumpkin3Nag guid: (GUID fromString: '{733EB4BA-985D-4F31-86A5-5C79B694362A}')!

HRPumpkin3Nag guid: (GUID fromString: '{733EB4BA-985D-4F31-86A5-5C79B694362A}')!
HRPumpkin3Nag comment: ''!

HRPumpkin3Nag comment:
''!
!HRPumpkin3Nag categoriesForClass!MVP-Models! !
!HRPumpkin3Nag methodsFor!
p3Fav

	^self favOrBlank! !
!HRPumpkin3Nag categoriesFor: #p3Fav!public! !

!HRPumpkin3Nag methodsFor!
p3Placed

	^self stratPlacedOrBlank! !
!HRPumpkin3Nag categoriesFor: #p3Placed!public! !

!HRPumpkin3Nag categoriesFor: #p3Fav!public! !

!HRPumpkin3Nag categoriesFor: #p3Placed!public! !

!HRPumpkin3Nag class methodsFor!
csvStringHeader

	^',P3 Fav,P3 Placed' "this class specific nag header"! !
!HRPumpkin3Nag class categoriesFor: #csvStringHeader!public! !

!HRPumpkin3Nag class methodsFor!
setVocabDictionary

	vocabDictionary := Dictionary new.
	vocabDictionary 
		at: #p3Fav put: 'P3 Fav';
		at: #p3Placed put: 'P3 Placed'.
! !
!HRPumpkin3Nag class categoriesFor: #setVocabDictionary!public! !

!HRPumpkin3Nag class categoriesFor: #csvStringHeader!public! !

!HRPumpkin3Nag class categoriesFor: #setVocabDictionary!public! !

HRRace guid: (GUID fromString: '{0B2D1EC8-380F-4C2D-8666-7E74CFA3D852}')!

HRRace guid: (GUID fromString: '{0B2D1EC8-380F-4C2D-8666-7E74CFA3D852}')!
HRRace comment: 'HRRace setVocabDictionary'!

HRRace comment:
'HRRace setVocabDictionary'!
!HRRace categoriesForClass!MVP-Models! !
!HRRace methodsFor!
actualRunners
	actualRunners ifNil: [self actualRunners: 0].
	^actualRunners! !
!HRRace categoriesFor: #actualRunners!public! !

!HRRace methodsFor!
actualRunners: anObject
	actualRunners := anObject! !
!HRRace categoriesFor: #actualRunners:!public! !

!HRRace methodsFor!
addNag: aNag
	self nags addLast: aNag.
	aNag race: self.! !
!HRRace categoriesFor: #addNag:!public! !

!HRRace methodsFor!
adjustEstsFor: cap
	| sorted fav rest rem denom |
	HRLogger current 
		showFull: Time now displayString , ' Adjusting PP Estimates for: ' , self shortTime, ' ', self meeting course, String lineDelimiter.
	sorted := self nags asSortedCollection: [ :a :b | a ppEst > b ppEst ].
	fav := sorted first.
	rest := sorted copyFrom: 2 to: sorted size.
	rem := fav ppEst - cap.
	fav ppEst: cap.
	denom := rest inject: 0 into: [:sum :each | sum + each estRatio].
	denom isZero 
		ifFalse: [rest do: [:each | each ppEst: (each ppEst + ((each estRatio * rem / denom) asFloat rounded))]].
! !
!HRRace categoriesFor: #adjustEstsFor:!public! !

!HRRace methodsFor!
ageOfNags
	ageOfNags ifNil: [self ageOfNags: 'any'].
	^ageOfNags! !
!HRRace categoriesFor: #ageOfNags!public! !

!HRRace methodsFor!
ageOfNags: anObject
	ageOfNags := anObject! !
!HRRace categoriesFor: #ageOfNags:!public! !

!HRRace methodsFor!
ageOfNagsStripped
	^self ageOfNags readStream upTo: $,
! !
!HRRace categoriesFor: #ageOfNagsStripped!public! !

!HRRace methodsFor!
allNagsAsCsvString
	| result |
	result := String writeStream.
	self nags do: [ :each |
		result 
			nextPutAll: each asCsvString;
			nextPutAll: String lineDelimiter.
		].
	^result contents! !
!HRRace categoriesFor: #allNagsAsCsvString!public! !

!HRRace methodsFor!
allNonRunners

	^self nags select: [ :each | each nonRunner == true ]! !
!HRRace categoriesFor: #allNonRunners!public! !

!HRRace methodsFor!
allPlacedNags

	^self nags select: [ :each | each placed ]! !
!HRRace categoriesFor: #allPlacedNags!public! !

!HRRace methodsFor!
allRunners

	^self nags select: [ :each | each nonRunner == false ]! !
!HRRace categoriesFor: #allRunners!public! !

!HRRace methodsFor!
allRunnersSorted

	^self allRunners asSortedCollection: [ :a :b | a rpForecast < b rpForecast ]! !
!HRRace categoriesFor: #allRunnersSorted!public! !

!HRRace methodsFor!
asCsvString

"		nextPut: $;
		nextPutAll: self rpWholeSpotlight;
		nextPut: $;
		nextPutAll: String lineDelimiter;
"
	| result |
	result := String writeStream.
	result 
		nextPutAll: 'Leg ';
		nextPutAll: self leg displayString;
		nextPut: $,;
		nextPutAll: self shortTime;
		nextPut: $,;
		nextPut: $";
		nextPutAll: self name;
		nextPut: $";
		nextPut: $,;
		nextPutAll: self distance;
		nextPut: $,;
		nextPutAll: self ageOfNagsStripped;
		nextPutAll: ',Race type:,';
		nextPutAll: self raceType;
		nextPutAll: ',,,Bookies %:,';
		nextPutAll: self bookiesPercentageAsPercentage printString;
		nextPutAll: ',Forecast runners:,';
		nextPutAll: self forecastRunners printString;
		nextPutAll: ',Actual runners:,';
		nextPutAll: self actualRunners printString;
		nextPutAll: ',PP Carried Forward:,';
		nextPutAll: self ppCarriedForward printString;
		nextPut: $,;
		nextPutAll: (self ppCFPercAsPercentage asScaledDecimal: 2) displayString;
		nextPut: $,;
		nextPutAll: (self ppCFPercAsPercOfPrev asScaledDecimal: 2) displayString;
		nextPutAll: ',,Cum place odds:,';
		nextPutAll: self myPlaceOddsAsPercentage displayString.
	^result contents! !
!HRRace categoriesFor: #asCsvString!public! !

!HRRace methodsFor!
bestOddsFav

	|fav|
	self nags isEmpty ifTrue: [^nil].
	fav := self nags first.
	nags do: [ :each | 
		fav bestOdds = 0 ifTrue: [ fav := each ].
		(( each bestOdds > 0) and: [each bestOdds < fav bestOdds])
			ifTrue: [fav := each]].
	^fav
! !
!HRRace categoriesFor: #bestOddsFav!public! !

!HRRace methodsFor!
bfRaceID
	bfRaceID ifNil: [bfRaceID := ''].
	^bfRaceID! !
!HRRace categoriesFor: #bfRaceID!public! !

!HRRace methodsFor!
bfRaceID: anObject
	bfRaceID := anObject! !
!HRRace categoriesFor: #bfRaceID:!public! !

!HRRace methodsFor!
bfRaceTO
	bfRaceTO ifNil: [bfRaceTO := 0].
	^bfRaceTO! !
!HRRace categoriesFor: #bfRaceTO!public! !

!HRRace methodsFor!
bfRaceTO: anObject
	bfRaceTO := anObject! !
!HRRace categoriesFor: #bfRaceTO:!public! !

!HRRace methodsFor!
bookiesPercentage
	bookiesPercentage ifNil: [self calculateBookiesPercentage].
	^bookiesPercentage! !
!HRRace categoriesFor: #bookiesPercentage!public! !

!HRRace methodsFor!
bookiesPercentage: anObject
	bookiesPercentage := anObject! !
!HRRace categoriesFor: #bookiesPercentage:!public! !

!HRRace methodsFor!
bookiesPercentageAsPercentage
	^(100*self bookiesPercentage) roundTo: 0.1! !
!HRRace categoriesFor: #bookiesPercentageAsPercentage!public! !

!HRRace methodsFor!
calculateBookiesPercentage
	"return the difference of 100% and the sum of rp forecast odds"

	self nags isEmpty ifTrue: [^self bookiesPercentage: 0].
	^self bookiesPercentage: (self nags inject: -1 into: [ :sum :nag | sum + nag rpGrossChance])! !
!HRRace categoriesFor: #calculateBookiesPercentage!public! !

!HRRace methodsFor!
chase

	"^self name words anySatisfy: [ :each | each sameAs: 'chase' ] "
	^self type isBitSet: (self raceTypes at: #Chase)

! !
!HRRace categoriesFor: #chase!public! !

!HRRace methodsFor!
checkAllNags

	^self nags size = self forecastRunners
! !
!HRRace categoriesFor: #checkAllNags!public! !

!HRRace methodsFor!
checkBookiesPerc

	^self bookiesPercentage between: 0.01 and: 0.6! !
!HRRace categoriesFor: #checkBookiesPerc!public! !

!HRRace methodsFor!
checkCFPPValue

	(self leg between: 2 and: 6) ifFalse: [^true].
	self ppCarriedForward = 0 ifTrue: [^false].
	^((self nags inject: 0 into: [ :sum :each | sum + each ppValue ]) + self ppFav) 
		equals: self ppCarriedForward
! !
!HRRace categoriesFor: #checkCFPPValue!public! !

!HRRace methodsFor!
checkCompleteness

	self checkAllNags ifFalse: [^false].
	self checkBookiesPerc ifFalse: [^false].
	self checkSP ifFalse: [^false].
	self checkCFPPValue ifFalse: [^false].
	self checkResult ifFalse: [^false].
	^true! !
!HRRace categoriesFor: #checkCompleteness!public! !

!HRRace methodsFor!
checkResult

	^(self nags inject: 0 into: [ :sum :each | 
		each racePosition understandsArithmetic 
			ifTrue: [sum + each racePosition] 
			ifFalse: [sum]
		]) > 0! !
!HRRace categoriesFor: #checkResult!public! !

!HRRace methodsFor!
checkSP

	^(self nags reject: [ :each | each nonRunner or: [ each slFinalOdds isZero not ]]) isEmpty! !
!HRRace categoriesFor: #checkSP!public! !

!HRRace methodsFor!
claimer

	"^self name words anySatisfy: [ :each | each sameAs: 'claimer' ] "
	^self type isBitSet: (self raceTypes at: #Claimer)

! !
!HRRace categoriesFor: #claimer!public! !

!HRRace methodsFor!
claiming

"	^self name words anySatisfy: [ :each | each sameAs: 'claiming' ] "
	^self type isBitSet: (self raceTypes at: #Claiming)
! !
!HRRace categoriesFor: #claiming!public! !

!HRRace methodsFor!
collectSlipLines
	| result header |
	result := OrderedCollection new.
	header := self myPPSelectionHeader lines.
	header do: [ :each | result addLast: nil -> each ].
	self hasResults
		ifTrue: [ 
			self myUnnamedFav 
				ifTrue: [result addLast: self bestOddsFav placed -> ('UNNAMED FAV', String lineDelimiter)].
			self myFavsExUnnamed do: [ :each | 
				result addLast: each placed -> each outputMyPPSelections ]]
		ifFalse: [
			self myUnnamedFav 
				ifTrue: [result addLast: nil -> ('UNNAMED FAV', String lineDelimiter)].
			self myFavsExUnnamed do: [ :each | 
				result addLast: nil -> each outputMyPPSelections ]].
	result addLast: nil -> '================================================================='.
	^result
! !
!HRRace categoriesFor: #collectSlipLines!public! !

!HRRace methodsFor!
copyPreviews

	self nags do: [ :each | each copyPreviews ]! !
!HRRace categoriesFor: #copyPreviews!public! !

!HRRace methodsFor!
createScheduleItemForSLLiveShow

	| item |
	item := (HRScheduleItem new)
		date: self meeting date;
		time: self time;
		object: self;
		process: #findSLLiveShow.
	HRScheduler current addScheduleItem: item! !
!HRRace categoriesFor: #createScheduleItemForSLLiveShow!public! !

!HRRace methodsFor!
createScheduleItemForSLResult

	self createScheduleItemForSLResultAt: (self time addTime: (Time fromString: '0:30'))! !
!HRRace categoriesFor: #createScheduleItemForSLResult!public! !

!HRRace methodsFor!
createScheduleItemForSLResultAt: aTime

	| item |
	item := HRScheduleItem new 
		date: self meeting date; 
		time: aTime;
		object: self;
		process: #findSLResult.
	HRScheduler current addScheduleItem: item.
! !
!HRRace categoriesFor: #createScheduleItemForSLResultAt:!public! !

!HRRace methodsFor!
displayOn: aStream

	self name isEmpty ifFalse: [
		aStream nextPutAll: self meeting course;
			nextPutAll: ', ';
			nextPutAll: self shortTime;
			nextPutAll: ', ';
			nextPutAll: self name
		].
! !
!HRRace categoriesFor: #displayOn:!public! !

!HRRace methodsFor!
distance
	distance ifNil: [self distance: '0.0f'].
	^distance! !
!HRRace categoriesFor: #distance!public! !

!HRRace methodsFor!
distance: anObject
	distance := anObject! !
!HRRace categoriesFor: #distance:!public! !

!HRRace methodsFor!
favPlaced
	"did the fav get placed?"

	self nags isEmpty ifTrue: [^false].
	self hasFinalOdds ifFalse: [^self bestOddsFav placed].
	^self finalFav placed
	! !
!HRRace categoriesFor: #favPlaced!public! !

!HRRace methodsFor!
favValueFor: aNag

	aNag isPreRaceFav ifTrue: [^self ppFav + self ppNR].
	^0! !
!HRRace categoriesFor: #favValueFor:!public! !

!HRRace methodsFor!
fileInLiveShow

	| file import |
	file := FileOpenDialog new
		fileTypes: #(('HTML files (*.HTM*)' '*.htm*') ('All Files (*.*)' '*.*') );
		defaultExtension: 'htm';
		showModal.
	file notNil ifTrue: [
		import := HRImportSLLiveShow on: file race: self.
		import setAll.
		self ppValDirty: true.].
! !
!HRRace categoriesFor: #fileInLiveShow!public! !

!HRRace methodsFor!
fileInResult

	| file import |
	file := FileOpenDialog new
		fileTypes: #(('HTML files (*.HTM*)' '*.htm*') ('All Files (*.*)' '*.*') );
		defaultExtension: 'htm';
		showModal.
	file notNil ifTrue: [
		import := HRImportSLPostRaceRace on: file race: self.
		import setAll.
		self ppValDirty: true.].
! !
!HRRace categoriesFor: #fileInResult!public! !

!HRRace methodsFor!
fileInSLCard

	| file import |
	file := FileOpenDialog new
		fileTypes: #(('HTML files (*.HTM*)' '*.htm*') ('All Files (*.*)' '*.*') );
		defaultExtension: 'htm';
		showModal.
	file notNil ifTrue: [
		import := HRImportSLPreRaceRace on: file race: self.
		import setAll].
! !
!HRRace categoriesFor: #fileInSLCard!public! !

!HRRace methodsFor!
fileInTotePPData
	| file totePP |
	file := (FileOpenDialog new)
				fileTypes: #(#('HTML files (*.HTM*)' '*.htm*') #('All Files (*.*)' '*.*'));
				defaultExtension: 'htm';
				showModal.
	file notNil 
		ifTrue: 
			[totePP := HRImportTotePPRace on: file.
			totePP setData.
			totePP leg = self leg ifFalse: [^self].
			self meeting totePPPool: totePP poolTotal.
			self meeting totePPCF: totePP poolBF.
			self ppCarriedForward: totePP thisRace.
			self ppFav: (totePP valueFor: 'Fav').
			self nags do: [:nag | nag ppValue: (totePP valueFor: nag racecardNo)].
			self ppValDirty: true.]! !
!HRRace categoriesFor: #fileInTotePPData!public! !

!HRRace methodsFor!
finalFav

	|fav|
	self nags isEmpty ifTrue: [^nil].
	fav := self nags first.
	nags do: [ :each | 
		fav slFinalOdds = 0 ifTrue: [ fav := each ].
		(( each slFinalOdds > 0) and: [each slFinalOdds < fav slFinalOdds])
			ifTrue: [fav := each]].
	^fav
! !
!HRRace categoriesFor: #finalFav!public! !

!HRRace methodsFor!
finalPPBFAsCsvString
	| result |
	result := String writeStream.
	result 
		nextPut: $,;
		nextPut: $,;
		nextPut: $,;
		nextPut: $,;
		nextPut: $,;
		nextPutAll: ',,';
		nextPutAll: ',,,,,,';
		nextPutAll: ',';
		nextPutAll: ',PP Through:,';
		nextPutAll: self ppBroughtForward printString;
		nextPut: $,;
		nextPutAll: (self ppBFPercAsPercentage asScaledDecimal: 2) displayString;
		nextPut: $,;
		nextPutAll: (self ppBFPercAsPercOfPrev asScaledDecimal: 2) displayString;
		nextPutAll: String lineDelimiter.
	^result contents
! !
!HRRace categoriesFor: #finalPPBFAsCsvString!public! !

!HRRace methodsFor!
findBetfairOdds

	self findBFWinOdds.
	self findBFPlaceOdds.
	self ppValDirty: true.
"
	| betfair url collectTime bfPlaceID |
	collectTime := Time now.
	self bfRaceID isEmpty ifTrue: [^nil].
	bfPlaceID := ((Number fromString: self bfRaceID) + 1) displayString.
	url := 'http://www.betfair.com/Betting/HTML/Odds_IEDataFrame.asp?ei=' , self bfRaceID.
	HRLogger current 
		showFull: collectTime displayString , ' Collecting betfair odds for: ' , self shortTime , ' - ' 
				, self name , String lineDelimiter.
	betfair := HRImportBetfairRace onURL: url race: self time: collectTime.
	HRLogger current showFull: 'URL: ' , url , String lineDelimiter.
	betfair setAll.
	self nags do: [ :nag |
		url := 'http://www.betfair.com/Betting/MoreInfo/MoreInfoTotals.asp?typ=O&ei=', self bfRaceID, '&supeid=&si=', nag bfID, '&hc=&fxr=1&iid=&rf=14.3'.
""		url := 'http://www.betfair.com/Betting/MoreInformation.asp?ei=', self bfRaceID, '&si=', nag bfID.""
		betfair := HRImportBetfairNag onURL: url nag: nag time: collectTime.
		betfair setAll.
		].
	HRLogger current 
		showFull: collectTime displayString , ' Collecting betfair turnovers', String lineDelimiter.
	HRLogger current showFull: 'URL: ' , url , String lineDelimiter.
"! !
!HRRace categoriesFor: #findBetfairOdds!public! !

!HRRace methodsFor!
findBFPlaceOdds

	| betfair url collectTime bfPlaceID |
	collectTime := Time now.
	self bfRaceID isEmpty ifTrue: [^nil].
	bfPlaceID := ((Number fromString: self bfRaceID) + 1) displayString.
	url := 'http://global.betfair.com/betting/LoadMarketDataAction.do?mi=' , bfPlaceID.
	HRLogger current 
		showAlways: collectTime displayString , ' Collecting betfair place odds for: ' , self shortTime, ' ', self meeting course, String lineDelimiter.
	betfair := HRImportBetfairRace onURL: url race: self time: collectTime.
	HRLogger current showFull: 'URL: ' , url , String lineDelimiter.
	betfair setAllPlace.
	self nags do: [ :nag |
		url := 'http://global.betfair.com/betting/LoadRunnerInfoAction.do?marketId=', bfPlaceID, '&selectionId=', nag bfPlaceID, '&hybrid=http%3A%2F%2Fwww%2Ebetfair%2Ecom'.
"http://global.betfair.com/betting/LoadRunnerInfoAction.do?marketId=2016513&selectionId=178848&hybrid=http%3A%2F%2Fwww%2Ebetfair%2Ecom"
		betfair := HRImportBetfairNag onURL: url nag: nag time: collectTime.
		betfair setAllPlace.
		].
	HRLogger current 
		showFull: collectTime displayString , ' Collecting betfair place turnovers', String lineDelimiter.
	HRLogger current showFull: 'URL: ' , url , String lineDelimiter.
! !
!HRRace categoriesFor: #findBFPlaceOdds!public! !

!HRRace methodsFor!
findBFWinOdds

	| betfair url collectTime |
	collectTime := Time now.
	self bfRaceID isEmpty ifTrue: [^nil].
	url := 'http://global.betfair.com/betting/LoadMarketDataAction.do?mi=' , self bfRaceID.
	HRLogger current 
		showAlways: collectTime displayString , ' Collecting betfair win odds for: ' , self shortTime, ' ', self meeting course, String lineDelimiter.
	betfair := HRImportBetfairRace onURL: url race: self time: collectTime.
	HRLogger current showFull: 'URL: ' , url , String lineDelimiter.
	betfair setAllWin.
	self nags do: [ :nag |
		url := 'http://global.betfair.com/betting/LoadRunnerInfoAction.do?marketId=', self bfRaceID, '&selectionId=', nag bfWinID, '&hybrid=http%3A%2F%2Fwww%2Ebetfair%2Ecom'.
"		url := 'http://www.betfair.com/Betting/MoreInformation.asp?ei=', self bfRaceID, '&si=', nag bfID."
		betfair := HRImportBetfairNag onURL: url nag: nag time: collectTime.
		betfair setAllWin.
		].
	HRLogger current 
		showFull: collectTime displayString , ' Collecting betfair win turnovers', String lineDelimiter.
	HRLogger current showFull: 'URL: ' , url , String lineDelimiter.
! !
!HRRace categoriesFor: #findBFWinOdds!public! !

!HRRace methodsFor!
findRPSpotlightAtURL: aURL

	| import |
	import := HRImportRPPreRaceRace onURL: aURL.
	import race: self.
	import setRPSpotlight.! !
!HRRace categoriesFor: #findRPSpotlightAtURL:!public! !

!HRRace methodsFor!
findSLLiveShow

	| url import nextTime |
	HRLogger current showAlways: 
		(Time now displayString, ' Collecting live show for: ', self shortTime, ' ', self meeting course, String lineDelimiter).
	url := 'http://www.sportinglife.com/racing/liveshows/', self meeting date weekday, '/', self meeting slCourseName, '_', self slTime, '.html'.
HRLogger current showFull: ('URL: ', url, String lineDelimiter).
	import := HRImportSLLiveShow onURL: url race: self.
	import setAll.
	self ppValDirty: true.
"	import rawNags isEmpty ifTrue: 
		[nextTime := Time now addTime: (Time fromString: '0.15').
		(nextTime > (self meeting races last time addTime: (Time fromString: '1:35'))) ifFalse: 
			[self createScheduleItemForSLResultAt: nextTime] ].
"! !
!HRRace categoriesFor: #findSLLiveShow!public! !

!HRRace methodsFor!
findSLRaceCard

	| url import |
	HRLogger current showAlways: 
		(Time now displayString, ' Collecting SL racecard for: ', self shortTime, ' ', self meeting course, String lineDelimiter).
	url := 'http://www.sportinglife.com/racing/racecards/', self meeting date weekday, '/', self meeting slCourseName, '/', self slTime, '/index.html'.
HRLogger current showFull: ('URL: ', url, String lineDelimiter).
	import := HRImportSLPreRaceRace onURL: url race: self.
	import setAll.
! !
!HRRace categoriesFor: #findSLRaceCard!public! !

!HRRace methodsFor!
findSLResult

	| url import nextTime |
	HRLogger current showAlways: 
		(Time now displayString, ' Collecting results for: ', self shortTime, ' ', self meeting course, String lineDelimiter).
	url := 'http://www.sportinglife.com/racing/results/', self meeting date weekday, '/', self meeting slCourseName, '_', self slTime, '.html'.
HRLogger current showFull: ('URL: ', url, String lineDelimiter).
	import := HRImportSLPostRaceRace onURL: url race: self.
	import setAll.
	import rawNags isEmpty ifTrue: 
		[nextTime := Time now addTime: (Time fromString: '0.15').
		(nextTime > (self meeting races last time addTime: (Time fromString: '1:35'))) ifFalse: 
			[self createScheduleItemForSLResultAt: nextTime] ].
	self ppValDirty: true.! !
!HRRace categoriesFor: #findSLResult!public! !

!HRRace methodsFor!
findTotePPData

	| totePP |
#deprecated. "version 55 - dead code???"
	totePP := HRImportTotePPRace onURL: self meeting totePPURL.
	totePP setData.
	totePP leg = self leg ifFalse: [^self].
	self meeting totePPPool: totePP poolTotal.
	self meeting totePPCF: totePP poolBF.
	self ppCarriedForward: totePP thisRace.
	self ppFav: (totePP valueFor: 'Fav').
	self nags do: [ :nag |
		nag ppPercentage: (totePP valueFor: nag racecardNo)].
	self ppValDirty: true.! !
!HRRace categoriesFor: #findTotePPData!public! !

!HRRace methodsFor!
flat

	^self hurdle not and: [self chase not]
! !
!HRRace categoriesFor: #flat!public! !

!HRRace methodsFor!
forecastRunners
	forecastRunners ifNil: [self forecastRunners: 0].
	^forecastRunners! !
!HRRace categoriesFor: #forecastRunners!public! !

!HRRace methodsFor!
forecastRunners: anObject
	forecastRunners := anObject! !
!HRRace categoriesFor: #forecastRunners:!public! !

!HRRace methodsFor!
graded

	"^self name words anySatisfy: [ :each | each sameAs: 'graded' ] "
	^self type isBitSet: (self raceTypes at: #Graded)

! !
!HRRace categoriesFor: #graded!public! !

!HRRace methodsFor!
group

	"^self name words anySatisfy: [ :each | each sameAs: 'group' ] "
	^self type isBitSet: (self raceTypes at: #Group)

! !
!HRRace categoriesFor: #group!public! !

!HRRace methodsFor!
handicap

	handicap ifNil: [self setHandicap].
	^handicap! !
!HRRace categoriesFor: #handicap!public! !

!HRRace methodsFor!
handicap: aBoolean

	handicap := aBoolean! !
!HRRace categoriesFor: #handicap:!public! !

!HRRace methodsFor!
hasBFOdds

	^self sumOfBFOdds isZero not! !
!HRRace categoriesFor: #hasBFOdds!public! !

!HRRace methodsFor!
hasFinalOdds

	^self sumOfFinalOdds isZero not! !
!HRRace categoriesFor: #hasFinalOdds!public! !

!HRRace methodsFor!
hasFullResults

	^(self nags select: [ :nag | nag placed ]) size = self places! !
!HRRace categoriesFor: #hasFullResults!public! !

!HRRace methodsFor!
hasLiveShows

	^self allRunners anySatisfy: [ :each | each preRaceShow notEmpty ]! !
!HRRace categoriesFor: #hasLiveShows!public! !

!HRRace methodsFor!
hasPPValues

	^self ppCarriedForward isZero not! !
!HRRace categoriesFor: #hasPPValues!public! !

!HRRace methodsFor!
hasResults

	^self nags anySatisfy: [ :nag | nag placed ]! !
!HRRace categoriesFor: #hasResults!public! !

!HRRace methodsFor!
hurdle

	"^self name words anySatisfy: [ :each | each sameAs: 'hurdle' ] "
	^self type isBitSet: (self raceTypes at: #Hurdle)

! !
!HRRace categoriesFor: #hurdle!public! !

!HRRace methodsFor!
includesNagNamed: aString
	^(self nagNamed: aString) isNil not
! !
!HRRace categoriesFor: #includesNagNamed:!public! !

!HRRace methodsFor!
jumps

	^self hurdle or: [self chase]
! !
!HRRace categoriesFor: #jumps!public! !

!HRRace methodsFor!
lastUpdate

	lastUpdate ifNil: [^Time fromString: '0.00'].
	^lastUpdate! !
!HRRace categoriesFor: #lastUpdate!public! !

!HRRace methodsFor!
lastUpdate: anObject
	lastUpdate := anObject.
! !
!HRRace categoriesFor: #lastUpdate:!public! !

!HRRace methodsFor!
leg
	leg ifNil: [self leg: 0].
	^leg! !
!HRRace categoriesFor: #leg!public! !

!HRRace methodsFor!
leg: anObject
	leg := anObject! !
!HRRace categoriesFor: #leg:!public! !

!HRRace methodsFor!
listed

	"^self name words anySatisfy: [ :each | each sameAs: 'listed' ] "
	^self type isBitSet: (self raceTypes at: #Listed)

! !
!HRRace categoriesFor: #listed!public! !

!HRRace methodsFor!
maiden

	"^self name words anySatisfy: [ :each | each sameAs: 'maiden' ] "
	^self type isBitSet: (self raceTypes at: #Maiden)

! !
!HRRace categoriesFor: #maiden!public! !

!HRRace methodsFor!
meeting
	meeting ifNil: [self meeting: HRMeeting new].
	^meeting! !
!HRRace categoriesFor: #meeting!public! !

!HRRace methodsFor!
meeting: anObject
	meeting := anObject! !
!HRRace categoriesFor: #meeting:!public! !

!HRRace methodsFor!
myFavCount

	^self myFavs size! !
!HRRace categoriesFor: #myFavCount!public! !

!HRRace methodsFor!
myFavs

	| result |
	result := self nags select: [ :nag | nag mySelect ].
	self myUnnamedFav ifTrue: [result addFirst: self bestOddsFav].
	^result! !
!HRRace categoriesFor: #myFavs!public! !

!HRRace methodsFor!
myFavsExUnnamed

	| result |
	result := self nags select: [ :nag | nag mySelect ].
	^result! !
!HRRace categoriesFor: #myFavsExUnnamed!public! !

!HRRace methodsFor!
myFavThrough

	| prev |
	prev := 1.0.
	self myFavCount isZero ifTrue: [^0].
	self leg = 1 ifFalse: [ prev := (self meeting leg: (self leg - 1)) myFavThrough ].
	^prev * self myPlacedFavCount / self myFavCount
! !
!HRRace categoriesFor: #myFavThrough!public! !

!HRRace methodsFor!
myFavThroughAsPerc

	^(self myFavThrough * 100) roundTo: 0.1.! !
!HRRace categoriesFor: #myFavThroughAsPerc!public! !

!HRRace methodsFor!
myLinesRunning

"	^(1 to: self leg) inject: (self meeting myLines) into: [ :lines :thisLeg | 
		lines * (self meeting leg: thisLeg) myPlacedFavCount / 
		(self meeting leg: thisLeg) myFavCount ]
"
	^(self meeting myLines * self myFavThrough) rounded! !
!HRRace categoriesFor: #myLinesRunning!public! !

!HRRace methodsFor!
myLinesRunningLog

	^(self myLinesRunning + 1) log: (self meeting myLines + 1)! !
!HRRace categoriesFor: #myLinesRunningLog!public! !

!HRRace methodsFor!
myLinesRunningPerc

	^self myLinesRunning / self meeting myLines! !
!HRRace categoriesFor: #myLinesRunningPerc!public! !

!HRRace methodsFor!
myLinesThroughUptoCurrent

	| prev |
	self leg = 1 ifTrue: [^0].
	^(1 to: (self leg - 1)) inject: 1 into: [ :count :each | count * ((self meeting leg: each) myPlacedFavCount) ]! !
!HRRace categoriesFor: #myLinesThroughUptoCurrent!public! !

!HRRace methodsFor!
myPlacedFavCount

	^self myPlacedFavs size! !
!HRRace categoriesFor: #myPlacedFavCount!public! !

!HRRace methodsFor!
myPlacedFavs

	^self myFavs select: [ :nag | nag placed ]! !
!HRRace categoriesFor: #myPlacedFavs!public! !

!HRRace methodsFor!
myPlaceOdds

"	| coll |
	coll := self myFavs collect: [ :each | 1 - each placeChance ].
	^1-(coll inject: 1 into: [ :cum :odds | cum * odds ])
"
	myPlaceOdds ifNil: [myPlaceOdds := 0].
	^myPlaceOdds! !
!HRRace categoriesFor: #myPlaceOdds!public! !

!HRRace methodsFor!
myPlaceOdds: aFloat

	myPlaceOdds := aFloat! !
!HRRace categoriesFor: #myPlaceOdds:!public! !

!HRRace methodsFor!
myPlaceOddsAsPercentage

	^(self myPlaceOdds * 100) roundTo: 0.1! !
!HRRace categoriesFor: #myPlaceOddsAsPercentage!public! !

!HRRace methodsFor!
myPPSelectionHeader
	| result |
	result := String writeStream.
	result 
		nextPutAll: String lineDelimiter;
		nextPutAll: 'Leg: ';
		nextPutAll: self leg displayString;
		nextPutAll: ' - ';
		nextPutAll: self short24Time;
		nextPutAll: ' - runners: ';
		nextPutAll: (self forecastRunners - self nonRunners) displayString;
		nextPutAll: ' - places: ';
		nextPutAll: self places displayString;
		nextPutAll: String lineDelimiter;
		nextPutAll: 'Number of picks: ';
		nextPutAll: self myFavCount displayString.
	HRApplication current fullUnlock ifTrue: [
		result
			nextPutAll: ' - cumulative place odds: ';
			nextPutAll: self myPlaceOddsAsPercentage displayString].
	result
		nextPutAll: String lineDelimiter;
		nextPutAll: '=================================================================';
		nextPutAll: String lineDelimiter.
	^result contents
! !
!HRRace categoriesFor: #myPPSelectionHeader!public! !

!HRRace methodsFor!
myUnnamedFav
	myUnnamedFav ifNil: [myUnnamedFav := false].
	^myUnnamedFav! !
!HRRace categoriesFor: #myUnnamedFav!public! !

!HRRace methodsFor!
myUnnamedFav: aBoolean
	myUnnamedFav := aBoolean.
! !
!HRRace categoriesFor: #myUnnamedFav:!public! !

!HRRace methodsFor!
nagNamed: aString
	^self nags detect: [ :each | each name sameAs: aString ] ifNone: [
		self nags detect: [ :each | '*', each name, '*' match: aString ] ifNone: [
			self nags detect: [ :each | each nameNoQuotes soundsLike: aString] ifNone: [
				self nags detect: [ :each | each name soundsLike: aString] ifNone: [
					self nags detect: [ :each | (each name words first soundsLike: aString words first) and: 
						[each name words last soundsLike: aString words last]] ifNone: [
]]]]]
! !
!HRRace categoriesFor: #nagNamed:!public! !

!HRRace methodsFor!
nagNo: anInteger

	^self nags detect: [ :each | each racecardNoAsNumber = anInteger ] ifNone: [HRNag new].
! !
!HRRace categoriesFor: #nagNo:!public! !

!HRRace methodsFor!
nags
	nags ifNil: [nags := OrderedCollection new].
	^nags! !
!HRRace categoriesFor: #nags!public! !

!HRRace methodsFor!
nagsCsvStringHeader
	"return the csv header for the nags"

	^self nagsClass csvStringHeader! !
!HRRace categoriesFor: #nagsCsvStringHeader!public! !

!HRRace methodsFor!
name
	name ifNil: [self name: ''].
	^name! !
!HRRace categoriesFor: #name!public! !

!HRRace methodsFor!
name: anObject
	name := anObject.
	self setHandicap.
! !
!HRRace categoriesFor: #name:!public! !

!HRRace methodsFor!
nonRunners

	^(self nags select: [ :each | each nonRunner ]) size! !
!HRRace categoriesFor: #nonRunners!public! !

!HRRace methodsFor!
noOfNags
	^self nags size! !
!HRRace categoriesFor: #noOfNags!public! !

!HRRace methodsFor!
notPicked

	^self nags reject: [ :nag | nag mySelect ]! !
!HRRace categoriesFor: #notPicked!public! !

!HRRace methodsFor!
novice

"	^self name words anySatisfy: [ :each | (each leftString: 6) sameAs: 'novice' ] "
	^self type isBitSet: (self raceTypes at: #Novice)
! !
!HRRace categoriesFor: #novice!public! !

!HRRace methodsFor!
nursery

	"^self name words anySatisfy: [ :each | each sameAs: 'nursery' ] "
	^self type isBitSet: (self raceTypes at: #Nursery)

! !
!HRRace categoriesFor: #nursery!public! !

!HRRace methodsFor!
outputMyPPSelections
	| result |
	result := String writeStream.
	result 
		nextPutAll: self myPPSelectionHeader.
	self myUnnamedFav ifTrue: [result nextPutAll: ('** UNNAMED FAV **', String lineDelimiter)].
	self myFavsExUnnamed do: [ :each | result nextPutAll: each outputMyPPSelections ].
	result nextPutAll: '=================================================================';
		nextPutAll: String lineDelimiter.
	^result contents

! !
!HRRace categoriesFor: #outputMyPPSelections!public! !

!HRRace methodsFor!
outputMyPPSelectionsForSMS
	| result |
	result := String writeStream.
	result 
		nextPut: $(;
		nextPutAll: self leg displayString;
		nextPut: $).
	self myUnnamedFav ifTrue: [result nextPutAll: ' FAV'].
	self myFavsExUnnamed do: [ :each | result nextPutAll: ' '; nextPutAll: each racecardNo displayString ].
	result nextPutAll: String lineDelimiter.
	^result contents

! !
!HRRace categoriesFor: #outputMyPPSelectionsForSMS!public! !

!HRRace methodsFor!
performVocabDictionaryKey: aKey

	(self vocabDictionary includesKey: aKey) ifTrue: [^self perform: aKey].
	^self meeting performVocabDictionaryKey: aKey.! !
!HRRace categoriesFor: #performVocabDictionaryKey:!public! !

!HRRace methodsFor!
places

	| runners |
	runners := self actualRunners.
	runners isZero ifTrue: [ runners := self forecastRunners - self nonRunners ].
	(runners < 5) ifTrue: [ ^1 ].
	(runners between: 5 and: 7) ifTrue: [ ^2 ].
	(runners between: 8 and: 15) ifTrue: [ ^3 ].
	(self handicap or: [self nursery]) ifFalse: [^3].
	^4
! !
!HRRace categoriesFor: #places!public! !

!HRRace methodsFor!
ppBFPerc
	| pool |
	pool := self meeting totePPPool.
	pool isZero ifTrue: [^0].
	^self ppBroughtForward / pool! !
!HRRace categoriesFor: #ppBFPerc!public! !

!HRRace methodsFor!
ppBFPercAsPercentage

	^(100*self ppBFPerc) roundTo: 0.01! !
!HRRace categoriesFor: #ppBFPercAsPercentage!public! !

!HRRace methodsFor!
ppBFPercAsPercOfPrev

	^(100*self ppBFPercOfPrev) roundTo: 0.01! !
!HRRace categoriesFor: #ppBFPercAsPercOfPrev!public! !

!HRRace methodsFor!
ppBFPercOfPrev
	| prevCF |
	prevCF := self ppCarriedForward.
	prevCF isZero ifTrue: [^0].
	^self ppBroughtForward / prevCF! !
!HRRace categoriesFor: #ppBFPercOfPrev!public! !

!HRRace methodsFor!
ppBroughtForward

	^self allPlacedNags inject: 0 into: [ :sum :nag | sum + nag ppValueIncFav ]! !
!HRRace categoriesFor: #ppBroughtForward!public! !

!HRRace methodsFor!
ppCarriedForward

	self leg = 1 ifTrue: [ppCarriedForward := self meeting totePPPool].
	ppCarriedForward ifNil: [self ppCarriedForward: 0].
	^ppCarriedForward! !
!HRRace categoriesFor: #ppCarriedForward!public! !

!HRRace methodsFor!
ppCarriedForward: anObject
	ppCarriedForward := anObject! !
!HRRace categoriesFor: #ppCarriedForward:!public! !

!HRRace methodsFor!
ppCFPerc
	| pool |
	pool := self meeting totePPPool.
	pool isZero ifTrue: [^0].
	^self ppCarriedForward / pool! !
!HRRace categoriesFor: #ppCFPerc!public! !

!HRRace methodsFor!
ppCFPercAsPercentage

	^(100*self ppCFPerc) roundTo: 0.01! !
!HRRace categoriesFor: #ppCFPercAsPercentage!public! !

!HRRace methodsFor!
ppCFPercAsPercOfPrev

	^(100*self ppCFPercOfPrev) roundTo: 0.01! !
!HRRace categoriesFor: #ppCFPercAsPercOfPrev!public! !

!HRRace methodsFor!
ppCFPercOfPrev
	| prev prevCF |
	prev := self leg - 1.
	(prev < 2) ifTrue: [^self ppCFPerc].
	prevCF := (self meeting leg: prev) ppCarriedForward.
	prevCF isZero ifTrue: [^0].
	^self ppCarriedForward / prevCF! !
!HRRace categoriesFor: #ppCFPercOfPrev!public! !

!HRRace methodsFor!
ppCFWeightedNetPerc
	"This takes into account the 27% tote margin, split over the individual legs; each 4.5%"
	^self ppCFPerc/(1-(0.045*self leg))! !
!HRRace categoriesFor: #ppCFWeightedNetPerc!public! !

!HRRace methodsFor!
ppCFWeightedNetPercAsPerc
	"This takes into account the 27% tote margin, split over the individual legs; each 4.5%"
	^(self ppCFWeightedNetPerc * 100) roundTo: 0.1! !
!HRRace categoriesFor: #ppCFWeightedNetPercAsPerc!public! !

!HRRace methodsFor!
ppFav
	ppFav ifNil: [self ppFav: 0].
	^ppFav! !
!HRRace categoriesFor: #ppFav!public! !

!HRRace methodsFor!
ppFav: anObject
	ppFav := anObject! !
!HRRace categoriesFor: #ppFav:!public! !

!HRRace methodsFor!
ppFavEst
	ppFavEst ifNil: [ppFavEst := 0].
	^ppFavEst! !
!HRRace categoriesFor: #ppFavEst!public! !

!HRRace methodsFor!
ppFavEst: anObject
	ppFavEst := anObject.
	self ppValDirty: true.! !
!HRRace categoriesFor: #ppFavEst:!public! !

!HRRace methodsFor!
ppFavPercentage

	| denom ppVal |
	denom := self ppCarriedForward.
	(denom isZero) ifTrue: [^0].
	^((self ppFav * 100 / denom) asFloat) asInteger
! !
!HRRace categoriesFor: #ppFavPercentage!public! !

!HRRace methodsFor!
ppNR
	^self allNonRunners inject: 0 into: [ :sum :nr | sum + nr ppValue ].
! !
!HRRace categoriesFor: #ppNR!public! !

!HRRace methodsFor!
ppNREst
	^self allNonRunners inject: 0 into: [ :sum :nr | sum + nr ppEst ].
! !
!HRRace categoriesFor: #ppNREst!public! !

!HRRace methodsFor!
ppPercentage
	"bug in Omnibase? therefore calculate on the fly"
"	ppPercentage ifNil: [self ppPercentage: 0].
	^ppPercentage
"
	| denom ppVal |
	denom := self race ppCarriedForward.
	(denom == 0) ifTrue: [^0].
	ppVal := self ppValue + (self race favValueFor: self).
	^((self ppValue / denom) asFloat roundTo: 0.000001)
! !
!HRRace categoriesFor: #ppPercentage!public! !

!HRRace methodsFor!
ppThrough

	| result nextLeg |
	self leg < 6 ifTrue: [
		nextLeg := self meeting leg: (self leg + 1).
		nextLeg hasPPValues ifTrue: [^nextLeg ppCarriedForward]].
	result := 0.
	self favPlaced ifTrue: [ result := self ppFav ].
	^self nags inject: result into: [ :sum :nag | sum + (nag placed ifTrue: [nag ppValue] ifFalse: [0])]! !
!HRRace categoriesFor: #ppThrough!public! !

!HRRace methodsFor!
ppThroughLog
#deprecated.
	^(self ppThroughPerc * 100 + 1) log: 101! !
!HRRace categoriesFor: #ppThroughLog!public! !

!HRRace methodsFor!
ppThroughNetLog
#deprecated.
	^(self ppThroughPercNet * 100 + 1) log: 101! !
!HRRace categoriesFor: #ppThroughNetLog!public! !

!HRRace methodsFor!
ppThroughPerc

	| div |
	div := self meeting totePPPool + self meeting totePPCF.
	div := div*(1 - (0.045 * self leg)).
	div isZero ifTrue: [^0].
	^self ppThrough/div! !
!HRRace categoriesFor: #ppThroughPerc!public! !

!HRRace methodsFor!
ppThroughPercNet
	"taking into account the 27% split over the legs"
#deprecated.
	^self ppThroughPerc * (1 - (0.045 * self leg))! !
!HRRace categoriesFor: #ppThroughPercNet!public! !

!HRRace methodsFor!
ppValDirty
	ppValDirty ifNil: [ppValDirty := true].
	^ppValDirty! !
!HRRace categoriesFor: #ppValDirty!public! !

!HRRace methodsFor!
ppValDirty: anObject
	^ppValDirty := anObject! !
!HRRace categoriesFor: #ppValDirty:!public! !

!HRRace methodsFor!
preRaceFav

	preRaceFav ifNil: [self setPreRaceFav].
	^preRaceFav! !
!HRRace categoriesFor: #preRaceFav!public! !

!HRRace methodsFor!
preRaceFav: aNag

	preRaceFav := aNag.! !
!HRRace categoriesFor: #preRaceFav:!public! !

!HRRace methodsFor!
printOn: aStream
	"Overwrite the standard printOn so that the name of the object is shown if the class has a 'name' instance variable"

	aStream 
		basicPrint: self.
	self name isEmpty ifFalse: [
		aStream nextPut: $(;
		nextPutAll: self shortTime;
		nextPutAll: ', ';
		display: self name;
		nextPut: $) ].
! !
!HRRace categoriesFor: #printOn:!public! !

!HRRace methodsFor!
publishedAspects
	^(super publishedAspects)
		add: (Aspect time: #time);
		add: (Aspect string: #distance);
		add: (Aspect string: #name);
		add: (Aspect boolean: #handicap);
		add: (Aspect string: #type);
		add: (Aspect integer: #forecastRunners);
		add: (Aspect integer: #actualRunners);
		add: (Aspect number: #ppCarriedForward);
		add: (Aspect number: #ppFav);
		add: (Aspect sequenceableCollection: #nags);
		yourself! !
!HRRace categoriesFor: #publishedAspects!public! !

!HRRace methodsFor!
race
	^self! !
!HRRace categoriesFor: #race!public! !

!HRRace methodsFor!
raceID
	raceID ifNil: [self raceID: ''].
	^raceID! !
!HRRace categoriesFor: #raceID!public! !

!HRRace methodsFor!
raceID: anObject
	raceID := anObject! !
!HRRace categoriesFor: #raceID:!public! !

!HRRace methodsFor!
raceName

	| result in |
	in := self name readStream.
	result := String writeStream.
	[ in atEnd ] whileFalse: [ result nextPutAll: (in upTo: $,)].
	^result contents
! !
!HRRace categoriesFor: #raceName!public! !

!HRRace methodsFor!
raceType

	| result |
	type := 0.
	result := ''.
	self raceTypes associationsDo: [ :each | 
		self name words do: [ :substr | 
			(each key sameAs: substr) ifTrue: [
				result := result, each key, ' '.
				type setBit: (each value)]]].
	^result
! !
!HRRace categoriesFor: #raceType!public! !

!HRRace methodsFor!
raceTypes

	RaceTypes ifNil: [ self class setRaceTypes ].
	^RaceTypes! !
!HRRace categoriesFor: #raceTypes!public! !

!HRRace methodsFor!
recalcRace

	(HRRacePlaceCalc on: self) calculatePPValue! !
!HRRace categoriesFor: #recalcRace!public! !

!HRRace methodsFor!
resetMyFavs

	self myUnnamedFav: false.
	self nags do: [ :nag | nag mySelect: false ]! !
!HRRace categoriesFor: #resetMyFavs!public! !

!HRRace methodsFor!
resetPreRaceFav

	preRaceFav isNil ifFalse: [preRaceFav := nil].! !
!HRRace categoriesFor: #resetPreRaceFav!public! !

!HRRace methodsFor!
rpMargin
	"return the difference of 100% and the sum of rp forecast odds"

	^self bookiesPercentage! !
!HRRace categoriesFor: #rpMargin!public! !

!HRRace methodsFor!
rpWholeSpotlight
	rpWholeSpotlight ifNil: [self rpWholeSpotlight: ''].
	^rpWholeSpotlight! !
!HRRace categoriesFor: #rpWholeSpotlight!public! !

!HRRace methodsFor!
rpWholeSpotlight: anObject
	rpWholeSpotlight := anObject! !
!HRRace categoriesFor: #rpWholeSpotlight:!public! !

!HRRace methodsFor!
runners
	^self allRunners size! !
!HRRace categoriesFor: #runners!public! !

!HRRace methodsFor!
saveAsCsvFile

	self meeting saveAsCsvFile! !
!HRRace categoriesFor: #saveAsCsvFile!public! !

!HRRace methodsFor!
seller

	"^self name words anySatisfy: [ :each | each sameAs: 'seller' ] "
	^self type isBitSet: (self raceTypes at: #Seller)

! !
!HRRace categoriesFor: #seller!public! !

!HRRace methodsFor!
selling

	"^self name words anySatisfy: [ :each | each sameAs: 'selling' ] "
	^self type isBitSet: (self raceTypes at: #Selling)

! !
!HRRace categoriesFor: #selling!public! !

!HRRace methodsFor!
setEsts
	| denom cap |
	HRLogger current 
		showAlways: Time now displayString , ' Generating PP Estimates for: ' , self shortTime, ' ', self meeting course, String lineDelimiter.
	cap := 75.
	self ppValDirty: true.
	self handicap ifTrue: [cap := 60].
	denom := self nags inject: 0 into: [:sum :each | sum + each estRatio].
	denom isZero 
		ifFalse: [self nags do: [:each | each ppEst: (each estRatio * 100 / denom) asFloat rounded]].
	(self nags anySatisfy: [ :each | each ppEst > cap ]) ifTrue: [self adjustEstsFor: cap].
! !
!HRRace categoriesFor: #setEsts!public! !

!HRRace methodsFor!
setHandicap

	self name words detect: [ :each | ((each sameAs: 'Handicap') or: [each sameAs: 'H''cap']) or: [self nursery]] 
		ifNone: [^self handicap: false].
	self handicap: true.
	self type: (self type setBit: (self raceTypes at: #Handicap))! !
!HRRace categoriesFor: #setHandicap!public! !

!HRRace methodsFor!
setPlaced

	| places nonRunners |
	places := self places.
	nonRunners := Bag new.
	self nags do: [ :each | | pos |
		pos := each racePosition.
		(pos isInteger and: [pos between: 1 and: places]) 
			ifTrue: [each placed: true ]
			ifFalse: [each placed: false].
		(each preRaceNR or: [pos isInteger not and: [pos sameAs: 'Non Runner']]) ifTrue: [nonRunners add: each].
		].
	self favPlaced ifTrue: [ nonRunners do: [ :each | each placed: true ]].! !
!HRRace categoriesFor: #setPlaced!public! !

!HRRace methodsFor!
setTotePPDataFrom: totePP

	self ppCarriedForward: totePP thisRace.
	self ppFav: (totePP valueFor: 'Fav').
	self nags do: [ :nag |
		nag ppValue: (totePP valueFor: nag racecardNo)].
	self ppValDirty: true.! !
!HRRace categoriesFor: #setTotePPDataFrom:!public! !

!HRRace methodsFor!
setType

	| words |
	type := 0.
	words := self name words.
	self raceTypes associationsDo: [ :assoc | 
		words do: [ :word | 
			(word sameAs: assoc key) ifTrue: [
				type := type setBit: (assoc value)]]].
! !
!HRRace categoriesFor: #setType!public! !

!HRRace methodsFor!
short24Time
	| result |
	result := String writeStream.
	self time printOn: result format: 'HH:mm'.
	^result contents! !
!HRRace categoriesFor: #short24Time!public! !

!HRRace methodsFor!
shortTime
	| result |
	result := String writeStream.
	self time printOn: result format: 'h:mm'.
	^result contents! !
!HRRace categoriesFor: #shortTime!public! !

!HRRace methodsFor!
slMargin
	"return the difference of 100% and the sum of sl final odds"

	^(self nags inject: 0 into: [ :sum :nag | sum + (1 / (nag slFinalOdds + 1))]) - 1! !
!HRRace categoriesFor: #slMargin!public! !

!HRRace methodsFor!
slShortTime
	| result |
	result := String writeStream.
	self time printOn: result format: 'h.mm'.
	^result contents
! !
!HRRace categoriesFor: #slShortTime!public! !

!HRRace methodsFor!
slTime
	| result |
	result := String writeStream.
"	self time printOn: result format: 'HHmm'." "this should work but On Simon's machine it made it a 12-hour time ?????"
	self time hours < 10 ifTrue: [result nextPut: $0].
	result nextPutAll: self time hours printString.
	self time minutes < 10 ifTrue: [result nextPut: $0].
	result nextPutAll: self time minutes printString.
	^result contents
! !
!HRRace categoriesFor: #slTime!public! !

!HRRace methodsFor!
stakes

"	^self name words anySatisfy: [ :each | each sameAs: 'stakes' ] "
	^self type isBitSet: (self raceTypes at: #Stakes)
! !
!HRRace categoriesFor: #stakes!public! !

!HRRace methodsFor!
subtractNonPlaceValue

	self nags do: [ :each | each ppPlaceValue: each ppPlaceValue - (1 - each placeChance) + 1 ]! !
!HRRace categoriesFor: #subtractNonPlaceValue!public! !

!HRRace methodsFor!
sumOfBFOdds

	^self allRunners inject: 0 into: [ :sum :each | sum + each bfOdds ].
! !
!HRRace categoriesFor: #sumOfBFOdds!public! !

!HRRace methodsFor!
sumOfFinalOdds

	^self allRunners inject: 0 into: [ :sum :each | sum + each slFinalOdds ]! !
!HRRace categoriesFor: #sumOfFinalOdds!public! !

!HRRace methodsFor!
sumOfPlaceChanceBasisFor: aCollection

	^aCollection inject: 0 into: [ :sum :each | sum + each placeChanceBasis ]! !
!HRRace categoriesFor: #sumOfPlaceChanceBasisFor:!public! !

!HRRace methodsFor!
time
	time ifNil: [self time: (Time fromString: '0:00')].
	^time! !
!HRRace categoriesFor: #time!public! !

!HRRace methodsFor!
time: anObject
	time := anObject! !
!HRRace categoriesFor: #time:!public! !

!HRRace methodsFor!
type
	type isInteger ifFalse: [self setType].
	^type! !
!HRRace categoriesFor: #type!public! !

!HRRace methodsFor!
type: anObject
	type := anObject! !
!HRRace categoriesFor: #type:!public! !

!HRRace methodsFor!
unnamedFavAsCsvString
	| result |
	result := String writeStream.
	result 
		nextPutAll: ',,,,,,,,,,,,,,Fav:,'.
	self favPlaced ifTrue: [result nextPutAll: 'TRUE'].
	result
		nextPut: $,;
		nextPutAll: self ppFav printString;
		nextPut: $,;
		nextPutAll: self ppFavPercentage printString;
		nextPut: $,;
		nextPutAll: self ppFavEst printString;
		nextPutAll: ',,,,'.
	^result contents! !
!HRRace categoriesFor: #unnamedFavAsCsvString!public! !

!HRRace methodsFor!
updateLiveData

	[self meeting findPreMeetingNRs] forkAt: 3.
	[self findSLLiveShow] forkAt: 3. 
	self findBetfairOdds.
	self lastUpdate: Time now.
! !
!HRRace categoriesFor: #updateLiveData!public! !

!HRRace categoriesFor: #actualRunners!accessing!private! !

!HRRace categoriesFor: #actualRunners:!accessing!private! !

!HRRace categoriesFor: #addNag:!accessing!private! !

!HRRace categoriesFor: #adjustEstsFor:!public! !

!HRRace categoriesFor: #ageOfNags!accessing!private! !

!HRRace categoriesFor: #ageOfNags:!accessing!private! !

!HRRace categoriesFor: #ageOfNagsStripped!accessing!private! !

!HRRace categoriesFor: #allNagsAsCsvString!public! !

!HRRace categoriesFor: #allNonRunners!public! !

!HRRace categoriesFor: #allPlacedNags!accessing!private! !

!HRRace categoriesFor: #allRunners!public! !

!HRRace categoriesFor: #allRunnersSorted!public! !

!HRRace categoriesFor: #asCsvString!public! !

!HRRace categoriesFor: #bestOddsFav!public! !

!HRRace categoriesFor: #bfRaceID!accessing!private! !

!HRRace categoriesFor: #bfRaceID:!accessing!private! !

!HRRace categoriesFor: #bfRaceTO!accessing!private! !

!HRRace categoriesFor: #bfRaceTO:!accessing!private! !

!HRRace categoriesFor: #bookiesPercentage!accessing!public! !

!HRRace categoriesFor: #bookiesPercentage:!accessing!private! !

!HRRace categoriesFor: #bookiesPercentageAsPercentage!public! !

!HRRace categoriesFor: #calculateBookiesPercentage!public! !

!HRRace categoriesFor: #chase!public! !

!HRRace categoriesFor: #checkAllNags!accessing!private! !

!HRRace categoriesFor: #checkBookiesPerc!accessing!private! !

!HRRace categoriesFor: #checkCFPPValue!accessing!private! !

!HRRace categoriesFor: #checkCompleteness!accessing!private! !

!HRRace categoriesFor: #checkResult!accessing!private! !

!HRRace categoriesFor: #checkSP!accessing!private! !

!HRRace categoriesFor: #claimer!public! !

!HRRace categoriesFor: #claiming!public! !

!HRRace categoriesFor: #collectSlipLines!public! !

!HRRace categoriesFor: #copyPreviews!public! !

!HRRace categoriesFor: #createScheduleItemForSLLiveShow!public! !

!HRRace categoriesFor: #createScheduleItemForSLResult!public! !

!HRRace categoriesFor: #createScheduleItemForSLResultAt:!public! !

!HRRace categoriesFor: #displayOn:!displaying!public! !

!HRRace categoriesFor: #distance!accessing!private! !

!HRRace categoriesFor: #distance:!accessing!private! !

!HRRace categoriesFor: #favPlaced!public! !

!HRRace categoriesFor: #favValueFor:!public! !

!HRRace categoriesFor: #fileInLiveShow!public! !

!HRRace categoriesFor: #fileInResult!public! !

!HRRace categoriesFor: #fileInSLCard!public! !

!HRRace categoriesFor: #fileInTotePPData!public! !

!HRRace categoriesFor: #finalFav!public! !

!HRRace categoriesFor: #finalPPBFAsCsvString!public! !

!HRRace categoriesFor: #findBetfairOdds!public! !

!HRRace categoriesFor: #findBFPlaceOdds!public! !

!HRRace categoriesFor: #findBFWinOdds!public! !

!HRRace categoriesFor: #findRPSpotlightAtURL:!public! !

!HRRace categoriesFor: #findSLLiveShow!public! !

!HRRace categoriesFor: #findSLRaceCard!public! !

!HRRace categoriesFor: #findSLResult!public! !

!HRRace categoriesFor: #findTotePPData!public! !

!HRRace categoriesFor: #flat!public! !

!HRRace categoriesFor: #forecastRunners!accessing!private! !

!HRRace categoriesFor: #forecastRunners:!accessing!private! !

!HRRace categoriesFor: #graded!public! !

!HRRace categoriesFor: #group!public! !

!HRRace categoriesFor: #handicap!public! !

!HRRace categoriesFor: #handicap:!public! !

!HRRace categoriesFor: #hasBFOdds!public! !

!HRRace categoriesFor: #hasFinalOdds!public! !

!HRRace categoriesFor: #hasFullResults!public! !

!HRRace categoriesFor: #hasLiveShows!public! !

!HRRace categoriesFor: #hasPPValues!public! !

!HRRace categoriesFor: #hasResults!public! !

!HRRace categoriesFor: #hurdle!public! !

!HRRace categoriesFor: #includesNagNamed:!public! !

!HRRace categoriesFor: #jumps!public! !

!HRRace categoriesFor: #lastUpdate!accessing!private! !

!HRRace categoriesFor: #lastUpdate:!accessing!private! !

!HRRace categoriesFor: #leg!accessing!private! !

!HRRace categoriesFor: #leg:!accessing!private! !

!HRRace categoriesFor: #listed!public! !

!HRRace categoriesFor: #maiden!public! !

!HRRace categoriesFor: #meeting!accessing!private! !

!HRRace categoriesFor: #meeting:!accessing!private! !

!HRRace categoriesFor: #myFavCount!public! !

!HRRace categoriesFor: #myFavs!public! !

!HRRace categoriesFor: #myFavsExUnnamed!public! !

!HRRace categoriesFor: #myFavThrough!public! !

!HRRace categoriesFor: #myFavThroughAsPerc!public! !

!HRRace categoriesFor: #myLinesRunning!public! !

!HRRace categoriesFor: #myLinesRunningLog!public! !

!HRRace categoriesFor: #myLinesRunningPerc!public! !

!HRRace categoriesFor: #myLinesThroughUptoCurrent!public! !

!HRRace categoriesFor: #myPlacedFavCount!public! !

!HRRace categoriesFor: #myPlacedFavs!public! !

!HRRace categoriesFor: #myPlaceOdds!public! !

!HRRace categoriesFor: #myPlaceOdds:!public! !

!HRRace categoriesFor: #myPlaceOddsAsPercentage!public! !

!HRRace categoriesFor: #myPPSelectionHeader!public! !

!HRRace categoriesFor: #myUnnamedFav!accessing!private! !

!HRRace categoriesFor: #myUnnamedFav:!accessing!private! !

!HRRace categoriesFor: #nagNamed:!accessing!public! !

!HRRace categoriesFor: #nagNo:!accessing!private! !

!HRRace categoriesFor: #nags!accessing!private! !

!HRRace categoriesFor: #nagsCsvStringHeader!public! !

!HRRace categoriesFor: #name!accessing!private! !

!HRRace categoriesFor: #name:!accessing!private! !

!HRRace categoriesFor: #nonRunners!public! !

!HRRace categoriesFor: #noOfNags!accessing!private! !

!HRRace categoriesFor: #notPicked!public! !

!HRRace categoriesFor: #novice!public! !

!HRRace categoriesFor: #nursery!public! !

!HRRace categoriesFor: #outputMyPPSelections!public! !

!HRRace categoriesFor: #outputMyPPSelectionsForSMS!public! !

!HRRace categoriesFor: #performVocabDictionaryKey:!public! !

!HRRace categoriesFor: #places!public! !

!HRRace categoriesFor: #ppBFPerc!public! !

!HRRace categoriesFor: #ppBFPercAsPercentage!public! !

!HRRace categoriesFor: #ppBFPercAsPercOfPrev!public! !

!HRRace categoriesFor: #ppBFPercOfPrev!public! !

!HRRace categoriesFor: #ppBroughtForward!accessing!private! !

!HRRace categoriesFor: #ppCarriedForward!accessing!private! !

!HRRace categoriesFor: #ppCarriedForward:!accessing!private! !

!HRRace categoriesFor: #ppCFPerc!public! !

!HRRace categoriesFor: #ppCFPercAsPercentage!public! !

!HRRace categoriesFor: #ppCFPercAsPercOfPrev!public! !

!HRRace categoriesFor: #ppCFPercOfPrev!public! !

!HRRace categoriesFor: #ppCFWeightedNetPerc!public! !

!HRRace categoriesFor: #ppCFWeightedNetPercAsPerc!public! !

!HRRace categoriesFor: #ppFav!accessing!private! !

!HRRace categoriesFor: #ppFav:!accessing!private! !

!HRRace categoriesFor: #ppFavEst!accessing!private! !

!HRRace categoriesFor: #ppFavEst:!accessing!private! !

!HRRace categoriesFor: #ppFavPercentage!accessing!public! !

!HRRace categoriesFor: #ppNR!public! !

!HRRace categoriesFor: #ppNREst!public! !

!HRRace categoriesFor: #ppPercentage!accessing!public! !

!HRRace categoriesFor: #ppThrough!accessing!private! !

!HRRace categoriesFor: #ppThroughLog!accessing!private! !

!HRRace categoriesFor: #ppThroughNetLog!accessing!private! !

!HRRace categoriesFor: #ppThroughPerc!accessing!private! !

!HRRace categoriesFor: #ppThroughPercNet!accessing!private! !

!HRRace categoriesFor: #ppValDirty!accessing!private! !

!HRRace categoriesFor: #ppValDirty:!accessing!private! !

!HRRace categoriesFor: #preRaceFav!public! !

!HRRace categoriesFor: #preRaceFav:!public! !

!HRRace categoriesFor: #printOn:!displaying!public! !

!HRRace categoriesFor: #publishedAspects!development!must strip!public! !

!HRRace categoriesFor: #race!public! !

!HRRace categoriesFor: #raceID!accessing!private! !

!HRRace categoriesFor: #raceID:!accessing!private! !

!HRRace categoriesFor: #raceName!public! !

!HRRace categoriesFor: #raceType!public! !

!HRRace categoriesFor: #raceTypes!public! !

!HRRace categoriesFor: #recalcRace!public! !

!HRRace categoriesFor: #resetMyFavs!public! !

!HRRace categoriesFor: #resetPreRaceFav!public! !

!HRRace categoriesFor: #rpMargin!public! !

!HRRace categoriesFor: #rpWholeSpotlight!accessing!private! !

!HRRace categoriesFor: #rpWholeSpotlight:!accessing!private! !

!HRRace categoriesFor: #runners!public! !

!HRRace categoriesFor: #saveAsCsvFile!public! !

!HRRace categoriesFor: #seller!public! !

!HRRace categoriesFor: #selling!public! !

!HRRace categoriesFor: #setEsts!public! !

!HRRace categoriesFor: #setHandicap!public! !

!HRRace categoriesFor: #setPlaced!public! !

!HRRace categoriesFor: #setTotePPDataFrom:!public! !

!HRRace categoriesFor: #setType!public! !

!HRRace categoriesFor: #short24Time!public! !

!HRRace categoriesFor: #shortTime!public! !

!HRRace categoriesFor: #slMargin!public! !

!HRRace categoriesFor: #slShortTime!public! !

!HRRace categoriesFor: #slTime!public! !

!HRRace categoriesFor: #stakes!public! !

!HRRace categoriesFor: #subtractNonPlaceValue!public! !

!HRRace categoriesFor: #sumOfBFOdds!public! !

!HRRace categoriesFor: #sumOfFinalOdds!public! !

!HRRace categoriesFor: #sumOfPlaceChanceBasisFor:!public! !

!HRRace categoriesFor: #time!accessing!private! !

!HRRace categoriesFor: #time:!accessing!private! !

!HRRace categoriesFor: #type!accessing!private! !

!HRRace categoriesFor: #type:!accessing!private! !

!HRRace categoriesFor: #unnamedFavAsCsvString!public! !

!HRRace categoriesFor: #updateLiveData!public! !

!HRRace class methodsFor!
setRaceTypes
"
	HRRace setRaceTypes
"
	RaceTypes := (LookupTable new: 18);
		at: #Chase put: 1;
		at: #Claimer put: 2;
		at: #Claiming put: 2;
		at: #Flat put: 3;
		at: #Graded put: 4;
		at: #Group put: 5;
		at: #Handicap put: 6;
		at: #'H''cap' put: 6;
		at: #Hurdle put: 7;
		at: #Listed put: 8;
		at: #Maiden put: 9;
		at: #Novice put: 10;
		at: #Novices put: 10;
		at: #Nursery put: 11;
		at: #Seller put: 12;
		at: #Selling put: 12;
		at: #Stakes put: 13;
		yourself.! !
!HRRace class categoriesFor: #setRaceTypes!public! !

!HRRace class methodsFor!
setVocabDictionary

	vocabDictionary := Dictionary new.
	vocabDictionary 
		at: #actualRunners put: 'Actual runners';
		at: #ageOfNagsStripped put: 'Age of nags';
		at: #bookiesPercentageAsPercentage put: 'Bookies %age';
		at: #distance put: 'Distance';
		at: #forecastRunners put: 'Forecast runners';
		at: #handicap put: 'Handicap';
		at: #leg put: 'Leg';
		at: #time put: 'Time';
		at: #short24Time put: 'Time (hh:mm)';
		at: #ppCarriedForward put: 'PP carried forward';
		at: #ppCFPercAsPercentage put: 'PP CF %';
		at: #ppFav put: 'PP Fav';
		at: #raceID put: 'Race ID';
		at: #raceName put: 'Race name';
		at: #rpWholeSpotlight put: 'Spotlight';
		at: #raceType  put: 'Race type';
		at: #type put: 'Type';
		at: #ppFavEst put: 'PP Fav Est'.! !
!HRRace class categoriesFor: #setVocabDictionary!public! !

!HRRace class methodsFor!
stbConvertFrom: anSTBClassFormat
	"Convert from earlier version models.
	1: see Model.
	2: Added 'preRaceFavs' instance variable to Model.
	3: Replaced 'preRaceFavs' with 'preRaceFav'
	4: Added 'ppFavEst'
	5: Added 'bfRaceID'
	6: Added bfRaceTO
	7: Added lastUpdate
	8: Added myPlaceOdds
	9: Version 55, added myUnnamedFav
	10: Version 55, added ppValDirty
"

	^[:data | | newInst |
		newInst := self basicNew.
		1 to: data size do: [ :i | newInst instVarAt: i put: (data at: i)].
		newInst]
! !
!HRRace class categoriesFor: #stbConvertFrom:!public! !

!HRRace class methodsFor!
stbVersion
	"Answer the current binary filer version number for instances of the receiver."

	^10! !
!HRRace class categoriesFor: #stbVersion!public! !

!HRRace class methodsFor!
vocabDictionaryAt: aKey

	^(self vocabDictionary) at: aKey ifAbsent: [ HRNag vocabDictionaryAt: aKey ]! !
!HRRace class categoriesFor: #vocabDictionaryAt:!public! !

!HRRace class categoriesFor: #setRaceTypes!public! !

!HRRace class categoriesFor: #setVocabDictionary!public! !

!HRRace class categoriesFor: #stbConvertFrom:!public! !

!HRRace class categoriesFor: #stbVersion!public! !

!HRRace class categoriesFor: #vocabDictionaryAt:!public! !

HRRaceStrat guid: (GUID fromString: '{9D6A214B-7A25-48A6-AD43-F2DC8E6ED13B}')!

HRRaceStrat guid: (GUID fromString: '{9D6A214B-7A25-48A6-AD43-F2DC8E6ED13B}')!
HRRaceStrat comment: ''!

HRRaceStrat comment:
''!
!HRRaceStrat categoriesForClass!MVP-Models! !
!HRRaceStrat methodsFor!
asCsvString
	| result |
	result := String writeStream.
	result 
		nextPutAll: self predecessor asCsvString.
"	result nextPut: $,;
		nextPutAll: 'decorator specific race header:,';
		nextPutAll: self decoratorSpecificRaceInfo printString."
	^result contents! !
!HRRaceStrat categoriesFor: #asCsvString!public! !

!HRRaceStrat methodsFor!
doesNotUnderstand: aMessage
	"The receiver has not understood aMessage. Most likely this is because it was intended for
	the originator so we forward it up the chain."

	^aMessage forwardTo: predecessor! !
!HRRaceStrat categoriesFor: #doesNotUnderstand:!public! !

!HRRaceStrat methodsFor!
findPlacedNags

	^(self nags select: [ :each | each stratPlaced ]) size. 
! !
!HRRaceStrat categoriesFor: #findPlacedNags!public! !

!HRRaceStrat methodsFor!
hasPPValues

	self hasRealPPValues ifFalse: [^self nags anySatisfy: [ :each | each ppEst isZero not ]].
	^true! !
!HRRaceStrat categoriesFor: #hasPPValues!public! !

!HRRaceStrat methodsFor!
maxValue

	| result |
	self leg > 6 ifTrue: [^1].
	self hasPPValues ifFalse: [^1].
	result := self nags select: [ :sel | sel fav = true ] thenCollect: [ :col | col ppPlaceValue ].
	result isEmpty ifTrue: [^1].
	^result inject: 0 into: [ :val :ppVal | val max: ppVal ]! !
!HRRaceStrat categoriesFor: #maxValue!public! !

!HRRaceStrat methodsFor!
meeting
	^meeting! !
!HRRaceStrat categoriesFor: #meeting!public! !

!HRRaceStrat methodsFor!
meeting: anObject
	meeting := anObject! !
!HRRaceStrat categoriesFor: #meeting:!public! !

!HRRaceStrat methodsFor!
minValue

	| result |
	self leg > 6 ifTrue: [^1].
	self hasPPValues ifFalse: [^1].
	result := self nags select: [ :sel | sel fav = true ] thenCollect: [ :col | col ppPlaceValue ].
	result isEmpty ifTrue: [^1].
	^result inject: 999 into: [ :val :ppVal | val min: ppVal ]! !
!HRRaceStrat categoriesFor: #minValue!public! !

!HRRaceStrat methodsFor!
nags

	^self subclassResponsibility
"	nags ifNil: [nags := self predecessor nags collect: [ :each | 
		(HRWhateverNag predecessor: each) race: self ]].
	^nags
"! !
!HRRaceStrat categoriesFor: #nags!public! !

!HRRaceStrat methodsFor!
nagsCsvStringHeader
	"return the csv header for the nags"

	^self predecessor nagsCsvStringHeader, self nagsClass csvStringHeader! !
!HRRaceStrat categoriesFor: #nagsCsvStringHeader!public! !

!HRRaceStrat methodsFor!
performVocabDictionaryKey: aKey

	| result |
	(self vocabDictionary includesKey: aKey) ifTrue: [^self perform: aKey].
	result := self meeting performVocabDictionaryKey: aKey.
	(result = '') ifTrue: [result := self predecessor performVocabDictionaryKey: aKey].
	^result! !
!HRRaceStrat categoriesFor: #performVocabDictionaryKey:!public! !

!HRRaceStrat methodsFor!
predecessor
	^predecessor! !
!HRRaceStrat categoriesFor: #predecessor!public! !

!HRRaceStrat methodsFor!
predecessor: anObject
	predecessor := anObject! !
!HRRaceStrat categoriesFor: #predecessor:!public! !

!HRRaceStrat methodsFor!
unnamedFavAsCsvString
	| result |
	result := String writeStream.
	result 
		nextPutAll: self predecessor unnamedFavAsCsvString.
"	result nextPut: $,;
		nextPutAll: 'decorator specific race header:,';
		nextPutAll: self decoratorSpecificRaceInfo printString."
	^result contents! !
!HRRaceStrat categoriesFor: #unnamedFavAsCsvString!public! !

!HRRaceStrat methodsFor!
vocabDictionaryAt: aKey

	| result |
	result := self class vocabDictionaryAt: aKey.
	(result = '') ifTrue: [ result := self predecessor vocabDictionaryAt: aKey ].
	^result! !
!HRRaceStrat categoriesFor: #vocabDictionaryAt:!public! !

!HRRaceStrat categoriesFor: #asCsvString!public! !

!HRRaceStrat categoriesFor: #doesNotUnderstand:!exceptions!public! !

!HRRaceStrat categoriesFor: #findPlacedNags!public! !

!HRRaceStrat categoriesFor: #hasPPValues!public! !

!HRRaceStrat categoriesFor: #maxValue!public! !

!HRRaceStrat categoriesFor: #meeting!accessing!private! !

!HRRaceStrat categoriesFor: #meeting:!accessing!private! !

!HRRaceStrat categoriesFor: #minValue!public! !

!HRRaceStrat categoriesFor: #nags!public! !

!HRRaceStrat categoriesFor: #nagsCsvStringHeader!public! !

!HRRaceStrat categoriesFor: #performVocabDictionaryKey:!public! !

!HRRaceStrat categoriesFor: #predecessor!accessing!private! !

!HRRaceStrat categoriesFor: #predecessor:!accessing!private! !

!HRRaceStrat categoriesFor: #unnamedFavAsCsvString!public! !

!HRRaceStrat categoriesFor: #vocabDictionaryAt:!public! !

!HRRaceStrat class methodsFor!
on: aPredecessor

	^self new predecessor: aPredecessor! !
!HRRaceStrat class categoriesFor: #on:!public! !

!HRRaceStrat class methodsFor!
predecessor: aPredecessor

	^(self new) predecessor: aPredecessor! !
!HRRaceStrat class categoriesFor: #predecessor:!public! !

!HRRaceStrat class categoriesFor: #on:!public! !

!HRRaceStrat class categoriesFor: #predecessor:!public! !

HRBlokeSystemRace guid: (GUID fromString: '{D193E992-5116-43F2-8BBD-EE37D2A922E2}')!

HRBlokeSystemRace guid: (GUID fromString: '{D193E992-5116-43F2-8BBD-EE37D2A922E2}')!
HRBlokeSystemRace comment: ''!

HRBlokeSystemRace comment:
''!
!HRBlokeSystemRace categoriesForClass!MVP-Models! !
!HRBlokeSystemRace methodsFor!
asCsvString
	| result |
	result := String writeStream.
	result 
		nextPutAll: self predecessor asCsvString;
		nextPut: $,.
	result nextPutAll: 'Placed BS Nags:,';
		nextPutAll: self showPlacedBSNags.
	^result contents! !
!HRBlokeSystemRace categoriesFor: #asCsvString!public! !

!HRBlokeSystemRace methodsFor!
findPlacedBSNags

	^self findPlacedNags! !
!HRBlokeSystemRace categoriesFor: #findPlacedBSNags!public! !

!HRBlokeSystemRace methodsFor!
findPlacedNags

	| result |
	result := self nags 
		select: [ :each | each stratPlaced ] 
		thenCollect: [ :each | each fav ].
	^result asArray! !
!HRBlokeSystemRace categoriesFor: #findPlacedNags!public! !

!HRBlokeSystemRace methodsFor!
maxValue

	| result |
	self leg > 6 ifTrue: [^1].
	self hasPPValues ifFalse: [^1].
	result := self nags select: [ :sel | sel fav notNil and: [sel fav > 0 ]] thenCollect: [ :col | col ppPlaceValue ].
	result isEmpty ifTrue: [^1].
	^result inject: 0 into: [ :val :ppVal | val max: ppVal ]! !
!HRBlokeSystemRace categoriesFor: #maxValue!public! !

!HRBlokeSystemRace methodsFor!
minValue

	| result |
	self leg > 6 ifTrue: [^1].
	self hasPPValues ifFalse: [^1].
	result := self nags select: [ :sel | sel fav notNil and: [sel fav > 0 ]] thenCollect: [ :col | col ppPlaceValue ].
	result isEmpty ifTrue: [^1].
	^result inject: 999 into: [ :val :ppVal | val min: ppVal ]! !
!HRBlokeSystemRace categoriesFor: #minValue!public! !

!HRBlokeSystemRace methodsFor!
nags

	nags ifNil: [nags := self predecessor nags collect: [ :each | 
		(HRBlokeSystemNag predecessor: each) race: self ]].
	^nags! !
!HRBlokeSystemRace categoriesFor: #nags!public! !

!HRBlokeSystemRace methodsFor!
nagsClass
	^HRBlokeSystemNag! !
!HRBlokeSystemRace categoriesFor: #nagsClass!public! !

!HRBlokeSystemRace methodsFor!
setBlokeSystemFavs
	| sorted skip |
	self leg = 1 
		ifTrue: [sorted := self nags asSortedCollection: [:a :b | a compareSlFinalOddsWith: b].
			skip := (sorted first slFinalOdds - 3) ceiling min: sorted size - 3] 
		ifFalse: [sorted := self nags asSortedCollection: [:a :b | a compareRpForecastWith: b].
			skip := (sorted first rpForecast - 3) ceiling min: sorted size - 3].
	skip negative ifTrue: [skip := 0].
	1 to: (3 min: sorted size) do: [:i | (sorted at: skip + i) fav: i]! !
!HRBlokeSystemRace categoriesFor: #setBlokeSystemFavs!public! !

!HRBlokeSystemRace methodsFor!
showPlacedBSNags

	| result |
	result := ''.
	self findPlacedNags do: [ :each | result := result, each displayString, ' ' ].
	^result! !
!HRBlokeSystemRace categoriesFor: #showPlacedBSNags!public! !

!HRBlokeSystemRace categoriesFor: #asCsvString!public! !

!HRBlokeSystemRace categoriesFor: #findPlacedBSNags!public! !

!HRBlokeSystemRace categoriesFor: #findPlacedNags!public! !

!HRBlokeSystemRace categoriesFor: #maxValue!public! !

!HRBlokeSystemRace categoriesFor: #minValue!public! !

!HRBlokeSystemRace categoriesFor: #nags!public! !

!HRBlokeSystemRace categoriesFor: #nagsClass!public! !

!HRBlokeSystemRace categoriesFor: #setBlokeSystemFavs!public! !

!HRBlokeSystemRace categoriesFor: #showPlacedBSNags!public! !

!HRBlokeSystemRace class methodsFor!
setVocabDictionary

	vocabDictionary := Dictionary new.
	vocabDictionary 
		at: #findPlacedBSNags put: 'Placed BS Nags (array)';
		at: #showPlacedBSNags put: 'Placed BS Nags'.
! !
!HRBlokeSystemRace class categoriesFor: #setVocabDictionary!public! !

!HRBlokeSystemRace class methodsFor!
vocabDictionaryAt: aKey

	^(self vocabDictionary) at: aKey ifAbsent: [ HRBlokeSystemNag vocabDictionaryAt: aKey ]! !
!HRBlokeSystemRace class categoriesFor: #vocabDictionaryAt:!public! !

!HRBlokeSystemRace class categoriesFor: #setVocabDictionary!public! !

!HRBlokeSystemRace class categoriesFor: #vocabDictionaryAt:!public! !

HRMyRace guid: (GUID fromString: '{771FC08F-646E-47A5-A8E3-18D2AD190CD4}')!

HRMyRace guid: (GUID fromString: '{771FC08F-646E-47A5-A8E3-18D2AD190CD4}')!
HRMyRace comment: ''!

HRMyRace comment:
''!
!HRMyRace categoriesForClass!MVP-Models! !
!HRMyRace methodsFor!
allMyHighestWithHigh

	| mine others result |
	mine := self myPicksSortedByPP.
	others := self notPickedSortedByPP.
	mine size >= self places ifTrue: [^mine first: self places].
	result := mine.
	result addAll: (others first: (self places - mine size)).
	^result! !
!HRMyRace categoriesFor: #allMyHighestWithHigh!public! !

!HRMyRace methodsFor!
allMyHighestWithLow

	| mine others result |
	mine := self myPicksSortedByPP.
	others := self notPickedSortedByPP.
	mine size >= self places ifTrue: [^mine first: self places].
	result := mine.
	result addAll: (others last: (self places - mine size)).
	^result! !
!HRMyRace categoriesFor: #allMyHighestWithLow!public! !

!HRMyRace methodsFor!
allMyHighestWithMiddle

	| mine others result skip |
	mine := self myPicksSortedByPP.
	others := self notPickedSortedByPP.
	skip := others size // 4 + 1.
	mine size >= self places ifTrue: [^mine first: self places].
	result := mine.
	result addAll: (others copyFrom: skip to: (skip - 1 + self places - mine size)).
	^result! !
!HRMyRace categoriesFor: #allMyHighestWithMiddle!public! !

!HRMyRace methodsFor!
allMyLowestWithHigh

	| mine others result |
	mine := self myPicksSortedByPP.
	others := self notPickedSortedByPP.
	mine size >= self places ifTrue: [^mine last: self places].
	result := mine.
	result addAll: (others first: (self places - mine size)).
	^result! !
!HRMyRace categoriesFor: #allMyLowestWithHigh!public! !

!HRMyRace methodsFor!
allMyLowestWithLow

	| mine others result |
	mine := self myPicksSortedByPP.
	others := self notPickedSortedByPP.
	mine size >= self places ifTrue: [^mine last: self places].
	result := mine.
	result addAll: (others last: (self places - mine size)).
	^result! !
!HRMyRace categoriesFor: #allMyLowestWithLow!public! !

!HRMyRace methodsFor!
allMyLowestWithMiddle

	| mine others result skip |
	mine := self myPicksSortedByPP.
	others := self notPickedSortedByPP.
	skip := others size // 4 + 1.
	mine size >= self places ifTrue: [^mine last: self places].
	result := mine.
	result addAll: (others copyFrom: skip to: (skip - 1 + self places - mine size)).
	^result! !
!HRMyRace categoriesFor: #allMyLowestWithMiddle!public! !

!HRMyRace methodsFor!
asCsvString
	| result |
	result := String writeStream.
	result 
		nextPutAll: self predecessor asCsvString;
		nextPut: $,.
	result nextPutAll: 'My placed nags:,';
		nextPutAll: self showMyPlacedNags.
	^result contents! !
!HRMyRace categoriesFor: #asCsvString!public! !

!HRMyRace methodsFor!
estimatedDiviFor: aColl

	| colls through pot |
	through := aColl inject: 0 into: [ :sum :sel | sum + sel ppValueIncFav ].
	pot := self meeting totePPPool * 0.73.
	through isZero ifTrue: [^0].
	^((10 * pot / through) asInteger * 0.1) asScaledDecimal: 2! !
!HRMyRace categoriesFor: #estimatedDiviFor:!public! !

!HRMyRace methodsFor!
estimateForMultiPlace

	| picks places |
	picks := self favCount.
	places := self places.
	picks = 1 ifTrue: [^self estimateSinglePickMultiPlaces].
	picks < places ifTrue: [^self estimatePicksLessThanPlaces].
	picks = places ifTrue: [^self estimateSamePlacesAsPicks].
	^self estimatePicksMoreThanPlaces! !
!HRMyRace categoriesFor: #estimateForMultiPlace!public! !

!HRMyRace methodsFor!
estimateForSinglePlace

	self favCount = 1 ifTrue: [^self estimateSinglePickWithSinglePlace].
	^self estimateMultiPickWithSinglePlace! !
!HRMyRace categoriesFor: #estimateForSinglePlace!public! !

!HRMyRace methodsFor!
estimateMultiPickWithSinglePlace

	| results result |
	results := OrderedCollection new.
	result := self resultFor: (self myPicksSortedByPP first: 1).
	result descr: 'My highest pick'.
	results add: result.
	result := self resultFor: (self myPicksSortedByPP last: 1).
	result descr: 'My lowest pick'.
	results add: result.
	^ListModel on: results! !
!HRMyRace categoriesFor: #estimateMultiPickWithSinglePlace!public! !

!HRMyRace methodsFor!
estimatePicksLessThanPlaces

	| results result |
	results := OrderedCollection new.
	result := self resultFor: (self myHighestWithHigh).
	result descr: 'My highest pick with high ones'.
	results add: result.
	result := self resultFor: (self myHighestWithMiddle).
	result descr: 'My highest pick with medium ones'.
	results add: result.
	result := self resultFor: (self myHighestWithLow).
	result descr: 'My highest pick with outsiders'.
	results add: result.
	self favCount > 2 ifTrue: [
		result := self resultFor: (self myMiddleWithHigh).
		result descr: 'My middle pick with high ones'.
		results add: result.
		result := self resultFor: (self myMiddleWithMiddle).
		result descr: 'My middle pick with medium ones'.
		results add: result.
		result := self resultFor: (self myMiddleWithLow).
		result descr: 'My middle pick with outsiders'.
		results add: result.
		].
	result := self resultFor: (self myLowestWithHigh).
	result descr: 'My lowest pick with high ones'.
	results add: result.
	result := self resultFor: (self myLowestWithMiddle).
	result descr: 'My lowest pick with medium ones'.
	results add: result.
	result := self resultFor: (self myLowestWithLow).
	result descr: 'My lowest pick with outsiders'.
	results add: result.
	result := self resultFor: (self allMyHighestWithHigh).
	result descr: 'All my picks with high ones'.
	results add: result.
	result := self resultFor: (self allMyHighestWithMiddle).
	result descr: 'All my picks with medium ones'.
	results add: result.
	result := self resultFor: (self allMyHighestWithLow).
	result descr: 'All my picks with outsiders'.
	results add: result.
	^ListModel on: results
! !
!HRMyRace categoriesFor: #estimatePicksLessThanPlaces!public! !

!HRMyRace methodsFor!
estimatePicksMoreThanPlaces

	| results result |
	results := OrderedCollection new.
	result := self resultFor: (self myHighestWithHigh).
	result descr: 'My highest pick with high ones'.
	results add: result.
	result := self resultFor: (self myHighestWithMiddle).
	result descr: 'My highest pick with medium ones'.
	results add: result.
	result := self resultFor: (self myHighestWithLow).
	result descr: 'My highest pick with outsiders'.
	results add: result.
	self favCount > 2 ifTrue: [
		result := self resultFor: (self myMiddleWithHigh).
		result descr: 'My middle pick with high ones'.
		results add: result.
		result := self resultFor: (self myMiddleWithMiddle).
		result descr: 'My middle pick with medium ones'.
		results add: result.
		result := self resultFor: (self myMiddleWithLow).
		result descr: 'My middle pick with outsiders'.
		results add: result.
		].
	result := self resultFor: (self myLowestWithHigh).
	result descr: 'My lowest pick with high ones'.
	results add: result.
	result := self resultFor: (self myLowestWithMiddle).
	result descr: 'My lowest pick with medium ones'.
	results add: result.
	result := self resultFor: (self myLowestWithLow).
	result descr: 'My lowest pick with outsiders'.
	results add: result.
	result := self resultFor: (self allMyHighestWithHigh).
	result descr: 'All my highest picks'.
	results add: result.
	result := self resultFor: (self allMyLowestWithHigh).
	result descr: 'All my lowest picks'.
	results add: result.
	^ListModel on: results
! !
!HRMyRace categoriesFor: #estimatePicksMoreThanPlaces!public! !

!HRMyRace methodsFor!
estimateResult

	self favCount isZero ifTrue: [^OrderedCollection with: HRDiviEst new].
	self places = 1 ifTrue: [^self estimateForSinglePlace].
	^self estimateForMultiPlace! !
!HRMyRace categoriesFor: #estimateResult!public! !

!HRMyRace methodsFor!
estimateSamePlacesAsPicks

	| results result |
	results := OrderedCollection new.
	result := self resultFor: (self myHighestWithHigh).
	result descr: 'My highest pick with high ones'.
	results add: result.
	result := self resultFor: (self myHighestWithMiddle).
	result descr: 'My highest pick with medium ones'.
	results add: result.
	result := self resultFor: (self myHighestWithLow).
	result descr: 'My highest pick with outsiders'.
	results add: result.
	self favCount > 2 ifTrue: [
		result := self resultFor: (self myMiddleWithHigh).
		result descr: 'My middle pick with high ones'.
		results add: result.
		result := self resultFor: (self myMiddleWithMiddle).
		result descr: 'My middle pick with medium ones'.
		results add: result.
		result := self resultFor: (self myMiddleWithLow).
		result descr: 'My middle pick with outsiders'.
		results add: result.
		].
	result := self resultFor: (self myLowestWithHigh).
	result descr: 'My lowest pick with high ones'.
	results add: result.
	result := self resultFor: (self myLowestWithMiddle).
	result descr: 'My lowest pick with medium ones'.
	results add: result.
	result := self resultFor: (self myLowestWithLow).
	result descr: 'My lowest pick with outsiders'.
	results add: result.
	result := self resultFor: (self allMyHighestWithHigh).
	result descr: 'All my picks'.
	results add: result.
	^ListModel on: results
! !
!HRMyRace categoriesFor: #estimateSamePlacesAsPicks!public! !

!HRMyRace methodsFor!
estimateSinglePickMultiPlaces

	| results result |
	results := OrderedCollection new.
	result := self resultFor: (self myHighestWithHigh).
	result descr: 'My pick with high ones'.
	results add: result.
	result := self resultFor: (self myHighestWithMiddle).
	result descr: 'My pick with medium ones'.
	results add: result.
	result := self resultFor: (self myHighestWithLow).
	result descr: 'My pick with outsiders'.
	results add: result.
	^ListModel on: results
! !
!HRMyRace categoriesFor: #estimateSinglePickMultiPlaces!public! !

!HRMyRace methodsFor!
estimateSinglePickWithSinglePlace

	| results result |
	results := OrderedCollection new.
	result := self resultFor: self myFavs.
	result descr: 'My single pick'.
	results add: result.
	^ListModel on: results! !
!HRMyRace categoriesFor: #estimateSinglePickWithSinglePlace!public! !

!HRMyRace methodsFor!
favCount

	^self myFavCount! !
!HRMyRace categoriesFor: #favCount!public! !

!HRMyRace methodsFor!
findPlacedNags

	(self myUnnamedFav and: [self favPlaced]) ifTrue: [^super findPlacedNags + 1].
	^super findPlacedNags
! !
!HRMyRace categoriesFor: #findPlacedNags!public! !

!HRMyRace methodsFor!
happy

	happy ifNil: [happy := false].
	^happy! !
!HRMyRace categoriesFor: #happy!public! !

!HRMyRace methodsFor!
happy: aBoolean

	happy := aBoolean! !
!HRMyRace categoriesFor: #happy:!public! !

!HRMyRace methodsFor!
happyString

	self happy ifTrue: [^' - Happy'].
	^''! !
!HRMyRace categoriesFor: #happyString!public! !

!HRMyRace methodsFor!
myHighestWithHigh

	| mine others result |
	mine := self myPicksSortedByPP.
	others := self notPickedSortedByPP.
	result := others first: (self places - 1).
	result add: mine first.
	^result! !
!HRMyRace categoriesFor: #myHighestWithHigh!public! !

!HRMyRace methodsFor!
myHighestWithLow

	| mine others result |
	mine := self myPicksSortedByPP.
	others := self notPickedSortedByPP.
	result := others last: (self places - 1).
	result add: mine first.
	^result! !
!HRMyRace categoriesFor: #myHighestWithLow!public! !

!HRMyRace methodsFor!
myHighestWithMiddle

	| mine others result skip |
	mine := self myPicksSortedByPP.
	others := self notPickedSortedByPP.
	skip := others size // 4 + 1.
	others size = 3 ifTrue: [skip := skip + 1].
	result := others copyFrom: skip to: (skip - 1 + self places - 1).
	result add: mine first.
	^result! !
!HRMyRace categoriesFor: #myHighestWithMiddle!public! !

!HRMyRace methodsFor!
myLowestWithHigh

	| mine others result |
	mine := self myPicksSortedByPP.
	others := self notPickedSortedByPP.
	result := others first: (self places - 1).
	result add: mine last.
	^result! !
!HRMyRace categoriesFor: #myLowestWithHigh!public! !

!HRMyRace methodsFor!
myLowestWithLow

	| mine others result |
	mine := self myPicksSortedByPP.
	others := self notPickedSortedByPP.
	result := others last: (self places - 1).
	result add: mine last.
	^result! !
!HRMyRace categoriesFor: #myLowestWithLow!public! !

!HRMyRace methodsFor!
myLowestWithMiddle

	| mine others result skip |
	mine := self myPicksSortedByPP.
	others := self notPickedSortedByPP.
	skip := others size // 4 + 1.
	others size = 3 ifTrue: [skip := skip + 1].
	result := others copyFrom: skip to: (skip - 1 + self places - 1).
	result add: mine last.
	^result! !
!HRMyRace categoriesFor: #myLowestWithMiddle!public! !

!HRMyRace methodsFor!
myMiddleWithHigh

	| mine others result mySkip |
	mine := self myPicksSortedByPP.
	others := self notPickedSortedByPP.
	mySkip := mine size // 4 + 1.
	mine size = 3 ifTrue: [mySkip := mySkip + 1].
	result := others first: (self places - 1).
	result add: (mine at: mySkip).
	^result! !
!HRMyRace categoriesFor: #myMiddleWithHigh!public! !

!HRMyRace methodsFor!
myMiddleWithLow

	| mine others result mySkip |
	mine := self myPicksSortedByPP.
	others := self notPickedSortedByPP.
	mySkip := mine size // 4 + 1.
	mine size = 3 ifTrue: [mySkip := mySkip + 1].
	result := others last: (self places - 1).
	result add: (mine at: mySkip).
	^result! !
!HRMyRace categoriesFor: #myMiddleWithLow!public! !

!HRMyRace methodsFor!
myMiddleWithMiddle

	| mine others result skip mySkip |
	mine := self myPicksSortedByPP.
	others := self notPickedSortedByPP.
	mySkip := mine size // 4 + 1.
	mine size = 3 ifTrue: [mySkip := mySkip + 1].
	skip := others size // 4 + 1.
	others size = 3 ifTrue: [skip := skip + 1].
	result := others copyFrom: skip to: (skip - 1 + self places - 1).
	result add: (mine at: mySkip).
	^result! !
!HRMyRace categoriesFor: #myMiddleWithMiddle!public! !

!HRMyRace methodsFor!
myPicksSortedByPP

	| coll |
	coll := self myFavs.
	coll isEmpty ifTrue: [^coll].
	^coll asSortedCollection: [ :a :b | a ppValueIncFav > b ppValueIncFav ]! !
!HRMyRace categoriesFor: #myPicksSortedByPP!public! !

!HRMyRace methodsFor!
myPlaceOdds

"	| coll |
	coll := self nags select: [ :each | each fav ] thenCollect: [ :each | 1 - each placeChance ].
	^1-(coll inject: 1 into: [ :cum :odds | cum * odds ])
"
	^self predecessor myPlaceOdds! !
!HRMyRace categoriesFor: #myPlaceOdds!public! !

!HRMyRace methodsFor!
nags

	nags ifNil: [nags := self predecessor nags collect: [ :each | 
		(HRMyNag predecessor: each) race: self ]].
	^nags! !
!HRMyRace categoriesFor: #nags!public! !

!HRMyRace methodsFor!
nagsClass
	^HRMyNag! !
!HRMyRace categoriesFor: #nagsClass!public! !

!HRMyRace methodsFor!
notPickedSortedByPP

	| coll |
	coll := self notPicked.
	coll isEmpty ifTrue: [^coll].
	^coll asSortedCollection: [ :a :b | a ppValueIncFav > b ppValueIncFav ]! !
!HRMyRace categoriesFor: #notPickedSortedByPP!public! !

!HRMyRace methodsFor!
resultFor: aCollection

	| lines divi return profit placedFavCount result |
	result := HRDiviEst new.
	placedFavCount := (aCollection select: [ :each | each mySelect ]) size.
	lines := placedFavCount * self myLinesThroughUptoCurrent.
	divi := self estimatedDiviFor: aCollection.
	return := (lines * divi * self meeting myStake) asScaledDecimal: 2.
	profit := (return - (self meeting myLines * self meeting myStake)) asScaledDecimal: 2.
	result lines: lines; divi: divi; return: return; profit: profit.
	^result! !
!HRMyRace categoriesFor: #resultFor:!public! !

!HRMyRace methodsFor!
showMyPlacedNags

	^self findPlacedNags displayString.
! !
!HRMyRace categoriesFor: #showMyPlacedNags!public! !

!HRMyRace methodsFor!
unnamedFavAsCsvString
	| result |
	result := String writeStream.
	result 
		nextPutAll: self predecessor unnamedFavAsCsvString.
	self myUnnamedFav ifTrue: [
		result 
			nextPut: $,;
			nextPutAll: 'TRUE';
			nextPut: $,.
		self favPlaced ifTrue: [result nextPutAll: 'TRUE']].
	^result contents! !
!HRMyRace categoriesFor: #unnamedFavAsCsvString!public! !

!HRMyRace categoriesFor: #allMyHighestWithHigh!public! !

!HRMyRace categoriesFor: #allMyHighestWithLow!public! !

!HRMyRace categoriesFor: #allMyHighestWithMiddle!public! !

!HRMyRace categoriesFor: #allMyLowestWithHigh!public! !

!HRMyRace categoriesFor: #allMyLowestWithLow!public! !

!HRMyRace categoriesFor: #allMyLowestWithMiddle!public! !

!HRMyRace categoriesFor: #asCsvString!public! !

!HRMyRace categoriesFor: #estimatedDiviFor:!public! !

!HRMyRace categoriesFor: #estimateForMultiPlace!public! !

!HRMyRace categoriesFor: #estimateForSinglePlace!public! !

!HRMyRace categoriesFor: #estimateMultiPickWithSinglePlace!public! !

!HRMyRace categoriesFor: #estimatePicksLessThanPlaces!public! !

!HRMyRace categoriesFor: #estimatePicksMoreThanPlaces!public! !

!HRMyRace categoriesFor: #estimateResult!public! !

!HRMyRace categoriesFor: #estimateSamePlacesAsPicks!public! !

!HRMyRace categoriesFor: #estimateSinglePickMultiPlaces!public! !

!HRMyRace categoriesFor: #estimateSinglePickWithSinglePlace!public! !

!HRMyRace categoriesFor: #favCount!public! !

!HRMyRace categoriesFor: #findPlacedNags!public! !

!HRMyRace categoriesFor: #happy!public! !

!HRMyRace categoriesFor: #happy:!public! !

!HRMyRace categoriesFor: #happyString!public! !

!HRMyRace categoriesFor: #myHighestWithHigh!public! !

!HRMyRace categoriesFor: #myHighestWithLow!public! !

!HRMyRace categoriesFor: #myHighestWithMiddle!public! !

!HRMyRace categoriesFor: #myLowestWithHigh!public! !

!HRMyRace categoriesFor: #myLowestWithLow!public! !

!HRMyRace categoriesFor: #myLowestWithMiddle!public! !

!HRMyRace categoriesFor: #myMiddleWithHigh!public! !

!HRMyRace categoriesFor: #myMiddleWithLow!public! !

!HRMyRace categoriesFor: #myMiddleWithMiddle!public! !

!HRMyRace categoriesFor: #myPicksSortedByPP!public! !

!HRMyRace categoriesFor: #myPlaceOdds!public! !

!HRMyRace categoriesFor: #nags!public! !

!HRMyRace categoriesFor: #nagsClass!public! !

!HRMyRace categoriesFor: #notPickedSortedByPP!public! !

!HRMyRace categoriesFor: #resultFor:!public! !

!HRMyRace categoriesFor: #showMyPlacedNags!public! !

!HRMyRace categoriesFor: #unnamedFavAsCsvString!public! !

HRPumpkin3Race guid: (GUID fromString: '{837FD931-A9E3-48C1-8CE2-048A7FC62AA8}')!

HRPumpkin3Race guid: (GUID fromString: '{837FD931-A9E3-48C1-8CE2-048A7FC62AA8}')!
HRPumpkin3Race comment: ''!

HRPumpkin3Race comment:
''!
!HRPumpkin3Race categoriesForClass!MVP-Models! !
!HRPumpkin3Race methodsFor!
asCsvString
	| result |
	result := String writeStream.
	result 
		nextPutAll: self predecessor asCsvString;
		nextPut: $,.
	self badRace 
		ifTrue: [result nextPutAll: 'Bad Pumpkin3 race,']
		ifFalse: [
			result nextPutAll: 'Placed Pumpkin3 nags:,'.
			result nextPutAll: self showPlacedPumpkin3Nags].
	^result contents! !
!HRPumpkin3Race categoriesFor: #asCsvString!public! !

!HRPumpkin3Race methodsFor!
badP3Race

	^self badRace! !
!HRPumpkin3Race categoriesFor: #badP3Race!public! !

!HRPumpkin3Race methodsFor!
badRace

	badRace ifNil: [ badRace := false ].
	^badRace! !
!HRPumpkin3Race categoriesFor: #badRace!public! !

!HRPumpkin3Race methodsFor!
bestOdds
	self sortedOdds isEmpty ifTrue: [badRace := true. ^0].
	^(self sortedOdds) first 
! !
!HRPumpkin3Race categoriesFor: #bestOdds!public! !

!HRPumpkin3Race methodsFor!
bestOddsPos
	| selection |
	selection := self class oddsRange detect: [:each | self bestOdds < each]
				ifNone: [^self class oddsRange size + 1].
	^self class oddsRange indexOf: selection! !
!HRPumpkin3Race categoriesFor: #bestOddsPos!public! !

!HRPumpkin3Race methodsFor!
favCount
	favCount ifNil: [self setFavCount].
	^favCount
	! !
!HRPumpkin3Race categoriesFor: #favCount!public! !

!HRPumpkin3Race methodsFor!
favP3Count
	^self favCount
	! !
!HRPumpkin3Race categoriesFor: #favP3Count!public! !

!HRPumpkin3Race methodsFor!
findSelectionCandidates

"	| result maxOdds this next |
	(self bestOdds <= 3) ifTrue: [ result := 3 ] ifFalse: [ result := self bestOdds ceiling ].
	this := sortedOdds at: result.
	next := sortedOdds at: (result + 1).
	this = next ifFalse: [ 
		((1/(1+this))-(1/(1+next)))/(1/(1+this)) < 0.16 ifTrue: [ 
			result := result + 1]].
	maxOdds := sortedOdds at: result.
	^nags select: [ :each | each bestOdds <= maxOdds ]
"
	^nags select: [ :each | each ppPlaceValue > 1 ]
! !
!HRPumpkin3Race categoriesFor: #findSelectionCandidates!public! !

!HRPumpkin3Race methodsFor!
nags

	nags ifNil: [nags := self predecessor nags collect: [ :each | 
		(HRPumpkin3Nag predecessor: each) race: self ]].
	^nags! !
!HRPumpkin3Race categoriesFor: #nags!public! !

!HRPumpkin3Race methodsFor!
nagsClass
	^HRPumpkin3Nag! !
!HRPumpkin3Race categoriesFor: #nagsClass!public! !

!HRPumpkin3Race methodsFor!
noOfSelections

	^(self class selectionMatrix at: self bestOddsPos) at: self runnersPos
! !
!HRPumpkin3Race categoriesFor: #noOfSelections!public! !

!HRPumpkin3Race methodsFor!
oddsAsPercentage: odds

	^1/(1+odds)! !
!HRPumpkin3Race categoriesFor: #oddsAsPercentage:!public! !

!HRPumpkin3Race methodsFor!
pickP3Candidates

	| selectionCandidates selections |
	self nags do: [ :each | each fav: nil ].
	self badRace ifTrue: [^nil].
	self noOfSelections = 0 ifTrue: [ badRace := true. ^nil ].
	selectionCandidates := self findSelectionCandidates asSortedCollection: 
		[ :a :b | a betterValueThan: b].
	selectionCandidates isEmpty ifTrue: [^self setFavsWithoutPP].
	(selectionCandidates first: (self noOfSelections min: selectionCandidates size)) do: [ :each | 
		each fav: true. 
		self sumValue: self sumValue + each value].
	self setFavCount.	! !
!HRPumpkin3Race categoriesFor: #pickP3Candidates!public! !

!HRPumpkin3Race methodsFor!
runnersPos

	| runners selection |
	runners := self actualRunners.
	runners = 0 ifTrue: [runners := self forecastRunners].
	selection := self class runnersRange detect: [ :each | runners <= each ] ifNone: [^self class runnersRange size + 1].
	^self class runnersRange indexOf: selection! !
!HRPumpkin3Race categoriesFor: #runnersPos!public! !

!HRPumpkin3Race methodsFor!
setFavCount
	favCount := (self nags select: [ :each | each fav notNil ]) size
	! !
!HRPumpkin3Race categoriesFor: #setFavCount!public! !

!HRPumpkin3Race methodsFor!
setFavsWithoutPP
	"follow blokesystem but with P3 no of selections"
	| sorted skip |
	sorted := self nags asSortedCollection: [:a :b | a compareBestOddsWith: b].
	skip := (sorted first bestOdds - 3) ceiling min: sorted size - 3. 
	skip negative ifTrue: [skip := 0].
	1 to: (self noOfSelections) do: [:i | (sorted at: skip + i) fav: true].
	self setFavCount.! !
!HRPumpkin3Race categoriesFor: #setFavsWithoutPP!public! !

!HRPumpkin3Race methodsFor!
setSortedOdds

	| oddsCollection |
	oddsCollection := self nags collect: [ :each | each bestOdds ].
	oddsCollection := oddsCollection reject: [ :each | each = 0 ].
	sortedOdds := oddsCollection asSortedCollection: [ :a :b | a <= b ].! !
!HRPumpkin3Race categoriesFor: #setSortedOdds!public! !

!HRPumpkin3Race methodsFor!
showPlacedPumpkin3Nags

	^self findPlacedNags displayString.
! !
!HRPumpkin3Race categoriesFor: #showPlacedPumpkin3Nags!public! !

!HRPumpkin3Race methodsFor!
sortedOdds

	sortedOdds 
		ifNil: [self setSortedOdds].
	^sortedOdds

	! !
!HRPumpkin3Race categoriesFor: #sortedOdds!public! !

!HRPumpkin3Race methodsFor!
sumValue
	sumValue ifNil: [sumValue := 0].
	^sumValue! !
!HRPumpkin3Race categoriesFor: #sumValue!public! !

!HRPumpkin3Race methodsFor!
sumValue: anObject
	sumValue := anObject! !
!HRPumpkin3Race categoriesFor: #sumValue:!public! !

!HRPumpkin3Race categoriesFor: #asCsvString!public! !

!HRPumpkin3Race categoriesFor: #badP3Race!public! !

!HRPumpkin3Race categoriesFor: #badRace!public! !

!HRPumpkin3Race categoriesFor: #bestOdds!public! !

!HRPumpkin3Race categoriesFor: #bestOddsPos!public! !

!HRPumpkin3Race categoriesFor: #favCount!public! !

!HRPumpkin3Race categoriesFor: #favP3Count!public! !

!HRPumpkin3Race categoriesFor: #findSelectionCandidates!public! !

!HRPumpkin3Race categoriesFor: #nags!public! !

!HRPumpkin3Race categoriesFor: #nagsClass!public! !

!HRPumpkin3Race categoriesFor: #noOfSelections!public! !

!HRPumpkin3Race categoriesFor: #oddsAsPercentage:!public! !

!HRPumpkin3Race categoriesFor: #pickP3Candidates!public! !

!HRPumpkin3Race categoriesFor: #runnersPos!public! !

!HRPumpkin3Race categoriesFor: #setFavCount!public! !

!HRPumpkin3Race categoriesFor: #setFavsWithoutPP!public! !

!HRPumpkin3Race categoriesFor: #setSortedOdds!public! !

!HRPumpkin3Race categoriesFor: #showPlacedPumpkin3Nags!public! !

!HRPumpkin3Race categoriesFor: #sortedOdds!public! !

!HRPumpkin3Race categoriesFor: #sumValue!accessing!private! !

!HRPumpkin3Race categoriesFor: #sumValue:!accessing!private! !

!HRPumpkin3Race class methodsFor!
oddsRange

	^#(1 2 3 5 7)! !
!HRPumpkin3Race class categoriesFor: #oddsRange!public! !

!HRPumpkin3Race class methodsFor!
runnersRange
	^#(4 5 7 9 14).! !
!HRPumpkin3Race class categoriesFor: #runnersRange!public! !

!HRPumpkin3Race class methodsFor!
selectionMatrix

	^#(
		(0 1 2 1 2 3) 
		(0 1 2 1 2 3)
		(0 1 2 1 2 3)
		(0 2 2 2 3 3)
		(0 2 2 2 3 4)
		(0 2 2 3 3 4)
	)
! !
!HRPumpkin3Race class categoriesFor: #selectionMatrix!public! !

!HRPumpkin3Race class methodsFor!
setVocabDictionary

	vocabDictionary := Dictionary new.
	vocabDictionary 
		at: #badP3Race put: 'Bad P3 Race';
		at: #favP3Count put: 'P3 Favs';
		at: #showPlacedPumpkin3Nags put: 'Placed P3 Nags'.
! !
!HRPumpkin3Race class categoriesFor: #setVocabDictionary!public! !

!HRPumpkin3Race class methodsFor!
vocabDictionaryAt: aKey

	^(self vocabDictionary) at: aKey ifAbsent: [ HRPumpkin3Nag vocabDictionaryAt: aKey ]! !
!HRPumpkin3Race class categoriesFor: #vocabDictionaryAt:!public! !

!HRPumpkin3Race class categoriesFor: #oddsRange!public! !

!HRPumpkin3Race class categoriesFor: #runnersRange!public! !

!HRPumpkin3Race class categoriesFor: #selectionMatrix!public! !

!HRPumpkin3Race class categoriesFor: #setVocabDictionary!public! !

!HRPumpkin3Race class categoriesFor: #vocabDictionaryAt:!public! !

HRRacePlaceCalc guid: (GUID fromString: '{45BDC543-A9C1-4E6C-AED4-1A31C53294D8}')!

HRRacePlaceCalc guid: (GUID fromString: '{45BDC543-A9C1-4E6C-AED4-1A31C53294D8}')!
HRRacePlaceCalc comment: ''!

HRRacePlaceCalc comment:
''!
!HRRacePlaceCalc categoriesForClass!MVP-Models! !
!HRRacePlaceCalc methodsFor!
addPPPlaceValueFor: anArray chance: aChance

	| cum favs favVal |
	self allPlaceChances addLast: (anArray -> aChance).
	cum := anArray inject: 0 into: [ :sum :each | sum + each ppPercIncFav ].
	cum isZero ifFalse: [anArray do: [ :each |
		each ppPlaceValue: each ppPlaceValue + (((1 / cum) - 1) * aChance) ]].! !
!HRRacePlaceCalc categoriesFor: #addPPPlaceValueFor:chance:!public! !

!HRRacePlaceCalc methodsFor!
allNonRunners

	^self nags select: [ :each | each nonRunner == true ]! !
!HRRacePlaceCalc categoriesFor: #allNonRunners!public! !

!HRRacePlaceCalc methodsFor!
allPlaceChances

	allPlaceChances ifNil: [allPlaceChances := OrderedCollection new].
	^allPlaceChances! !
!HRRacePlaceCalc categoriesFor: #allPlaceChances!public! !

!HRRacePlaceCalc methodsFor!
allRunners

	allRunners ifNil: [allRunners := self nags select: [ :each | each nonRunner == false ]].
	^allRunners! !
!HRRacePlaceCalc categoriesFor: #allRunners!public! !

!HRRacePlaceCalc methodsFor!
allRunnersBasis

	allRunnersBasis ifNil: [allRunnersBasis := self sumOfPlaceChanceBasisFor: self allRunners].
	^allRunnersBasis! !
!HRRacePlaceCalc categoriesFor: #allRunnersBasis!public! !

!HRRacePlaceCalc methodsFor!
allRunnersSorted

	^self allRunners asSortedCollection: [ :a :b | a placeChanceBasis > b placeChanceBasis ]! !
!HRRacePlaceCalc categoriesFor: #allRunnersSorted!public! !

!HRRacePlaceCalc methodsFor!
asCsvString
	| result |
	result := String writeStream.
	result 
		nextPutAll: self predecessor asCsvString;
		nextPut: $,.
	^result contents! !
!HRRacePlaceCalc categoriesFor: #asCsvString!public! !

!HRRacePlaceCalc methodsFor!
calculateFirstPlaceChance

	| final basis |
	final := self places < 2.
	basis := self allRunnersBasis.
	basis isZero ifTrue: [^self].
	self allRunners do: [ :each |
		each placeChance: ((each placeChanceBasis / basis) roundTo: 0.000001).
		final ifTrue: [self addPPPlaceValueFor: (Array with: each) chance: each placeChance ]].
	final ifFalse: [ self calculateSecondPlaceChance ].! !
!HRRacePlaceCalc categoriesFor: #calculateFirstPlaceChance!public! !

!HRRacePlaceCalc methodsFor!
calculateFourthPlaceChance

	| basis myNags |
	myNags := self allRunners.
	basis := self allRunnersBasis.
	basis isZero ifTrue: [basis := 1].
	myNags size > 25 ifTrue: [
		myNags := self mainRunners.
		basis := self mainRunnersBasis ].
	myNags do: [ :first |
		myNags do: [ :second |
			second == first ifFalse: [
				myNags do: [ :third |
					((third ~~ second) and: [third ~~ first]) ifTrue: [
						myNags do: [ :fourth |
							((fourth ~~ third) and: [(fourth ~~ second) and: 
								[fourth ~~ first]]) 
							ifTrue: [ | chance |
	chance := (first placeChanceBasis * second placeChanceBasis * 
		third placeChanceBasis * fourth placeChanceBasis / 
		basis /
		(basis - first placeChanceBasis) / 
		(basis - first placeChanceBasis - second placeChanceBasis) /
		(basis - first placeChanceBasis - second placeChanceBasis - third placeChanceBasis)
		) roundTo: 0.000001.
	fourth placeChance: (fourth placeChance + chance).
	self addPPPlaceValueFor: 
			(Array with: first with: second with: third with: fourth) chance: chance.
								]
							]
						]
					]
				]
			]
		].
! !
!HRRacePlaceCalc categoriesFor: #calculateFourthPlaceChance!public! !

!HRRacePlaceCalc methodsFor!
calculatePlaceChance
	"first set to zero"
"	self nags do: [ :each | each placeChance: 0; placeChanceBasis: nil; ppPlaceValue: 0.].
	self setPreRaceFavs.
	self calculateFirstPlaceChance.
	self subtractNonPlaceValue."
	self calculatePPValue
! !
!HRRacePlaceCalc categoriesFor: #calculatePlaceChance!public! !

!HRRacePlaceCalc methodsFor!
calculatePPValue
	"first set to zero"
	self ppValDirty ifFalse: [^nil].
	allRunners := nil.
	allRunnersBasis := nil.
	mainRunners := nil.
	mainRunnersBasis := nil.
	places := nil.
	sumOfBFOdds := nil.
	sumOfFinalOdds := nil.
	hasRealPPValues := nil.
	totalPPEst := nil.
	self nags do: [ :each | each placeChance: 0; placeChanceBasis: nil; ppPlaceValue: 0; ppPercIncFav: nil.].
	self setNagsPPPercIncFav.
	self resetAllPlaceChances.
	self calculateFirstPlaceChance.
	self subtractNonPlaceValue.
	self setMyPlaceOdds.
	self nags do: [ :each | 
		each predecessor placeChance: each placeChance. 
		each predecessor ppPlaceValue: each ppPlaceValue.].
	self copyFavValuesToNRs.
	self ppValDirty: false.
! !
!HRRacePlaceCalc categoriesFor: #calculatePPValue!public! !

!HRRacePlaceCalc methodsFor!
calculateSecondPlaceChance

	| final basis |
	final := self places = 2.
	basis := self allRunnersBasis.
	basis isZero ifTrue: [basis := 1].
	self allRunners do: [ :first |
		self allRunners do: [ :second |
			second == first ifFalse: [ | chance |
				chance := (first placeChanceBasis * second placeChanceBasis / 
					basis /
					(basis - first placeChanceBasis)) roundTo: 0.000001.
				second placeChance: (second placeChance + chance).
				final ifTrue: [self addPPPlaceValueFor: (Array with: first with: second) chance: chance].
				]
			]
		].
	final ifFalse: [ self calculateThirdPlaceChance ].! !
!HRRacePlaceCalc categoriesFor: #calculateSecondPlaceChance!public! !

!HRRacePlaceCalc methodsFor!
calculateThirdPlaceChance

	| final basis myNags |
	final := self places = 3.
	myNags := self allRunners.
	basis := self allRunnersBasis.
	basis isZero ifTrue: [basis := 1].
	myNags do: [ :first |
		myNags do: [ :second |
			second == first ifFalse: [
				myNags do: [ :third |
					((third ~~ second) and: [third ~~ first]) ifTrue: [ | chance |
		chance := (first placeChanceBasis * second placeChanceBasis * 
			third placeChanceBasis / 
			basis /
			(basis - first placeChanceBasis) / 
			(basis - first placeChanceBasis - second placeChanceBasis)) 
			roundTo: 0.000001.
		third placeChance: (third placeChance + chance).
		final ifTrue: [self addPPPlaceValueFor: (Array with: first with: second with: third) chance: chance].
						]
					]
				]
			]
		].
	final ifFalse: [ self calculateFourthPlaceChance ].! !
!HRRacePlaceCalc categoriesFor: #calculateThirdPlaceChance!public! !

!HRRacePlaceCalc methodsFor!
copyFavValuesToNRs

	self allNonRunners do: [ :each | 
		each placeChance: self preRaceFav placeChance. 
		each predecessor placeChance: self preRaceFav placeChance. 
		each predecessor ppPlaceValue: self preRaceFav ppPlaceValue.].
! !
!HRRacePlaceCalc categoriesFor: #copyFavValuesToNRs!public! !

!HRRacePlaceCalc methodsFor!
findNagsUpTo: aPercentage

	| basis sortedOdds sum index |
	basis := self allRunnersBasis.
	sortedOdds := (self allRunners collect: [ :each | (each placeChanceBasis / basis) 
		roundTo: 0.000001 ]) asSortedCollection: [ :a :b | a > b ].
	sum := 0.
	sortedOdds := sortedOdds collect: [ :each | sum := each + sum ].
	index := sortedOdds findFirst: [ :each | each >= aPercentage ].
	^self allRunnersSorted first: index! !
!HRRacePlaceCalc categoriesFor: #findNagsUpTo:!public! !

!HRRacePlaceCalc methodsFor!
hasBFOdds

	^self sumOfBFOdds isZero not! !
!HRRacePlaceCalc categoriesFor: #hasBFOdds!public! !

!HRRacePlaceCalc methodsFor!
hasFinalOdds

	^self sumOfFinalOdds isZero not! !
!HRRacePlaceCalc categoriesFor: #hasFinalOdds!public! !

!HRRacePlaceCalc methodsFor!
hasFinalResult

	^self nags anySatisfy: [ :each | each placed ]! !
!HRRacePlaceCalc categoriesFor: #hasFinalResult!public! !

!HRRacePlaceCalc methodsFor!
hasRealPPValues

	hasRealPPValues ifNil: [hasRealPPValues := self nags anySatisfy: [ :each | each ppValue isZero not ]].
	^hasRealPPValues! !
!HRRacePlaceCalc categoriesFor: #hasRealPPValues!public! !

!HRRacePlaceCalc methodsFor!
mainRunners

	mainRunners ifNil: [mainRunners := self findNagsUpTo: 0.97].
	^mainRunners! !
!HRRacePlaceCalc categoriesFor: #mainRunners!public! !

!HRRacePlaceCalc methodsFor!
mainRunnersBasis

	mainRunnersBasis ifNil: [mainRunnersBasis := self sumOfPlaceChanceBasisFor: self mainRunners].
	^mainRunnersBasis! !
!HRRacePlaceCalc categoriesFor: #mainRunnersBasis!public! !

!HRRacePlaceCalc methodsFor!
meeting

	meeting ifNil: [meeting := HRMeetingPlaceCalc on: self predecessor meeting].
	^meeting! !
!HRRacePlaceCalc categoriesFor: #meeting!public! !

!HRRacePlaceCalc methodsFor!
nags

	nags ifNil: [nags := self predecessor nags collect: [ :each | 
		(HRNagPlaceCalc predecessor: each) race: self ]].
	^nags
! !
!HRRacePlaceCalc categoriesFor: #nags!public! !

!HRRacePlaceCalc methodsFor!
nagsClass
	^HRNagPlaceCalc! !
!HRRacePlaceCalc categoriesFor: #nagsClass!public! !

!HRRacePlaceCalc methodsFor!
places

	places ifNil: [ places := self predecessor places ].
	^places! !
!HRRacePlaceCalc categoriesFor: #places!public! !

!HRRacePlaceCalc methodsFor!
places: anObject
	places := anObject! !
!HRRacePlaceCalc categoriesFor: #places:!public! !

!HRRacePlaceCalc methodsFor!
ppNRLeg1Est
	^self allNonRunners inject: 0 into: [ :sum :nr | sum + nr ppLeg1Est ].
! !
!HRRacePlaceCalc categoriesFor: #ppNRLeg1Est!public! !

!HRRacePlaceCalc methodsFor!
ppValueChksum

	^(self nags inject: 0 into: [ :sum :nag | sum + nag ppValueChksum ]) roundTo: 0.001.
! !
!HRRacePlaceCalc categoriesFor: #ppValueChksum!public! !

!HRRacePlaceCalc methodsFor!
preRaceFav

	preRaceFav ifNil: [self setPreRaceFav].
	^preRaceFav! !
!HRRacePlaceCalc categoriesFor: #preRaceFav!public! !

!HRRacePlaceCalc methodsFor!
preRaceFav: aNag

	preRaceFav := aNag.! !
!HRRacePlaceCalc categoriesFor: #preRaceFav:!public! !

!HRRacePlaceCalc methodsFor!
resetAllPlaceChances

	allPlaceChances := OrderedCollection new! !
!HRRacePlaceCalc categoriesFor: #resetAllPlaceChances!public! !

!HRRacePlaceCalc methodsFor!
setLeg1EstPPPercIncFav

	| cf tmpNags |
	cf := (self meeting races at: 2) ppCarriedForward.
	cf isZero ifTrue: [^self].
	tmpNags := self nags select: [ :each | each placed and: [each nonRunner not]].
	self spreadLeg1PP: cf between: tmpNags.
	tmpNags := self nags reject: [ :each | each placed or: [each nonRunner]].
	self spreadLeg1PP: (self meeting totePPPool - cf) between: tmpNags.
	self nags do: [ :each | each setLeg1EstPPPercIncFav ].
	self ppValDirty: true.
! !
!HRRacePlaceCalc categoriesFor: #setLeg1EstPPPercIncFav!public! !

!HRRacePlaceCalc methodsFor!
setMyMeetingPlaceOdds

	self meeting setMyMeetingPlaceOdds! !
!HRRacePlaceCalc categoriesFor: #setMyMeetingPlaceOdds!public! !

!HRRacePlaceCalc methodsFor!
setMyPlaceOdds

	self myFavCount > 0 ifTrue: [self setMyRacePlaceOdds].
	self setMyMeetingPlaceOdds.
! !
!HRRacePlaceCalc categoriesFor: #setMyPlaceOdds!public! !

!HRRacePlaceCalc methodsFor!
setMyRacePlaceOdds

	| myPicks myChances fav |
	fav := self nags detect: [ :nag | nag baseNag == self bestOddsFav ].
	myPicks := self nags select: [ :nag | nag mySelect ].
	self myUnnamedFav ifTrue: [myPicks addLast: fav].
	(myPicks anySatisfy: [ :each | each nonRunner ]) ifTrue: [myPicks addLast: fav].
	myChances := self allPlaceChances select: [ :each | each key includesAnyOf: myPicks ].
	self myPlaceOdds: (myChances inject: 0 into: [ :sum :mine | sum + mine value ]).
	! !
!HRRacePlaceCalc categoriesFor: #setMyRacePlaceOdds!public! !

!HRRacePlaceCalc methodsFor!
setNagsPPPercIncFav

	| denom |
	self setPreRaceFav.
	(self leg = 1 and: [self hasFinalResult]) ifTrue: [ ^self setLeg1EstPPPercIncFav ].
	self hasRealPPValues ifFalse: [ ^self nags do: [ :each | each setEstPPPercIncFav ]].
	self nags do: [ :each | each setPPPercIncFav]! !
!HRRacePlaceCalc categoriesFor: #setNagsPPPercIncFav!public! !

!HRRacePlaceCalc methodsFor!
spreadLeg1PP: cf between: tmpNags

	| denom |
	denom := tmpNags inject: 0 into: [ :sum :each | 
		sum + ((1/(each rpForecast + each slFinalOdds + 0.0000001)) raisedTo: 2) ].
	tmpNags do: [ :each | 
		each ppLeg1Est: (cf * ((1/(each rpForecast + each slFinalOdds + 0.0000001)) raisedTo: 2) / denom) asFloat. 
		each ppValue: (each ppLeg1Est roundTo: 0.01)].! !
!HRRacePlaceCalc categoriesFor: #spreadLeg1PP:between:!public! !

!HRRacePlaceCalc methodsFor!
subtractNonPlaceValue

	self nags do: [ :each | each ppPlaceValue: each ppPlaceValue - (1 - each placeChance) + 1 ]! !
!HRRacePlaceCalc categoriesFor: #subtractNonPlaceValue!public! !

!HRRacePlaceCalc methodsFor!
sumOfBFOdds

	sumOfBFOdds ifNil: [sumOfBFOdds := self allRunners inject: 0 into: [ :sum :each | sum + each bfOdds ]].
	^sumOfBFOdds! !
!HRRacePlaceCalc categoriesFor: #sumOfBFOdds!public! !

!HRRacePlaceCalc methodsFor!
sumOfFinalOdds

	sumOfFinalOdds ifNil: [sumOfFinalOdds := self allRunners inject: 0 into: [ :sum :each | sum + each slFinalOdds ]].
	^sumOfFinalOdds! !
!HRRacePlaceCalc categoriesFor: #sumOfFinalOdds!public! !

!HRRacePlaceCalc methodsFor!
sumOfPlaceChanceBasisFor: aCollection

	^aCollection inject: 0 into: [ :sum :each | sum + each placeChanceBasis ]! !
!HRRacePlaceCalc categoriesFor: #sumOfPlaceChanceBasisFor:!public! !

!HRRacePlaceCalc methodsFor!
totalPPEst

	totalPPEst ifNil: [totalPPEst := self nags inject: self ppFavEst into: [ :sum :each | sum + each ppEst ]].
	^totalPPEst! !
!HRRacePlaceCalc categoriesFor: #totalPPEst!public! !

!HRRacePlaceCalc methodsFor!
totalPPLeg1Est

	totalPPLeg1Est ifNil: [totalPPLeg1Est := self nags inject: 0 into: [ :sum :each | sum + each ppLeg1Est ]].
	^totalPPLeg1Est! !
!HRRacePlaceCalc categoriesFor: #totalPPLeg1Est!public! !

!HRRacePlaceCalc categoriesFor: #addPPPlaceValueFor:chance:!public! !

!HRRacePlaceCalc categoriesFor: #allNonRunners!public! !

!HRRacePlaceCalc categoriesFor: #allPlaceChances!public! !

!HRRacePlaceCalc categoriesFor: #allRunners!public! !

!HRRacePlaceCalc categoriesFor: #allRunnersBasis!public! !

!HRRacePlaceCalc categoriesFor: #allRunnersSorted!public! !

!HRRacePlaceCalc categoriesFor: #asCsvString!public! !

!HRRacePlaceCalc categoriesFor: #calculateFirstPlaceChance!public! !

!HRRacePlaceCalc categoriesFor: #calculateFourthPlaceChance!public! !

!HRRacePlaceCalc categoriesFor: #calculatePlaceChance!public! !

!HRRacePlaceCalc categoriesFor: #calculatePPValue!public! !

!HRRacePlaceCalc categoriesFor: #calculateSecondPlaceChance!public! !

!HRRacePlaceCalc categoriesFor: #calculateThirdPlaceChance!public! !

!HRRacePlaceCalc categoriesFor: #copyFavValuesToNRs!public! !

!HRRacePlaceCalc categoriesFor: #findNagsUpTo:!public! !

!HRRacePlaceCalc categoriesFor: #hasBFOdds!public! !

!HRRacePlaceCalc categoriesFor: #hasFinalOdds!public! !

!HRRacePlaceCalc categoriesFor: #hasFinalResult!public! !

!HRRacePlaceCalc categoriesFor: #hasRealPPValues!public! !

!HRRacePlaceCalc categoriesFor: #mainRunners!public! !

!HRRacePlaceCalc categoriesFor: #mainRunnersBasis!public! !

!HRRacePlaceCalc categoriesFor: #meeting!public! !

!HRRacePlaceCalc categoriesFor: #nags!public! !

!HRRacePlaceCalc categoriesFor: #nagsClass!public! !

!HRRacePlaceCalc categoriesFor: #places!accessing!private! !

!HRRacePlaceCalc categoriesFor: #places:!accessing!private! !

!HRRacePlaceCalc categoriesFor: #ppNRLeg1Est!public! !

!HRRacePlaceCalc categoriesFor: #ppValueChksum!public! !

!HRRacePlaceCalc categoriesFor: #preRaceFav!public! !

!HRRacePlaceCalc categoriesFor: #preRaceFav:!public! !

!HRRacePlaceCalc categoriesFor: #resetAllPlaceChances!public! !

!HRRacePlaceCalc categoriesFor: #setLeg1EstPPPercIncFav!public! !

!HRRacePlaceCalc categoriesFor: #setMyMeetingPlaceOdds!public! !

!HRRacePlaceCalc categoriesFor: #setMyPlaceOdds!public! !

!HRRacePlaceCalc categoriesFor: #setMyRacePlaceOdds!public! !

!HRRacePlaceCalc categoriesFor: #setNagsPPPercIncFav!public! !

!HRRacePlaceCalc categoriesFor: #spreadLeg1PP:between:!public! !

!HRRacePlaceCalc categoriesFor: #subtractNonPlaceValue!public! !

!HRRacePlaceCalc categoriesFor: #sumOfBFOdds!public! !

!HRRacePlaceCalc categoriesFor: #sumOfFinalOdds!public! !

!HRRacePlaceCalc categoriesFor: #sumOfPlaceChanceBasisFor:!public! !

!HRRacePlaceCalc categoriesFor: #totalPPEst!public! !

!HRRacePlaceCalc categoriesFor: #totalPPLeg1Est!public! !

HRDiviEstPresenter guid: (GUID fromString: '{536DCB37-5F9B-4081-9057-B30B8F678319}')!

HRDiviEstPresenter guid: (GUID fromString: '{536DCB37-5F9B-4081-9057-B30B8F678319}')!
HRDiviEstPresenter comment: ''!

HRDiviEstPresenter comment:
''!
!HRDiviEstPresenter categoriesForClass!MVP-Presenters! !
!HRDiviEstPresenter methodsFor!
createComponents

	super createComponents.
	ests := self add: ListPresenter new name: 'ests'.
! !
!HRDiviEstPresenter categoriesFor: #createComponents!public! !

!HRDiviEstPresenter categoriesFor: #createComponents!initializing!private! !

!HRDiviEstPresenter class methodsFor!
showOn: aMeeting

	| mtg |
	mtg := HRMyMeeting on: aMeeting.
	^super showOn: mtg
! !
!HRDiviEstPresenter class categoriesFor: #showOn:!public! !

!HRDiviEstPresenter class categoriesFor: #showOn:!public! !

HRGraphPresenter guid: (GUID fromString: '{255B2C56-7F76-4ABB-8756-58BDB001A163}')!

HRGraphPresenter guid: (GUID fromString: '{255B2C56-7F76-4ABB-8756-58BDB001A163}')!
HRGraphPresenter comment: ''!

HRGraphPresenter comment:
''!
!HRGraphPresenter categoriesForClass!MVP-Presenters! !
HRDiviEstShell guid: (GUID fromString: '{8C16BEF6-B40B-4E36-96F6-E9965FD1310F}')!

HRDiviEstShell guid: (GUID fromString: '{8C16BEF6-B40B-4E36-96F6-E9965FD1310F}')!
HRDiviEstShell comment: ''!

HRDiviEstShell comment:
''!
!HRDiviEstShell categoriesForClass!MVP-Presenters! !
!HRDiviEstShell methodsFor!
createComponents

	super createComponents.
	ests := self add: HRDiviEstPresenter new name: 'ests'.
! !
!HRDiviEstShell categoriesFor: #createComponents!public! !

!HRDiviEstShell methodsFor!
model: aModel

	super model: aModel.
	ests model: aModel estimateResult.
! !
!HRDiviEstShell categoriesFor: #model:!public! !

!HRDiviEstShell methodsFor!
onViewOpened

	super onViewOpened.
	self setCaption.
! !
!HRDiviEstShell categoriesFor: #onViewOpened!public! !

!HRDiviEstShell methodsFor!
refresh

	ests model: self model estimateResult.
	self view refreshContents.
! !
!HRDiviEstShell categoriesFor: #refresh!public! !

!HRDiviEstShell methodsFor!
setCaption

	self caption: self model meeting shortDate, ' - ', self model meeting course.
! !
!HRDiviEstShell categoriesFor: #setCaption!public! !

!HRDiviEstShell categoriesFor: #createComponents!initializing!private! !

!HRDiviEstShell categoriesFor: #model:!initializing!private! !

!HRDiviEstShell categoriesFor: #onViewOpened!public! !

!HRDiviEstShell categoriesFor: #refresh!public! !

!HRDiviEstShell categoriesFor: #setCaption!public! !

HRMeetingIDEditor guid: (GUID fromString: '{81352034-FED2-4C56-B214-C4F41158C69A}')!

HRMeetingIDEditor guid: (GUID fromString: '{81352034-FED2-4C56-B214-C4F41158C69A}')!
HRMeetingIDEditor comment: ''!

HRMeetingIDEditor comment:
''!
!HRMeetingIDEditor categoriesForClass!MVP-Presenters! !
!HRMeetingIDEditor methodsFor!
bfSkip
	bfSkip ifNil: [bfSkip := 0].
	^bfSkip! !
!HRMeetingIDEditor categoriesFor: #bfSkip!public! !

!HRMeetingIDEditor methodsFor!
bfSkip: anObject 
	bfSkip := anObject! !
!HRMeetingIDEditor categoriesFor: #bfSkip:!public! !

!HRMeetingIDEditor methodsFor!
changeBFID

	bfEditPres value: self selectedBFIDOrNil.
	self redraw
! !
!HRMeetingIDEditor categoriesFor: #changeBFID!public! !

!HRMeetingIDEditor methodsFor!
createComponents

	super createComponents.
	bfAbbrPres := self add: TextPresenter new name: 'bfAbbr'.
	bfListPres := self add: ListPresenter new name: 'bfList'.
	bfEditPres := self add: TextPresenter new name: 'bfEdit'.
	toteIDPres := self add: TextPresenter new name: 'toteID'.
	slNamePres := self add: TextPresenter new name: 'slName'.! !
!HRMeetingIDEditor categoriesFor: #createComponents!public! !

!HRMeetingIDEditor methodsFor!
createSchematicWiring
	"Private - create the trigger wiring"

	super createSchematicWiring.
	bfListPres when: #selectionChanged send: #changeBFID to: self.
! !
!HRMeetingIDEditor categoriesFor: #createSchematicWiring!public! !

!HRMeetingIDEditor methodsFor!
generateBetfairIDs

	bfListPres resetSelection.
	self model setBetfairRaceIDsSkip: self bfSkip.
	bfListPres model: (ListModel on: self model races).
	self bfSkip: (self bfSkip + 1).
! !
!HRMeetingIDEditor categoriesFor: #generateBetfairIDs!public! !

!HRMeetingIDEditor methodsFor!
generateSLName

	self model setSlCourseName.
"	slNamePres value: self model slCourseName"! !
!HRMeetingIDEditor categoriesFor: #generateSLName!public! !

!HRMeetingIDEditor methodsFor!
generateToteURLID

	self model setToteURLID.
! !
!HRMeetingIDEditor categoriesFor: #generateToteURLID!public! !

!HRMeetingIDEditor methodsFor!
model: aModel

	super model: aModel.
	bfAbbrPres model: (aModel aspectValue: #bfAbbr).
	bfListPres model: (ListModel on: aModel races).
	toteIDPres model: (aModel aspectValue: #toteURLID).
	slNamePres model: (aModel aspectValue: #slCourseName).

	toteIDPres model aspectTriggers: #idChanged.
	slNamePres model aspectTriggers: #valueChanged.

! !
!HRMeetingIDEditor categoriesFor: #model:!public! !

!HRMeetingIDEditor methodsFor!
modifyBFID

	| idx |
	idx := self selectedBFIDIndex.
	idx isZero ifFalse: [
		(self model leg: self selectedBFIDIndex) bfRaceID: bfEditPres value.
		idx := idx + 1].
	bfListPres model: (ListModel on: self model races).
	idx > bfListPres model size ifFalse: [bfListPres selectionByIndex: idx]! !
!HRMeetingIDEditor categoriesFor: #modifyBFID!public! !

!HRMeetingIDEditor methodsFor!
onViewOpened

	super onViewOpened.
	self setCaption.
! !
!HRMeetingIDEditor categoriesFor: #onViewOpened!public! !

!HRMeetingIDEditor methodsFor!
redraw

"	bfAbbrPres model: self model bfAbbr.
	toteIDPres model: self model toteURLID.
	slNamePres model: self model slCourseName.
"
	self view refreshContents! !
!HRMeetingIDEditor categoriesFor: #redraw!public! !

!HRMeetingIDEditor methodsFor!
selectedBFIDIndex

	^bfListPres selectionByIndex! !
!HRMeetingIDEditor categoriesFor: #selectedBFIDIndex!public! !

!HRMeetingIDEditor methodsFor!
selectedBFIDOrNil

	bfListPres selectionOrNil ifNil: [^''].
	^bfListPres selection bfRaceID! !
!HRMeetingIDEditor categoriesFor: #selectedBFIDOrNil!public! !

!HRMeetingIDEditor methodsFor!
setCaption

	self caption: self model meeting shortDate, ' - ', self model meeting course.
! !
!HRMeetingIDEditor categoriesFor: #setCaption!public! !

!HRMeetingIDEditor methodsFor!
toteURLChanged

	toteIDPres value: self model toteURLID! !
!HRMeetingIDEditor categoriesFor: #toteURLChanged!public! !

!HRMeetingIDEditor categoriesFor: #bfSkip!accessing!private! !

!HRMeetingIDEditor categoriesFor: #bfSkip:!accessing!private! !

!HRMeetingIDEditor categoriesFor: #changeBFID!initializing!private! !

!HRMeetingIDEditor categoriesFor: #createComponents!initializing!private! !

!HRMeetingIDEditor categoriesFor: #createSchematicWiring!initializing!private! !

!HRMeetingIDEditor categoriesFor: #generateBetfairIDs!public! !

!HRMeetingIDEditor categoriesFor: #generateSLName!public! !

!HRMeetingIDEditor categoriesFor: #generateToteURLID!public! !

!HRMeetingIDEditor categoriesFor: #model:!initializing!private! !

!HRMeetingIDEditor categoriesFor: #modifyBFID!public! !

!HRMeetingIDEditor categoriesFor: #onViewOpened!public! !

!HRMeetingIDEditor categoriesFor: #redraw!public! !

!HRMeetingIDEditor categoriesFor: #selectedBFIDIndex!initializing!private! !

!HRMeetingIDEditor categoriesFor: #selectedBFIDOrNil!initializing!private! !

!HRMeetingIDEditor categoriesFor: #setCaption!public! !

!HRMeetingIDEditor categoriesFor: #toteURLChanged!initializing!private! !

HRMtgDashboardPresenter guid: (GUID fromString: '{97838FC0-29AB-4D82-9CD0-353C3DC1E42D}')!

HRMtgDashboardPresenter guid: (GUID fromString: '{97838FC0-29AB-4D82-9CD0-353C3DC1E42D}')!
HRMtgDashboardPresenter comment: ''!

HRMtgDashboardPresenter comment:
''!
!HRMtgDashboardPresenter categoriesForClass!MVP-Presenters! !
!HRMtgDashboardPresenter methodsFor!
calcAspect

	| lines ests |
	lines := ((self view viewNamed: 'linesAndEsts') extent y)//17.5.
	ests := estPresenter model size.
	(self view viewNamed: 'ests') arrangement: (ests + 1.5).
	(self view viewNamed: 'linesWithEsts') arrangement: (lines - ests - 1.5).
! !
!HRMtgDashboardPresenter categoriesFor: #calcAspect!public! !

!HRMtgDashboardPresenter methodsFor!
createComponents

	super createComponents.
	graphPresenter := self add: HRGraphPresenter new name: 'graph'.
	linesPresenter := self add: RichTextPresenter new name: 'lines'.
	linesWithEstPresenter := self add: RichTextPresenter new name: 'linesWithEsts'.
	estPresenter := self add: ListPresenter new name: 'ests'.
	self add: TextPresenter new name: 'cumOdds'.
	self add: TextPresenter new name: 'totalLines'.
	self add: TextPresenter new name: 'pot'.
	self add: TextPresenter new name: 'divi'.
	self add: TextPresenter new name: 'payOut'.
	self add: TextPresenter new name: 'totalStake'.
	self add: TextPresenter new name: 'profit'.
	self add: NumberPresenter new name: 'unitStake'.
! !
!HRMtgDashboardPresenter categoriesFor: #createComponents!public! !

!HRMtgDashboardPresenter methodsFor!
createSchematicWiring

	super createSchematicWiring.
	self model when: #allUpdated send: #redraw to: self.
	self when: #positionChanged: send: #refreshContents to: self view.
	self model meeting when: #goingUpdated send: #setCaption to: self.
! !
!HRMtgDashboardPresenter categoriesFor: #createSchematicWiring!public! !

!HRMtgDashboardPresenter methodsFor!
hideEstimate

	(self view viewNamed: 'linesAndEsts' ifNone: [^nil]) hide.
	linesPresenter view show.
! !
!HRMtgDashboardPresenter categoriesFor: #hideEstimate!public! !

!HRMtgDashboardPresenter methodsFor!
model: aModel

	super model: aModel.
	graphPresenter model: aModel graphs.
	linesPresenter model: aModel slipLinesRTF asValue.
	(self presenterNamed: 'cumOdds') model: aModel cumOdds.
	(self presenterNamed: 'totalLines') model: aModel totalLines.
	(self presenterNamed: 'pot') model: aModel pot.
	(self presenterNamed: 'divi') model: aModel divi.
	(self presenterNamed: 'payOut') model: aModel payOut.
	(self presenterNamed: 'totalStake') model: aModel totalStake.
	(self presenterNamed: 'profit') model: aModel profit.
	(self presenterNamed: 'unitStake') model: (aModel aspectValue: #unitStake).! !
!HRMtgDashboardPresenter categoriesFor: #model:!public! !

!HRMtgDashboardPresenter methodsFor!
onViewClosed
	"A request to close the view onto the receiver has occurred.
	Prompt to save any outstanding changed"

	self model release
! !
!HRMtgDashboardPresenter categoriesFor: #onViewClosed!public! !

!HRMtgDashboardPresenter methodsFor!
onViewOpened

	super onViewOpened.
	self setCaption.
	self model createDashboardScheduleItems.
	self hideEstimate.! !
!HRMtgDashboardPresenter categoriesFor: #onViewOpened!public! !

!HRMtgDashboardPresenter methodsFor!
openEstimateWindow
#deprecated.
	HRDiviEstPresenter showOn: self model meeting! !
!HRMtgDashboardPresenter categoriesFor: #openEstimateWindow!public! !

!HRMtgDashboardPresenter methodsFor!
queryCommand: aCommandQuery

	super queryCommand: aCommandQuery.
	(#(openEstimateWindow toggleEstimate) includes: aCommandQuery command) ifTrue: [
		aCommandQuery isEnabled: (self model meeting leg: 5) hasResults].
! !
!HRMtgDashboardPresenter categoriesFor: #queryCommand:!public! !

!HRMtgDashboardPresenter methodsFor!
redraw

	graphPresenter model: self model graphs.
	linesPresenter model: self model slipLinesRTF asValue.
	linesWithEstPresenter model: self model slipLinesRTF asValue.
	estPresenter model: (HRMyMeeting on: self model meeting) estimateResult.
	(self presenterNamed: 'cumOdds') model: self model cumOdds.
	(self presenterNamed: 'totalLines') model: self model totalLines.
	(self presenterNamed: 'pot') model: self model pot.
	(self presenterNamed: 'divi') model: self model divi.
	(self presenterNamed: 'payOut') model: self model payOut.
	(self presenterNamed: 'totalStake') model: self model totalStake.
	(self presenterNamed: 'profit') model: self model profit.
	self view refreshContents.
	self model remainingLines size > 3 ifTrue: [ 
		linesPresenter view scrollToEnd; lineScrollBy: -24.
		linesWithEstPresenter view scrollToEnd; lineScrollBy: -16.
		].
! !
!HRMtgDashboardPresenter categoriesFor: #redraw!public! !

!HRMtgDashboardPresenter methodsFor!
refresh

	self model refresh! !
!HRMtgDashboardPresenter categoriesFor: #refresh!public! !

!HRMtgDashboardPresenter methodsFor!
setCaption

	self caption: self model meeting shortDate, ' - ', self model meeting course.
	self model meeting going isEmpty ifFalse: [ self caption: self caption, ' - ', self model meeting going ].
! !
!HRMtgDashboardPresenter categoriesFor: #setCaption!public! !

!HRMtgDashboardPresenter methodsFor!
showEstimate

	estPresenter model: (HRMyMeeting on: self model meeting) estimateResult.
	linesWithEstPresenter model: self model slipLinesRTF asValue.
	linesPresenter view hide.
	self calcAspect.
	(self view viewNamed: 'linesAndEsts') show.
! !
!HRMtgDashboardPresenter categoriesFor: #showEstimate!public! !

!HRMtgDashboardPresenter methodsFor!
toggleEstimate

	linesPresenter view isWindowVisible 
		ifTrue: [self showEstimate.
				(self view viewNamed: 'toggleEst') text: 'Hide Estimate'.]
		ifFalse: [self hideEstimate.
				(self view viewNamed: 'toggleEst') text: 'Show Estimate'.]
! !
!HRMtgDashboardPresenter categoriesFor: #toggleEstimate!public! !

!HRMtgDashboardPresenter categoriesFor: #calcAspect!public! !

!HRMtgDashboardPresenter categoriesFor: #createComponents!initializing!private! !

!HRMtgDashboardPresenter categoriesFor: #createSchematicWiring!public! !

!HRMtgDashboardPresenter categoriesFor: #hideEstimate!public! !

!HRMtgDashboardPresenter categoriesFor: #model:!initializing!private! !

!HRMtgDashboardPresenter categoriesFor: #onViewClosed!event handling!public! !

!HRMtgDashboardPresenter categoriesFor: #onViewOpened!public! !

!HRMtgDashboardPresenter categoriesFor: #openEstimateWindow!public! !

!HRMtgDashboardPresenter categoriesFor: #queryCommand:!public! !

!HRMtgDashboardPresenter categoriesFor: #redraw!public! !

!HRMtgDashboardPresenter categoriesFor: #refresh!public! !

!HRMtgDashboardPresenter categoriesFor: #setCaption!public! !

!HRMtgDashboardPresenter categoriesFor: #showEstimate!public! !

!HRMtgDashboardPresenter categoriesFor: #toggleEstimate!public! !

!HRMtgDashboardPresenter class methodsFor!
defaultModel

	^HRMtgDashboardModel new! !
!HRMtgDashboardPresenter class categoriesFor: #defaultModel!public! !

!HRMtgDashboardPresenter class categoriesFor: #defaultModel!public! !

HRPPSlipPresenter guid: (GUID fromString: '{82C47E7B-4AC1-4F08-BD06-B54D774AEB29}')!

HRPPSlipPresenter guid: (GUID fromString: '{82C47E7B-4AC1-4F08-BD06-B54D774AEB29}')!
HRPPSlipPresenter comment: ''!

HRPPSlipPresenter comment:
''!
!HRPPSlipPresenter categoriesForClass!MVP-Presenters! !
!HRPPSlipPresenter methodsFor!
createComponents

	super createComponents.
	leg1 := self add: TextPresenter new name: 'leg1'.
	leg2 := self add: TextPresenter new name: 'leg2'.
	leg3 := self add: TextPresenter new name: 'leg3'.
	leg4 := self add: TextPresenter new name: 'leg4'.
	leg5 := self add: TextPresenter new name: 'leg5'.
	leg6 := self add: TextPresenter new name: 'leg6'.
	lines := self add: NumberPresenter new name: 'lines'.
	unitStake := self add: NumberPresenter new name: 'unitStake'.
	totalStake := self add: NumberPresenter new name: 'totalStake'.
	winningLines := self add: NumberPresenter new name: 'winningLines'.
	divi := self add: NumberPresenter new name: 'divi'.
	payOut := self add: NumberPresenter new name: 'payOut'.
	profit := self add: NumberPresenter new name: 'profit'.
! !
!HRPPSlipPresenter categoriesFor: #createComponents!public! !

!HRPPSlipPresenter methodsFor!
createSchematicWiring

	super createSchematicWiring.
	self model when: #anyUpdate send: #refresh to: self.
! !
!HRPPSlipPresenter categoriesFor: #createSchematicWiring!public! !

!HRPPSlipPresenter methodsFor!
model: aModel

	super model: aModel.
	leg1 model: (aModel aspectValue: #leg1Picks).
	leg2 model: (aModel aspectValue: #leg2Picks). 
	leg3 model: (aModel aspectValue: #leg3Picks).
	leg4 model: (aModel aspectValue: #leg4Picks).
	leg5 model: (aModel aspectValue: #leg5Picks).
	leg6 model: (aModel aspectValue: #leg6Picks).
	lines model: aModel lines.
	unitStake model: (aModel aspectValue: #unitStake).
	totalStake model: aModel totalStake.
	winningLines model: aModel winningLines.
	divi model: aModel divi.
	payOut model: aModel payOut.
	profit model: aModel profit.
! !
!HRPPSlipPresenter categoriesFor: #model:!public! !

!HRPPSlipPresenter methodsFor!
onViewClosed
	"A request to close the view onto the receiver has occurred.
	Prompt to save any outstanding changed"

	self model release
! !
!HRPPSlipPresenter categoriesFor: #onViewClosed!public! !

!HRPPSlipPresenter methodsFor!
onViewOpened

	super onViewOpened.
	self setCaption.
! !
!HRPPSlipPresenter categoriesFor: #onViewOpened!public! !

!HRPPSlipPresenter methodsFor!
openDashboard

	| mtg dash |
	HRApplication current fullUnlock ifTrue: [self model meeting races do: [ :each | each calculatePPValue ]].
	mtg := self model meeting.
	dash := HRMtgDashboardModel on: mtg.
	dash refresh.
	HRApplication current fullUnlock 
		ifTrue: [HRMtgDashboardPresenter showOn: dash]
		ifFalse: [HRMtgDashboardPresenter show: 'Limited view' on: dash].
	self exit.
! !
!HRPPSlipPresenter categoriesFor: #openDashboard!public! !

!HRPPSlipPresenter methodsFor!
redraw

"	graphPresenter model: self model graphs.
	linesPresenter model: self model slipLinesRTF asValue.
	(self presenterNamed: 'cumOdds') model: self model cumOdds.
	(self presenterNamed: 'totalLines') model: self model totalLines.
	(self presenterNamed: 'pot') model: self model pot.
	self view refreshContents.
	self model remainingLines size > 3 ifTrue: [ linesPresenter view scrollToEnd; lineScrollBy: -24 ].
"! !
!HRPPSlipPresenter categoriesFor: #redraw!public! !

!HRPPSlipPresenter methodsFor!
refresh

	self model: self model! !
!HRPPSlipPresenter categoriesFor: #refresh!public! !

!HRPPSlipPresenter methodsFor!
setCaption

	self caption: self model meeting shortDate, ' - ', self model meeting course.
! !
!HRPPSlipPresenter categoriesFor: #setCaption!public! !

!HRPPSlipPresenter categoriesFor: #createComponents!initializing!private! !

!HRPPSlipPresenter categoriesFor: #createSchematicWiring!public! !

!HRPPSlipPresenter categoriesFor: #model:!initializing!private! !

!HRPPSlipPresenter categoriesFor: #onViewClosed!event handling!public! !

!HRPPSlipPresenter categoriesFor: #onViewOpened!public! !

!HRPPSlipPresenter categoriesFor: #openDashboard!public! !

!HRPPSlipPresenter categoriesFor: #redraw!public! !

!HRPPSlipPresenter categoriesFor: #refresh!public! !

!HRPPSlipPresenter categoriesFor: #setCaption!public! !

!HRPPSlipPresenter class methodsFor!
defaultModel

	^HRPPSlipModel new! !
!HRPPSlipPresenter class categoriesFor: #defaultModel!public! !

!HRPPSlipPresenter class categoriesFor: #defaultModel!public! !

HRPPSlipTextPresenter guid: (GUID fromString: '{EFEE2E18-7C83-437A-8F15-6C534045D1E9}')!

HRPPSlipTextPresenter guid: (GUID fromString: '{EFEE2E18-7C83-437A-8F15-6C534045D1E9}')!
HRPPSlipTextPresenter comment: ''!

HRPPSlipTextPresenter comment:
''!
!HRPPSlipTextPresenter categoriesForClass!MVP-Presenters! !
!HRPPSlipTextPresenter methodsFor!
createComponents

	super createComponents.
	text := self add: TextPresenter new name: 'text'.
! !
!HRPPSlipTextPresenter categoriesFor: #createComponents!public! !

!HRPPSlipTextPresenter methodsFor!
model: aModel

	super model: aModel.
	text model: aModel.
! !
!HRPPSlipTextPresenter categoriesFor: #model:!public! !

!HRPPSlipTextPresenter methodsFor!
onViewOpened

	| rect |
	super onViewOpened.
	rect := RECT new.
	UserLibrary default getWindowRect: (UserLibrary default getDesktopWindow) lpRect: rect.
	self view topView position: ((rect width - 400)@0).
! !
!HRPPSlipTextPresenter categoriesFor: #onViewOpened!public! !

!HRPPSlipTextPresenter categoriesFor: #createComponents!initializing!private! !

!HRPPSlipTextPresenter categoriesFor: #model:!initializing!private! !

!HRPPSlipTextPresenter categoriesFor: #onViewOpened!public! !

HRRacePresenter guid: (GUID fromString: '{B4D4A5A1-C2A3-4368-85BE-22F6D86D151D}')!

HRRacePresenter guid: (GUID fromString: '{B4D4A5A1-C2A3-4368-85BE-22F6D86D151D}')!
HRRacePresenter comment: ''!

HRRacePresenter comment:
''!
!HRRacePresenter categoriesForClass!MVP-Presenters! !
!HRRacePresenter methodsFor!
additionalAccelerators
	^#(#(#keyUp 'Up') #(#keyDown 'Down'))! !
!HRRacePresenter categoriesFor: #additionalAccelerators!public! !

!HRRacePresenter methodsFor!
bfChanged

	changedBF := true
! !
!HRRacePresenter categoriesFor: #bfChanged!public! !

!HRRacePresenter methodsFor!
changedBF

	changedBF ifNil: [^false].
	^changedBF! !
!HRRacePresenter categoriesFor: #changedBF!public! !

!HRRacePresenter methodsFor!
changeRace

	| sortColumn |
	lastRace := currentRace.
	currentRace := racesListPres selectionOrNil.
	currentRace ifNil: [
		currentRace := lastRace.
		racesListPres selection: currentRace].
	slPres model: (currentRace aspectValue: #rpWholeSpotlight).
	raceTypePres model: (currentRace raceType).
	runnersPres model: (currentRace runners).
	placesPres model: (currentRace places).
	ppFavEstPres model: (currentRace aspectValue: #ppFavEst).
	(self presenterNamed: 'unnamedFav') model: (currentRace aspectValue: #myUnnamedFav).
"	ppEstTotalPres model: (self ppEstTotal)."
	nagsListPres model: (ListModel on: (currentRace nags)).
	self rememberSort 
		ifTrue: [nagsListPres view resort] 
		ifFalse: [nagsListPres view forgetLastClickedColumn].
	self refresh.
	self view refreshContents.
! !
!HRRacePresenter categoriesFor: #changeRace!public! !

!HRRacePresenter methodsFor!
clearNag

	(self presenterNamed: 'nagNo') value: nil.
	(self presenterNamed: 'nagName') value: nil.
	(self presenterNamed: 'rpForecast') value: nil.
	(self presenterNamed: 'liveShow') value: nil.
	bfPres value: 0.
	ppEstPres value: 0.
	nagSelectPres value: false.
	nrPres value: false.
! !
!HRRacePresenter categoriesFor: #clearNag!public! !

!HRRacePresenter methodsFor!
createComponents

	super createComponents.
	racesListPres := self add: ListPresenter new name: 'races'.
	slPres := self add: TextPresenter new name: 'spotlight'.
	raceTypePres := self add: TextPresenter new name: 'raceType'.
	runnersPres := self add: NumberPresenter new name: 'runners'.
	placesPres := self add: NumberPresenter new name: 'places'.
	ppEstTotalPres := self add: NumberPresenter new name: 'ppEstTotal'.
	ppFavEstPres := self add: NumberPresenter new name: 'ppFavEst'.
	nagsListPres := self add: ListPresenter new name: 'nagsList'.
	self add: TextPresenter new name: 'nagNo'.
	self add: TextPresenter new name: 'nagName'.
	self add: NumberPresenter new name: 'rpForecast'.
	self add: NumberPresenter new name: 'raceOdds'.
	self add: NumberPresenter new name: 'mtgOdds'.
	self add: TextPresenter new name: 'liveShow'.
	bfPres := self add: NumberPresenter new name: 'betfair'.
	ppEstPres := self add: NumberPresenter new name: 'ppEst'.
	nagSelectPres := self add: BooleanPresenter new name: 'pick'.
	nrPres := self add: BooleanPresenter new name: 'nonRunner'.
	self add: NumberPresenter new name: 'totalLines'.
	self add: NumberPresenter new name: 'totalPicks'.
	self add: TextPresenter new name: 'jockey'.
	self add: TextPresenter new name: 'trainer'.
	self add: NumberPresenter new name: 'minValue'.
	self add: NumberPresenter new name: 'maxValue'.
	self add: BooleanPresenter new name: 'sort'.
	self add: TextPresenter new name: 'lastUpdate'.
	self add: BooleanPresenter new name: 'unnamedFav'.
! !
!HRRacePresenter categoriesFor: #createComponents!public! !

!HRRacePresenter methodsFor!
createSchematicWiring
	"Private - create the trigger wiring"

	super createSchematicWiring.
	nagsListPres when: #leftButtonDoubleClicked: send: #selectOrDeselectNag to: self.
	nagsListPres when: #selectionChanged send: #editNag to: self.
	(self presenterNamed: 'unnamedFav') when: #valueChanged send: #refresh to: self.
	racesListPres when: #selectionChanged send: #changeRace to: self.
	ppEstPres when: #focusLost send: #setPPEstTotal to: self.
	ppFavEstPres when: #focusLost send: #setPPEstTotal to: self.
	(self presenterNamed: 'sort') when: #valueChanged send: #updateRememberSort to: self.
	bfPres when: #keyTyped: send: #bfChanged to: self.
	self model baseMeeting when: #goingUpdated send: #setCaption to: self.

"	placesPres when: #focusLost send: #placesChanged to: self.
	self model when: #redrawList send: #redrawList to: self.
	self model when: #statusChanged send: #updateStatus to: self.
	HRLogger current when: #changed send: #updateLog to: self.
	self when: #closeRequested: send: #onCloseRequested: to: self.
"! !
!HRRacePresenter categoriesFor: #createSchematicWiring!public! !

!HRRacePresenter methodsFor!
createSlip

	currentRace meeting createPlacepotSlip.
"	TextPresenter 
		show: 'Multiline text' 
		on: (currentRace meeting outputMyPPSelections)
"
	HRPPSlipTextPresenter showOn: (currentRace meeting outputMyPPSelections)
! !
!HRRacePresenter categoriesFor: #createSlip!public! !

!HRRacePresenter methodsFor!
currentNag

	^nagsListPres selectionIfNone: [ ^HRNag new ].
! !
!HRRacePresenter categoriesFor: #currentNag!public! !

!HRRacePresenter methodsFor!
editNag

	| nag |
	nag := self currentNag.
	(self presenterNamed: 'nagNo') value: nag racecardNo.
	(self presenterNamed: 'nagName') value: nag name.
	(self presenterNamed: 'jockey') value: nag jockey.
	(self presenterNamed: 'trainer') value: nag trainer.
	(self presenterNamed: 'rpForecast') value: nag rpForecast.
	(self presenterNamed: 'liveShow') value: nag preRaceShow.
	bfPres value: nag bfMiddle.
	ppEstPres value: nag ppEst.
	nagSelectPres value: nag mySelect.
	nrPres value: nag preRaceNR.
	ppEstPres view selectAll; setFocus.! !
!HRRacePresenter categoriesFor: #editNag!public! !

!HRRacePresenter methodsFor!
editOK

	| index |
	index := nagsListPres selectionByIndex + 1.
	self updateNag.
	nagsListPres selectionByIndex: index ifAbsent: [self recalcRace].
! !
!HRRacePresenter categoriesFor: #editOK!public! !

!HRRacePresenter methodsFor!
importEsts

	currentRace meeting importPPEsts.
	self racesList do: [ :each | each calculatePPValue; pickP3Candidates ].
	self refresh.
	nagsListPres view refreshContents.
! !
!HRRacePresenter categoriesFor: #importEsts!public! !

!HRRacePresenter methodsFor!
keyDown

	| index |
	racesListPres hasFocus ifTrue: [ 
		racesListPres hasSelection ifTrue: [ 
			index := racesListPres selectionByIndex.
			racesListPres selectionByIndex: (index + 1)
				ifAbsent: [racesListPres selectionByIndex]]]. 

	nagsListPres hasSelection ifTrue: [
		index := nagsListPres selectionByIndex.
		self updateNag.
		nagsListPres selectionByIndex: (index + 1) 
				ifAbsent: [nagsListPres selectionByIndex: index]]. 
! !
!HRRacePresenter categoriesFor: #keyDown!public! !

!HRRacePresenter methodsFor!
keyUp

	| index |
	racesListPres hasFocus ifTrue: [ 
		racesListPres hasSelection ifTrue: [ 
			index := racesListPres selectionByIndex.
			index = 1 ifFalse: [ index := index - 1 ].
			racesListPres selectionByIndex: index ifAbsent: [racesListPres selectionByIndex: 1]]]. 

	nagsListPres hasSelection ifTrue: [ 
		index := nagsListPres selectionByIndex.
		self updateNag.
		index = 1 ifFalse: [ index := index - 1 ].
		nagsListPres selectionByIndex: index ifAbsent: [nagsListPres selectionByIndex: 1]]. 
! !
!HRRacePresenter categoriesFor: #keyUp!public! !

!HRRacePresenter methodsFor!
model: aModel

	super model: aModel.
	racesListPres model: (ListModel on: self racesList).
	(self presenterNamed: 'sort') model: self rememberSort.! !
!HRRacePresenter categoriesFor: #model:!public! !

!HRRacePresenter methodsFor!
onViewOpened

	super onViewOpened.
	self setCaption.
	racesListPres selectionByIndex: (self model meeting races indexOf: self model).
	currentRace := self model.
	currentRace meeting races do: [ :each | each calculatePPValue; pickP3Candidates ].
	self refresh.
	Cursor arrow setCursor.
! !
!HRRacePresenter categoriesFor: #onViewOpened!public! !

!HRRacePresenter methodsFor!
openDashboard

	| mtg dash |
	mtg := self model meeting.
	dash := HRMtgDashboardModel on: mtg.
	dash refresh.
	HRApplication current fullUnlock 
		ifTrue: [HRMtgDashboardPresenter showOn: dash.]
		ifFalse: [HRMtgDashboardPresenter show: 'Limited view' on: dash.]
! !
!HRRacePresenter categoriesFor: #openDashboard!public! !

!HRRacePresenter methodsFor!
openMtgIDEditor

	| mtg |
	mtg := self model baseMeeting.
	HRApplication current fullUnlock 
		ifTrue: [HRMeetingIDEditor showOn: mtg.]
		ifFalse: [HRMeetingIDEditor show: 'Limited view' on: mtg.]
! !
!HRRacePresenter categoriesFor: #openMtgIDEditor!public! !

!HRRacePresenter methodsFor!
ppEstTotal
#deprecated.
	^currentRace nags 
		inject: currentRace ppFavEst 
		into: [ :sum :nag | sum + nag ppEst ]! !
!HRRacePresenter categoriesFor: #ppEstTotal!public! !

!HRRacePresenter methodsFor!
queryCommand: aCommandQuery

	super queryCommand: aCommandQuery.
	(aCommandQuery command == #sendSlip) ifTrue: [
		aCommandQuery isEnabled: (HRMailer canMailPlacepotSMS)].
! !
!HRRacePresenter categoriesFor: #queryCommand:!public! !

!HRRacePresenter methodsFor!
racesList

	racesList ifNil: [racesList := self model meeting races].
	^racesList! !
!HRRacePresenter categoriesFor: #racesList!public! !

!HRRacePresenter methodsFor!
recalcRace

	Cursor wait setCursor.
	currentRace ppValDirty: true.
	currentRace calculatePPValue.
	currentRace pickP3Candidates.
	self refresh.
	nagsListPres view refreshContents.
	Cursor arrow setCursor.
! !
!HRRacePresenter categoriesFor: #recalcRace!public! !

!HRRacePresenter methodsFor!
refresh

	self 
		setTotalPicks; 
		setTotalLines; 
		setMinMaxValues; 
		setRunnersAndPlaces;
		setCumOdds;
		setPPEstTotal;
		showLastUpdate.
! !
!HRRacePresenter categoriesFor: #refresh!public! !

!HRRacePresenter methodsFor!
rememberSort

	rememberSort ifNil: [rememberSort := HRApplication current rememberSort].
	^rememberSort! !
!HRRacePresenter categoriesFor: #rememberSort!public! !

!HRRacePresenter methodsFor!
selectOrDeselectNag

	self currentNag mySelect 
		ifTrue: [ self currentNag mySelect: false ]
		ifFalse: [ self currentNag mySelect: true ].
	nagsListPres view refreshContents.
	self refresh.
	self updateRacesList.! !
!HRRacePresenter categoriesFor: #selectOrDeselectNag!public! !

!HRRacePresenter methodsFor!
sendSlip

	currentRace meeting mailPlacepotSMS.
		! !
!HRRacePresenter categoriesFor: #sendSlip!public! !

!HRRacePresenter methodsFor!
setAllEsts

	currentRace meeting races do: [ :each | each setEsts; recalcRace ].
	self refresh.
! !
!HRRacePresenter categoriesFor: #setAllEsts!public! !

!HRRacePresenter methodsFor!
setCaption

	self caption: self model meeting shortDate, ' - ', self model meeting course.
	self model meeting going isEmpty ifFalse: [ self caption: self caption, ' - ', self model meeting going ].
! !
!HRRacePresenter categoriesFor: #setCaption!public! !

!HRRacePresenter methodsFor!
setCumOdds

	currentRace setMyPlaceOdds.
	(self presenterNamed: 'mtgOdds') value: currentRace meeting myPlaceOddsAsPercentage.
	(self presenterNamed: 'raceOdds') value: currentRace myPlaceOddsAsPercentage.
! !
!HRRacePresenter categoriesFor: #setCumOdds!public! !

!HRRacePresenter methodsFor!
setEsts

	currentRace setEsts.
	self recalcRace.
	self refresh.! !
!HRRacePresenter categoriesFor: #setEsts!public! !

!HRRacePresenter methodsFor!
setMinMaxValues

	(self presenterNamed: 'minValue') value: (currentRace meeting myMinValue * 100) asInteger.
	(self presenterNamed: 'maxValue') value: (currentRace meeting myMaxValue * 100) asInteger.
! !
!HRRacePresenter categoriesFor: #setMinMaxValues!public! !

!HRRacePresenter methodsFor!
setPPEstTotal

	ppEstTotalPres value: (currentRace nags 
		inject: currentRace ppFavEst 
		into: [ :sum :nag | sum + nag ppEst ])! !
!HRRacePresenter categoriesFor: #setPPEstTotal!public! !

!HRRacePresenter methodsFor!
setRunnersAndPlaces
	runnersPres model: (currentRace runners).
	placesPres model: (currentRace places).
! !
!HRRacePresenter categoriesFor: #setRunnersAndPlaces!public! !

!HRRacePresenter methodsFor!
setTotalLines

	(self presenterNamed: 'totalLines') value: currentRace meeting myLines.! !
!HRRacePresenter categoriesFor: #setTotalLines!public! !

!HRRacePresenter methodsFor!
setTotalPicks

	(self presenterNamed: 'totalPicks') value: currentRace myFavCount.
! !
!HRRacePresenter categoriesFor: #setTotalPicks!public! !

!HRRacePresenter methodsFor!
showLastUpdate

	(self presenterNamed: 'lastUpdate') value: 'Last update: ', currentRace lastUpdate displayString.
! !
!HRRacePresenter categoriesFor: #showLastUpdate!public! !

!HRRacePresenter methodsFor!
updateAll

	| sel |
	self racesList do: [ :each | each updateLiveData; calculatePPValue; pickP3Candidates ].
	sel := nagsListPres selectionByIndex.
	self refresh.
	nagsListPres view refreshContents.
	sel isNil ifFalse: [nagsListPres selectionByIndex: sel ifAbsent: []].
! !
!HRRacePresenter categoriesFor: #updateAll!public! !

!HRRacePresenter methodsFor!
updateLiveData

	Cursor wait showWhile: [currentRace updateLiveData].
	self recalcRace.
	self refresh.
	nagsListPres view refreshContents.
! !
!HRRacePresenter categoriesFor: #updateLiveData!public! !

!HRRacePresenter methodsFor!
updateNag

	| nag |
	nag := self currentNag.
	self changedBF ifTrue: [nag bfMiddle: bfPres value].
	nag ppEst: ppEstPres value.
	nag mySelect = nagSelectPres value ifFalse: [ nag mySelect: nagSelectPres value. self updateRacesList ].
	nag preRaceNR: nrPres value.
	nag race ppValDirty: true.
	self clearNag.
	self refresh.
	nagsListPres view refreshContents.
! !
!HRRacePresenter categoriesFor: #updateNag!public! !

!HRRacePresenter methodsFor!
updatePPEstTotal
#deprecated.
"	ppEstPres value ifNil: [ppEstPres value: 0]."
"	ppEstTotalPres value: (self ppEstTotal + ppEstPres value - self currentNag ppEst)."
	ppEstTotalPres model: (self ppEstTotal).
	ppEstTotalPres view refreshContents! !
!HRRacePresenter categoriesFor: #updatePPEstTotal!public! !

!HRRacePresenter methodsFor!
updateRacesList

"	racesListPres view refreshContents."
! !
!HRRacePresenter categoriesFor: #updateRacesList!public! !

!HRRacePresenter methodsFor!
updateRememberSort

	rememberSort := (self presenterNamed: 'sort') value.
! !
!HRRacePresenter categoriesFor: #updateRememberSort!public! !

!HRRacePresenter categoriesFor: #additionalAccelerators!constants!private! !

!HRRacePresenter categoriesFor: #bfChanged!public! !

!HRRacePresenter categoriesFor: #changedBF!public! !

!HRRacePresenter categoriesFor: #changeRace!public! !

!HRRacePresenter categoriesFor: #clearNag!public! !

!HRRacePresenter categoriesFor: #createComponents!initializing!private! !

!HRRacePresenter categoriesFor: #createSchematicWiring!initializing!public! !

!HRRacePresenter categoriesFor: #createSlip!public! !

!HRRacePresenter categoriesFor: #currentNag!public! !

!HRRacePresenter categoriesFor: #editNag!public! !

!HRRacePresenter categoriesFor: #editOK!public! !

!HRRacePresenter categoriesFor: #importEsts!public! !

!HRRacePresenter categoriesFor: #keyDown!public! !

!HRRacePresenter categoriesFor: #keyUp!public! !

!HRRacePresenter categoriesFor: #model:!accessing!public! !

!HRRacePresenter categoriesFor: #onViewOpened!public! !

!HRRacePresenter categoriesFor: #openDashboard!public! !

!HRRacePresenter categoriesFor: #openMtgIDEditor!public! !

!HRRacePresenter categoriesFor: #ppEstTotal!public! !

!HRRacePresenter categoriesFor: #queryCommand:!public! !

!HRRacePresenter categoriesFor: #racesList!public! !

!HRRacePresenter categoriesFor: #recalcRace!public! !

!HRRacePresenter categoriesFor: #refresh!public! !

!HRRacePresenter categoriesFor: #rememberSort!public! !

!HRRacePresenter categoriesFor: #selectOrDeselectNag!public! !

!HRRacePresenter categoriesFor: #sendSlip!public! !

!HRRacePresenter categoriesFor: #setAllEsts!public! !

!HRRacePresenter categoriesFor: #setCaption!public! !

!HRRacePresenter categoriesFor: #setCumOdds!public! !

!HRRacePresenter categoriesFor: #setEsts!public! !

!HRRacePresenter categoriesFor: #setMinMaxValues!public! !

!HRRacePresenter categoriesFor: #setPPEstTotal!public! !

!HRRacePresenter categoriesFor: #setRunnersAndPlaces!public! !

!HRRacePresenter categoriesFor: #setTotalLines!public! !

!HRRacePresenter categoriesFor: #setTotalPicks!public! !

!HRRacePresenter categoriesFor: #showLastUpdate!public! !

!HRRacePresenter categoriesFor: #updateAll!public! !

!HRRacePresenter categoriesFor: #updateLiveData!public! !

!HRRacePresenter categoriesFor: #updateNag!public! !

!HRRacePresenter categoriesFor: #updatePPEstTotal!public! !

!HRRacePresenter categoriesFor: #updateRacesList!public! !

!HRRacePresenter categoriesFor: #updateRememberSort!public! !

!HRRacePresenter class methodsFor!
defaultModel

	^HRRacePlaceCalc on: HRRace new! !
!HRRacePresenter class categoriesFor: #defaultModel!public! !

!HRRacePresenter class methodsFor!
show: aView on: aRace

	| raceIdx mtg race |
	raceIdx := aRace meeting races indexOf: aRace.
	mtg := aRace meeting.
	mtg := mtg withDecorators: mtg strategies.
	race := mtg races at: raceIdx.
	super show: aView on: race! !
!HRRacePresenter class categoriesFor: #show:on:!public! !

!HRRacePresenter class methodsFor!
showOn: aRace

	| raceIdx mtg race |
	raceIdx := aRace meeting races indexOf: aRace.
	mtg := aRace meeting.
	mtg races do: [ :each | each ppValDirty: true ].
	mtg := mtg withDecorators: mtg strategies.
	race := mtg races at: raceIdx.
	super showOn: race! !
!HRRacePresenter class categoriesFor: #showOn:!public! !

!HRRacePresenter class categoriesFor: #defaultModel!public! !

!HRRacePresenter class categoriesFor: #show:on:!public! !

!HRRacePresenter class categoriesFor: #showOn:!public! !

HRSchedulerPresenter guid: (GUID fromString: '{868C1D85-6CC4-4247-8FFE-9008C983F253}')!

HRSchedulerPresenter guid: (GUID fromString: '{868C1D85-6CC4-4247-8FFE-9008C983F253}')!
HRSchedulerPresenter comment: ''!

HRSchedulerPresenter comment:
''!
!HRSchedulerPresenter categoriesForClass!MVP-Presenters! !
!HRSchedulerPresenter methodsFor!
additionalAccelerators

	^#(#(#keyEnter 'Enter'))! !
!HRSchedulerPresenter categoriesFor: #additionalAccelerators!public! !

!HRSchedulerPresenter methodsFor!
createComponents

	super createComponents.
	scheduleListPresenter := self add: ListPresenter new name: 'scheduleList'.
	logPresenter := self add: TextPresenter new name: 'log'.
	statusPresenter := self add: TextPresenter new name: 'status'.
	pwdPresenter := self add: TextPresenter new name: 'pwd'.
	self add: DatePresenter new name: 'date'.

! !
!HRSchedulerPresenter categoriesFor: #createComponents!public! !

!HRSchedulerPresenter methodsFor!
createSchematicWiring
	"Private - create the trigger wiring"

	super createSchematicWiring.
	self model when: #listChanged send: #updateList to: self.
	self model when: #redrawList send: #redrawList to: self.
	self model when: #statusChanged send: #updateStatus to: self.
	HRLogger current when: #changed send: #updateLog to: self.
	self when: #closeRequested: send: #onCloseRequested: to: self.
	scheduleListPresenter when: #leftButtonDoubleClicked: send: #editRace to: self.
"	self model when: #dateChanged send: #updateDate to: self.
"! !
!HRSchedulerPresenter categoriesFor: #createSchematicWiring!public! !

!HRSchedulerPresenter methodsFor!
editItem

	| anItem |
	anItem := scheduleListPresenter selectionOrNil.
	anItem isNil ifFalse: [
		HRScheduleItemPresenter showModalOn: anItem.
		self model scheduleItems reSort.
		self updateList].! !
!HRSchedulerPresenter categoriesFor: #editItem!public! !

!HRSchedulerPresenter methodsFor!
editRace

	| anItem |
	anItem := scheduleListPresenter selectionOrNil.
	anItem isNil ifFalse: [
		Cursor wait setCursor.
		anItem editRace].! !
!HRSchedulerPresenter categoriesFor: #editRace!public! !

!HRSchedulerPresenter methodsFor!
executeAllItems

	scheduleListPresenter list copy do: [ :each | self model executeScheduleItem: each].! !
!HRSchedulerPresenter categoriesFor: #executeAllItems!public! !

!HRSchedulerPresenter methodsFor!
executeAllItemsForToday

	self todaysItems do: [ :each | self model executeScheduleItem: each].! !
!HRSchedulerPresenter categoriesFor: #executeAllItemsForToday!public! !

!HRSchedulerPresenter methodsFor!
executeItem

	| anItem |
	anItem := scheduleListPresenter selectionOrNil.
	anItem isNil ifFalse: [self model executeScheduleItem: anItem].! !
!HRSchedulerPresenter categoriesFor: #executeItem!public! !

!HRSchedulerPresenter methodsFor!
importEsts

	| sel mtg dash |
	sel := scheduleListPresenter selectionOrNil.
	(sel isNil or: [sel canHaveDashboard not]) ifTrue: [^nil].
	mtg := sel object baseMeeting.
	mtg importPPEsts.
! !
!HRSchedulerPresenter categoriesFor: #importEsts!public! !

!HRSchedulerPresenter methodsFor!
keyEnter
	self lock 
		ifFalse: [self start]
		ifTrue: [self unlock].
! !
!HRSchedulerPresenter categoriesFor: #keyEnter!public! !

!HRSchedulerPresenter methodsFor!
listUpdateCounter
	listUpdateCounter ifNil: [self listUpdateCounter: 0].
	^listUpdateCounter! !
!HRSchedulerPresenter categoriesFor: #listUpdateCounter!public! !

!HRSchedulerPresenter methodsFor!
listUpdateCounter: anObject
	listUpdateCounter := anObject! !
!HRSchedulerPresenter categoriesFor: #listUpdateCounter:!public! !

!HRSchedulerPresenter methodsFor!
lock

	lock ifNil: [lock := true].
	^lock! !
!HRSchedulerPresenter categoriesFor: #lock!public! !

!HRSchedulerPresenter methodsFor!
logon

	self model logon! !
!HRSchedulerPresenter categoriesFor: #logon!public! !

!HRSchedulerPresenter methodsFor!
logPresenter

	^logPresenter! !
!HRSchedulerPresenter categoriesFor: #logPresenter!public! !

!HRSchedulerPresenter methodsFor!
model: aModel

	super model: aModel.
	scheduleListPresenter model: (ListModel on: (aModel scheduleItems)).
	(self presenterNamed: 'date') model: (aModel aspectValue: #date).
	logPresenter model: (HRLogger current contents).
	statusPresenter model: (self model status).
	pwdPresenter model: (self pwd).
	(self presenterNamed: 'date') model aspectTriggers: #dateChanged.! !
!HRSchedulerPresenter categoriesFor: #model:!public! !

!HRSchedulerPresenter methodsFor!
onCloseRequested

	self stop.
	^super onCloseRequested! !
!HRSchedulerPresenter categoriesFor: #onCloseRequested!public! !

!HRSchedulerPresenter methodsFor!
onCloseRequested: boolValueHolder
	"A request to close the view onto the receiver has occurred.
	Prompt to save any outstanding changed"

	self todaysItems isEmpty ifFalse: [
		self onPromptToExecuteRemainder: boolValueHolder ]! !
!HRSchedulerPresenter categoriesFor: #onCloseRequested:!public! !

!HRSchedulerPresenter methodsFor!
onPromptToExecuteRemainder: aBooleanValue
	"prompt to see if the remaining schedule items should be executed"

	MessageBox 
		confirm: ('Execute remaining schedule items for today?')
				onYes: [self executeAllItemsForToday. (Delay forSeconds: 5) wait.]
				onNo: []
				onCancel: [aBooleanValue value: false].
	^aBooleanValue value! !
!HRSchedulerPresenter categoriesFor: #onPromptToExecuteRemainder:!public! !

!HRSchedulerPresenter methodsFor!
openDashboard

	| sel mtg dash |
	sel := scheduleListPresenter selectionOrNil.
	(sel isNil or: [sel canHaveDashboard not]) ifTrue: [^nil].
	mtg := sel object baseMeeting.
	dash := HRMtgDashboardModel on: (HRMeetingPlaceCalc on: mtg).
	dash refresh.
	HRApplication current fullUnlock 
		ifTrue: [HRMtgDashboardPresenter show: 'Combined view' on: dash.]
		ifFalse: [HRMtgDashboardPresenter show: 'Limited view' on: dash.]
! !
!HRSchedulerPresenter categoriesFor: #openDashboard!public! !

!HRSchedulerPresenter methodsFor!
openMeeting

	| sel mtg race raceIdx deco |
#deprecated.
	sel := self selectionOrNil.
	(sel isNil or: [sel canEditRace not]) ifTrue: [^nil].
	race := sel object race.
	raceIdx := race meeting races indexOf: race.
	mtg := race meeting withDecorators: race meeting strategies.
	race := mtg races at: raceIdx.
	HRRacePresenter openOn: race! !
!HRSchedulerPresenter categoriesFor: #openMeeting!public! !

!HRSchedulerPresenter methodsFor!
openMtgIDEditor

	| sel mtg |
	sel := scheduleListPresenter selectionOrNil.
	(sel isNil or: [sel canHaveDashboard not]) ifTrue: [^nil].
	mtg := sel object meeting.
	HRApplication current fullUnlock 
		ifTrue: [HRMeetingIDEditor showOn: mtg.]
		ifFalse: [HRMeetingIDEditor show: 'Limited view' on: mtg.]
! !
!HRSchedulerPresenter categoriesFor: #openMtgIDEditor!public! !

!HRSchedulerPresenter methodsFor!
openPPSlip

	| sel mtg slip |
	sel := scheduleListPresenter selectionOrNil.
	(sel isNil or: [sel canHaveDashboard not]) ifTrue: [^nil].
	mtg := sel object meeting baseMeeting.
	slip := HRPPSlipModel on: mtg.
	HRPPSlipPresenter showOn: slip.
! !
!HRSchedulerPresenter categoriesFor: #openPPSlip!public! !

!HRSchedulerPresenter methodsFor!
pwd

	pwd ifNil: [pwd := ''].
	^pwd! !
!HRSchedulerPresenter categoriesFor: #pwd!public! !

!HRSchedulerPresenter methodsFor!
pwd: aText

	pwd := aText! !
!HRSchedulerPresenter categoriesFor: #pwd:!public! !

!HRSchedulerPresenter methodsFor!
queryCommand: aCommandQuery

	super queryCommand: aCommandQuery.
	(#(saveAsCsvFile setBetfairRaceIDs updateAllLiveData) includes: aCommandQuery command) ifTrue: [ 
		aCommandQuery isEnabled: HRApplication current fullUnlock ].
	(#(start stop redrawList) includes: aCommandQuery command) ifTrue: [
		aCommandQuery isEnabled: self lock not ].
	(aCommandQuery command == #unlock) ifTrue: [
		aCommandQuery isEnabled: self lock].
! !
!HRSchedulerPresenter categoriesFor: #queryCommand:!public! !

!HRSchedulerPresenter methodsFor!
redrawList

	scheduleListPresenter resetSelection.
	scheduleListPresenter view refreshContents. " - full redraw"
! !
!HRSchedulerPresenter categoriesFor: #redrawList!public! !

!HRSchedulerPresenter methodsFor!
removeItem

	| anItem |
	anItem := scheduleListPresenter selectionOrNil.
	anItem isNil ifFalse: [scheduleListPresenter model remove: anItem ifAbsent: []].! !
!HRSchedulerPresenter categoriesFor: #removeItem!public! !

!HRSchedulerPresenter methodsFor!
removeMeeting

	| sel mtg dash |
	sel := scheduleListPresenter selectionOrNil.
	(sel isNil or: [sel canHaveDashboard not]) ifTrue: [^nil].
	mtg := sel object meeting baseMeeting.
	(MessageBox confirm: ('Are you sure to completely delete the meeting ', mtg course, '?')) ifTrue: 
		[ mtg removeFromHRApp ]! !
!HRSchedulerPresenter categoriesFor: #removeMeeting!public! !

!HRSchedulerPresenter methodsFor!
removeMenuItems
	| menu |
	menu := (self view viewNamed: 'scheduleList') contextMenu.
	menu 
		removeItemAt: 8;
"		removeItemAt: 7;
		removeItemAt: 6;
"		removeItemAt: 4;
		removeItemAt: 1.! !
!HRSchedulerPresenter categoriesFor: #removeMenuItems!public! !

!HRSchedulerPresenter methodsFor!
saveAsCsvFile

	| anItem |
	anItem := scheduleListPresenter selectionOrNil.
	anItem isNil ifFalse: [anItem saveAsCsvFile].! !
!HRSchedulerPresenter categoriesFor: #saveAsCsvFile!public! !

!HRSchedulerPresenter methodsFor!
setCaption

	self caption: (SessionManager current imageFileName, ' - Datacollection scheduler')! !
!HRSchedulerPresenter categoriesFor: #setCaption!public! !

!HRSchedulerPresenter methodsFor!
setDate

	(Time now > (Time fromString: '21.00')) ifTrue: [ self model date: (Date today addDays: 1)] ifFalse: [ self model date: Date today]

! !
!HRSchedulerPresenter categoriesFor: #setDate!public! !

!HRSchedulerPresenter methodsFor!
start

	| runDate |
	self model isRunning ifTrue: [
		(MessageBox confirm: 'This will remove all items and restart. Are you sure you want to restart?') ifFalse: [^nil]].
"	runDate := (self presenterNamed: 'date') value.
	runDate ifNil: [ runDate := Date today]."
"	self model restartFor: self model date."
	self model restart.
	(self view viewNamed: 'start') text: 'Restart'.
! !
!HRSchedulerPresenter categoriesFor: #start!public! !

!HRSchedulerPresenter methodsFor!
stop

	self model stop
! !
!HRSchedulerPresenter categoriesFor: #stop!public! !

!HRSchedulerPresenter methodsFor!
tmpAdditionalAccelerators
	^#(#(#keyEnter 'Enter'))! !
!HRSchedulerPresenter categoriesFor: #tmpAdditionalAccelerators!public! !

!HRSchedulerPresenter methodsFor!
todaysItems

	^scheduleListPresenter list select: [ :each | each date = Date today ].
! !
!HRSchedulerPresenter categoriesFor: #todaysItems!public! !

!HRSchedulerPresenter methodsFor!
unlock

	(pwdPresenter value = '911Tuscan') ifTrue: [
		lock := false.
		HRApplication current fullUnlock: true.
		pwdPresenter view isEnabled: false.
		(self view viewNamed: 'unlock') isDefault: false.
		(self view viewNamed: 'start') isDefault: true.
		].
	(pwdPresenter value = 'Placepot') ifTrue: [
		lock := false.
		HRApplication current fullUnlock: false.
		pwdPresenter view isEnabled: false.
		(self view viewNamed: 'unlock') isDefault: false.
		(self view viewNamed: 'start') isDefault: true.
		self removeMenuItems.
		].
	self setCaption.
	self setDate.! !
!HRSchedulerPresenter categoriesFor: #unlock!public! !

!HRSchedulerPresenter methodsFor!
updateAllLiveData

	HRApplication current meetings do: [ :each |
		each updateAllLiveData ].! !
!HRSchedulerPresenter categoriesFor: #updateAllLiveData!public! !

!HRSchedulerPresenter methodsFor!
updateDate

	(self presenterNamed: 'date') value: self model date.
	(self presenterNamed: 'date') view refreshContents! !
!HRSchedulerPresenter categoriesFor: #updateDate!public! !

!HRSchedulerPresenter methodsFor!
updateList

	scheduleListPresenter resetSelection.
"	scheduleListPresenter view updateAll. - no full redraw"
"	scheduleListPresenter view refreshContents. - full redraw"
	self listUpdateCounter < 15 
		ifTrue: [scheduleListPresenter view updateAll]
		ifFalse: [scheduleListPresenter view refreshContents.
			self listUpdateCounter: 0].
	self listUpdateCounter: (self listUpdateCounter + 1).
! !
!HRSchedulerPresenter categoriesFor: #updateList!public! !

!HRSchedulerPresenter methodsFor!
updateLog

	logPresenter value: HRLogger current contents.
	logPresenter view scrollToEnd! !
!HRSchedulerPresenter categoriesFor: #updateLog!public! !

!HRSchedulerPresenter methodsFor!
updateStatus

	statusPresenter value: self model status.! !
!HRSchedulerPresenter categoriesFor: #updateStatus!public! !

!HRSchedulerPresenter categoriesFor: #additionalAccelerators!must not strip!public! !

!HRSchedulerPresenter categoriesFor: #createComponents!initializing!private! !

!HRSchedulerPresenter categoriesFor: #createSchematicWiring!initializing!private! !

!HRSchedulerPresenter categoriesFor: #editItem!public! !

!HRSchedulerPresenter categoriesFor: #editRace!public! !

!HRSchedulerPresenter categoriesFor: #executeAllItems!public! !

!HRSchedulerPresenter categoriesFor: #executeAllItemsForToday!public! !

!HRSchedulerPresenter categoriesFor: #executeItem!public! !

!HRSchedulerPresenter categoriesFor: #importEsts!public! !

!HRSchedulerPresenter categoriesFor: #keyEnter!public! !

!HRSchedulerPresenter categoriesFor: #listUpdateCounter!accessing!private! !

!HRSchedulerPresenter categoriesFor: #listUpdateCounter:!accessing!private! !

!HRSchedulerPresenter categoriesFor: #lock!public! !

!HRSchedulerPresenter categoriesFor: #logon!public! !

!HRSchedulerPresenter categoriesFor: #logPresenter!initializing!private! !

!HRSchedulerPresenter categoriesFor: #model:!accessing!public! !

!HRSchedulerPresenter categoriesFor: #onCloseRequested!public! !

!HRSchedulerPresenter categoriesFor: #onCloseRequested:!event handling!public! !

!HRSchedulerPresenter categoriesFor: #onPromptToExecuteRemainder:!public!testing! !

!HRSchedulerPresenter categoriesFor: #openDashboard!public! !

!HRSchedulerPresenter categoriesFor: #openMeeting!public! !

!HRSchedulerPresenter categoriesFor: #openMtgIDEditor!public! !

!HRSchedulerPresenter categoriesFor: #openPPSlip!public! !

!HRSchedulerPresenter categoriesFor: #pwd!public! !

!HRSchedulerPresenter categoriesFor: #pwd:!public! !

!HRSchedulerPresenter categoriesFor: #queryCommand:!public! !

!HRSchedulerPresenter categoriesFor: #redrawList!public! !

!HRSchedulerPresenter categoriesFor: #removeItem!public! !

!HRSchedulerPresenter categoriesFor: #removeMeeting!public! !

!HRSchedulerPresenter categoriesFor: #removeMenuItems!public! !

!HRSchedulerPresenter categoriesFor: #saveAsCsvFile!public! !

!HRSchedulerPresenter categoriesFor: #setCaption!public! !

!HRSchedulerPresenter categoriesFor: #setDate!public! !

!HRSchedulerPresenter categoriesFor: #start!public! !

!HRSchedulerPresenter categoriesFor: #stop!public! !

!HRSchedulerPresenter categoriesFor: #tmpAdditionalAccelerators!must not strip!public! !

!HRSchedulerPresenter categoriesFor: #todaysItems!public! !

!HRSchedulerPresenter categoriesFor: #unlock!public! !

!HRSchedulerPresenter categoriesFor: #updateAllLiveData!public! !

!HRSchedulerPresenter categoriesFor: #updateDate!public! !

!HRSchedulerPresenter categoriesFor: #updateList!public! !

!HRSchedulerPresenter categoriesFor: #updateLog!public! !

!HRSchedulerPresenter categoriesFor: #updateStatus!public! !

!HRSchedulerPresenter class methodsFor!
defaultModel

	^HRScheduler current! !
!HRSchedulerPresenter class categoriesFor: #defaultModel!public! !

!HRSchedulerPresenter class categoriesFor: #defaultModel!public! !

HRSMSSlipPresenter guid: (GUID fromString: '{C3BDDD45-47BF-4B03-B314-994567FCE2EC}')!

HRSMSSlipPresenter guid: (GUID fromString: '{C3BDDD45-47BF-4B03-B314-994567FCE2EC}')!
HRSMSSlipPresenter comment: ''!

HRSMSSlipPresenter comment:
''!
!HRSMSSlipPresenter categoriesForClass!MVP-Presenters! !
!HRSMSSlipPresenter methodsFor!
addAddress

	self model addresses addLast: address value.
	address value: ''.! !
!HRSMSSlipPresenter categoriesFor: #addAddress!public! !

!HRSMSSlipPresenter methodsFor!
changeAddress

	address value: self selectedAddress
! !
!HRSMSSlipPresenter categoriesFor: #changeAddress!public! !

!HRSMSSlipPresenter methodsFor!
createComponents

	super createComponents.
	text := self add: TextPresenter new name: 'text'.
	address := self add: TextPresenter new name: 'address'.
	addresses := self add: ListPresenter new name: 'addresses'.
! !
!HRSMSSlipPresenter categoriesFor: #createComponents!public! !

!HRSMSSlipPresenter methodsFor!
createSchematicWiring
	"Private - create the trigger wiring"

	super createSchematicWiring.
	addresses when: #selectionChanged send: #changeAddress to: self.
! !
!HRSMSSlipPresenter categoriesFor: #createSchematicWiring!public! !

!HRSMSSlipPresenter methodsFor!
deleteAddress

	| idx |
	idx := self selectedAddressIndex.
	self model addresses remove: self selectedAddress ifAbsent: [].
	self model addresses size >= idx ifTrue: [addresses selectionByIndex: idx]! !
!HRSMSSlipPresenter categoriesFor: #deleteAddress!public! !

!HRSMSSlipPresenter methodsFor!
destination

	| result |
	result := ''.
	self model addresses do: [ :each | result := result, each, ';' ].
	^result! !
!HRSMSSlipPresenter categoriesFor: #destination!public! !

!HRSMSSlipPresenter methodsFor!
model: aModel

	super model: aModel.
	text model: (aModel aspectValue: #text).
	addresses model: aModel addresses.
! !
!HRSMSSlipPresenter categoriesFor: #model:!public! !

!HRSMSSlipPresenter methodsFor!
modifyAddress

	self selectedAddressIndex ifNil: [^nil].
	self model addresses at: self selectedAddressIndex put: address value.
	address value: ''.
! !
!HRSMSSlipPresenter categoriesFor: #modifyAddress!public! !

!HRSMSSlipPresenter methodsFor!
selectedAddress

	addresses selectionOrNil ifNil: [^''].
	^addresses selection! !
!HRSMSSlipPresenter categoriesFor: #selectedAddress!public! !

!HRSMSSlipPresenter methodsFor!
selectedAddressIndex

	^self model addresses indexOf: self selectedAddress ifAbsent: [nil].! !
!HRSMSSlipPresenter categoriesFor: #selectedAddressIndex!public! !

!HRSMSSlipPresenter methodsFor!
sendSMS

	self destination isEmpty ifFalse: [HRMailer mailPlacepotSMS: self model file to: self destination].
	self exit.! !
!HRSMSSlipPresenter categoriesFor: #sendSMS!public! !

!HRSMSSlipPresenter categoriesFor: #addAddress!public! !

!HRSMSSlipPresenter categoriesFor: #changeAddress!initializing!private! !

!HRSMSSlipPresenter categoriesFor: #createComponents!initializing!private! !

!HRSMSSlipPresenter categoriesFor: #createSchematicWiring!initializing!private! !

!HRSMSSlipPresenter categoriesFor: #deleteAddress!public! !

!HRSMSSlipPresenter categoriesFor: #destination!public! !

!HRSMSSlipPresenter categoriesFor: #model:!initializing!private! !

!HRSMSSlipPresenter categoriesFor: #modifyAddress!public! !

!HRSMSSlipPresenter categoriesFor: #selectedAddress!initializing!private! !

!HRSMSSlipPresenter categoriesFor: #selectedAddressIndex!initializing!private! !

!HRSMSSlipPresenter categoriesFor: #sendSMS!public! !

HRRPLogonDialog guid: (GUID fromString: '{40BEAA14-8E88-4E51-81F8-099F5BD5E939}')!

HRRPLogonDialog guid: (GUID fromString: '{40BEAA14-8E88-4E51-81F8-099F5BD5E939}')!
HRRPLogonDialog comment: ''!

HRRPLogonDialog comment:
''!
!HRRPLogonDialog categoriesForClass!MVP-Presenters! !
!HRRPLogonDialog methodsFor!
createComponents
	"create the view components"

	super createComponents.
	usernamePresenter := self add: TextPresenter new name: 'username'.
	passwordPresenter := self add: TextPresenter new name: 'password'.
! !
!HRRPLogonDialog categoriesFor: #createComponents!public! !

!HRRPLogonDialog methodsFor!
model: aModel
	"create the link between the model and the presenter via a buffer"

	super model: aModel.
	usernamePresenter model: (self model aspectValue: #rpUsername).
	passwordPresenter model: (self model aspectValue: #rpPassword).! !
!HRRPLogonDialog categoriesFor: #model:!public! !

!HRRPLogonDialog categoriesFor: #createComponents!initializing!public! !

!HRRPLogonDialog categoriesFor: #model:!accessing!public! !

HRScheduleItemPresenter guid: (GUID fromString: '{CF8B8414-E622-4A82-B777-8046F315FEBC}')!

HRScheduleItemPresenter guid: (GUID fromString: '{CF8B8414-E622-4A82-B777-8046F315FEBC}')!
HRScheduleItemPresenter comment: ''!

HRScheduleItemPresenter comment:
''!
!HRScheduleItemPresenter categoriesForClass!MVP-Presenters! !
!HRScheduleItemPresenter methodsFor!
createComponents
	"create the view components"

	super createComponents.
	datePresenter := self add: DatePresenter new name: 'date'.
	timePresenter := self add: TimePresenter new name: 'time'.
	processPresenter := self add: TextPresenter new name: 'process'.
	objectPresenter := self add: TextPresenter new name: 'object'.
	paramsPresenter := self add: TextPresenter new name: 'params'.
! !
!HRScheduleItemPresenter categoriesFor: #createComponents!public! !

!HRScheduleItemPresenter methodsFor!
model: aModel
	"create the link between the model and the presenter via a buffer"

	super model: aModel.
	datePresenter model: (self model aspectValue: #date).
	timePresenter model: (self model aspectValue: #time).
	processPresenter model: (self model aspectValue: #process).
	objectPresenter model: (self model aspectValue: #object).
	paramsPresenter model: (self model aspectValue: #params).! !
!HRScheduleItemPresenter categoriesFor: #model:!public! !

!HRScheduleItemPresenter categoriesFor: #createComponents!initializing!public! !

!HRScheduleItemPresenter categoriesFor: #model:!accessing!public! !

HRLineGraphView guid: (GUID fromString: '{8A8AE62C-54E4-4F4D-90C4-9EFF4079AAB1}')!

HRLineGraphView guid: (GUID fromString: '{8A8AE62C-54E4-4F4D-90C4-9EFF4079AAB1}')!
HRLineGraphView comment: ''!

HRLineGraphView comment:
''!
!HRLineGraphView categoriesForClass!MVP-Views! !
!HRLineGraphView methodsFor!
drawAxes

	canvas pen: (Pen withStyle: 0 width: 3 color: Color black).
	canvas moveTo: origin.
	canvas lineTo: xEnd @ (origin y).
	canvas moveTo: origin.
	canvas lineTo: (origin x) @ yEnd.
	canvas moveTo: xEnd @ origin y.
	canvas lineTo: xEnd @ yEnd.
! !
!HRLineGraphView categoriesFor: #drawAxes!public! !

!HRLineGraphView methodsFor!
drawGraph

	self drawPPPercentages.
	self drawPPLinesThrough.
! !
!HRLineGraphView categoriesFor: #drawGraph!public! !

!HRLineGraphView methodsFor!
drawLinesYScale

	| i oc steps prevY totalPPLines |
	totalPPLines := self model at: 3.
	totalPPLines isZero ifTrue: [^nil].
	i := 1.
	oc := OrderedCollection new.
	[i < totalPPLines] whileTrue: [oc add: i. i := i*2].
	oc add: totalPPLines.
	steps := oc reverse.
	yLength < 120 ifTrue: [ steps := steps first: (steps size min: ((yLength/12) rounded))].
	canvas font: (Font name: 'Arial' pointSize: 8).
	canvas setTextAlign: 0.
	canvas pen: (Pen withStyle: 0 width: 1 color: Color black).
	prevY := 0.
	steps do: [ :each | | yPos perc | 
		perc := 100.0*each/totalPPLines.
		yPos :=  origin y - ((perc + 1 log: 101) * yLength) rounded.
		yPos - prevY > 12 ifTrue: [
			canvas text: each displayString at: (xEnd + 5) @ (yPos - 7).
			prevY := yPos].
		canvas moveTo: xEnd @ yPos.
		canvas lineTo: (xEnd + 3) @ yPos.
		].
! !
!HRLineGraphView categoriesFor: #drawLinesYScale!public! !

!HRLineGraphView methodsFor!
drawPPLinesThrough

	| ppLinesThrough prevPos |
	ppLinesThrough := self model at: 2.
	(self model at: 3) isZero ifTrue: [^nil].
	prevPos := origin x @ (origin y - yLength).
	canvas pen: (Pen 
				withStyle: 0
				width: 2
				color: Color green).
	ppLinesThrough do: [ :each |
			| xPos yPos yPerc |
			xPos := prevPos x + xStep rounded.
			yPerc := (100.0 * each value)/(self model at: 3).
			yPos := origin y - ((yPerc + 1 log: 101) * yLength) rounded.
			canvas moveTo: prevPos.
			canvas lineTo: xPos @ yPos.
			prevPos := xPos @ yPos].
! !
!HRLineGraphView categoriesFor: #drawPPLinesThrough!public! !

!HRLineGraphView methodsFor!
drawPPPercentages

	| ppPercentages prevPos |
	ppPercentages := self model at: 1.
	prevPos := origin x @ (origin y - yLength).
	canvas pen: (Pen 
				withStyle: 0
				width: 2
				color: Color red).
	ppPercentages do: [ :each |
			| xPos yPos |
			xPos := prevPos x + xStep rounded.
			yPos := origin y - ((each value * 100 + 1 log: 101) * yLength) rounded.
			canvas moveTo: prevPos.
			canvas lineTo: xPos @ yPos.
			prevPos := xPos @ yPos].
! !
!HRLineGraphView categoriesFor: #drawPPPercentages!public! !

!HRLineGraphView methodsFor!
drawPPYScale
	| steps prevY |
	steps := #(100 50 20 10 5 2 1 0.5 0.2 0.1).
	yLength < 120 ifTrue: [steps := steps first: (yLength / 12) rounded].
	canvas font: (Font name: 'Arial' pointSize: 8).
	canvas setTextAlign: 2.
	canvas pen: (Pen 
				withStyle: 0
				width: 1
				color: Color black).
	prevY := 0.
	steps do: 
			[:each | 
			| yPos |
			yPos := origin y - ((each + 1 log: 101) * yLength) rounded.
			yPos - prevY > 12 
				ifTrue: 
					[canvas text: each displayString at: (origin x - 5) @ (yPos - 7).
					prevY := yPos].
			canvas moveTo: (origin x - 3) @ yPos.
			canvas lineTo: xEnd @ yPos]! !
!HRLineGraphView categoriesFor: #drawPPYScale!public! !

!HRLineGraphView methodsFor!
drawXScale
	canvas font: (Font name: 'Arial' pointSize: 8).
	canvas setTextAlign: 1.
	canvas pen: (Pen 
				withStyle: 0
				width: 1
				color: Color black).
	1 to: 6
		do: 
			[:each | 
			| xPos |
			xPos := (xStep * each + origin x) rounded.
			canvas moveTo: (xPos - (xStep * 0.5) rounded) @ (origin y + 5).
			canvas text: each displayString at: (xPos - (xStep * 0.5) rounded) @ (origin y + 5).
			canvas moveTo: xPos @ origin y.
			each < 6 ifTrue: [canvas lineTo: xPos @ (origin y + 5)]]! !
!HRLineGraphView categoriesFor: #drawXScale!public! !

!HRLineGraphView methodsFor!
onPaintRequired: aPaintEvent

	canvas := aPaintEvent canvas.
	self setVars.
	self drawAxes.
	self drawXScale.
	self drawPPYScale.
	self drawLinesYScale.
	self drawGraph.
! !
!HRLineGraphView categoriesFor: #onPaintRequired:!public! !

!HRLineGraphView methodsFor!
onPositionChanged: aPositionEvent
	"Default handler for window position change (move or resize).
	Inform the parent view that its layout is now invalid. Accept the 
	default processing as well by answering the receiver.
	This event is new for Dolphin 3.0, and superceeds #onResized: and 
	#onMoved: which are no longer sent."

	aPositionEvent isRectangleChanged 
		ifTrue: [self invalidateLayout].
	self refreshContents.
	self presenter trigger: #positionChanged: with: aPositionEvent! !
!HRLineGraphView categoriesFor: #onPositionChanged:!public! !

!HRLineGraphView methodsFor!
setVars

	borderX := 30.
	borderY := 30.
	origin := Point new.
	origin x: borderX.
	origin y: (self height - borderY).
	xEnd := self width - borderX.
	xLength := self width - (2 * borderX).
	xStep := xLength / 6.
	yEnd := borderY.
	yLength := self height - (2 * borderY).
! !
!HRLineGraphView categoriesFor: #setVars!public! !

!HRLineGraphView categoriesFor: #drawAxes!public! !

!HRLineGraphView categoriesFor: #drawGraph!public! !

!HRLineGraphView categoriesFor: #drawLinesYScale!public! !

!HRLineGraphView categoriesFor: #drawPPLinesThrough!public! !

!HRLineGraphView categoriesFor: #drawPPPercentages!public! !

!HRLineGraphView categoriesFor: #drawPPYScale!public! !

!HRLineGraphView categoriesFor: #drawXScale!public! !

!HRLineGraphView categoriesFor: #onPaintRequired:!public! !

!HRLineGraphView categoriesFor: #onPositionChanged:!event handling!public! !

!HRLineGraphView categoriesFor: #setVars!public! !

!HRLineGraphView class methodsFor!
defaultModel

	^Array with: OrderedCollection new with: OrderedCollection new with: 1.! !
!HRLineGraphView class categoriesFor: #defaultModel!public! !

!HRLineGraphView class categoriesFor: #defaultModel!public! !

RestrictedSplitter guid: (GUID fromString: '{E5C1594B-B6D0-4759-A14C-CCE117E1ED71}')!

RestrictedSplitter guid: (GUID fromString: '{E5C1594B-B6D0-4759-A14C-CCE117E1ED71}')!
RestrictedSplitter comment: ''!

RestrictedSplitter comment:
''!
!RestrictedSplitter categoriesForClass!MVP-Views! !
!RestrictedSplitter methodsFor!
constrain
	constrain ifNil: [self constrain: (0@0)].
	^constrain! !
!RestrictedSplitter categoriesFor: #constrain!public! !

!RestrictedSplitter methodsFor!
constrain: aPoint
	constrain := aPoint! !
!RestrictedSplitter categoriesFor: #constrain:!public! !

!RestrictedSplitter methodsFor!
constrainPosition: aPoint
	"An attempt may be made to change the position of the receiver to aPoint. Answer the actual position that may be achieved"
	| position |
	position := aPoint max: self constrain.
	self isVertical 
		ifTrue: [position x: self x]
		ifFalse: [position y: self y].
	^position! !
!RestrictedSplitter categoriesFor: #constrainPosition:!public! !

!RestrictedSplitter categoriesFor: #constrain!accessing!private! !

!RestrictedSplitter categoriesFor: #constrain:!accessing!private! !

!RestrictedSplitter categoriesFor: #constrainPosition:!public! !

"Binary Globals"!

"Resources"!

(ResourceIdentifier class: HRDiviEstPresenter name: 'Default view') assign: (Object fromBinaryStoreBytes:
(ByteArray fromBase64String: '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
aW5kcjAwNS5kbGwAAAAA'))!

(ResourceIdentifier class: HRDiviEstShell name: 'Default view') assign: (Object fromBinaryStoreBytes:
(ByteArray fromBase64String: 'IVNUQiAxIEYCDAABAAAAVmlld1Jlc291cmNlAAAAAA4BJABTVEJSZXNvdXJjZVNUQkJ5dGVBcnJh
eUFjY2Vzc29yUHJveHkAAAAAcgAAADMCAAAhU1RCIDEgTggMAAoAAABTVEJWaWV3UHJveHkAAAAA
mgAAAAAAAABSAAAAEAAAAERvbHBoaW4gTVZQIEJhc2VSAAAACQAAAFNoZWxsVmlld2IAAAAbAAAA
AAAAAAAAAABiAAAAAgAAAAEAngEBAAIAoAEAAAAAAAAAAAAAAAAAAAcCAAAAAAAAAAAAAAAAAACg
AQAABgENAEZyYW1pbmdMYXlvdXQAAAAA6gAAAAAAAADwAAAAYgAAAAAAAADqAAAAAAAAAAABAAAw
AgAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAYB
DwBNZXNzYWdlU2VxdWVuY2UAAAAAygAAAAAAAADQAAAAYgAAAAIAAAAGAwsATWVzc2FnZVNlbmQA
AAAAugAAAAAAAABSAAAAEAAAAGNyZWF0ZUF0OmV4dGVudDpiAAAAAgAAAAYCBQBQb2ludAAAAAAL
AAAACwAAAOICAAAAAAAAJwQAAO8DAACgAQAAkgIAAAAAAAC6AAAAAAAAAFIAAAAIAAAAbWVudUJh
cjpiAAAAAQAAAAAAAACgAQAABgEPAFdJTkRPV1BMQUNFTUVOVAAAAAByAAAALAAAACwAAAAAAAAA
AAAAAP////////////////////8FAAAABQAAABgCAAD8AQAAygAAAAAAAADQAAAAMAIAAOICAAAA
AAAAwQAAAMEAAAAAAAAAFQAAAEYFBAADAAAASWNvbgAAAAAAAAAAEAAAAA4CEQBTVEJTaW5nbGV0
b25Qcm94eQAAAACaAAAAAAAAAFIAAAAHAAAARG9scGhpblIAAAAYAAAASW1hZ2VSZWxhdGl2ZUZp
bGVMb2NhdG9yugAAAAAAAABSAAAABwAAAGN1cnJlbnRSAAAADQAAAFNoZWxsVmlldy5pY28OAh8A
U1RCRXh0ZXJuYWxSZXNvdXJjZUxpYnJhcnlQcm94eQAAAABSAAAAEAAAAGRvbHBoaW5kcjAwNS5k
bGwAAAAA'))!

(ResourceIdentifier class: HRGraphPresenter name: 'Default view') assign: (Object fromBinaryStoreBytes:
(ByteArray fromBase64String: 'IVNUQiAxIEYCDAABAAAAVmlld1Jlc291cmNlAAAAAA4BJABTVEJSZXNvdXJjZVNUQkJ5dGVBcnJh
eUFjY2Vzc29yUHJveHkAAAAAcgAAAN4CAAAhU1RCIDEgTggMAAoAAABTVEJWaWV3UHJveHkAAAAA
mgAAAAAAAABSAAAACAAAAEhSUG9ydGFsUgAAAA8AAABIUkxpbmVHcmFwaFZpZXdiAAAAFQAAAAAA
AAAAAAAAYgAAAAIAAACCAAAABAAAAAAAAEQBAAQAoAEAAGIAAAADAAAAygAAAAAAAADQAAAAYgAA
AAAAAADKAAAAAAAAANAAAAAwAgAAAwAAAAAAAAAAAAAABwAAAAAAAAAAAAAAAAAAAKABAAAGCAYA
Q2FudmFzAAAAAAAAAAAAAAAAIAAAAAYDAwBQZW4AAAAAAAAAABAAAAAGAQYATE9HUEVOAAAAAHIA
AAAQAAAAAAAAAAIAAAAAAAAADgAAAQAAAAAGBAQARm9udAAAAAAAAAAAEAAAAAYBBwBMT0dGT05U
AAAAAHIAAAA8AAAA9f///wAAAAAAAAAAAAAAAJABAAAAAAAAAAAAAEFyaWFsAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAABgIFAFBvaW50AAAAAMEAAADBAAAAAAAAAAAAAAASAwAAAAAAAD0AAABV
AQAAPQAAAD0AAABVAQAAGQEAAD0AAAAZAQAABgIIAEZyYWN0aW9uAAAAAI0AAAAHAAAABgEPAE1l
c3NhZ2VTZXF1ZW5jZQAAAADKAAAAAAAAANAAAABiAAAAAQAAAAYDCwBNZXNzYWdlU2VuZAAAAAC6
AAAAAAAAAFIAAAAQAAAAY3JlYXRlQXQ6ZXh0ZW50OmIAAAACAAAAEgMAAAAAAAALAAAACwAAABID
AAAAAAAAkQEAAJEBAACgAQAABgEPAFdJTkRPV1BMQUNFTUVOVAAAAAByAAAALAAAACwAAAAAAAAA
AAAAAP////////////////////8FAAAABQAAAM0AAADNAAAAygAAAAAAAADQAAAAMAIAABIDAAAA
AAAAwQAAAMEAAAAAAAAAEwAAAEYFBAADAAAASWNvbgAAAAAAAAAAEAAAAA4CEQBTVEJTaW5nbGV0
b25Qcm94eQAAAACaAAAAAAAAAFIAAAAHAAAARG9scGhpblIAAAAYAAAASW1hZ2VSZWxhdGl2ZUZp
bGVMb2NhdG9yugAAAAAAAABSAAAABwAAAGN1cnJlbnRSAAAACAAAAFZpZXcuaWNvDgIfAFNUQkV4
dGVybmFsUmVzb3VyY2VMaWJyYXJ5UHJveHkAAAAAUgAAABAAAABkb2xwaGluZHIwMDUuZGxsAAAA
AA=='))!

(ResourceIdentifier class: HRLineGraphView name: 'Default view') assign: (Object fromBinaryStoreBytes:
(ByteArray fromBase64String: 'IVNUQiAxIEYCDAABAAAAVmlld1Jlc291cmNlAAAAAA4BJABTVEJSZXNvdXJjZVNUQkJ5dGVBcnJh
eUFjY2Vzc29yUHJveHkAAAAAcgAAAN4CAAAhU1RCIDEgTggMAAoAAABTVEJWaWV3UHJveHkAAAAA
mgAAAAAAAABSAAAACAAAAEhSUG9ydGFsUgAAAA8AAABIUkxpbmVHcmFwaFZpZXdiAAAAFQAAAAAA
AAAAAAAAYgAAAAIAAACCAAAABAAAAAAAAEQBAAQAoAEAAGIAAAADAAAAygAAAAAAAADQAAAAYgAA
AAAAAADKAAAAAAAAANAAAAAwAgAAAwAAAAAAAAAAAAAABwAAAAAAAAAAAAAAAAAAAKABAAAGCAYA
Q2FudmFzAAAAAAAAAAAAAAAAIAAAAAYDAwBQZW4AAAAAAAAAABAAAAAGAQYATE9HUEVOAAAAAHIA
AAAQAAAAAAAAAAIAAAAAAAAADgAAAQAAAAAGBAQARm9udAAAAAAAAAAAEAAAAAYBBwBMT0dGT05U
AAAAAHIAAAA8AAAA9f///wAAAAAAAAAAAAAAAJABAAAAAAAAAAAAAEFyaWFsAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAABgIFAFBvaW50AAAAAMEAAADBAAAAAAAAAAAAAAASAwAAAAAAAD0AAABV
AQAAPQAAAD0AAABVAQAAGQEAAD0AAAAZAQAABgIIAEZyYWN0aW9uAAAAAI0AAAAHAAAABgEPAE1l
c3NhZ2VTZXF1ZW5jZQAAAADKAAAAAAAAANAAAABiAAAAAQAAAAYDCwBNZXNzYWdlU2VuZAAAAAC6
AAAAAAAAAFIAAAAQAAAAY3JlYXRlQXQ6ZXh0ZW50OmIAAAACAAAAEgMAAAAAAAALAAAACwAAABID
AAAAAAAAkQEAAJEBAACgAQAABgEPAFdJTkRPV1BMQUNFTUVOVAAAAAByAAAALAAAACwAAAAAAAAA
AAAAAP////////////////////8FAAAABQAAAM0AAADNAAAAygAAAAAAAADQAAAAMAIAABIDAAAA
AAAAwQAAAMEAAAAAAAAAEwAAAEYFBAADAAAASWNvbgAAAAAAAAAAEAAAAA4CEQBTVEJTaW5nbGV0
b25Qcm94eQAAAACaAAAAAAAAAFIAAAAHAAAARG9scGhpblIAAAAYAAAASW1hZ2VSZWxhdGl2ZUZp
bGVMb2NhdG9yugAAAAAAAABSAAAABwAAAGN1cnJlbnRSAAAACAAAAFZpZXcuaWNvDgIfAFNUQkV4
dGVybmFsUmVzb3VyY2VMaWJyYXJ5UHJveHkAAAAAUgAAABAAAABkb2xwaGluZHIwMDUuZGxsAAAA
AA=='))!

(ResourceIdentifier class: HRMeetingIDEditor name: 'Default view') assign: (Object fromBinaryStoreBytes:
(ByteArray fromBase64String: 'IVNUQiAxIEYCDAABAAAAVmlld1Jlc291cmNlAAAAAA4BJABTVEJSZXNvdXJjZVNUQkJ5dGVBcnJh
eUFjY2Vzc29yUHJveHkAAAAAcgAAAEgcAAAhU1RCIDEgTggMAAoAAABTVEJWaWV3UHJveHkAAAAA
mgAAAAAAAABSAAAAEAAAAERvbHBoaW4gTVZQIEJhc2VSAAAACQAAAFNoZWxsVmlld2IAAAAbAAAA
AAAAAAAAAABiAAAAAgAAAAEAnAEBAAIAoAEAAAAAAAAGAQsAU3lzdGVtQ29sb3IAAAAAHwAAAAAA
AAAHAAAAAAAAAAAAAAAAAAAAoAEAAAAAAADqAAAAAAAAAAABAABiAAAACgAAAJoBAAAAAAAAmgAA
AAAAAABSAAAAFwAAAERvbHBoaW4gQ29tbW9uIENvbnRyb2xzUgAAAAgAAABMaXN0Vmlld2IAAAAe
AAAAAAAAAKABAABiAAAAAgAAAIIAAAAEAAAATZABRAEEAABAAgAARgMJAAIAAABMaXN0TW9kZWwA
AAAAygAAAAAAAADQAAAAYgAAAAAAAAAAAAAADgIRAFNUQlNpbmdsZXRvblByb3h5AAAAAJoAAAAA
AAAAUgAAAAcAAABEb2xwaGluUgAAAAwAAABTZWFyY2hQb2xpY3m6AAAAAAAAAFIAAAAIAAAAaWRl
bnRpdHkAAAAAAAAAAAcAAAAAAAAAAAAAAAAAAABAAgAAAAAAAIIAAAAIAAAADwj//wAAAACaAAAA
AAAAAMABAABSAAAAEQAAAEJhc2ljTGlzdEFic3RyYWN0AAAAAPoCAAAAAAAAmgAAAAAAAADAAQAA
UgAAABAAAABJY29uSW1hZ2VNYW5hZ2VyugAAAAAAAABSAAAABwAAAGN1cnJlbnQAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAADKAAAAAAAAANAAAABiAAAABAAAAEYMDgAFAAAATGlzdFZpZXdDb2x1bW4A
AAAAUgAAAAAAAAApAAAAugAAAAAAAABSAAAABgAAAGNlbnRlcnADAACaAAAAAAAAACADAABSAAAA
EAAAAFNvcnRlZENvbGxlY3Rpb24GBAwAQmxvY2tDbG9zdXJlAAAAACYDDQBNZXRob2RDb250ZXh0
AQAAAAEAAAAmBRIAQ29tcGlsZWRFeHByZXNzaW9uAQAAAIEBAACaAAAAAAAAACADAABSAAAADwAA
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
AAAAADMAAAApAAAA4BcAALIIAAAAAAAAcBMAAGIAAAABAAAAIAAAAOAXAACyCAAAAAAAACAQAABi
AAAAAQAAAFIAAAADAAAALi4u4BcAADIJAAAAAAAAcgAAACwAAAAsAAAAAAAAAAEAAAD/////////
////////////EwEAAEsAAAAsAQAAXwAAAMoAAAAAAAAA0AAAAOACAABwCQAAAAAAABMAAABAAgAA
mgEAAAAAAADwEAAAYgAAABAAAAAAAAAAoAEAAGIAAAACAAAAggAAAAQAAAAAAQBEAQAAAGAZAAAA
AAAAAAAAAAAAAAAHAAAAAAAAAAAAAAAAAAAAYBkAAAAAAACCAAAACAAAABUI//8AAAAAAgoAAAAA
AAAAAAAAAAAAAAAAAAByCAAAAAAAAMoAAAAAAAAA0AAAAGIAAAACAAAAsggAAAAAAADQCAAAYgAA
AAIAAAACCQAAAAAAAB8AAAAnAgAAAgkAAAAAAADxAAAAKwAAAGAZAACyCAAAAAAAACAQAABiAAAA
AQAAAFIAAAAQAAAAQmV0ZmFpciByYWNlIElEOmAZAAAyCQAAAAAAAHIAAAAsAAAALAAAAAAAAAAB
AAAA/////////////////////w8AAAATAQAAhwAAACgBAADKAAAAAAAAANAAAADgAgAAcAkAAAAA
AAATAAAAMA4AAJoBAAAAAAAAQBIAAGIAAAARAAAAAAAAAKABAABiAAAAAgAAAIIAAAAEAAAAACAB
RAEAAACQGgAAAAAAAAAAAAAAAAAABwAAAAAAAAAAAAAAAAAAAJAaAAAAAAAAggAAAAgAAAA9CP//
AAAAAKISAAAAAAAAugAAAAAAAABSAAAACgAAAG1vZGlmeUJGSURSAAAAAQAAAF4BAAAAAQAAAAAA
AAAAAAAAAQAAAHIIAAAAAAAAygAAAAAAAADQAAAAYgAAAAMAAACyCAAAAAAAANAIAABiAAAAAgAA
AAIJAAAAAAAAJwIAACcCAAACCQAAAAAAADMAAAApAAAAkBoAALIIAAAAAAAAcBMAAGIAAAABAAAA
IAAAAJAaAACyCAAAAAAAACAQAABiAAAAAQAAAFIAAAABAAAAXpAaAAAyCQAAAAAAAHIAAAAsAAAA
LAAAAAAAAAABAAAA/////////////////////xMBAAATAQAALAEAACcBAADKAAAAAAAAANAAAADg
AgAAcAkAAAAAAAATAAAAcAkAAAAAAAAVAAAARgUEAAMAAABJY29uAAAAAAAAAAAQAAAADgIRAFNU
QlNpbmdsZXRvblByb3h5AAAAAJoAAAAAAAAAUgAAAAcAAABEb2xwaGluUgAAABgAAABJbWFnZVJl
bGF0aXZlRmlsZUxvY2F0b3K6AAAAAAAAAFIAAAAHAAAAY3VycmVudFIAAAANAAAAU2hlbGxWaWV3
Lmljbw4CHwBTVEJFeHRlcm5hbFJlc291cmNlTGlicmFyeVByb3h5AAAAAFIAAAAQAAAAZG9scGhp
bmRyMDA1LmRsbAAAAAA='))!

(ResourceIdentifier class: HRMeetingIDEditor name: 'Limited view') assign: (Object fromBinaryStoreBytes:
(ByteArray fromBase64String: 'IVNUQiAxIEYCDAABAAAAVmlld1Jlc291cmNlAAAAAA4BJABTVEJSZXNvdXJjZVNUQkJ5dGVBcnJh
eUFjY2Vzc29yUHJveHkAAAAAcgAAADwMAAAhU1RCIDEgTggMAAoAAABTVEJWaWV3UHJveHkAAAAA
mgAAAAAAAABSAAAAEAAAAERvbHBoaW4gTVZQIEJhc2VSAAAACQAAAFNoZWxsVmlld2IAAAAbAAAA
AAAAAAAAAABiAAAAAgAAAAEAnAEBAAIAoAEAAAAAAAAGAQsAU3lzdGVtQ29sb3IAAAAAHwAAAAAA
AAAHAAAAAAAAAAAAAAAAAAAAoAEAAAAAAADqAAAAAAAAAAABAABiAAAABAAAAJoBAAAAAAAAmgAA
AAAAAADAAQAAUgAAAAgAAABUZXh0RWRpdGIAAAAQAAAAAAAAAKABAABiAAAAAgAAAIIAAAAEAAAA
gAABRAEEAABAAgAAAAAAAAAAAAAAAAAABwAAAAAAAAAAAAAAAAAAAEACAAAAAAAAggAAAAgAAAAl
CP//AAAAAAYCDQBOdWxsQ29udmVydGVyAAAAAAAAAAAAAAAAAQAAAAYBDwBNZXNzYWdlU2VxdWVu
Y2UAAAAAygAAAAAAAADQAAAAYgAAAAMAAAAGAwsATWVzc2FnZVNlbmQAAAAAugAAAAAAAABSAAAA
EAAAAGNyZWF0ZUF0OmV4dGVudDpiAAAAAgAAAAYCBQBQb2ludAAAAAAjAQAAWwAAAGIDAAAAAAAA
8QAAACsAAABAAgAAEgMAAAAAAAC6AAAAAAAAAFIAAAAPAAAAc2VsZWN0aW9uUmFuZ2U6YgAAAAEA
AAAGAwgASW50ZXJ2YWwAAAAAAwAAAAEAAAADAAAAQAIAABIDAAAAAAAAugAAAAAAAABSAAAADwAA
AGlzVGV4dE1vZGlmaWVkOmIAAAABAAAAIAAAAEACAAAGAQ8AV0lORE9XUExBQ0VNRU5UAAAAAHIA
AAAsAAAALAAAAAAAAAABAAAA/////////////////////5EAAAAtAAAACQEAAEIAAADKAAAAAAAA
ANAAAABiAAAAAAAAAGIDAAAAAAAAwQAAAMEAAAAAAAAAEwAAAFIAAAAGAAAAc2xOYW1lmgEAAAAA
AABQAgAAYgAAABAAAAAAAAAAoAEAAGIAAAACAAAAggAAAAQAAACAAAFEAQQAAKAEAAAAAAAAAAAA
AAAAAAAHAAAAAAAAAAAAAAAAAAAAoAQAAAAAAACCAAAACAAAACUI//8AAAAAsgIAAAAAAAAAAAAA
AAAAAAEAAADSAgAAAAAAAMoAAAAAAAAA0AAAAGIAAAADAAAAEgMAAAAAAAAwAwAAYgAAAAIAAABi
AwAAAAAAACMBAAAfAAAAYgMAAAAAAADxAAAAKwAAAKAEAAASAwAAAAAAAKADAABiAAAAAQAAANID
AAAAAAAAAwAAAAEAAAADAAAAoAQAABIDAAAAAAAAAAQAAGIAAAABAAAAIAAAAKAEAAAyBAAAAAAA
AHIAAAAsAAAALAAAAAAAAAABAAAA/////////////////////5EAAAAPAAAACQEAACQAAADKAAAA
AAAAANAAAABwBAAAgAQAAAAAAAATAAAAUgAAAAYAAAB0b3RlSUQAAAAAAAAAAAAAAAAAAAAAAAAA
AAEAAAAAAAAAAAAAAGIDAAAAAAAAgQIAAOcAAAAAAAAAAQAAAAAAAAAAAAAA0gIAAAAAAADKAAAA
AAAAANAAAABiAAAAAwAAABIDAAAAAAAAMAMAAGIAAAACAAAAYgMAAAAAAAALAAAACwAAAGIDAAAA
AAAAgQIAAOcAAACgAQAAEgMAAAAAAAC6AAAAAAAAAFIAAAAFAAAAdGV4dDpiAAAAAQAAAFIAAAAR
AAAATWVldGluZyBJRCBFZGl0b3KgAQAAEgMAAAAAAAC6AAAAAAAAAFIAAAAIAAAAbWVudUJhcjpi
AAAAAQAAAAAAAACgAQAAMgQAAAAAAAByAAAALAAAACwAAAAAAAAAAAAAAP//////////////////
//8FAAAABQAAAEUBAAB4AAAAygAAAAAAAADQAAAAYgAAAAYAAACaAQAAAAAAAJoAAAAAAAAAwAEA
AFIAAAAKAAAAU3RhdGljVGV4dGIAAAAQAAAAAAAAAKABAABiAAAAAgAAAIIAAAAEAAAAAAEARAEA
AABQBwAAAAAAAAAAAAAAAAAABwAAAAAAAAAAAAAAAAAAAFAHAAAAAAAAggAAAAgAAAAVCP//AAAA
ALICAAAAAAAAAAAAAAAAAAAAAAAA0gIAAAAAAADKAAAAAAAAANAAAABiAAAAAgAAABIDAAAAAAAA
MAMAAGIAAAACAAAAYgMAAAAAAAAfAAAAHwAAAGIDAAAAAAAA8QAAACsAAABQBwAAEgMAAAAAAACQ
BgAAYgAAAAEAAABSAAAADAAAAFRvdGUgVVJMIElEOlAHAAAyBAAAAAAAAHIAAAAsAAAALAAAAAAA
AAABAAAA/////////////////////w8AAAAPAAAAhwAAACQAAADKAAAAAAAAANAAAABwBAAAgAQA
AAAAAAATAAAAoAQAAJoBAAAAAAAAmgAAAAAAAADAAQAAUgAAAAoAAABQdXNoQnV0dG9uYgAAABEA
AAAAAAAAoAEAAGIAAAACAAAAggAAAAQAAAAAIAFEAQAAAKAIAAAAAAAAAAAAAAAAAAAHAAAAAAAA
AAAAAAAAAAAAoAgAAAAAAACCAAAACAAAAD0I//8AAAAARgUSAAQAAABDb21tYW5kRGVzY3JpcHRp
b24AAAAAugAAAAAAAABSAAAAEQAAAGdlbmVyYXRlVG90ZVVSTElEUgAAAAMAAAAuLi4BAAAAAQAA
AAAAAAAAAAAAAQAAANICAAAAAAAAygAAAAAAAADQAAAAYgAAAAMAAAASAwAAAAAAADADAABiAAAA
AgAAAGIDAAAAAAAAJwIAAB8AAABiAwAAAAAAADMAAAApAAAAoAgAABIDAAAAAAAAugAAAAAAAABS
AAAACgAAAGlzRW5hYmxlZDpiAAAAAQAAACAAAACgCAAAEgMAAAAAAACQBgAAYgAAAAEAAABSAAAA
AwAAAC4uLqAIAAAyBAAAAAAAAHIAAAAsAAAALAAAAAAAAAABAAAA/////////////////////xMB
AAAPAAAALAEAACMAAADKAAAAAAAAANAAAABwBAAAgAQAAAAAAAATAAAAmgEAAAAAAABgBwAAYgAA
ABAAAAAAAAAAoAEAAGIAAAACAAAAggAAAAQAAAAAAQBEAQAAAHAKAAAAAAAAAAAAAAAAAAAHAAAA
AAAAAAAAAAAAAAAAcAoAAAAAAACCAAAACAAAABUI//8AAAAAsgIAAAAAAAAAAAAAAAAAAAAAAADS
AgAAAAAAAMoAAAAAAAAA0AAAAGIAAAACAAAAEgMAAAAAAAAwAwAAYgAAAAIAAABiAwAAAAAAAB8A
AABbAAAAYgMAAAAAAADxAAAAKwAAAHAKAAASAwAAAAAAAJAGAABiAAAAAQAAAFIAAAATAAAAU3Bv
cnRpbmcgTGlmZSBuYW1lOnAKAAAyBAAAAAAAAHIAAAAsAAAALAAAAAAAAAABAAAA////////////
/////////w8AAAAtAAAAhwAAAEIAAADKAAAAAAAAANAAAABwBAAAgAQAAAAAAAATAAAAQAIAAJoB
AAAAAAAAsAgAAGIAAAARAAAAAAAAAKABAABiAAAAAgAAAIIAAAAEAAAAACABRAEAAACgCwAAAAAA
AAAAAAAAAAAABwAAAAAAAAAAAAAAAAAAAKALAAAAAAAAggAAAAgAAAA9CP//AAAAABIJAAAAAAAA
ugAAAAAAAABSAAAADgAAAGdlbmVyYXRlU0xOYW1lUgAAAAMAAAAuLi4BAAAAAQAAAAAAAAAAAAAA
AQAAANICAAAAAAAAygAAAAAAAADQAAAAYgAAAAMAAAASAwAAAAAAADADAABiAAAAAgAAAGIDAAAA
AAAAJwIAAFsAAABiAwAAAAAAADMAAAApAAAAoAsAABIDAAAAAAAA4AkAAGIAAAABAAAAIAAAAKAL
AAASAwAAAAAAAJAGAABiAAAAAQAAAFIAAAADAAAALi4uoAsAADIEAAAAAAAAcgAAACwAAAAsAAAA
AAAAAAEAAAD/////////////////////EwEAAC0AAAAsAQAAQQAAAMoAAAAAAAAA0AAAAHAEAACA
BAAAAAAAABMAAACABAAAAAAAABUAAABGBQQAAwAAAEljb24AAAAAAAAAABAAAAAOAhEAU1RCU2lu
Z2xldG9uUHJveHkAAAAAmgAAAAAAAABSAAAABwAAAERvbHBoaW5SAAAAGAAAAEltYWdlUmVsYXRp
dmVGaWxlTG9jYXRvcroAAAAAAAAAUgAAAAcAAABjdXJyZW50UgAAAA0AAABTaGVsbFZpZXcuaWNv
DgIfAFNUQkV4dGVybmFsUmVzb3VyY2VMaWJyYXJ5UHJveHkAAAAAUgAAABAAAABkb2xwaGluZHIw
MDUuZGxsAAAAAA=='))!

(ResourceIdentifier class: HRMtgDashboardPresenter name: 'Combined Limited view') assign: (Object fromBinaryStoreBytes:
(ByteArray fromBase64String: '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
cmVhdGVBdDpleHRlbnQ6YgAAAAIAAAAGAgUAUG9pbnQAAAAAAQAAAMsAAAByCAAAAAAAAA0DAAAV
AwAAgAMAACIIAAAAAAAAugAAAAAAAABSAAAADAAAAGNvbnRleHRNZW51OmIAAAABAAAA8AMAAIAD
AAAiCAAAAAAAALoAAAAAAAAAUgAAAAUAAAB0ZXh0OmIAAAABAAAABgEIAFJpY2hUZXh0AAAAAFIA
AAB4AAAAe1xydGYxXGFuc2lcYW5zaWNwZzEyNTJcZGVmZjBcZGVmbGFuZzIwNTd7XGZvbnR0Ymx7
XGYwXGZyb21hbiBUaW1lcyBOZXcgUm9tYW47fX0NClx2aWV3a2luZDRcdWMxXHBhcmRcZjBcZnMy
MiANClxwYXIgfQ0KgAMAACIIAAAAAAAAugAAAAAAAABSAAAADwAAAHNlbGVjdGlvblJhbmdlOmIA
AAABAAAABgMIAEludGVydmFsAAAAAAMAAAABAAAAAwAAAIADAAAiCAAAAAAAALoAAAAAAAAAUgAA
AA8AAABpc1RleHRNb2RpZmllZDpiAAAAAQAAACAAAACAAwAAIggAAAAAAAC6AAAAAAAAAFIAAAAP
AAAAcmVzZXRDaGFyRm9ybWF0YgAAAAAAAACAAwAABgEPAFdJTkRPV1BMQUNFTUVOVAAAAAByAAAA
LAAAACwAAAAAAAAAAQAAAP////////////////////8AAAAAZQAAAIYBAADvAQAAygAAAAAAAADQ
AAAAYgAAAAAAAAByCAAAAAAAAMEAAADBAAAAAAAAABMAAAAJAAAAEAAAAOoAAAAAAAAAAAEAAGIA
AAAEAAAAgAMAAFIAAAANAAAAbGluZXNXaXRoRXN0c5oBAAAAAAAAmgAAAAAAAABSAAAAFwAAAERv
bHBoaW4gQ29tbW9uIENvbnRyb2xzUgAAAAgAAABMaXN0Vmlld2IAAAAeAAAAAAAAABADAABiAAAA
AgAAAIIAAAAEAAAATRABRAEEAADACgAARgMJAAIAAABMaXN0TW9kZWwAAAAAygAAAAAAAADQAAAA
cAoAAAAAAAAOAhEAU1RCU2luZ2xldG9uUHJveHkAAAAAmgAAAAAAAABSAAAABwAAAERvbHBoaW5S
AAAADAAAAFNlYXJjaFBvbGljeboAAAAAAAAAUgAAAAgAAABpZGVudGl0eQAAAAAAAAAABwAAAAAA
AAAAAAAAAAAAAMAKAAAAAAAAggAAAAgAAACfBP//AAAAAJoAAAAAAAAAwAEAAFIAAAARAAAAQmFz
aWNMaXN0QWJzdHJhY3QAAAAAagsAAAAAAACaAAAAAAAAAMABAABSAAAAEAAAAEljb25JbWFnZU1h
bmFnZXK6AAAAAAAAAFIAAAAHAAAAY3VycmVudAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMoAAAAA
AAAA0AAAAGIAAAAFAAAARgwOAAUAAABMaXN0Vmlld0NvbHVtbgAAAABSAAAACwAAAERlc2NyaXB0
aW9uawEAALoAAAAAAAAAUgAAAAQAAABsZWZ04AsAAJoAAAAAAAAAkAsAAFIAAAAQAAAAU29ydGVk
Q29sbGVjdGlvbgYCBwBNZXNzYWdlAAAAALoAAAAAAAAAUgAAAAUAAABkZXNjcmIAAAAAAAAAAAAA
AMAKAAAAAAAAAwAAAAAAAAAAAAAAcgwAAAAAAABSAAAABQAAAExpbmVzUQAAALoAAAAAAAAAUgAA
AAYAAABjZW50ZXLgCwAAwAwAAOIMAAAAAAAAugAAAAAAAABSAAAABQAAAGxpbmVzIA0AAAAAAADA
CgAAAAAAAAEAAAAAAAAAAAAAAHIMAAAAAAAAUgAAAAQAAABEaXZpbwAAALoAAAAAAAAAUgAAAAUA
AAByaWdodOALAADADAAA4gwAAAAAAAC6AAAAAAAAAFIAAAAEAAAAZGl2aSANAAAAAAAAwAoAAAAA
AAABAAAAAAAAAAAAAAByDAAAAAAAAFIAAAAGAAAAUmV0dXJubwAAAMANAADgCwAAwAwAAOIMAAAA
AAAAugAAAAAAAABSAAAABgAAAHJldHVybiANAAAAAAAAwAoAAAAAAAABAAAAAAAAAAAAAAByDAAA
AAAAAFIAAAAGAAAAUHJvZml0bwAAAMANAADgCwAAwAwAAOIMAAAAAAAAugAAAAAAAABSAAAABgAA
AHByb2ZpdCANAAAAAAAAwAoAAAAAAAABAAAAAAAAAAAAAAC6AAAAAAAAAFIAAAAGAAAAcmVwb3J0
YgAAAAAAAAAAAAAAYQAAAAAAAAAAAAAA4gcAAAAAAADKAAAAAAAAANAAAABiAAAAAgAAACIIAAAA
AAAAQAgAAGIAAAACAAAAcggAAAAAAAABAAAAAQAAAHIIAAAAAAAADQMAAMUAAADACgAAIggAAAAA
AADwCAAAYgAAAAEAAABSAAAACwAAAERlc2NyaXB0aW9uwAoAADIKAAAAAAAAcgAAACwAAAAsAAAA
AAAAAAEAAAD/////////////////////AAAAAAAAAACGAQAAYgAAAMoAAAAAAAAA0AAAAHAKAACA
CgAAAAAAABcAAABSAAAABAAAAGVzdHMAAAAA4gcAAAAAAADKAAAAAAAAANAAAABiAAAAAQAAACII
AAAAAAAAQAgAAGIAAAACAAAAcggAAAAAAAABAAAA4QEAAHIIAAAAAAAADQMAAN8DAAAQAwAAMgoA
AAAAAAByAAAALAAAACwAAAAAAAAAAQAAAP////////////////////8AAAAA8AAAAIYBAADfAgAA
ygAAAAAAAADQAAAAYgAAAAMAAADACgAAmgEAAAAAAACaAAAAAAAAAMABAABSAAAACAAAAFNwbGl0
dGVyYgAAAAwAAAAAAAAAEAMAAGIAAAACAAAAggAAAAQAAAAAAABEAQAAAHAQAAAAAAAAAAAAAAAA
AAAHAgAAAAAAAAAAAAAAAAAAcBAAAOIHAAAAAAAAygAAAAAAAADQAAAAYgAAAAEAAAAiCAAAAAAA
AEAIAABiAAAAAgAAAHIIAAAAAAAAAQAAAMUAAAByCAAAAAAAAA0DAAAHAAAAcBAAADIKAAAAAAAA
cgAAACwAAAAsAAAAAAAAAAEAAAD/////////////////////AAAAAGIAAACGAQAAZQAAAMoAAAAA
AAAA0AAAAHAKAACACgAAAAAAABMAAACAAwAAgAoAAAAAAAATAAAARggSAAEAAABGcmFtaW5nQ29u
c3RyYWludHMAAAAAugAAAAAAAABSAAAADwAAAGZpeGVkUGFyZW50TGVmdAEAAAC6AAAAAAAAAFIA
AAAQAAAAZml4ZWRQYXJlbnRSaWdodP3///+6AAAAAAAAAFIAAAAOAAAAZml4ZWRQYXJlbnRUb3Dh
AQAAugAAAAAAAABSAAAAEQAAAGZpeGVkUGFyZW50Qm90dG9t/////5oBAAAAAAAAmgAAAAAAAADA
AQAAUgAAAAgAAABUZXh0RWRpdGIAAAAQAAAAAAAAAGACAABiAAAAAgAAAIIAAAAEAAAAgAAARAEE
AAAQEgAAAAAAAAAAAAAAAAAABwAAAAAAAAAAAAAAAAAAABASAAAAAAAAggAAAAgAAACPBf//AAAA
AJIHAAAAAAAAAAAAAAAAAAADAAAA4gcAAAAAAADKAAAAAAAAANAAAABiAAAAAwAAACIIAAAAAAAA
QAgAAGIAAAACAAAAcggAAAAAAAAxAgAAFQAAAHIIAAAAAAAA0wAAACkAAAAQEgAAIggAAAAAAABg
CQAAYgAAAAEAAACSCQAAAAAAAAMAAAABAAAAAwAAABASAAAiCAAAAAAAAMAJAABiAAAAAQAAACAA
AAAQEgAAMgoAAAAAAAByAAAALAAAACwAAAAAAAAAAQAAAP////////////////////8YAQAACgAA
AIEBAAAeAAAAygAAAAAAAADQAAAAcAoAAIAKAAAAAAAAEwAAAHIRAAAAAAAAugAAAAAAAABSAAAA
DgAAAGZpeGVkVmlld1JpZ2h0L////7ARAADz////0BEAABUAAAC6AAAAAAAAAFIAAAAMAAAAZml4
ZWRWaWV3VG9wKQAAAJoBAAAAAAAAmgAAAAAAAADAAQAAUgAAAAoAAABTdGF0aWNUZXh0YgAAABAA
AAAAAAAAYAIAAGIAAAACAAAAggAAAAQAAAAAAQBEAQAAANATAAAAAAAAAAAAAAAAAAAHAAAAAAAA
AAAAAAAAAAAA0BMAAAAAAACCAAAACAAAAFkF//8AAAAAkgcAAAAAAAAAAAAAAAAAAAAAAADiBwAA
AAAAAMoAAAAAAAAA0AAAAGIAAAACAAAAIggAAAAAAABACAAAYgAAAAIAAAByCAAAAAAAANcBAABR
AAAAcggAAAAAAABRAAAAHwAAANATAAAiCAAAAAAAAPAIAABiAAAAAQAAAFIAAAAGAAAATGluZXM6
0BMAADIKAAAAAAAAcgAAACwAAAAsAAAAAAAAAAEAAAD/////////////////////6wAAACgAAAAT
AQAANwAAAMoAAAAAAAAA0AAAAHAKAACACgAAAAAAABMAAAByEQAAAAAAALARAADH/v//ugAAAAAA
AABSAAAADQAAAGZpeGVkVmlld0xlZnRRAAAA0BEAAFEAAACwEwAAHwAAAJoBAAAAAAAAIBIAAGIA
AAAQAAAAAAAAAGACAABiAAAAAgAAAIIAAAAEAAAAAAAARAEEAABQFQAAAAAAAAAAAAAAAAAABwAA
AAAAAAAAAAAAAAAAAFAVAAAAAAAAggAAAAgAAACPBf//AAAAAAYDDABOdW1iZXJUb1RleHQAAAAA
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
AAAA8AgAAGIAAAABAAAAUgAAAAcAAABSZWZyZXNoICcAADIKAAAAAAAAcgAAACwAAAAsAAAAAAAA
AAEAAAD/////////////////////6wAAAMgAAACBAQAA5gAAAMoAAAAAAAAA0AAAAHAKAACACgAA
AAAAABMAAAByEQAAAAAAAJATAADV/v//sBEAAPP////QEQAAkQEAALATAAA9AAAAmgEAAAAAAADg
EwAAYgAAABAAAAAAAAAAYAIAAGIAAAACAAAAggAAAAQAAAAAAQBEAQAAALAoAAAAAAAAAAAAAAAA
AAAHAAAAAAAAAAAAAAAAAAAAsCgAAAAAAACCAAAACAAAAFkF//8AAAAAkgcAAAAAAAAAAAAAAAAA
AAAAAADiBwAAAAAAAMoAAAAAAAAA0AAAAGIAAAACAAAAIggAAAAAAABACAAAYgAAAAIAAAByCAAA
AAAAANcBAADnAAAAcggAAAAAAABbAAAAHwAAALAoAAAiCAAAAAAAAPAIAABiAAAAAQAAAFIAAAAH
AAAAUmV0dXJuOrAoAAAyCgAAAAAAAHIAAAAsAAAALAAAAAAAAAABAAAA////////////////////
/+sAAABzAAAAGAEAAIIAAADKAAAAAAAAANAAAABwCgAAgAoAAAAAAAATAAAAchEAAAAAAACwEQAA
x/7//zAVAABbAAAA0BEAAOcAAACwEwAAHwAAAJoBAAAAAAAA4BMAAGIAAAAQAAAAAAAAAGACAABi
AAAAAgAAAIIAAAAEAAAAAAEARAEAAADwKQAAAAAAAAAAAAAAAAAABwAAAAAAAAAAAAAAAAAAAPAp
AAAAAAAAggAAAAgAAABZBf//AAAAAJIHAAAAAAAAAAAAAAAAAAAAAAAA4gcAAAAAAADKAAAAAAAA
ANAAAABiAAAAAgAAACIIAAAAAAAAQAgAAGIAAAACAAAAcggAAAAAAADXAQAAgwAAAHIIAAAAAAAA
UQAAAB8AAADwKQAAIggAAAAAAADwCAAAYgAAAAEAAABSAAAABgAAAFN0YWtlOvApAAAyCgAAAAAA
AHIAAAAsAAAALAAAAAAAAAABAAAA/////////////////////+sAAABBAAAAEwEAAFAAAADKAAAA
AAAAANAAAABwCgAAgAoAAAAAAAATAAAAchEAAAAAAACwEQAAx/7//zAVAABRAAAA0BEAAIMAAACw
EwAAHwAAAJoBAAAAAAAAIBIAAGIAAAAQAAAAAAAAAGACAABiAAAAAgAAAIIAAAAEAAAAAAABRAEE
AAAwKwAAAAAAAAAAAAAAAAAABwAAAAAAAAAAAAAAAAAAADArAAAAAAAAggAAAAgAAACPBf//AAAA
AKIVAAAAAAAAAAAAAFIAAAAAAAAAAAAAAAEAAADiBwAAAAAAAMoAAAAAAAAA0AAAAGIAAAADAAAA
IggAAAAAAABACAAAYgAAAAIAAAByCAAAAAAAADECAAB5AAAAcggAAAAAAABlAAAAKQAAADArAAAi
CAAAAAAAAGAJAABiAAAAAQAAAJIJAAAAAAAAAwAAAAEAAAADAAAAMCsAACIIAAAAAAAAwAkAAGIA
AAABAAAAIAAAADArAAAyCgAAAAAAAHIAAAAsAAAALAAAAAAAAAABAAAA////////////////////
/xgBAAA8AAAASgEAAFAAAADKAAAAAAAAANAAAABwCgAAgAoAAAAAAAATAAAAchEAAAAAAACQEwAA
nf///7ARAACF////0BEAAHkAAACwEwAAKQAAAJoBAAAAAAAAIBIAAGIAAAAQAAAAAAAAAGACAABi
AAAAAgAAAIIAAAAEAAAAAAAARAEEAACgLAAAAAAAAAAAAAAAAAAABwAAAAAAAAAAAAAAAAAAAKAs
AAAAAAAAggAAAAgAAACPBf//AAAAAKIVAAAAAAAAAAAAAFIAAAAAAAAAAAAAAAMAAADiBwAAAAAA
AMoAAAAAAAAA0AAAAGIAAAADAAAAIggAAAAAAABACAAAYgAAAAIAAAByCAAAAAAAAJ8CAAB5AAAA
cggAAAAAAABlAAAAKQAAAKAsAAAiCAAAAAAAAGAJAABiAAAAAQAAAJIJAAAAAAAAAwAAAAEAAAAD
AAAAoCwAACIIAAAAAAAAwAkAAGIAAAABAAAAIAAAAKAsAAAyCgAAAAAAAHIAAAAsAAAALAAAAAAA
AAABAAAA/////////////////////08BAAA8AAAAgQEAAFAAAADKAAAAAAAAANAAAABwCgAAgAoA
AAAAAAATAAAAchEAAAAAAACQEwAAnf///7ARAADz////0BEAAHkAAACwEwAAKQAAAOoAAAAAAAAA
AAEAAGIAAAAWAAAAgBoAAFIAAAAGAAAAcHJvZml0wB0AAFIAAAAFAAAAbGluZXPwGwAAUgAAAAkA
AAB0b2dnbGVFc3TQFgAAUgAAAAoAAAB0b3RhbExpbmVzUBUAAFIAAAAGAAAAcGF5T3V0MCsAAFIA
AAAJAAAAdW5pdFN0YWtlcCQAAFIAAAAEAAAAZGl2aRADAABSAAAADAAAAGxpbmVzQW5kRXN0c6As
AABSAAAACgAAAHRvdGFsU3Rha2UwGAAAUgAAAAUAAABncmFwaBASAABSAAAAAwAAAHBvdAAAAADi
BwAAAAAAAMoAAAAAAAAA0AAAAGIAAAABAAAAIggAAAAAAABACAAAYgAAAAIAAAByCAAAAAAAAAEA
AAABAAAAcggAAAAAAAARAwAAwQUAAGACAAAyCgAAAAAAAHIAAAAsAAAALAAAAAAAAAABAAAA////
/////////////////wAAAAAAAAAAiAEAAOACAADKAAAAAAAAANAAAABiAAAAEgAAADAYAAAgJwAA
0BYAABASAADQEwAAMCMAAPApAAAwKwAAoCwAAPAhAACwKAAA4CUAAHAkAABQFQAAgBoAAPAbAADA
HQAAEAMAAIAKAAAAAAAAEwAAABUAAAAQAAAA6gAAAAAAAAAAAQAAcAoAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAADiBwAAAAAAAMoAAAAAAAAA0AAA
AGIAAAACAAAAIggAAAAAAABACAAAYgAAAAIAAAByCAAAAAAAAAsAAAALAAAAcggAAAAAAAAhAwAA
BQYAAKABAAAiCAAAAAAAALoAAAAAAAAAUgAAAAgAAABtZW51QmFyOmIAAAABAAAAAAAAAKABAAAy
CgAAAAAAAHIAAAAsAAAALAAAAAAAAAAAAAAA/////////////////////wUAAAAFAAAAlQEAAAcD
AADKAAAAAAAAANAAAABiAAAAAQAAAGACAACACgAAAAAAABUAAABGBQQAAwAAAEljb24AAAAAAAAA
ABAAAAAOAhEAU1RCU2luZ2xldG9uUHJveHkAAAAAmgAAAAAAAABSAAAABwAAAERvbHBoaW5SAAAA
GAAAAEltYWdlUmVsYXRpdmVGaWxlTG9jYXRvcroAAAAAAAAAUgAAAAcAAABjdXJyZW50UgAAAA0A
AABTaGVsbFZpZXcuaWNvDgIfAFNUQkV4dGVybmFsUmVzb3VyY2VMaWJyYXJ5UHJveHkAAAAAUgAA
ABAAAABkb2xwaGluZHIwMDUuZGxsAAAAAA=='))!

(ResourceIdentifier class: HRMtgDashboardPresenter name: 'Combined view') assign: (Object fromBinaryStoreBytes:
(ByteArray fromBase64String: 'IVNUQiAxIEYCDAABAAAAVmlld1Jlc291cmNlAAAAAA4BJABTVEJSZXNvdXJjZVNUQkJ5dGVBcnJh
eUFjY2Vzc29yUHJveHkAAAAAcgAAAJQ3AAAhU1RCIDEgTggMAAoAAABTVEJWaWV3UHJveHkAAAAA
mgAAAAAAAABSAAAAEAAAAERvbHBoaW4gTVZQIEJhc2VSAAAACQAAAFNoZWxsVmlld2IAAAAbAAAA
AAAAAAAAAABiAAAAAgAAAAEAngEBAAIAoAEAAAAAAAAGAQsAU3lzdGVtQ29sb3IAAAAAHwAAAAAA
AAAHAAAAAAAAAAAAAAAAAAAAoAEAAAYCEgBQcm9wb3J0aW9uYWxMYXlvdXQAAAAA6gAAAAAAAADw
AAAAYgAAAAIAAACaAQAAAAAAAJoAAAAAAAAAwAEAAFIAAAANAAAAQ29udGFpbmVyVmlld2IAAAAP
AAAAAAAAAKABAABiAAAAAgAAAIIAAAAEAAAAAAAARAEAAgBgAgAAAAAAAAICAAAAAAAAHwAAAAAA
AAAHAAAAAAAAAAAAAAAAAAAAYAIAAAYBDQBGcmFtaW5nTGF5b3V0AAAAAOoAAAAAAAAA8AAAAGIA
AAAoAAAAmgEAAAAAAACaAAAAAAAAAMABAABSAAAACgAAAFN0YXRpY1RleHRiAAAAEAAAAAAAAABg
AgAAYgAAAAIAAACCAAAABAAAAAABAEQBAAAAEAMAAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAAAAAA
AAAQAwAAAAAAAIIAAAAIAAAAWQX//wAAAAAGAg0ATnVsbENvbnZlcnRlcgAAAAAAAAAAAAAAAAAA
AAAGAQ8ATWVzc2FnZVNlcXVlbmNlAAAAAMoAAAAAAAAA0AAAAGIAAAACAAAABgMLAE1lc3NhZ2VT
ZW5kAAAAALoAAAAAAAAAUgAAABAAAABjcmVhdGVBdDpleHRlbnQ6YgAAAAIAAAAGAgUAUG9pbnQA
AAAA1wEAAFEAAAAyBAAAAAAAAG8AAAAfAAAAEAMAAOIDAAAAAAAAugAAAAAAAABSAAAABQAAAHRl
eHQ6YgAAAAEAAABSAAAACgAAAEN1bS4gb2RkczoQAwAABgEPAFdJTkRPV1BMQUNFTUVOVAAAAABy
AAAALAAAACwAAAAAAAAAAQAAAP/////////////////////rAAAAKAAAACIBAAA3AAAAygAAAAAA
AADQAAAAYgAAAAAAAAAyBAAAAAAAAMEAAADBAAAAAAAAABMAAABGCBIAAQAAAEZyYW1pbmdDb25z
dHJhaW50cwAAAAC6AAAAAAAAAFIAAAAQAAAAZml4ZWRQYXJlbnRSaWdodMf+//+6AAAAAAAAAFIA
AAANAAAAZml4ZWRWaWV3TGVmdG8AAAC6AAAAAAAAAFIAAAAOAAAAZml4ZWRQYXJlbnRUb3BRAAAA
ugAAAAAAAABSAAAADAAAAGZpeGVkVmlld1RvcB8AAACaAQAAAAAAAJoAAAAAAAAAwAEAAFIAAAAI
AAAAVGV4dEVkaXRiAAAAEAAAAAAAAABgAgAAYgAAAAIAAACCAAAABAAAAIAAAEQBBAAAsAUAAAAA
AAAAAAAAAAAAAAcAAAAAAAAAAAAAAAAAAACwBQAAAAAAAIIAAAAIAAAAjwX//wAAAACCAwAAAAAA
AAAAAAAAAAAAAwAAAKIDAAAAAAAAygAAAAAAAADQAAAAYgAAAAMAAADiAwAAAAAAAAAEAABiAAAA
AgAAADIEAAAAAAAAbQIAAHkAAAAyBAAAAAAAAJcAAAApAAAAsAUAAOIDAAAAAAAAugAAAAAAAABS
AAAADwAAAHNlbGVjdGlvblJhbmdlOmIAAAABAAAABgMIAEludGVydmFsAAAAAAMAAAABAAAAAwAA
ALAFAADiAwAAAAAAALoAAAAAAAAAUgAAAA8AAABpc1RleHRNb2RpZmllZDpiAAAAAQAAACAAAACw
BQAAsgQAAAAAAAByAAAALAAAACwAAAAAAAAAAQAAAP////////////////////82AQAAPAAAAIEB
AABQAAAAygAAAAAAAADQAAAA8AQAAAAFAAAAAAAAEwAAABIFAAAAAAAAugAAAAAAAABSAAAADgAA
AGZpeGVkVmlld1JpZ2h0a////zAFAADz////cAUAAHkAAACQBQAAKQAAAJoBAAAAAAAAIAMAAGIA
AAAQAAAAAAAAAGACAABiAAAAAgAAAIIAAAAEAAAAAAEARAEAAACgBwAAAAAAAAAAAAAAAAAABwAA
AAAAAAAAAAAAAAAAAKAHAAAAAAAAggAAAAgAAABZBf//AAAAAIIDAAAAAAAAAAAAAAAAAAAAAAAA
ogMAAAAAAADKAAAAAAAAANAAAABiAAAAAgAAAOIDAAAAAAAAAAQAAGIAAAACAAAAMgQAAAAAAADX
AQAASwEAADIEAAAAAAAAbwAAAB8AAACgBwAA4gMAAAAAAABwBAAAYgAAAAEAAABSAAAABwAAAFBy
b2ZpdDqgBwAAsgQAAAAAAAByAAAALAAAACwAAAAAAAAAAQAAAP/////////////////////rAAAA
pQAAACIBAAC0AAAAygAAAAAAAADQAAAA8AQAAAAFAAAAAAAAEwAAABIFAAAAAAAAMAUAAMf+//9Q
BQAAbwAAAHAFAABLAQAAkAUAAB8AAACaAQAAAAAAAMAFAABiAAAAEAAAAAAAAABgAgAAYgAAAAIA
AACCAAAABAAAAAAAAUQBBAAA4AgAAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAAAAAAAADgCAAAAAAA
AIIAAAAIAAAAjwX//wAAAAAGAwwATnVtYmVyVG9UZXh0AAAAAAAAAABSAAAAAAAAAAAAAAABAAAA
ogMAAAAAAADKAAAAAAAAANAAAABiAAAAAwAAAOIDAAAAAAAAAAQAAGIAAAACAAAAMgQAAAAAAAAx
AgAAqwAAADIEAAAAAAAAZQAAACkAAADgCAAA4gMAAAAAAACwBgAAYgAAAAEAAADiBgAAAAAAAAMA
AAABAAAAAwAAAOAIAADiAwAAAAAAABAHAABiAAAAAQAAACAAAADgCAAAsgQAAAAAAAByAAAALAAA
ACwAAAAAAAAAAQAAAP////////////////////8YAQAAVQAAAEoBAABpAAAAygAAAAAAAADQAAAA
8AQAAAAFAAAAAAAAEwAAABIFAAAAAAAAgAcAAJ3///8wBQAAhf///3AFAACrAAAAkAUAACkAAACa
AQAAAAAAAMAFAABiAAAAEAAAAAAAAABgAgAAYgAAAAIAAACCAAAABAAAAAAAAEQBBAAAYAoAAAAA
AAAAAAAAAAAAAAcAAAAAAAAAAAAAAAAAAABgCgAAAAAAAIIAAAAIAAAAjwX//wAAAAAyCQAAAAAA
AAAAAABSAAAAAAAAAAAAAAADAAAAogMAAAAAAADKAAAAAAAAANAAAABiAAAAAwAAAOIDAAAAAAAA
AAQAAGIAAAACAAAAMgQAAAAAAABtAgAADwEAADIEAAAAAAAAlwAAACkAAABgCgAA4gMAAAAAAACw
BgAAYgAAAAEAAADiBgAAAAAAAAMAAAABAAAAAwAAAGAKAADiAwAAAAAAABAHAABiAAAAAQAAACAA
AABgCgAAsgQAAAAAAAByAAAALAAAACwAAAAAAAAAAQAAAP////////////////////82AQAAhwAA
AIEBAACbAAAAygAAAAAAAADQAAAA8AQAAAAFAAAAAAAAEwAAABIFAAAAAAAAgAcAAGv///8wBQAA
8////3AFAAAPAQAAkAUAACkAAACaAQAAAAAAAJoAAAAAAAAAUgAAABAAAABIb3JzZVJhY2VCZXR0
aW5nUgAAAA8AAABIUkxpbmVHcmFwaFZpZXdiAAAAFQAAAAAAAABgAgAAYgAAAAIAAACCAAAABAAA
AAAAAEQBAAQA0AsAAGIAAAADAAAAygAAAAAAAADQAAAA8AQAAMoAAAAAAAAA0AAAAPAEAAADAAAA
AAAAAAAAAAAHAAAAAAAAAAAAAAAAAAAA0AsAAAYIBgBDYW52YXMAAAAAAAAAAAAAAAAgAAAABgMD
AFBlbgAAAAAAAAAAEAAAAAYBBgBMT0dQRU4AAAAAcgAAABAAAAAAAAAAAgAAAAAAAAAOAAABAAAA
AAYEBABGb250AAAAAAAAAAAQAAAABgEHAExPR0ZPTlQAAAAAcgAAADwAAAD1////AAAAAAAAAAAA
AAAAkAEAAAAAAAAAAAAAQXJpYWwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAyBAAAAAAAAMEA
AADBAAAAAAAAAAAAAAAyBAAAAAAAAD0AAADDAQAAPQAAAD0AAACHAQAASwEAAD0AAACHAQAABgII
AEZyYWN0aW9uAAAAAG8AAAAFAAAAogMAAAAAAADKAAAAAAAAANAAAABiAAAAAQAAAOIDAAAAAAAA
AAQAAGIAAAACAAAAMgQAAAAAAAABAAAAAQAAADIEAAAAAAAAwwEAAP8BAADQCwAAsgQAAAAAAABy
AAAALAAAACwAAAAAAAAAAQAAAP////////////////////8AAAAAAAAAAOEAAAD/AAAAygAAAAAA
AADQAAAA8AQAAAAFAAAAAAAAEwAAABIFAAAAAAAAugAAAAAAAABSAAAADwAAAGZpeGVkUGFyZW50
TGVmdAEAAAAwBQAAs/7//3AFAAABAAAAcAUAAP8BAACaAQAAAAAAAHACAABiAAAADwAAAAAAAABg
AgAAYgAAAAIAAACCAAAABAAAAAAAAEQBAAIAQA4AAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAAAAAA
AABADgAAIgIAAAAAAADqAAAAAAAAAPAAAABiAAAAAgAAAJoBAAAAAAAAmgAAAAAAAADAAQAAUgAA
AAwAAABSaWNoVGV4dEVkaXRiAAAAEgAAAAAAAABADgAAYgAAAAIAAACCAAAABAAAAMQRMUQBBAAA
sA4AAAAAAAAAAAAAAAAAAAcAAABGBQQAAgAAAE1lbnUAAAAAAAAAABAAAABiAAAACgAAAEYEDwAC
AAAAQ29tbWFuZE1lbnVJdGVtAAAAAAEAAABGBRIABAAAAENvbW1hbmREZXNjcmlwdGlvbgAAAAC6
AAAAAAAAAFIAAAATAAAAY2hvb3NlU2VsZWN0aW9uRm9udFIAAAAIAAAAJkZvbnQuLi4BAAAAAQAA
AAAAAAAAAAAAAAAAAEYBDwABAAAARGl2aWRlck1lbnVJdGVtAAAAAAEQAABCDwAAAAAAAAEAAABi
DwAAAAAAALoAAAAAAAAAUgAAAAcAAABiZVBsYWluUgAAAAYAAAAmUGxhaW4BAAAAAQAAAAAAAAAA
AAAAAAAAAEIPAAAAAAAAAQAAAGIPAAAAAAAAugAAAAAAAABSAAAACgAAAHRvZ2dsZUJvbGRSAAAA
BQAAACZCb2xkAQAAAAEAAAAAAAAAAAAAAAAAAABCDwAAAAAAAAEAAABiDwAAAAAAALoAAAAAAAAA
UgAAAAwAAAB0b2dnbGVJdGFsaWNSAAAABwAAACZJdGFsaWMBAAAAAQAAAAAAAAAAAAAAAAAAAEIP
AAAAAAAAAQAAAGIPAAAAAAAAugAAAAAAAABSAAAAEAAAAHRvZ2dsZVVuZGVybGluZWRSAAAACwAA
ACZVbmRlcmxpbmVkAQAAAAEAAAAAAAAAAAAAAAAAAACyDwAAAAAAAAEQAAASDwAAAAAAAAAAAAAQ
AAAAYgAAAAMAAABCDwAAAAAAAAEEAABiDwAAAAAAALoAAAAAAAAAUgAAABIAAABhbGlnblBhcmFn
cmFwaExlZnRSAAAABQAAACZMZWZ0AQAAAAEAAAAAAAAAAAAAAAAAAABCDwAAAAAAAAEEAABiDwAA
AAAAALoAAAAAAAAAUgAAABQAAABhbGlnblBhcmFncmFwaENlbnRlclIAAAAHAAAAJkNlbnRyZQEA
AAABAAAAAAAAAAAAAAAAAAAAQg8AAAAAAAABBAAAYg8AAAAAAAC6AAAAAAAAAFIAAAATAAAAYWxp
Z25QYXJhZ3JhcGhSaWdodFIAAAAGAAAAJlJpZ2h0AQAAAAEAAAAAAAAAAAAAAAAAAABSAAAABgAA
ACZBbGlnbgAAAACyDwAAAAAAAAEQAABCDwAAAAAAAAEAAABiDwAAAAAAALoAAAAAAAAAUgAAABQA
AABjaG9vc2VTZWxlY3Rpb25Db2xvclIAAAAKAAAAJkNvbG91ci4uLgEAAAABAAAAAAAAAAAAAAAA
AAAAUgAAAAAAAAAAAAAAAAAAAAAAAACwDgAAAAAAAIIAAAAEAAAAAdvmdIIDAAAAAAAAAAAAAAAA
AAAJAAAAAAAAAAYBCgBFRElUU1RSRUFNAAAAAHIAAAAMAAAAAAAAAAAAAAA8Z9ULogMAAAAAAADK
AAAAAAAAANAAAABiAAAABgAAAOIDAAAAAAAAAAQAAGIAAAACAAAAMgQAAAAAAAABAAAAwwAAADIE
AAAAAAAADQMAAPUCAACwDgAA4gMAAAAAAAC6AAAAAAAAAFIAAAAMAAAAY29udGV4dE1lbnU6YgAA
AAEAAAAgDwAAsA4AAOIDAAAAAAAAcAQAAGIAAAABAAAABgEIAFJpY2hUZXh0AAAAAFIAAAB4AAAA
e1xydGYxXGFuc2lcYW5zaWNwZzEyNTJcZGVmZjBcZGVmbGFuZzIwNTd7XGZvbnR0Ymx7XGYwXGZy
b21hbiBUaW1lcyBOZXcgUm9tYW47fX0NClx2aWV3a2luZDRcdWMxXHBhcmRcZjBcZnMyMiANClxw
YXIgfQ0KsA4AAOIDAAAAAAAAsAYAAGIAAAABAAAA4gYAAAAAAAADAAAAAQAAAAMAAACwDgAA4gMA
AAAAAAAQBwAAYgAAAAEAAAAgAAAAsA4AAOIDAAAAAAAAugAAAAAAAABSAAAADwAAAHJlc2V0Q2hh
ckZvcm1hdGIAAAAAAAAAsA4AALIEAAAAAAAAcgAAACwAAAAsAAAAAAAAAAEAAAD/////////////
////////AAAAAGEAAACGAQAA2wEAAMoAAAAAAAAA0AAAAPAEAAAABQAAAAAAABMAAAAJAAAAEAAA
AOoAAAAAAAAAAAEAAGIAAAAEAAAAsA4AAFIAAAANAAAAbGluZXNXaXRoRXN0c5oBAAAAAAAAmgAA
AAAAAABSAAAAFwAAAERvbHBoaW4gQ29tbW9uIENvbnRyb2xzUgAAAAgAAABMaXN0Vmlld2IAAAAe
AAAAAAAAAEAOAABiAAAAAgAAAIIAAAAEAAAATRABRAEEAADwFAAARgMJAAIAAABMaXN0TW9kZWwA
AAAAygAAAAAAAADQAAAA8AQAAAAAAAAOAhEAU1RCU2luZ2xldG9uUHJveHkAAAAAmgAAAAAAAABS
AAAABwAAAERvbHBoaW5SAAAADAAAAFNlYXJjaFBvbGljeboAAAAAAAAAUgAAAAgAAABpZGVudGl0
eQAAAAAAAAAABwAAAAAAAAAAAAAAAAAAAPAUAAAAAAAAggAAAAgAAACfBP//AAAAAJoAAAAAAAAA
wAEAAFIAAAARAAAAQmFzaWNMaXN0QWJzdHJhY3QAAAAAmhUAAAAAAACaAAAAAAAAAMABAABSAAAA
EAAAAEljb25JbWFnZU1hbmFnZXK6AAAAAAAAAFIAAAAHAAAAY3VycmVudAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAMoAAAAAAAAA0AAAAGIAAAAFAAAARgwOAAUAAABMaXN0Vmlld0NvbHVtbgAAAABS
AAAACwAAAERlc2NyaXB0aW9uawEAALoAAAAAAAAAUgAAAAQAAABsZWZ0EBYAAJoAAAAAAAAAwBUA
AFIAAAAQAAAAU29ydGVkQ29sbGVjdGlvbgYCBwBNZXNzYWdlAAAAALoAAAAAAAAAUgAAAAUAAABk
ZXNjcmIAAAAAAAAAAAAAAPAUAAAAAAAAAwAAAAAAAAAAAAAAohYAAAAAAABSAAAABQAAAExpbmVz
UQAAALoAAAAAAAAAUgAAAAYAAABjZW50ZXIQFgAA8BYAABIXAAAAAAAAugAAAAAAAABSAAAABQAA
AGxpbmVzUBcAAAAAAADwFAAAAAAAAAEAAAAAAAAAAAAAAKIWAAAAAAAAUgAAAAQAAABEaXZpbwAA
ALoAAAAAAAAAUgAAAAUAAAByaWdodBAWAADwFgAAEhcAAAAAAAC6AAAAAAAAAFIAAAAEAAAAZGl2
aVAXAAAAAAAA8BQAAAAAAAABAAAAAAAAAAAAAACiFgAAAAAAAFIAAAAGAAAAUmV0dXJubwAAAPAX
AAAQFgAA8BYAABIXAAAAAAAAugAAAAAAAABSAAAABgAAAHJldHVyblAXAAAAAAAA8BQAAAAAAAAB
AAAAAAAAAAAAAACiFgAAAAAAAFIAAAAGAAAAUHJvZml0bwAAAPAXAAAQFgAA8BYAABIXAAAAAAAA
ugAAAAAAAABSAAAABgAAAHByb2ZpdFAXAAAAAAAA8BQAAAAAAAABAAAAAAAAAAAAAAC6AAAAAAAA
AFIAAAAGAAAAcmVwb3J0YgAAAAAAAAAAAAAAYQAAAAAAAAAAAAAAogMAAAAAAADKAAAAAAAAANAA
AABiAAAAAgAAAOIDAAAAAAAAAAQAAGIAAAACAAAAMgQAAAAAAAABAAAAAQAAADIEAAAAAAAADQMA
AL0AAADwFAAA4gMAAAAAAABwBAAAYgAAAAEAAABSAAAACwAAAERlc2NyaXB0aW9u8BQAALIEAAAA
AAAAcgAAACwAAAAsAAAAAAAAAAEAAAD/////////////////////AAAAAAAAAACGAQAAXgAAAMoA
AAAAAAAA0AAAAPAEAAAABQAAAAAAABcAAABSAAAABAAAAGVzdHMAAAAAogMAAAAAAADKAAAAAAAA
ANAAAABiAAAAAQAAAOIDAAAAAAAAAAQAAGIAAAACAAAAMgQAAAAAAAABAAAACQIAADIEAAAAAAAA
DQMAALcDAABADgAAsgQAAAAAAAByAAAALAAAACwAAAAAAAAAAQAAAP////////////////////8A
AAAABAEAAIYBAADfAgAAygAAAAAAAADQAAAAYgAAAAMAAADwFAAAmgEAAAAAAACaAAAAAAAAAMAB
AABSAAAACAAAAFNwbGl0dGVyYgAAAAwAAAAAAAAAQA4AAGIAAAACAAAAggAAAAQAAAAAAABEAQAA
AKAaAAAAAAAAAAAAAAAAAAAHAgAAAAAAAAAAAAAAAAAAoBoAAKIDAAAAAAAAygAAAAAAAADQAAAA
YgAAAAEAAADiAwAAAAAAAAAEAABiAAAAAgAAADIEAAAAAAAAAQAAAL0AAAAyBAAAAAAAAA0DAAAH
AAAAoBoAALIEAAAAAAAAcgAAACwAAAAsAAAAAAAAAAEAAAD/////////////////////AAAAAF4A
AACGAQAAYQAAAMoAAAAAAAAA0AAAAPAEAAAABQAAAAAAABMAAACwDgAAAAUAAAAAAAATAAAAEgUA
AAAAAAAgDgAAAQAAADAFAAD9////cAUAAAkCAAC6AAAAAAAAAFIAAAARAAAAZml4ZWRQYXJlbnRC
b3R0b23/////mgEAAAAAAADABQAAYgAAABAAAAAAAAAAYAIAAGIAAAACAAAAggAAAAQAAAAAAABE
AQQAANAbAAAAAAAAAAAAAAAAAAAHAAAAAAAAAAAAAAAAAAAA0BsAAAAAAACCAAAACAAAAI8F//8A
AAAAMgkAAAAAAAAAAAAAUgAAAAAAAAAAAAAAAwAAAKIDAAAAAAAAygAAAAAAAADQAAAAYgAAAAMA
AADiAwAAAAAAAAAEAABiAAAAAgAAADIEAAAAAAAAbQIAAEEBAAAyBAAAAAAAAJcAAAApAAAA0BsA
AOIDAAAAAAAAsAYAAGIAAAABAAAA4gYAAAAAAAADAAAAAQAAAAMAAADQGwAA4gMAAAAAAAAQBwAA
YgAAAAEAAAAgAAAA0BsAALIEAAAAAAAAcgAAACwAAAAsAAAAAAAAAAEAAAD/////////////////
////NgEAAKAAAACBAQAAtAAAAMoAAAAAAAAA0AAAAPAEAAAABQAAAAAAABMAAAASBQAAAAAAAIAH
AABr////MAUAAPP///9wBQAAQQEAAJAFAAApAAAAmgEAAAAAAACaAAAAAAAAAMABAABSAAAACgAA
AFB1c2hCdXR0b25iAAAAEQAAAAAAAABgAgAAYgAAAAIAAACCAAAABAAAAAAgAUQBAAAAQB0AAAAA
AAAAAAAAAAAAAAcAAAAAAAAAAAAAAAAAAABAHQAAAAAAAIIAAAAIAAAAcQb//wAAAABiDwAAAAAA
ALoAAAAAAAAAUgAAAA4AAAB0b2dnbGVFc3RpbWF0ZVIAAAANAAAAU2hvdyBFc3RpbWF0ZQEAAAAB
AAAAAAAAAAAAAAABAAAAogMAAAAAAADKAAAAAAAAANAAAABiAAAAAwAAAOIDAAAAAAAAAAQAAGIA
AAACAAAAMgQAAAAAAADXAQAAfQEAADIEAAAAAAAALQEAAD0AAABAHQAA4gMAAAAAAAC6AAAAAAAA
AFIAAAAKAAAAaXNFbmFibGVkOmIAAAABAAAAIAAAAEAdAADiAwAAAAAAAHAEAABiAAAAAQAAAFIA
AAANAAAAU2hvdyBFc3RpbWF0ZUAdAACyBAAAAAAAAHIAAAAsAAAALAAAAAAAAAABAAAA////////
/////////////+sAAAC+AAAAgQEAANwAAADKAAAAAAAAANAAAADwBAAAAAUAAAAAAAATAAAAEgUA
AAAAAACABwAA1f7//zAFAADz////cAUAAH0BAACQBQAAPQAAAJoBAAAAAAAAIAMAAGIAAAAQAAAA
AAAAAGACAABiAAAAAgAAAIIAAAAEAAAAAAEARAEAAAAQHwAAAAAAAAAAAAAAAAAABwAAAAAAAAAA
AAAAAAAAABAfAAAAAAAAggAAAAgAAABZBf//AAAAAIIDAAAAAAAAAAAAAAAAAAAAAAAAogMAAAAA
AADKAAAAAAAAANAAAABiAAAAAgAAAOIDAAAAAAAAAAQAAGIAAAACAAAAMgQAAAAAAADXAQAAtQAA
ADIEAAAAAAAAUQAAAB8AAAAQHwAA4gMAAAAAAABwBAAAYgAAAAEAAABSAAAABgAAAFN0YWtlOhAf
AACyBAAAAAAAAHIAAAAsAAAALAAAAAAAAAABAAAA/////////////////////+sAAABaAAAAEwEA
AGkAAADKAAAAAAAAANAAAADwBAAAAAUAAAAAAAATAAAAEgUAAAAAAAAwBQAAx/7//1AFAABRAAAA
cAUAALUAAACQBQAAHwAAAJoBAAAAAAAAUB0AAGIAAAARAAAAAAAAAGACAABiAAAAAgAAAIIAAAAE
AAAAACABRAEAAABQIAAAAAAAAAAAAAAAAAAABwAAAAAAAAAAAAAAAAAAAFAgAAAAAAAAggAAAAgA
AABxBv//AAAAAGIPAAAAAAAAugAAAAAAAABSAAAABwAAAHJlZnJlc2hSAAAABwAAAFJlZnJlc2gB
AAAAAQAAAAAAAAAAAAAAAQAAAKIDAAAAAAAAygAAAAAAAADQAAAAYgAAAAMAAADiAwAAAAAAAAAE
AABiAAAAAgAAADIEAAAAAAAA1wEAAMMBAAAyBAAAAAAAAC0BAAA9AAAAUCAAAOIDAAAAAAAAcB4A
AGIAAAABAAAAIAAAAFAgAADiAwAAAAAAAHAEAABiAAAAAQAAAFIAAAAHAAAAUmVmcmVzaFAgAACy
BAAAAAAAAHIAAAAsAAAALAAAAAAAAAABAAAA/////////////////////+sAAADhAAAAgQEAAP8A
AADKAAAAAAAAANAAAADwBAAAAAUAAAAAAAATAAAAEgUAAAAAAACABwAA1f7//zAFAADz////cAUA
AMMBAACQBQAAPQAAAJoBAAAAAAAAwAUAAGIAAAAQAAAAAAAAAGACAABiAAAAAgAAAIIAAAAEAAAA
AAAARAEEAADgIQAAAAAAAAAAAAAAAAAABwAAAAAAAAAAAAAAAAAAAOAhAAAAAAAAggAAAAgAAACP
Bf//AAAAADIJAAAAAAAAAAAAAFIAAAAAAAAAAAAAAAMAAACiAwAAAAAAAMoAAAAAAAAA0AAAAGIA
AAADAAAA4gMAAAAAAAAABAAAYgAAAAIAAAAyBAAAAAAAAG0CAADdAAAAMgQAAAAAAACXAAAAKQAA
AOAhAADiAwAAAAAAALAGAABiAAAAAQAAAOIGAAAAAAAAAwAAAAEAAAADAAAA4CEAAOIDAAAAAAAA
EAcAAGIAAAABAAAAIAAAAOAhAACyBAAAAAAAAHIAAAAsAAAALAAAAAAAAAABAAAA////////////
/////////zYBAABuAAAAgQEAAIIAAADKAAAAAAAAANAAAADwBAAAAAUAAAAAAAATAAAAEgUAAAAA
AACABwAAa////zAFAADz////cAUAAN0AAACQBQAAKQAAAJoBAAAAAAAAIAMAAGIAAAAQAAAAAAAA
AGACAABiAAAAAgAAAIIAAAAEAAAAAAEARAEAAABQIwAAAAAAAAAAAAAAAAAABwAAAAAAAAAAAAAA
AAAAAFAjAAAAAAAAggAAAAgAAABZBf//AAAAAIIDAAAAAAAAAAAAAAAAAAAAAAAAogMAAAAAAADK
AAAAAAAAANAAAABiAAAAAgAAAOIDAAAAAAAAAAQAAGIAAAACAAAAMgQAAAAAAADXAQAA5wAAADIE
AAAAAAAARwAAAB8AAABQIwAA4gMAAAAAAABwBAAAYgAAAAEAAABSAAAABQAAAERpdmk6UCMAALIE
AAAAAAAAcgAAACwAAAAsAAAAAAAAAAEAAAD/////////////////////6wAAAHMAAAAOAQAAggAA
AMoAAAAAAAAA0AAAAPAEAAAABQAAAAAAABMAAAASBQAAAAAAADAFAADH/v//UAUAAEcAAABwBQAA
5wAAAJAFAAAfAAAAmgEAAAAAAADADgAAYgAAABIAAAAAAAAAYAIAAGIAAAACAAAAggAAAAQAAADE
ADBEAQQAAJAkAAAAAAAAAAAAAAAAAAAHAAAAEg8AAAAAAAAAAAAAEAAAAGIAAAAKAAAAQg8AAAAA
AAABAAAAYg8AAAAAAACADwAAUgAAAAgAAAAmRm9udC4uLgEAAAABAAAAAAAAAAAAAAAAAAAAsg8A
AAAAAAABEAAAQg8AAAAAAAABAAAAYg8AAAAAAADwDwAAUgAAAAYAAAAmUGxhaW4BAAAAAQAAAAAA
AAAAAAAAAAAAAEIPAAAAAAAAAQAAAGIPAAAAAAAAQBAAAFIAAAAFAAAAJkJvbGQBAAAAAQAAAAAA
AAAAAAAAAAAAAEIPAAAAAAAAAQAAAGIPAAAAAAAAkBAAAFIAAAAHAAAAJkl0YWxpYwEAAAABAAAA
AAAAAAAAAAAAAAAAQg8AAAAAAAABAAAAYg8AAAAAAADgEAAAUgAAAAsAAAAmVW5kZXJsaW5lZAEA
AAABAAAAAAAAAAAAAAAAAAAAsg8AAAAAAAABEAAAEg8AAAAAAAAAAAAAEAAAAGIAAAADAAAAQg8A
AAAAAAABBAAAYg8AAAAAAABgEQAAUgAAAAUAAAAmTGVmdAEAAAABAAAAAAAAAAAAAAAAAAAAQg8A
AAAAAAABBAAAYg8AAAAAAACwEQAAUgAAAAcAAAAmQ2VudHJlAQAAAAEAAAAAAAAAAAAAAAAAAABC
DwAAAAAAAAEEAABiDwAAAAAAAAASAABSAAAABgAAACZSaWdodAEAAAABAAAAAAAAAAAAAAAAAAAA
UgAAAAYAAAAmQWxpZ24AAAAAsg8AAAAAAAABEAAAQg8AAAAAAAABAAAAYg8AAAAAAABwEgAAUgAA
AAoAAAAmQ29sb3VyLi4uAQAAAAEAAAAAAAAAAAAAAAAAAABSAAAAAAAAAAAAAAAAAAAAAAAAAJAk
AAAAAAAAggAAAAQAAAAB2+Z0ggMAAAAAAAAAAAAAAAAAAAEAAAAAAAAA0hIAAAAAAAByAAAADAAA
AAAAAAAAAAAAJE3VC6IDAAAAAAAAygAAAAAAAADQAAAAYgAAAAYAAADiAwAAAAAAAAAEAABiAAAA
AgAAADIEAAAAAAAAAQAAAAkCAAAyBAAAAAAAAA0DAAC3AwAAkCQAAOIDAAAAAAAAgBMAAGIAAAAB
AAAA0CQAAJAkAADiAwAAAAAAAHAEAABiAAAAAQAAANITAAAAAAAAUgAAAIUAAAB7XHJ0ZjFcYW5z
aVxhbnNpY3BnMTI1MlxkZWZmMFxkZWZsYW5nMjA1N3tcZm9udHRibHtcZjBcZm5pbFxmY2hhcnNl
dDAgTWljcm9zb2Z0IFNhbnMgU2VyaWY7fX0NClx2aWV3a2luZDRcdWMxXHBhcmRcZjBcZnMxNiAN
ClxwYXIgfQ0KkCQAAOIDAAAAAAAAsAYAAGIAAAABAAAA4gYAAAAAAAADAAAAAQAAAAMAAACQJAAA
4gMAAAAAAAAQBwAAYgAAAAEAAAAgAAAAkCQAAOIDAAAAAAAAYBQAAIAUAACQJAAAsgQAAAAAAABy
AAAALAAAACwAAAAAAAAAAQAAAP////////////////////8AAAAABAEAAIYBAADfAgAAygAAAAAA
AADQAAAA8AQAAAAFAAAAAAAAEwAAABIFAAAAAAAAIA4AAAEAAAAwBQAA/f///3AFAAAJAgAAsBsA
AP////+aAQAAAAAAAMAFAABiAAAAEAAAAAAAAABgAgAAYgAAAAIAAACCAAAABAAAAIAAAEQBBAAA
wCgAAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAAAAAAAADAKAAAAAAAAIIAAAAIAAAAjwX//wAAAACC
AwAAAAAAAAAAAAAAAAAAAwAAAKIDAAAAAAAAygAAAAAAAADQAAAAYgAAAAMAAADiAwAAAAAAAAAE
AABiAAAAAgAAADIEAAAAAAAAbQIAAEcAAAAyBAAAAAAAAJcAAAApAAAAwCgAAOIDAAAAAAAAsAYA
AGIAAAABAAAA4gYAAAAAAAADAAAAAQAAAAMAAADAKAAA4gMAAAAAAAAQBwAAYgAAAAEAAAAgAAAA
wCgAALIEAAAAAAAAcgAAACwAAAAsAAAAAAAAAAEAAAD/////////////////////NgEAACMAAACB
AQAANwAAAMoAAAAAAAAA0AAAAPAEAAAABQAAAAAAABMAAAASBQAAAAAAAIAHAABr////MAUAAPP/
//9wBQAARwAAAJAFAAApAAAAmgEAAAAAAADABQAAYgAAABAAAAAAAAAAYAIAAGIAAAACAAAAggAA
AAQAAACAAABEAQQAACAqAAAAAAAAAAAAAAAAAAAHAAAAAAAAAAAAAAAAAAAAICoAAAAAAACCAAAA
CAAAAI8F//8AAAAAggMAAAAAAAAAAAAAAAAAAAMAAACiAwAAAAAAAMoAAAAAAAAA0AAAAGIAAAAD
AAAA4gMAAAAAAAAABAAAYgAAAAIAAAAyBAAAAAAAADECAAAVAAAAMgQAAAAAAADTAAAAKQAAACAq
AADiAwAAAAAAALAGAABiAAAAAQAAAOIGAAAAAAAAAwAAAAEAAAADAAAAICoAAOIDAAAAAAAAEAcA
AGIAAAABAAAAIAAAACAqAACyBAAAAAAAAHIAAAAsAAAALAAAAAAAAAABAAAA////////////////
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
AHVuaXRTdGFrZdALAABSAAAABQAAAGdyYXBosAUAAFIAAAAKAAAAdG90YWxMaW5lc9AbAABSAAAA
BgAAAHByb2ZpdAAAAACiAwAAAAAAAMoAAAAAAAAA0AAAAGIAAAABAAAA4gMAAAAAAAAABAAAYgAA
AAIAAAAyBAAAAAAAAAEAAAABAAAAMgQAAAAAAAARAwAAwQUAAGACAACyBAAAAAAAAHIAAAAsAAAA
LAAAAAAAAAABAAAA/////////////////////wAAAAAAAAAAiAEAAOACAADKAAAAAAAAANAAAABi
AAAAFAAAANALAABQIAAAwCgAALAFAAAgKgAAEAMAAMAsAAAALgAAEB8AAOAIAABALwAAUCMAAIAr
AACgBwAA4CEAAGAKAADQGwAAQB0AAJAkAABADgAAAAUAAAAAAAATAAAAFQAAABAAAADqAAAAAAAA
AAABAADwBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAA
AAAAAKIDAAAAAAAAygAAAAAAAADQAAAAYgAAAAIAAADiAwAAAAAAAAAEAABiAAAAAgAAADIEAAAA
AAAACwAAAAsAAAAyBAAAAAAAACEDAAAFBgAAoAEAAOIDAAAAAAAAugAAAAAAAABSAAAACAAAAG1l
bnVCYXI6YgAAAAEAAAAAAAAAoAEAALIEAAAAAAAAcgAAACwAAAAsAAAAAAAAAAAAAAD/////////
////////////BQAAAAUAAACVAQAABwMAAMoAAAAAAAAA0AAAAGIAAAABAAAAYAIAAAAFAAAAAAAA
FQAAAEYFBAADAAAASWNvbgAAAAAAAAAAEAAAAA4CEQBTVEJTaW5nbGV0b25Qcm94eQAAAACaAAAA
AAAAAFIAAAAHAAAARG9scGhpblIAAAAYAAAASW1hZ2VSZWxhdGl2ZUZpbGVMb2NhdG9yugAAAAAA
AABSAAAABwAAAGN1cnJlbnRSAAAADQAAAFNoZWxsVmlldy5pY28OAh8AU1RCRXh0ZXJuYWxSZXNv
dXJjZUxpYnJhcnlQcm94eQAAAABSAAAAEAAAAGRvbHBoaW5kcjAwNS5kbGwAAAAA'))!

(ResourceIdentifier class: HRMtgDashboardPresenter name: 'Default view') assign: (Object fromBinaryStoreBytes:
(ByteArray fromBase64String: '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
Z25QYXJhZ3JhcGhMZWZ0UgAAAAUAAAAmTGVmdAEAAAABAAAAAAAAAAAAAAAAAAAAkgkAAAAAAAAB
BAAAsgkAAAAAAAC6AAAAAAAAAFIAAAAUAAAAYWxpZ25QYXJhZ3JhcGhDZW50ZXJSAAAABwAAACZD
ZW50cmUBAAAAAQAAAAAAAAAAAAAAAAAAAJIJAAAAAAAAAQQAALIJAAAAAAAAugAAAAAAAABSAAAA
EwAAAGFsaWduUGFyYWdyYXBoUmlnaHRSAAAABgAAACZSaWdodAEAAAABAAAAAAAAAAAAAAAAAAAA
UgAAAAYAAAAmQWxpZ24AAAAAAgoAAAAAAAABEAAAkgkAAAAAAAABAAAAsgkAAAAAAAC6AAAAAAAA
AFIAAAAUAAAAY2hvb3NlU2VsZWN0aW9uQ29sb3JSAAAACgAAACZDb2xvdXIuLi4BAAAAAQAAAAAA
AAAAAAAAAAAAAFIAAAAAAAAAAAAAAAAAAAAAAAAAAAkAAAAAAACCAAAABAAAAAHb5nSCAwAAAAAA
AAAAAAAAAAAAAQAAAAAAAAAGAQoARURJVFNUUkVBTQAAAAByAAAADAAAAAAAAAAAAAAAHNbUC6ID
AAAAAAAAygAAAAAAAADQAAAAYgAAAAYAAADiAwAAAAAAAAAEAABiAAAAAgAAADIEAAAAAAAAAQAA
AAkCAAAyBAAAAAAAAA0DAAC3AwAAAAkAAOIDAAAAAAAAugAAAAAAAABSAAAADAAAAGNvbnRleHRN
ZW51OmIAAAABAAAAcAkAAAAJAADiAwAAAAAAAHAEAABiAAAAAQAAAAYBCABSaWNoVGV4dAAAAABS
AAAAhQAAAHtccnRmMVxhbnNpXGFuc2ljcGcxMjUyXGRlZmYwXGRlZmxhbmcyMDU3e1xmb250dGJs
e1xmMFxmbmlsXGZjaGFyc2V0MCBNaWNyb3NvZnQgU2FucyBTZXJpZjt9fQ0KXHZpZXdraW5kNFx1
YzFccGFyZFxmMFxmczE2IA0KXHBhciB9DQoACQAA4gMAAAAAAADQBgAAYgAAAAEAAAACBwAAAAAA
AAMAAAABAAAAAwAAAAAJAADiAwAAAAAAADAHAABiAAAAAQAAACAAAAAACQAA4gMAAAAAAAC6AAAA
AAAAAFIAAAAPAAAAcmVzZXRDaGFyRm9ybWF0YgAAAAAAAAAACQAAsgQAAAAAAAByAAAALAAAACwA
AAAAAAAAAQAAAP////////////////////8AAAAABAEAAIYBAADfAgAAygAAAAAAAADQAAAA8AQA
AAAFAAAAAAAAEwAAABIFAAAAAAAAugAAAAAAAABSAAAADwAAAGZpeGVkUGFyZW50TGVmdAEAAAAw
BQAA/f///3AFAAAJAgAAugAAAAAAAABSAAAAEQAAAGZpeGVkUGFyZW50Qm90dG9t/////5oBAAAA
AAAAwAUAAGIAAAAQAAAAAAAAAGACAABiAAAAAgAAAIIAAAAEAAAAgAAARAEEAABgDwAAAAAAAAAA
AAAAAAAABwAAAAAAAAAAAAAAAAAAAGAPAAAAAAAAggAAAAgAAACPBf//AAAAAIIDAAAAAAAAAAAA
AAAAAAADAAAAogMAAAAAAADKAAAAAAAAANAAAABiAAAAAwAAAOIDAAAAAAAAAAQAAGIAAAACAAAA
MgQAAAAAAAAxAgAAFQAAADIEAAAAAAAA0wAAACkAAABgDwAA4gMAAAAAAADQBgAAYgAAAAEAAAAC
BwAAAAAAAAMAAAABAAAAAwAAAGAPAADiAwAAAAAAADAHAABiAAAAAQAAACAAAABgDwAAsgQAAAAA
AAByAAAALAAAACwAAAAAAAAAAQAAAP////////////////////8YAQAACgAAAIEBAAAeAAAAygAA
AAAAAADQAAAA8AQAAAAFAAAAAAAAEwAAABIFAAAAAAAAoAcAAC////8wBQAA8////3AFAAAVAAAA
kAUAACkAAACaAQAAAAAAACADAABiAAAAEAAAAAAAAABgAgAAYgAAAAIAAACCAAAABAAAAAABAEQB
AAAAwBAAAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAAAAAAAADAEAAAAAAAAIIAAAAIAAAAWQX//wAA
AACCAwAAAAAAAAAAAAAAAAAAAAAAAKIDAAAAAAAAygAAAAAAAADQAAAAYgAAAAIAAADiAwAAAAAA
AAAEAABiAAAAAgAAADIEAAAAAAAA1wEAABkBAAAyBAAAAAAAAFsAAAAfAAAAwBAAAOIDAAAAAAAA
cAQAAGIAAAABAAAAUgAAAAcAAABSZXR1cm46wBAAALIEAAAAAAAAcgAAACwAAAAsAAAAAAAAAAEA
AAD/////////////////////6wAAAIwAAAAYAQAAmwAAAMoAAAAAAAAA0AAAAPAEAAAABQAAAAAA
ABMAAAASBQAAAAAAADAFAADH/v//UAUAAFsAAABwBQAAGQEAAJAFAAAfAAAAmgEAAAAAAADABQAA
YgAAABAAAAAAAAAAYAIAAGIAAAACAAAAggAAAAQAAAAAAABEAQQAAAASAAAAAAAAAAAAAAAAAAAH
AAAAAAAAAAAAAAAAAAAAABIAAAAAAACCAAAACAAAAI8F//8AAAAAIgYAAAAAAAAAAAAAUgAAAAAA
AAAAAAAAAwAAAKIDAAAAAAAAygAAAAAAAADQAAAAYgAAAAMAAADiAwAAAAAAAAAEAABiAAAAAgAA
ADIEAAAAAAAAnwIAAKsAAAAyBAAAAAAAAGUAAAApAAAAABIAAOIDAAAAAAAA0AYAAGIAAAABAAAA
AgcAAAAAAAADAAAAAQAAAAMAAAAAEgAA4gMAAAAAAAAwBwAAYgAAAAEAAAAgAAAAABIAALIEAAAA
AAAAcgAAACwAAAAsAAAAAAAAAAEAAAD/////////////////////TwEAAFUAAACBAQAAaQAAAMoA
AAAAAAAA0AAAAPAEAAAABQAAAAAAABMAAAASBQAAAAAAAKAHAACd////MAUAAPP///9wBQAAqwAA
AJAFAAApAAAAmgEAAAAAAACaAAAAAAAAAFIAAAAQAAAASG9yc2VSYWNlQmV0dGluZ1IAAAAPAAAA
SFJMaW5lR3JhcGhWaWV3YgAAABUAAAAAAAAAYAIAAGIAAAACAAAAggAAAAQAAAAAAABEAQAEAHAT
AABiAAAAAwAAAMoAAAAAAAAA0AAAAPAEAADKAAAAAAAAANAAAADwBAAAAwAAAAAAAAAAAAAABwAA
AAAAAAAAAAAAAAAAAHATAAAGCAYAQ2FudmFzAAAAAAAAAAAAAAAAIAAAAAYDAwBQZW4AAAAAAAAA
ABAAAAAGAQYATE9HUEVOAAAAAHIAAAAQAAAAAAAAAAIAAAAAAAAADgAAAQAAAAAGBAQARm9udAAA
AAAAAAAAEAAAAAYBBwBMT0dGT05UAAAAAHIAAAA8AAAA9f///wAAAAAAAAAAAAAAAJABAAAAAAAA
AAAAAEFyaWFsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMgQAAAAAAADBAAAAwQAAAAAAAAAA
AAAAMgQAAAAAAAA9AAAAwwEAAD0AAAA9AAAAhwEAAEsBAAA9AAAAhwEAAAYCCABGcmFjdGlvbgAA
AABvAAAABQAAAKIDAAAAAAAAygAAAAAAAADQAAAAYgAAAAEAAADiAwAAAAAAAAAEAABiAAAAAgAA
ADIEAAAAAAAAAQAAAAEAAAAyBAAAAAAAAMMBAAD/AQAAcBMAALIEAAAAAAAAcgAAACwAAAAsAAAA
AAAAAAEAAAD/////////////////////AAAAAAAAAADhAAAA/wAAAMoAAAAAAAAA0AAAAPAEAAAA
BQAAAAAAABMAAAASBQAAAAAAACAPAAABAAAAMAUAALP+//9wBQAAAQAAAHAFAAD/AQAAmgEAAAAA
AABwAgAAYgAAAA8AAAAAAAAAYAIAAGIAAAACAAAAggAAAAQAAAAAAABEAQACAMAVAAAAAAAAAAAA
AAAAAAAHAAAAAAAAAAAAAAAAAAAAwBUAACICAAAAAAAA6gAAAAAAAADwAAAAYgAAAAIAAACaAQAA
AAAAABAJAABiAAAAEgAAAAAAAADAFQAAYgAAAAIAAACCAAAABAAAAMQRMUQBBAAAMBYAAAAAAAAA
AAAAAAAAAAcAAABiCQAAAAAAAAAAAAAQAAAAYgAAAAoAAACSCQAAAAAAAAEAAACyCQAAAAAAANAJ
AABSAAAACAAAACZGb250Li4uAQAAAAEAAAAAAAAAAAAAAAAAAAACCgAAAAAAAAEQAACSCQAAAAAA
AAEAAACyCQAAAAAAAEAKAABSAAAABgAAACZQbGFpbgEAAAABAAAAAAAAAAAAAAAAAAAAkgkAAAAA
AAABAAAAsgkAAAAAAACQCgAAUgAAAAUAAAAmQm9sZAEAAAABAAAAAAAAAAAAAAAAAAAAkgkAAAAA
AAABAAAAsgkAAAAAAADgCgAAUgAAAAcAAAAmSXRhbGljAQAAAAEAAAAAAAAAAAAAAAAAAACSCQAA
AAAAAAEAAACyCQAAAAAAADALAABSAAAACwAAACZVbmRlcmxpbmVkAQAAAAEAAAAAAAAAAAAAAAAA
AAACCgAAAAAAAAEQAABiCQAAAAAAAAAAAAAQAAAAYgAAAAMAAACSCQAAAAAAAAEEAACyCQAAAAAA
ALALAABSAAAABQAAACZMZWZ0AQAAAAEAAAAAAAAAAAAAAAAAAACSCQAAAAAAAAEEAACyCQAAAAAA
AAAMAABSAAAABwAAACZDZW50cmUBAAAAAQAAAAAAAAAAAAAAAAAAAJIJAAAAAAAAAQQAALIJAAAA
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
AAIAAAAyBAAAAAAAAAEAAAABAAAAMgQAAAAAAAANAwAAvQAAAHAaAADiAwAAAAAAAHAEAABiAAAA
AQAAAFIAAAALAAAARGVzY3JpcHRpb25wGgAAsgQAAAAAAAByAAAALAAAACwAAAAAAAAAAQAAAP//
//////////////////8AAAAAAAAAAIYBAABeAAAAygAAAAAAAADQAAAA8AQAAAAFAAAAAAAAFwAA
AFIAAAAEAAAAZXN0czAWAABSAAAADQAAAGxpbmVzV2l0aEVzdHMAAAAAogMAAAAAAADKAAAAAAAA
ANAAAABiAAAAAQAAAOIDAAAAAAAAAAQAAGIAAAACAAAAMgQAAAAAAAABAAAACQIAADIEAAAAAAAA
DQMAALcDAADAFQAAsgQAAAAAAAByAAAALAAAACwAAAAAAAAAAQAAAP////////////////////8A
AAAABAEAAIYBAADfAgAAygAAAAAAAADQAAAAYgAAAAMAAABwGgAAmgEAAAAAAACaAAAAAAAAAMAB
AABSAAAACAAAAFNwbGl0dGVyYgAAAAwAAAAAAAAAwBUAAGIAAAACAAAAggAAAAQAAAAAAABEAQAA
ADAgAAAAAAAAAAAAAAAAAAAHAgAAAAAAAAAAAAAAAAAAMCAAAKIDAAAAAAAAygAAAAAAAADQAAAA
YgAAAAEAAADiAwAAAAAAAAAEAABiAAAAAgAAADIEAAAAAAAAAQAAAL0AAAAyBAAAAAAAAA0DAAAH
AAAAMCAAALIEAAAAAAAAcgAAACwAAAAsAAAAAAAAAAEAAAD/////////////////////AAAAAF4A
AACGAQAAYQAAAMoAAAAAAAAA0AAAAPAEAAAABQAAAAAAABMAAAAwFgAAAAUAAAAAAAATAAAAEgUA
AAAAAAAgDwAAAQAAADAFAAD9////cAUAAAkCAABADwAA/////5oBAAAAAAAAIAMAAGIAAAAQAAAA
AAAAAGACAABiAAAAAgAAAIIAAAAEAAAAAAEARAEAAABAIQAAAAAAAAAAAAAAAAAABwAAAAAAAAAA
AAAAAAAAAEAhAAAAAAAAggAAAAgAAABZBf//AAAAAIIDAAAAAAAAAAAAAAAAAAAAAAAAogMAAAAA
AADKAAAAAAAAANAAAABiAAAAAgAAAOIDAAAAAAAAAAQAAGIAAAACAAAAMgQAAAAAAADXAQAAHwAA
ADIEAAAAAAAAPQAAAB8AAABAIQAA4gMAAAAAAABwBAAAYgAAAAEAAABSAAAABAAAAFBvdDpAIQAA
sgQAAAAAAAByAAAALAAAACwAAAAAAAAAAQAAAP/////////////////////rAAAADwAAAAkBAAAe
AAAAygAAAAAAAADQAAAA8AQAAAAFAAAAAAAAEwAAABIFAAAAAAAAMAUAAMf+//9QBQAAPQAAAHAF
AAAfAAAAkAUAAB8AAACaAQAAAAAAAMAFAABiAAAAEAAAAAAAAABgAgAAYgAAAAIAAACCAAAABAAA
AAAAAEQBBAAAgCIAAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAAAAAAAACAIgAAAAAAAIIAAAAIAAAA
jwX//wAAAAAiBgAAAAAAAAAAAABSAAAAAAAAAAAAAAADAAAAogMAAAAAAADKAAAAAAAAANAAAABi
AAAAAwAAAOIDAAAAAAAAAAQAAGIAAAACAAAAMgQAAAAAAABtAgAADwEAADIEAAAAAAAAlwAAACkA
AACAIgAA4gMAAAAAAADQBgAAYgAAAAEAAAACBwAAAAAAAAMAAAABAAAAAwAAAIAiAADiAwAAAAAA
ADAHAABiAAAAAQAAACAAAACAIgAAsgQAAAAAAAByAAAALAAAACwAAAAAAAAAAQAAAP//////////
//////////82AQAAhwAAAIEBAACbAAAAygAAAAAAAADQAAAA8AQAAAAFAAAAAAAAEwAAABIFAAAA
AAAAoAcAAGv///8wBQAA8////3AFAAAPAQAAkAUAACkAAACaAQAAAAAAAMAFAABiAAAAEAAAAAAA
AABgAgAAYgAAAAIAAACCAAAABAAAAIAAAEQBBAAA8CMAAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAA
AAAAAADwIwAAAAAAAIIAAAAIAAAAjwX//wAAAACCAwAAAAAAAAAAAAAAAAAAAwAAAKIDAAAAAAAA
ygAAAAAAAADQAAAAYgAAAAMAAADiAwAAAAAAAAAEAABiAAAAAgAAADIEAAAAAAAAbQIAAEcAAAAy
BAAAAAAAAJcAAAApAAAA8CMAAOIDAAAAAAAA0AYAAGIAAAABAAAAAgcAAAAAAAADAAAAAQAAAAMA
AADwIwAA4gMAAAAAAAAwBwAAYgAAAAEAAAAgAAAA8CMAALIEAAAAAAAAcgAAACwAAAAsAAAAAAAA
AAEAAAD/////////////////////NgEAACMAAACBAQAANwAAAMoAAAAAAAAA0AAAAPAEAAAABQAA
AAAAABMAAAASBQAAAAAAAKAHAABr////MAUAAPP///9wBQAARwAAAJAFAAApAAAAmgEAAAAAAADA
BQAAYgAAABAAAAAAAAAAYAIAAGIAAAACAAAAggAAAAQAAACAAABEAQQAAFAlAAAAAAAAAAAAAAAA
AAAHAAAAAAAAAAAAAAAAAAAAUCUAAAAAAACCAAAACAAAAI8F//8AAAAAggMAAAAAAAAAAAAAAAAA
AAMAAACiAwAAAAAAAMoAAAAAAAAA0AAAAGIAAAADAAAA4gMAAAAAAAAABAAAYgAAAAIAAAAyBAAA
AAAAAG0CAAB5AAAAMgQAAAAAAACXAAAAKQAAAFAlAADiAwAAAAAAANAGAABiAAAAAQAAAAIHAAAA
AAAAAwAAAAEAAAADAAAAUCUAAOIDAAAAAAAAMAcAAGIAAAABAAAAIAAAAFAlAACyBAAAAAAAAHIA
AAAsAAAALAAAAAAAAAABAAAA/////////////////////zYBAAA8AAAAgQEAAFAAAADKAAAAAAAA
ANAAAADwBAAAAAUAAAAAAAATAAAAEgUAAAAAAACgBwAAa////zAFAADz////cAUAAHkAAACQBQAA
KQAAAJoBAAAAAAAAwAUAAGIAAAAQAAAAAAAAAGACAABiAAAAAgAAAIIAAAAEAAAAAAAARAEEAACw
JgAAAAAAAAAAAAAAAAAABwAAAAAAAAAAAAAAAAAAALAmAAAAAAAAggAAAAgAAACPBf//AAAAACIG
AAAAAAAAAAAAAFIAAAAAAAAAAAAAAAMAAACiAwAAAAAAAMoAAAAAAAAA0AAAAGIAAAADAAAA4gMA
AAAAAAAABAAAYgAAAAIAAAAyBAAAAAAAAG0CAABBAQAAMgQAAAAAAACXAAAAKQAAALAmAADiAwAA
AAAAANAGAABiAAAAAQAAAAIHAAAAAAAAAwAAAAEAAAADAAAAsCYAAOIDAAAAAAAAMAcAAGIAAAAB
AAAAIAAAALAmAACyBAAAAAAAAHIAAAAsAAAALAAAAAAAAAABAAAA/////////////////////zYB
AACgAAAAgQEAALQAAADKAAAAAAAAANAAAADwBAAAAAUAAAAAAAATAAAAEgUAAAAAAACgBwAAa///
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
AAAFAAAAZ3JhcGjwIwAAUgAAAAcAAABjdW1PZGRzsAUAAFIAAAAEAAAAZGl2aWApAABSAAAACQAA
AHVuaXRTdGFrZQAAAACiAwAAAAAAAMoAAAAAAAAA0AAAAGIAAAABAAAA4gMAAAAAAAAABAAAYgAA
AAIAAAAyBAAAAAAAAAEAAAABAAAAMgQAAAAAAAARAwAAwQUAAGACAACyBAAAAAAAAHIAAAAsAAAA
LAAAAAAAAAABAAAA/////////////////////wAAAAAAAAAAiAEAAOACAADKAAAAAAAAANAAAABi
AAAAFAAAAHATAADQKgAA8CMAAFAlAABgDwAAEAMAAKAsAABAIQAA4C0AAGApAAAAEgAAwAcAAMAQ
AAAgKAAAsAUAAIAiAACwJgAAIC8AAAAJAADAFQAAAAUAAAAAAAATAAAAFQAAABAAAADqAAAAAAAA
AAABAADwBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAA
AAAAAKIDAAAAAAAAygAAAAAAAADQAAAAYgAAAAIAAADiAwAAAAAAAAAEAABiAAAAAgAAADIEAAAA
AAAACwAAAAsAAAAyBAAAAAAAACEDAAAFBgAAoAEAAOIDAAAAAAAAugAAAAAAAABSAAAACAAAAG1l
bnVCYXI6YgAAAAEAAAAAAAAAoAEAALIEAAAAAAAAcgAAACwAAAAsAAAAAAAAAAAAAAD/////////
////////////BQAAAAUAAACVAQAABwMAAMoAAAAAAAAA0AAAAGIAAAABAAAAYAIAAAAFAAAAAAAA
FQAAAEYFBAADAAAASWNvbgAAAAAAAAAAEAAAAA4CEQBTVEJTaW5nbGV0b25Qcm94eQAAAACaAAAA
AAAAAFIAAAAHAAAARG9scGhpblIAAAAYAAAASW1hZ2VSZWxhdGl2ZUZpbGVMb2NhdG9yugAAAAAA
AABSAAAABwAAAGN1cnJlbnRSAAAADQAAAFNoZWxsVmlldy5pY28OAh8AU1RCRXh0ZXJuYWxSZXNv
dXJjZUxpYnJhcnlQcm94eQAAAABSAAAAEAAAAGRvbHBoaW5kcjAwNS5kbGwAAAAA'))!

(ResourceIdentifier class: HRMtgDashboardPresenter name: 'Limited view') assign: (Object fromBinaryStoreBytes:
(ByteArray fromBase64String: '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
LAAAAAAAAAABAAAA/////////////////////wAAAABiAAAAhgEAAGUAAADKAAAAAAAAANAAAABg
BQAAcAUAAAAAAAATAAAAgB0AAHAFAAAAAAAAEwAAAIIFAAAAAAAAAAoAAAEAAADABQAA/f///+AF
AADhAQAAIBIAAP////+aAQAAAAAAADAKAABiAAAAEAAAAAAAAABgAgAAYgAAAAIAAACCAAAABAAA
AIAAAEQBBAAAkCgAAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAAAAAAAACQKAAAAAAAAIIAAAAIAAAA
jwX//wAAAACSBgAAAAAAAAAAAAAAAAAAAwAAANIDAAAAAAAAygAAAAAAAADQAAAAYgAAAAMAAAAS
BAAAAAAAADAEAABiAAAAAgAAAGIEAAAAAAAAMQIAABUAAABiBAAAAAAAANMAAAApAAAAkCgAABIE
AAAAAAAAQAsAAGIAAAABAAAAcgsAAAAAAAADAAAAAQAAAAMAAACQKAAAEgQAAAAAAACgCwAAYgAA
AAEAAAAgAAAAkCgAACIFAAAAAAAAcgAAACwAAAAsAAAAAAAAAAEAAAD/////////////////////
GAEAAAoAAACBAQAAHgAAAMoAAAAAAAAA0AAAAGAFAABwBQAAAAAAABMAAACCBQAAAAAAAKAFAAAv
////wAUAAPP////gBQAAFQAAAAAGAAApAAAAmgEAAAAAAAAwBgAAYgAAABAAAAAAAAAAYAIAAGIA
AAACAAAAggAAAAQAAAAAAQBEAQAAAPApAAAAAAAAAAAAAAAAAAAHAAAAAAAAAAAAAAAAAAAA8CkA
AAAAAACCAAAACAAAAFkF//8AAAAAkgYAAAAAAAAAAAAAAAAAAAAAAADSAwAAAAAAAMoAAAAAAAAA
0AAAAGIAAAACAAAAEgQAAAAAAAAwBAAAYgAAAAIAAABiBAAAAAAAANcBAAAZAQAAYgQAAAAAAABv
AAAAHwAAAPApAAASBAAAAAAAAOAEAABiAAAAAQAAAFIAAAAHAAAAUHJvZml0OvApAAAiBQAAAAAA
AHIAAAAsAAAALAAAAAAAAAABAAAA/////////////////////+sAAACMAAAAIgEAAJsAAADKAAAA
AAAAANAAAABgBQAAcAUAAAAAAAATAAAAggUAAAAAAADABQAAx/7//5AHAABvAAAA4AUAABkBAAAA
BgAAHwAAAJoBAAAAAAAAMAoAAGIAAAAQAAAAAAAAAGACAABiAAAAAgAAAIIAAAAEAAAAAAAARAEE
AAAwKwAAAAAAAAAAAAAAAAAABwAAAAAAAAAAAAAAAAAAADArAAAAAAAAggAAAAgAAACPBf//AAAA
AJIKAAAAAAAAAAAAAFIAAAAAAAAAAAAAAAMAAADSAwAAAAAAAMoAAAAAAAAA0AAAAGIAAAADAAAA
EgQAAAAAAAAwBAAAYgAAAAIAAABiBAAAAAAAAG0CAADdAAAAYgQAAAAAAACXAAAAKQAAADArAAAS
BAAAAAAAAEALAABiAAAAAQAAAHILAAAAAAAAAwAAAAEAAAADAAAAMCsAABIEAAAAAAAAoAsAAGIA
AAABAAAAIAAAADArAAAiBQAAAAAAAHIAAAAsAAAALAAAAAAAAAABAAAA////////////////////
/zYBAABuAAAAgQEAAIIAAADKAAAAAAAAANAAAABgBQAAcAUAAAAAAAATAAAAggUAAAAAAACgBQAA
a////8AFAADz////4AUAAN0AAAAABgAAKQAAAJoBAAAAAAAAMAoAAGIAAAAQAAAAAAAAAGACAABi
AAAAAgAAAIIAAAAEAAAAAAAARAEEAACgLAAAAAAAAAAAAAAAAAAABwAAAAAAAAAAAAAAAAAAAKAs
AAAAAAAAggAAAAgAAACPBf//AAAAAJIKAAAAAAAAAAAAAFIAAAAAAAAAAAAAAAMAAADSAwAAAAAA
AMoAAAAAAAAA0AAAAGIAAAADAAAAEgQAAAAAAAAwBAAAYgAAAAIAAABiBAAAAAAAAG0CAACrAAAA
YgQAAAAAAACXAAAAKQAAAKAsAAASBAAAAAAAAEALAABiAAAAAQAAAHILAAAAAAAAAwAAAAEAAAAD
AAAAoCwAABIEAAAAAAAAoAsAAGIAAAABAAAAIAAAAKAsAAAiBQAAAAAAAHIAAAAsAAAALAAAAAAA
AAABAAAA/////////////////////zYBAABVAAAAgQEAAGkAAADKAAAAAAAAANAAAABgBQAAcAUA
AAAAAAATAAAAggUAAAAAAACgBQAAa////8AFAADz////4AUAAKsAAAAABgAAKQAAAOoAAAAAAAAA
AAEAAGIAAAAWAAAAoBsAAFIAAAAKAAAAdG90YWxTdGFrZZAoAABSAAAAAwAAAHBvdKAsAABSAAAA
BAAAAGRpdmmAEwAAUgAAAAoAAAB0b3RhbExpbmVzIAoAAFIAAAAGAAAAcHJvZml0EAMAAFIAAAAJ
AAAAdG9nZ2xlRXN0MCsAAFIAAAAGAAAAcGF5T3V0MBoAAFIAAAAJAAAAdW5pdFN0YWtlEB0AAFIA
AAAMAAAAbGluZXNBbmRFc3RzsAcAAFIAAAAFAAAAZ3JhcGgQDAAAUgAAAAUAAABsaW5lcwAAAADS
AwAAAAAAAMoAAAAAAAAA0AAAAGIAAAABAAAAEgQAAAAAAAAwBAAAYgAAAAIAAABiBAAAAAAAAAEA
AAABAAAAYgQAAAAAAAARAwAAwQUAAGACAAAiBQAAAAAAAHIAAAAsAAAALAAAAAAAAAABAAAA////
/////////////////wAAAAAAAAAAiAEAAOACAADKAAAAAAAAANAAAABiAAAAEgAAALAHAABgFwAA
gBMAAJAoAABAEgAA8BgAAOAUAAAwGgAAoBsAACAWAAAgBgAA8CkAAKAsAAAwKwAAIAoAABADAAAQ
DAAAEB0AAHAFAAAAAAAAEwAAABUAAAAQAAAA6gAAAAAAAAAAAQAAYAUAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAADSAwAAAAAAAMoAAAAAAAAA0AAA
AGIAAAACAAAAEgQAAAAAAAAwBAAAYgAAAAIAAABiBAAAAAAAAAsAAAALAAAAYgQAAAAAAAAhAwAA
BQYAAKABAAASBAAAAAAAALoAAAAAAAAAUgAAAAgAAABtZW51QmFyOmIAAAABAAAAAAAAAKABAAAi
BQAAAAAAAHIAAAAsAAAALAAAAAAAAAAAAAAA/////////////////////wUAAAAFAAAAlQEAAAcD
AADKAAAAAAAAANAAAABiAAAAAQAAAGACAABwBQAAAAAAABUAAABGBQQAAwAAAEljb24AAAAAAAAA
ABAAAAAOAhEAU1RCU2luZ2xldG9uUHJveHkAAAAAmgAAAAAAAABSAAAABwAAAERvbHBoaW5SAAAA
GAAAAEltYWdlUmVsYXRpdmVGaWxlTG9jYXRvcroAAAAAAAAAUgAAAAcAAABjdXJyZW50UgAAAA0A
AABTaGVsbFZpZXcuaWNvDgIfAFNUQkV4dGVybmFsUmVzb3VyY2VMaWJyYXJ5UHJveHkAAAAAUgAA
ABAAAABkb2xwaGluZHIwMDUuZGxsAAAAAA=='))!

(ResourceIdentifier class: HRMtgDashboardPresenter name: 'Old Default view') assign: (Object fromBinaryStoreBytes:
(ByteArray fromBase64String: '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
AAAEAABiAAAAAgAAADIEAAAAAAAA1wEAAOcAAAAyBAAAAAAAAEcAAAAfAAAAsAcAAOIDAAAAAAAA
cAQAAGIAAAABAAAAUgAAAAUAAABEaXZpOrAHAACyBAAAAAAAAHIAAAAsAAAALAAAAAAAAAABAAAA
/////////////////////+sAAABzAAAADgEAAIIAAADKAAAAAAAAANAAAADwBAAAAAUAAAAAAAAT
AAAAEgUAAAAAAAAwBQAAx/7//1AFAABHAAAAcAUAAOcAAACQBQAAHwAAAJoBAAAAAAAAIAMAAGIA
AAAQAAAAAAAAAGACAABiAAAAAgAAAIIAAAAEAAAAAAEARAEAAADwCAAAAAAAAAAAAAAAAAAABwAA
AAAAAAAAAAAAAAAAAPAIAAAAAAAAggAAAAgAAABZBf//AAAAAIIDAAAAAAAAAAAAAAAAAAAAAAAA
ogMAAAAAAADKAAAAAAAAANAAAABiAAAAAgAAAOIDAAAAAAAAAAQAAGIAAAACAAAAMgQAAAAAAADX
AQAAgwAAADIEAAAAAAAAUQAAAB8AAADwCAAA4gMAAAAAAABwBAAAYgAAAAEAAABSAAAABgAAAExp
bmVzOvAIAACyBAAAAAAAAHIAAAAsAAAALAAAAAAAAAABAAAA/////////////////////+sAAABB
AAAAEwEAAFAAAADKAAAAAAAAANAAAADwBAAAAAUAAAAAAAATAAAAEgUAAAAAAAAwBQAAx/7//1AF
AABRAAAAcAUAAIMAAACQBQAAHwAAAJoBAAAAAAAAmgAAAAAAAABSAAAAEAAAAEhvcnNlUmFjZUJl
dHRpbmdSAAAADwAAAEhSTGluZUdyYXBoVmlld2IAAAAVAAAAAAAAAGACAABiAAAAAgAAAIIAAAAE
AAAAAAAARAEABAAwCgAAYgAAAAMAAADKAAAAAAAAANAAAADwBAAAygAAAAAAAADQAAAA8AQAAAMA
AAAAAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAwCgAABggGAENhbnZhcwAAAAAAAAAAAAAAACAAAAAG
AwMAUGVuAAAAAAAAAAAQAAAABgEGAExPR1BFTgAAAAByAAAAEAAAAAAAAAACAAAAAAAAAA4AAAEA
AAAABgQEAEZvbnQAAAAAAAAAABAAAAAGAQcATE9HRk9OVAAAAAByAAAAPAAAAPX///8AAAAAAAAA
AAAAAACQAQAAAAAAAAAAAABBcmlhbAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADIEAAAAAAAA
wQAAAMEAAAAAAAAAAAAAADIEAAAAAAAAPQAAAMMBAAA9AAAAPQAAAIcBAABLAQAAPQAAAIcBAAAG
AggARnJhY3Rpb24AAAAAbwAAAAUAAACiAwAAAAAAAMoAAAAAAAAA0AAAAGIAAAABAAAA4gMAAAAA
AAAABAAAYgAAAAIAAAAyBAAAAAAAAAEAAAABAAAAMgQAAAAAAADDAQAA/wEAADAKAACyBAAAAAAA
AHIAAAAsAAAALAAAAAAAAAABAAAA/////////////////////wAAAAAAAAAA4QAAAP8AAADKAAAA
AAAAANAAAADwBAAAAAUAAAAAAAATAAAAEgUAAAAAAAC6AAAAAAAAAFIAAAAPAAAAZml4ZWRQYXJl
bnRMZWZ0AQAAADAFAACz/v//cAUAAAEAAABwBQAA/wEAAJoBAAAAAAAAmgAAAAAAAADAAQAAUgAA
AAgAAABUZXh0RWRpdGIAAAAQAAAAAAAAAGACAABiAAAAAgAAAIIAAAAEAAAAAAAARAEEAACgDAAA
AAAAAAAAAAAAAAAABwAAAAAAAAAAAAAAAAAAAKAMAAAAAAAAggAAAAgAAACPBf//AAAAAAYDDABO
dW1iZXJUb1RleHQAAAAAAAAAAFIAAAAAAAAAAAAAAAMAAACiAwAAAAAAAMoAAAAAAAAA0AAAAGIA
AAADAAAA4gMAAAAAAAAABAAAYgAAAAIAAAAyBAAAAAAAAG0CAABBAQAAMgQAAAAAAACXAAAAKQAA
AKAMAADiAwAAAAAAALoAAAAAAAAAUgAAAA8AAABzZWxlY3Rpb25SYW5nZTpiAAAAAQAAAAYDCABJ
bnRlcnZhbAAAAAADAAAAAQAAAAMAAACgDAAA4gMAAAAAAAC6AAAAAAAAAFIAAAAPAAAAaXNUZXh0
TW9kaWZpZWQ6YgAAAAEAAAAgAAAAoAwAALIEAAAAAAAAcgAAACwAAAAsAAAAAAAAAAEAAAD/////
////////////////NgEAAKAAAACBAQAAtAAAAMoAAAAAAAAA0AAAAPAEAAAABQAAAAAAABMAAAAS
BQAAAAAAAJAHAABr////MAUAAPP///9wBQAAQQEAAJAFAAApAAAAmgEAAAAAAACwDAAAYgAAABAA
AAAAAAAAYAIAAGIAAAACAAAAggAAAAQAAACAAABEAQQAAJAOAAAAAAAAAAAAAAAAAAAHAAAAAAAA
AAAAAAAAAAAAkA4AAAAAAACCAAAACAAAAI8F//8AAAAAggMAAAAAAAAAAAAAAAAAAAMAAACiAwAA
AAAAAMoAAAAAAAAA0AAAAGIAAAADAAAA4gMAAAAAAAAABAAAYgAAAAIAAAAyBAAAAAAAAG0CAABH
AAAAMgQAAAAAAACXAAAAKQAAAJAOAADiAwAAAAAAAMANAABiAAAAAQAAAPINAAAAAAAAAwAAAAEA
AAADAAAAkA4AAOIDAAAAAAAAIA4AAGIAAAABAAAAIAAAAJAOAACyBAAAAAAAAHIAAAAsAAAALAAA
AAAAAAABAAAA/////////////////////zYBAAAjAAAAgQEAADcAAADKAAAAAAAAANAAAADwBAAA
AAUAAAAAAAATAAAAEgUAAAAAAACQBwAAa////zAFAADz////cAUAAEcAAACQBQAAKQAAAJoBAAAA
AAAAsAwAAGIAAAAQAAAAAAAAAGACAABiAAAAAgAAAIIAAAAEAAAAAAAARAEEAADwDwAAAAAAAAAA
AAAAAAAABwAAAAAAAAAAAAAAAAAAAPAPAAAAAAAAggAAAAgAAACPBf//AAAAABINAAAAAAAAAAAA
AFIAAAAAAAAAAAAAAAMAAACiAwAAAAAAAMoAAAAAAAAA0AAAAGIAAAADAAAA4gMAAAAAAAAABAAA
YgAAAAIAAAAyBAAAAAAAAG0CAAAPAQAAMgQAAAAAAACXAAAAKQAAAPAPAADiAwAAAAAAAMANAABi
AAAAAQAAAPINAAAAAAAAAwAAAAEAAAADAAAA8A8AAOIDAAAAAAAAIA4AAGIAAAABAAAAIAAAAPAP
AACyBAAAAAAAAHIAAAAsAAAALAAAAAAAAAABAAAA/////////////////////zYBAACHAAAAgQEA
AJsAAADKAAAAAAAAANAAAADwBAAAAAUAAAAAAAATAAAAEgUAAAAAAACQBwAAa////zAFAADz////
cAUAAA8BAACQBQAAKQAAAJoBAAAAAAAAIAMAAGIAAAAQAAAAAAAAAGACAABiAAAAAgAAAIIAAAAE
AAAAAAEARAEAAABgEQAAAAAAAAAAAAAAAAAABwAAAAAAAAAAAAAAAAAAAGARAAAAAAAAggAAAAgA
AABZBf//AAAAAIIDAAAAAAAAAAAAAAAAAAAAAAAAogMAAAAAAADKAAAAAAAAANAAAABiAAAAAgAA
AOIDAAAAAAAAAAQAAGIAAAACAAAAMgQAAAAAAADXAQAAHwAAADIEAAAAAAAAPQAAAB8AAABgEQAA
4gMAAAAAAABwBAAAYgAAAAEAAABSAAAABAAAAFBvdDpgEQAAsgQAAAAAAAByAAAALAAAACwAAAAA
AAAAAQAAAP/////////////////////rAAAADwAAAAkBAAAeAAAAygAAAAAAAADQAAAA8AQAAAAF
AAAAAAAAEwAAABIFAAAAAAAAMAUAAMf+//9QBQAAPQAAAHAFAAAfAAAAkAUAAB8AAACaAQAAAAAA
ACADAABiAAAAEAAAAAAAAABgAgAAYgAAAAIAAACCAAAABAAAAAABAEQBAAAAoBIAAAAAAAAAAAAA
AAAAAAcAAAAAAAAAAAAAAAAAAACgEgAAAAAAAIIAAAAIAAAAWQX//wAAAACCAwAAAAAAAAAAAAAA
AAAAAAAAAKIDAAAAAAAAygAAAAAAAADQAAAAYgAAAAIAAADiAwAAAAAAAAAEAABiAAAAAgAAADIE
AAAAAAAA1wEAAFEAAAAyBAAAAAAAAG8AAAAfAAAAoBIAAOIDAAAAAAAAcAQAAGIAAAABAAAAUgAA
AAoAAABDdW0uIG9kZHM6oBIAALIEAAAAAAAAcgAAACwAAAAsAAAAAAAAAAEAAAD/////////////
////////6wAAACgAAAAiAQAANwAAAMoAAAAAAAAA0AAAAPAEAAAABQAAAAAAABMAAAASBQAAAAAA
ADAFAADH/v//UAUAAG8AAABwBQAAUQAAAJAFAAAfAAAAmgEAAAAAAAAgAwAAYgAAABAAAAAAAAAA
YAIAAGIAAAACAAAAggAAAAQAAAAAAQBEAQAAAOATAAAAAAAAAAAAAAAAAAAHAAAAAAAAAAAAAAAA
AAAA4BMAAAAAAACCAAAACAAAAFkF//8AAAAAggMAAAAAAAAAAAAAAAAAAAAAAACiAwAAAAAAAMoA
AAAAAAAA0AAAAGIAAAACAAAA4gMAAAAAAAAABAAAYgAAAAIAAAAyBAAAAAAAANcBAAAZAQAAMgQA
AAAAAABbAAAAHwAAAOATAADiAwAAAAAAAHAEAABiAAAAAQAAAFIAAAAHAAAAUmV0dXJuOuATAACy
BAAAAAAAAHIAAAAsAAAALAAAAAAAAAABAAAA/////////////////////+sAAACMAAAAGAEAAJsA
AADKAAAAAAAAANAAAADwBAAAAAUAAAAAAAATAAAAEgUAAAAAAAAwBQAAx/7//1AFAABbAAAAcAUA
ABkBAACQBQAAHwAAAJoBAAAAAAAAsAwAAGIAAAAQAAAAAAAAAGACAABiAAAAAgAAAIIAAAAEAAAA
AAABRAEEAAAgFQAAAAAAAAAAAAAAAAAABwAAAAAAAAAAAAAAAAAAACAVAAAAAAAAggAAAAgAAACP
Bf//AAAAABINAAAAAAAAAAAAAFIAAAAAAAAAAAAAAAEAAACiAwAAAAAAAMoAAAAAAAAA0AAAAGIA
AAADAAAA4gMAAAAAAAAABAAAYgAAAAIAAAAyBAAAAAAAADECAACrAAAAMgQAAAAAAABlAAAAKQAA
ACAVAADiAwAAAAAAAMANAABiAAAAAQAAAPINAAAAAAAAAwAAAAEAAAADAAAAIBUAAOIDAAAAAAAA
IA4AAGIAAAABAAAAIAAAACAVAACyBAAAAAAAAHIAAAAsAAAALAAAAAAAAAABAAAA////////////
/////////xgBAABVAAAASgEAAGkAAADKAAAAAAAAANAAAADwBAAAAAUAAAAAAAATAAAAEgUAAAAA
AACQBwAAnf///zAFAACF////cAUAAKsAAACQBQAAKQAAAJoBAAAAAAAAsAwAAGIAAAAQAAAAAAAA
AGACAABiAAAAAgAAAIIAAAAEAAAAgAAARAEEAACQFgAAAAAAAAAAAAAAAAAABwAAAAAAAAAAAAAA
AAAAAJAWAAAAAAAAggAAAAgAAACPBf//AAAAAIIDAAAAAAAAAAAAAAAAAAADAAAAogMAAAAAAADK
AAAAAAAAANAAAABiAAAAAwAAAOIDAAAAAAAAAAQAAGIAAAACAAAAMgQAAAAAAAAxAgAAFQAAADIE
AAAAAAAA0wAAACkAAACQFgAA4gMAAAAAAADADQAAYgAAAAEAAADyDQAAAAAAAAMAAAABAAAAAwAA
AJAWAADiAwAAAAAAACAOAABiAAAAAQAAACAAAACQFgAAsgQAAAAAAAByAAAALAAAACwAAAAAAAAA
AQAAAP////////////////////8YAQAACgAAAIEBAAAeAAAAygAAAAAAAADQAAAA8AQAAAAFAAAA
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
AAAAAAAAAAAAACAhAAAAAAAAggAAAAgAAACPBf//AAAAABINAAAAAAAAAAAAAFIAAAAAAAAAAAAA
AAMAAACiAwAAAAAAAMoAAAAAAAAA0AAAAGIAAAADAAAA4gMAAAAAAAAABAAAYgAAAAIAAAAyBAAA
AAAAAJ8CAACrAAAAMgQAAAAAAABlAAAAKQAAACAhAADiAwAAAAAAAMANAABiAAAAAQAAAPINAAAA
AAAAAwAAAAEAAAADAAAAICEAAOIDAAAAAAAAIA4AAGIAAAABAAAAIAAAACAhAACyBAAAAAAAAHIA
AAAsAAAALAAAAAAAAAABAAAA/////////////////////08BAABVAAAAgQEAAGkAAADKAAAAAAAA
ANAAAADwBAAAAAUAAAAAAAATAAAAEgUAAAAAAACQBwAAnf///zAFAADz////cAUAAKsAAACQBQAA
KQAAAJoBAAAAAAAAsAwAAGIAAAAQAAAAAAAAAGACAABiAAAAAgAAAIIAAAAEAAAAgAAARAEEAACQ
IgAAAAAAAAAAAAAAAAAABwAAAAAAAAAAAAAAAAAAAJAiAAAAAAAAggAAAAgAAACPBf//AAAAAIID
AAAAAAAAAAAAAAAAAAADAAAAogMAAAAAAADKAAAAAAAAANAAAABiAAAAAwAAAOIDAAAAAAAAAAQA
AGIAAAACAAAAMgQAAAAAAABtAgAAeQAAADIEAAAAAAAAlwAAACkAAACQIgAA4gMAAAAAAADADQAA
YgAAAAEAAADyDQAAAAAAAAMAAAABAAAAAwAAAJAiAADiAwAAAAAAACAOAABiAAAAAQAAACAAAACQ
IgAAsgQAAAAAAAByAAAALAAAACwAAAAAAAAAAQAAAP////////////////////82AQAAPAAAAIEB
AABQAAAAygAAAAAAAADQAAAA8AQAAAAFAAAAAAAAEwAAABIFAAAAAAAAkAcAAGv///8wBQAA8///
/3AFAAB5AAAAkAUAACkAAACaAQAAAAAAACADAABiAAAAEAAAAAAAAABgAgAAYgAAAAIAAACCAAAA
BAAAAAABAEQBAAAA8CMAAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAAAAAAAADwIwAAAAAAAIIAAAAI
AAAAWQX//wAAAACCAwAAAAAAAAAAAAAAAAAAAAAAAKIDAAAAAAAAygAAAAAAAADQAAAAYgAAAAIA
AADiAwAAAAAAAAAEAABiAAAAAgAAADIEAAAAAAAA1wEAALUAAAAyBAAAAAAAAFEAAAAfAAAA8CMA
AOIDAAAAAAAAcAQAAGIAAAABAAAAUgAAAAYAAABTdGFrZTrwIwAAsgQAAAAAAAByAAAALAAAACwA
AAAAAAAAAQAAAP/////////////////////rAAAAWgAAABMBAABpAAAAygAAAAAAAADQAAAA8AQA
AAAFAAAAAAAAEwAAABIFAAAAAAAAMAUAAMf+//9QBQAAUQAAAHAFAAC1AAAAkAUAAB8AAADqAAAA
AAAAAAABAABiAAAAFAAAADAKAABSAAAABQAAAGdyYXBooAwAAFIAAAAGAAAAcHJvZml0kA4AAFIA
AAAHAAAAY3VtT2Rkc/APAABSAAAABgAAAHBheU91dJAWAABSAAAAAwAAAHBvdCAVAABSAAAACQAA
AHVuaXRTdGFrZfAXAABSAAAABAAAAGRpdmlgGQAAUgAAAAUAAABsaW5lc5AiAABSAAAACgAAAHRv
dGFsTGluZXMgIQAAUgAAAAoAAAB0b3RhbFN0YWtlAAAAAKIDAAAAAAAAygAAAAAAAADQAAAAYgAA
AAEAAADiAwAAAAAAAAAEAABiAAAAAgAAADIEAAAAAAAAAQAAAAEAAAAyBAAAAAAAABEDAACPBQAA
YAIAALIEAAAAAAAAcgAAACwAAAAsAAAAAAAAAAEAAAD/////////////////////AAAAAAAAAACI
AQAAxwIAAMoAAAAAAAAA0AAAAGIAAAATAAAAMAoAALAFAACQDgAAkCIAAJAWAACgEgAA8AgAAGAR
AADwIwAAIBUAACAhAACwBwAA4BMAABADAADwFwAA8A8AAKAMAACQHwAAYBkAAAAFAAAAAAAAEwAA
ABUAAAAQAAAA6gAAAAAAAAAAAQAA8AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAA
AAAAAAAAAAABAAAAAAAAAAAAAACiAwAAAAAAAMoAAAAAAAAA0AAAAGIAAAACAAAA4gMAAAAAAAAA
BAAAYgAAAAIAAAAyBAAAAAAAAAsAAAALAAAAMgQAAAAAAAAhAwAA0wUAAKABAADiAwAAAAAAALoA
AAAAAAAAUgAAAAgAAABtZW51QmFyOmIAAAABAAAAAAAAAKABAACyBAAAAAAAAHIAAAAsAAAALAAA
AAAAAAAAAAAA/////////////////////wUAAAAFAAAAlQEAAO4CAADKAAAAAAAAANAAAABiAAAA
AQAAAGACAAAABQAAAAAAABUAAABGBQQAAwAAAEljb24AAAAAAAAAABAAAAAOAhEAU1RCU2luZ2xl
dG9uUHJveHkAAAAAmgAAAAAAAABSAAAABwAAAERvbHBoaW5SAAAAGAAAAEltYWdlUmVsYXRpdmVG
aWxlTG9jYXRvcroAAAAAAAAAUgAAAAcAAABjdXJyZW50UgAAAA0AAABTaGVsbFZpZXcuaWNvDgIf
AFNUQkV4dGVybmFsUmVzb3VyY2VMaWJyYXJ5UHJveHkAAAAAUgAAABAAAABkb2xwaGluZHIwMDUu
ZGxsAAAAAA=='))!

(ResourceIdentifier class: HRMtgDashboardPresenter name: 'Old Limited view') assign: (Object fromBinaryStoreBytes:
(ByteArray fromBase64String: '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
AAAAALoAAAAAAAAAUgAAAA8AAABmaXhlZFBhcmVudExlZnQBAAAAsAUAAP3////QBQAAzQEAALoA
AAAAAAAAUgAAABEAAABmaXhlZFBhcmVudEJvdHRvbf////+aAQAAAAAAAJoAAAAAAAAAwAEAAFIA
AAAKAAAAUHVzaEJ1dHRvbmIAAAARAAAAAAAAAGACAABiAAAAAgAAAIIAAAAEAAAAACABRAEAAABA
EgAAAAAAAAAAAAAAAAAABwAAAAAAAAAAAAAAAAAAAEASAAAAAAAAggAAAAgAAABxBv//AAAAAJIM
AAAAAAAAugAAAAAAAABSAAAABwAAAHJlZnJlc2hSAAAABwAAAFJlZnJlc2gBAAAAAQAAAAAAAAAA
AAAAAQAAALIDAAAAAAAAygAAAAAAAADQAAAAYgAAAAMAAADyAwAAAAAAABAEAABiAAAAAgAAAEIE
AAAAAAAA1wEAAIcBAABCBAAAAAAAAC0BAAA9AAAAQBIAAPIDAAAAAAAAugAAAAAAAABSAAAACgAA
AGlzRW5hYmxlZDpiAAAAAQAAACAAAABAEgAA8gMAAAAAAAAgBwAAYgAAAAEAAABSAAAABwAAAFJl
ZnJlc2hAEgAAEgUAAAAAAAByAAAALAAAACwAAAAAAAAAAQAAAP/////////////////////rAAAA
wwAAAIEBAADhAAAAygAAAAAAAADQAAAAUAUAAGAFAAAAAAAAEwAAAHIFAAAAAAAAkAUAANX+//+w
BQAA8////9AFAACHAQAA8AUAAD0AAACaAQAAAAAAACAGAABiAAAAEAAAAAAAAABgAgAAYgAAAAIA
AACCAAAABAAAAAABAEQBAAAAEBQAAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAQFAAAAAAA
AIIAAAAIAAAAWQX//wAAAACCBgAAAAAAAAAAAAAAAAAAAAAAALIDAAAAAAAAygAAAAAAAADQAAAA
YgAAAAIAAADyAwAAAAAAABAEAABiAAAAAgAAAEIEAAAAAAAA1wEAALUAAABCBAAAAAAAAEcAAAAf
AAAAEBQAAPIDAAAAAAAAIAcAAGIAAAABAAAAUgAAAAUAAABEaXZpOhAUAAASBQAAAAAAAHIAAAAs
AAAALAAAAAAAAAABAAAA/////////////////////+sAAABaAAAADgEAAGkAAADKAAAAAAAAANAA
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
AABKAQAAUAAAAMoAAAAAAAAA0AAAAFAFAABgBQAAAAAAABMAAAByBQAAAAAAAJAFAACd////sAUA
AIX////QBQAAeQAAAPAFAAApAAAAmgEAAAAAAAAgAwAAYgAAABAAAAAAAAAAYAIAAGIAAAACAAAA
ggAAAAQAAACAAABEAQQAAJAbAAAAAAAAAAAAAAAAAAAHAAAAAAAAAAAAAAAAAAAAkBsAAAAAAACC
AAAACAAAAI8F//8AAAAAggYAAAAAAAAAAAAAAAAAAAMAAACyAwAAAAAAAMoAAAAAAAAA0AAAAGIA
AAADAAAA8gMAAAAAAAAQBAAAYgAAAAIAAABCBAAAAAAAADECAAAVAAAAQgQAAAAAAADTAAAAKQAA
AJAbAADyAwAAAAAAAIAEAABiAAAAAQAAALIEAAAAAAAAAwAAAAEAAAADAAAAkBsAAPIDAAAAAAAA
4AQAAGIAAAABAAAAIAAAAJAbAAASBQAAAAAAAHIAAAAsAAAALAAAAAAAAAABAAAA////////////
/////////xgBAAAKAAAAgQEAAB4AAADKAAAAAAAAANAAAABQBQAAYAUAAAAAAAATAAAAcgUAAAAA
AACQBQAAL////7AFAADz////0AUAABUAAADwBQAAKQAAAJoBAAAAAAAAIAMAAGIAAAAQAAAAAAAA
AGACAABiAAAAAgAAAIIAAAAEAAAAgAAARAEEAADwHAAAAAAAAAAAAAAAAAAABwAAAAAAAAAAAAAA
AAAAAPAcAAAAAAAAggAAAAgAAACPBf//AAAAAIIGAAAAAAAAAAAAAAAAAAADAAAAsgMAAAAAAADK
AAAAAAAAANAAAABiAAAAAwAAAPIDAAAAAAAAEAQAAGIAAAACAAAAQgQAAAAAAABtAgAARwAAAEIE
AAAAAAAAlwAAACkAAADwHAAA8gMAAAAAAACABAAAYgAAAAEAAACyBAAAAAAAAAMAAAABAAAAAwAA
APAcAADyAwAAAAAAAOAEAABiAAAAAQAAACAAAADwHAAAEgUAAAAAAAByAAAALAAAACwAAAAAAAAA
AQAAAP////////////////////82AQAAIwAAAIEBAAA3AAAAygAAAAAAAADQAAAAUAUAAGAFAAAA
AAAAEwAAAHIFAAAAAAAAkAUAAGv///+wBQAA8////9AFAABHAAAA8AUAACkAAACaAQAAAAAAACAD
AABiAAAAEAAAAAAAAABgAgAAYgAAAAIAAACCAAAABAAAAAAAAEQBBAAAUB4AAAAAAAAAAAAAAAAA
AAcAAAAAAAAAAAAAAAAAAABQHgAAAAAAAIIAAAAIAAAAjwX//wAAAACCAwAAAAAAAAAAAABSAAAA
AAAAAAAAAAADAAAAsgMAAAAAAADKAAAAAAAAANAAAABiAAAAAwAAAPIDAAAAAAAAEAQAAGIAAAAC
AAAAQgQAAAAAAABtAgAAqwAAAEIEAAAAAAAAlwAAACkAAABQHgAA8gMAAAAAAACABAAAYgAAAAEA
AACyBAAAAAAAAAMAAAABAAAAAwAAAFAeAADyAwAAAAAAAOAEAABiAAAAAQAAACAAAABQHgAAEgUA
AAAAAAByAAAALAAAACwAAAAAAAAAAQAAAP////////////////////82AQAAVQAAAIEBAABpAAAA
ygAAAAAAAADQAAAAUAUAAGAFAAAAAAAAEwAAAHIFAAAAAAAAkAUAAGv///+wBQAA8////9AFAACr
AAAA8AUAACkAAACaAQAAAAAAACAGAABiAAAAEAAAAAAAAABgAgAAYgAAAAIAAACCAAAABAAAAAAB
AEQBAAAAwB8AAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAAAAAAAADAHwAAAAAAAIIAAAAIAAAAWQX/
/wAAAACCBgAAAAAAAAAAAAAAAAAAAAAAALIDAAAAAAAAygAAAAAAAADQAAAAYgAAAAIAAADyAwAA
AAAAABAEAABiAAAAAgAAAEIEAAAAAAAA1wEAAIMAAABCBAAAAAAAAFEAAAAfAAAAwB8AAPIDAAAA
AAAAIAcAAGIAAAABAAAAUgAAAAYAAABTdGFrZTrAHwAAEgUAAAAAAAByAAAALAAAACwAAAAAAAAA
AQAAAP/////////////////////rAAAAQQAAABMBAABQAAAAygAAAAAAAADQAAAAUAUAAGAFAAAA
AAAAEwAAAHIFAAAAAAAAsAUAAMf+//+gBwAAUQAAANAFAACDAAAA8AUAAB8AAACaAQAAAAAAAFAS
AABiAAAAEQAAAAAAAABgAgAAYgAAAAIAAACCAAAABAAAAAAgAUQBAAAAACEAAAAAAAAAAAAAAAAA
AAcAAAAAAAAAAAAAAAAAAAAAIQAAAAAAAIIAAAAIAAAAcQb//wAAAACSDAAAAAAAALoAAAAAAAAA
UgAAABIAAABvcGVuRXN0aW1hdGVXaW5kb3dSAAAACAAAAEVzdGltYXRlAQAAAAEAAAAAAAAAAAAA
AAEAAACyAwAAAAAAAMoAAAAAAAAA0AAAAGIAAAADAAAA8gMAAAAAAAAQBAAAYgAAAAIAAABCBAAA
AAAAANcBAABBAQAAQgQAAAAAAAAtAQAAPQAAAAAhAADyAwAAAAAAAHATAABiAAAAAQAAACAAAAAA
IQAA8gMAAAAAAAAgBwAAYgAAAAEAAABSAAAACAAAAEVzdGltYXRlACEAABIFAAAAAAAAcgAAACwA
AAAsAAAAAAAAAAEAAAD/////////////////////6wAAAKAAAACBAQAAvgAAAMoAAAAAAAAA0AAA
AFAFAABgBQAAAAAAABMAAAByBQAAAAAAAJAFAADV/v//sAUAAPP////QBQAAQQEAAPAFAAA9AAAA
6gAAAAAAAAAAAQAAYgAAABIAAADwHAAAUgAAAAoAAAB0b3RhbExpbmVzUB4AAFIAAAAEAAAAZGl2
aSAaAABSAAAACQAAAHVuaXRTdGFrZcAHAABSAAAACgAAAHRvdGFsU3Rha2WQGwAAUgAAAAMAAABw
b3RwCgAAUgAAAAYAAABwYXlPdXTQFwAAUgAAAAUAAABncmFwaOALAABSAAAABQAAAGxpbmVzEAMA
AFIAAAAGAAAAcHJvZml0AAAAALIDAAAAAAAAygAAAAAAAADQAAAAYgAAAAEAAADyAwAAAAAAABAE
AABiAAAAAgAAAEIEAAAAAAAAAQAAAAEAAABCBAAAAAAAABEDAACPBQAAYAIAABIFAAAAAAAAcgAA
ACwAAAAsAAAAAAAAAAEAAAD/////////////////////AAAAAAAAAACIAQAAxwIAAMoAAAAAAAAA
0AAAAGIAAAARAAAA0BcAAEASAADwHAAAkBsAABAGAACQFgAAwB8AACAaAADABwAAEBQAAFAVAAAw
CQAAUB4AAHAKAAAQAwAAACEAAOALAABgBQAAAAAAABMAAAAVAAAAEAAAAOoAAAAAAAAAAAEAAFAF
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAsgMA
AAAAAADKAAAAAAAAANAAAABiAAAAAgAAAPIDAAAAAAAAEAQAAGIAAAACAAAAQgQAAAAAAAALAAAA
CwAAAEIEAAAAAAAAIQMAANMFAACgAQAA8gMAAAAAAAC6AAAAAAAAAFIAAAAIAAAAbWVudUJhcjpi
AAAAAQAAAAAAAACgAQAAEgUAAAAAAAByAAAALAAAACwAAAAAAAAAAAAAAP//////////////////
//8FAAAABQAAAJUBAADuAgAAygAAAAAAAADQAAAAYgAAAAEAAABgAgAAYAUAAAAAAAAVAAAARgUE
AAMAAABJY29uAAAAAAAAAAAQAAAADgIRAFNUQlNpbmdsZXRvblByb3h5AAAAAJoAAAAAAAAAUgAA
AAcAAABEb2xwaGluUgAAABgAAABJbWFnZVJlbGF0aXZlRmlsZUxvY2F0b3K6AAAAAAAAAFIAAAAH
AAAAY3VycmVudFIAAAANAAAAU2hlbGxWaWV3Lmljbw4CHwBTVEJFeHRlcm5hbFJlc291cmNlTGli
cmFyeVByb3h5AAAAAFIAAAAQAAAAZG9scGhpbmRyMDA1LmRsbAAAAAA='))!

(ResourceIdentifier class: HRPPSlipPresenter name: 'Default view') assign: (Object fromBinaryStoreBytes:
(ByteArray fromBase64String: 'IVNUQiAxIEYCDAABAAAAVmlld1Jlc291cmNlAAAAAA4BJABTVEJSZXNvdXJjZVNUQkJ5dGVBcnJh
eUFjY2Vzc29yUHJveHkAAAAAcgAAAN4uAAAhU1RCIDEgTggMAAoAAABTVEJWaWV3UHJveHkAAAAA
mgAAAAAAAABSAAAAEAAAAERvbHBoaW4gTVZQIEJhc2VSAAAACQAAAFNoZWxsVmlld2IAAAAbAAAA
AAAAAAAAAABiAAAAAgAAAAEAnAEBAAIAoAEAAAAAAAAGAQsAU3lzdGVtQ29sb3IAAAAAHwAAAAYC
BQBQb2ludAAAAAC3AwAATwIAAAcAAAAAAAAAAAAAAAAAAACgAQAAAAAAAOoAAAAAAAAAAAEAAGIA
AAAaAAAAmgEAAAAAAACaAAAAAAAAAMABAABSAAAACAAAAFRleHRFZGl0YgAAABAAAAAAAAAAoAEA
AGIAAAACAAAAggAAAAQAAAAAAAFEAQQAAGACAAAAAAAAAAAAAAAAAAAHAAAAAAAAAAAAAAAAAAAA
YAIAAAAAAACCAAAACAAAAKEF//8AAAAABgMMAE51bWJlclRvVGV4dAAAAAAAAAAAUgAAAAAAAAAA
AAAAAQAAAAYBDwBNZXNzYWdlU2VxdWVuY2UAAAAAygAAAAAAAADQAAAAYgAAAAMAAAAGAwsATWVz
c2FnZVNlbmQAAAAAugAAAAAAAABSAAAAEAAAAGNyZWF0ZUF0OmV4dGVudDpiAAAAAgAAACICAAAA
AAAAFwMAACkAAAAiAgAAAAAAAFEAAAApAAAAYAIAAEIDAAAAAAAAugAAAAAAAABSAAAADwAAAHNl
bGVjdGlvblJhbmdlOmIAAAABAAAABgMIAEludGVydmFsAAAAAAMAAAABAAAAAwAAAGACAABCAwAA
AAAAALoAAAAAAAAAUgAAAA8AAABpc1RleHRNb2RpZmllZDpiAAAAAQAAACAAAABgAgAABgEPAFdJ
TkRPV1BMQUNFTUVOVAAAAAByAAAALAAAACwAAAAAAAAAAQAAAP////////////////////+LAQAA
FAAAALMBAAAoAAAAygAAAAAAAADQAAAAYgAAAAAAAAAiAgAAAAAAAMEAAADBAAAAAAAAABMAAABS
AAAACQAAAHVuaXRTdGFrZZoBAAAAAAAAcAIAAGIAAAAQAAAAAAAAAKABAABiAAAAAgAAAIIAAAAE
AAAAACABRAEEAADABAAAAAAAAAAAAAAAAAAABwAAAAAAAAAAAAAAAAAAAMAEAAAAAAAAggAAAAgA
AAChBf//AAAAAAYDDQBJbnRlZ2VyVG9UZXh0AAAAAAAAAABSAAAAAAAAAAAAAAABAAAAAgMAAAAA
AADKAAAAAAAAANAAAABiAAAABAAAAEIDAAAAAAAAYAMAAGIAAAACAAAAIgIAAAAAAACLAgAA3QAA
ACICAAAAAAAAjQAAACkAAADABAAAQgMAAAAAAAC6AAAAAAAAAFIAAAAKAAAAaXNFbmFibGVkOmIA
AAABAAAAIAAAAMAEAABCAwAAAAAAAMADAABiAAAAAQAAAPIDAAAAAAAAAwAAAAEAAAADAAAAwAQA
AEIDAAAAAAAAIAQAAGIAAAABAAAAIAAAAMAEAABSBAAAAAAAAHIAAAAsAAAALAAAAAAAAAABAAAA
/////////////////////0UBAABuAAAAiwEAAIIAAADKAAAAAAAAANAAAACQBAAAoAQAAAAAAAAT
AAAAUgAAAAQAAABkaXZpmgEAAAAAAABwAgAAYgAAABAAAAAAAAAAoAEAAGIAAAACAAAAggAAAAQA
AAAAAAFEAQQAAIAGAAAAAAAAAAAAAAAAAAAHAAAAAAAAAAAAAAAAAAAAgAYAAAAAAACCAAAACAAA
AKEF//8AAAAA0gIAAAAAAAAAAAAAUgAAAAAAAAAAAAAAAQAAAAIDAAAAAAAAygAAAAAAAADQAAAA
YgAAAAQAAABCAwAAAAAAAGADAABiAAAAAgAAACICAAAAAAAAiwIAAFUBAAAiAgAAAAAAAI0AAAAp
AAAAgAYAAEIDAAAAAAAAwAUAAGIAAAABAAAAIAAAAIAGAABCAwAAAAAAAMADAABiAAAAAQAAAPID
AAAAAAAAAwAAAAEAAAADAAAAgAYAAEIDAAAAAAAAIAQAAGIAAAABAAAAIAAAAIAGAABSBAAAAAAA
AHIAAAAsAAAALAAAAAAAAAABAAAA/////////////////////0UBAACqAAAAiwEAAL4AAADKAAAA
AAAAANAAAACQBAAAoAQAAAAAAAATAAAAUgAAAAYAAABwcm9maXSaAQAAAAAAAHACAABiAAAAEAAA
AAAAAACgAQAAYgAAAAIAAACCAAAABAAAAIAAAUQBBAAAEAgAAAAAAAAAAAAAAAAAAAcAAAAAAAAA
AAAAAAAAAAAQCAAAAAAAAIIAAAAIAAAAoQX//wAAAAAGAg0ATnVsbENvbnZlcnRlcgAAAAAAAAAA
AAAAAAEAAAACAwAAAAAAAMoAAAAAAAAA0AAAAGIAAAADAAAAQgMAAAAAAABgAwAAYgAAAAIAAAAi
AgAAAAAAALUAAABVAQAAIgIAAAAAAADdAAAAKQAAABAIAABCAwAAAAAAAMADAABiAAAAAQAAAPID
AAAAAAAAAwAAAAEAAAADAAAAEAgAAEIDAAAAAAAAIAQAAGIAAAABAAAAIAAAABAIAABSBAAAAAAA
AHIAAAAsAAAALAAAAAAAAAABAAAA/////////////////////1oAAACqAAAAyAAAAL4AAADKAAAA
AAAAANAAAACQBAAAoAQAAAAAAAATAAAAUgAAAAQAAABsZWc2mgEAAAAAAABwAgAAYgAAABAAAAAA
AAAAoAEAAGIAAAACAAAAggAAAAQAAAAAAAFEAQQAAIAJAAAAAAAAAAAAAAAAAAAHAAAAAAAAAAAA
AAAAAAAAgAkAAAAAAACCAAAACAAAAKEF//8AAAAA0gIAAAAAAAAAAAAAUgAAAAAAAAAAAAAAAQAA
AAIDAAAAAAAAygAAAAAAAADQAAAAYgAAAAQAAABCAwAAAAAAAGADAABiAAAAAgAAACICAAAAAAAA
iwIAAKEAAAAiAgAAAAAAAFEAAAApAAAAgAkAAEIDAAAAAAAAwAUAAGIAAAABAAAAIAAAAIAJAABC
AwAAAAAAAMADAABiAAAAAQAAAPIDAAAAAAAAAwAAAAEAAAADAAAAgAkAAEIDAAAAAAAAIAQAAGIA
AAABAAAAIAAAAIAJAABSBAAAAAAAAHIAAAAsAAAALAAAAAAAAAABAAAA////////////////////
/0UBAABQAAAAbQEAAGQAAADKAAAAAAAAANAAAACQBAAAoAQAAAAAAAATAAAAUgAAAAwAAAB3aW5u
aW5nTGluZXOaAQAAAAAAAHACAABiAAAAEAAAAAAAAACgAQAAYgAAAAIAAACCAAAABAAAAIAAAUQB
BAAAEAsAAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAQCwAAAAAAAIIAAAAIAAAAoQX//wAA
AABiCAAAAAAAAAAAAAAAAAAAAQAAAAIDAAAAAAAAygAAAAAAAADQAAAAYgAAAAMAAABCAwAAAAAA
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
iwEAAKAAAADKAAAAAAAAANAAAACQBAAAoAQAAAAAAAATAAAAUgAAAAYAAABwYXlPdXSaAQAAAAAA
AHACAABiAAAAEAAAAAAAAACgAQAAYgAAAAIAAACCAAAABAAAAIAAAUQBBAAAgBIAAAAAAAAAAAAA
AAAAAAcAAAAAAAAAAAAAAAAAAACAEgAAAAAAAIIAAAAIAAAAoQX//wAAAABiCAAAAAAAAAAAAAAA
AAAAAQAAAAIDAAAAAAAAygAAAAAAAADQAAAAYgAAAAMAAABCAwAAAAAAAGADAABiAAAAAgAAACIC
AAAAAAAAtQAAAGUAAAAiAgAAAAAAAN0AAAApAAAAgBIAAEIDAAAAAAAAwAMAAGIAAAABAAAA8gMA
AAAAAAADAAAAAQAAAAMAAACAEgAAQgMAAAAAAAAgBAAAYgAAAAEAAAAgAAAAgBIAAFIEAAAAAAAA
cgAAACwAAAAsAAAAAAAAAAEAAAD/////////////////////WgAAADIAAADIAAAARgAAAMoAAAAA
AAAA0AAAAJAEAACgBAAAAAAAABMAAABSAAAABAAAAGxlZzKaAQAAAAAAAHACAABiAAAAEAAAAAAA
AACgAQAAYgAAAAIAAACCAAAABAAAAIAAAUQBBAAA4BMAAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAA
AAAAAADgEwAAAAAAAIIAAAAIAAAAoQX//wAAAABiCAAAAAAAAAAAAAAAAAAAAQAAAAIDAAAAAAAA
ygAAAAAAAADQAAAAYgAAAAMAAABCAwAAAAAAAGADAABiAAAAAgAAACICAAAAAAAAtQAAAKEAAAAi
AgAAAAAAAN0AAAApAAAA4BMAAEIDAAAAAAAAwAMAAGIAAAABAAAA8gMAAAAAAAADAAAAAQAAAAMA
AADgEwAAQgMAAAAAAAAgBAAAYgAAAAEAAAAgAAAA4BMAAFIEAAAAAAAAcgAAACwAAAAsAAAAAAAA
AAEAAAD/////////////////////WgAAAFAAAADIAAAAZAAAAMoAAAAAAAAA0AAAAJAEAACgBAAA
AAAAABMAAABSAAAABAAAAGxlZzOaAQAAAAAAAHACAABiAAAAEAAAAAAAAACgAQAAYgAAAAIAAACC
AAAABAAAAIAAAUQBBAAAQBUAAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAAAAAAAABAFQAAAAAAAIIA
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
AABSBAAAAAAAAHIAAAAsAAAALAAAAAAAAAABAAAA//////////////////////AAAAAyAAAALAEA
AEYAAADKAAAAAAAAANAAAACQBAAAoAQAAAAAAAATAAAAcAwAAJoBAAAAAAAAwBcAAGIAAAAQAAAA
AAAAAKABAABiAAAAAgAAAIIAAAAEAAAAAAEARAEAAACgIgAAAAAAAAAAAAAAAAAABwAAAAAAAAAA
AAAAAAAAAKAiAAAAAAAAggAAAAgAAADbBf//AAAAAGIIAAAAAAAAAAAAAAAAAAAAAAAAAgMAAAAA
AADKAAAAAAAAANAAAABiAAAAAgAAAEIDAAAAAAAAYAMAAGIAAAACAAAAIgIAAAAAAADhAQAAoQAA
ACICAAAAAAAAjQAAACkAAACgIgAAQgMAAAAAAACwGAAAYgAAAAEAAABSAAAADgAAAFdpbm5pbmcg
bGluZXM6oCIAAFIEAAAAAAAAcgAAACwAAAAsAAAAAAAAAAEAAAD/////////////////////8AAA
AFAAAAA2AQAAZAAAAMoAAAAAAAAA0AAAAJAEAACgBAAAAAAAABMAAACACQAAmgEAAAAAAADAFwAA
YgAAABAAAAAAAAAAoAEAAGIAAAACAAAAggAAAAQAAAAAAQBEAQAAANAjAAAAAAAAAAAAAAAAAAAH
AAAAAAAAAAAAAAAAAAAA0CMAAAAAAACCAAAACAAAANsF//8AAAAAYggAAAAAAAAAAAAAAAAAAAAA
AAACAwAAAAAAAMoAAAAAAAAA0AAAAGIAAAACAAAAQgMAAAAAAABgAwAAYgAAAAIAAAAiAgAAAAAA
AOEBAADdAAAAIgIAAAAAAAB5AAAAKQAAANAjAABCAwAAAAAAALAYAABiAAAAAQAAAFIAAAAFAAAA
RGl2aTrQIwAAUgQAAAAAAAByAAAALAAAACwAAAAAAAAAAQAAAP/////////////////////wAAAA
bgAAACwBAACCAAAAygAAAAAAAADQAAAAkAQAAKAEAAAAAAAAEwAAAMAEAACaAQAAAAAAAMAXAABi
AAAAEAAAAAAAAACgAQAAYgAAAAIAAACCAAAABAAAAAABAEQBAAAAACUAAAAAAAAAAAAAAAAAAAcA
AAAAAAAAAAAAAAAAAAAAJQAAAAAAAIIAAAAIAAAA2wX//wAAAABiCAAAAAAAAAAAAAAAAAAAAAAA
AAIDAAAAAAAAygAAAAAAAADQAAAAYgAAAAIAAABCAwAAAAAAAGADAABiAAAAAgAAACICAAAAAAAA
4QEAABkBAAAiAgAAAAAAAHkAAAApAAAAACUAAEIDAAAAAAAAsBgAAGIAAAABAAAAUgAAAAcAAABQ
YXlvdXQ6ACUAAFIEAAAAAAAAcgAAACwAAAAsAAAAAAAAAAEAAAD/////////////////////8AAA
AIwAAAAsAQAAoAAAAMoAAAAAAAAA0AAAAJAEAACgBAAAAAAAABMAAADwEAAAmgEAAAAAAADAFwAA
YgAAABAAAAAAAAAAoAEAAGIAAAACAAAAggAAAAQAAAAAAQBEAQAAADAmAAAAAAAAAAAAAAAAAAAH
AAAAAAAAAAAAAAAAAAAAMCYAAAAAAACCAAAACAAAANsF//8AAAAAYggAAAAAAAAAAAAAAAAAAAAA
AAACAwAAAAAAAMoAAAAAAAAA0AAAAGIAAAACAAAAQgMAAAAAAABgAwAAYgAAAAIAAAAiAgAAAAAA
AOEBAABVAQAAIgIAAAAAAAB5AAAAKQAAADAmAABCAwAAAAAAALAYAABiAAAAAQAAAFIAAAAHAAAA
UHJvZml0OjAmAABSBAAAAAAAAHIAAAAsAAAALAAAAAAAAAABAAAA//////////////////////AA
AACqAAAALAEAAL4AAADKAAAAAAAAANAAAACQBAAAoAQAAAAAAAATAAAAgAYAAJoBAAAAAAAAmgAA
AAAAAADAAQAAUgAAAAgAAABHcm91cEJveGIAAAAOAAAAAAAAAKABAABiAAAAAgAAAIIAAAAEAAAA
BwAAREEAAABgJwAAAAAAAAAAAAAAAAAABwAAAAAAAAAAAAAAAAAAAGAnAAAAAAAAggAAAAgAAACN
Bf//AAAAAAIDAAAAAAAAygAAAAAAAADQAAAAYgAAAAEAAABCAwAAAAAAAGADAABiAAAAAgAAACIC
AAAAAAAAFQAAAAsAAAAiAgAAAAAAAJsBAACRAQAAYCcAAFIEAAAAAAAAcgAAACwAAAAsAAAAAAAA
AAEAAAD/////////////////////CgAAAAUAAADXAAAAzQAAAMoAAAAAAAAA0AAAAJAEAACgBAAA
AAAAABMAAACaAQAAAAAAAHAnAABiAAAADgAAAAAAAACgAQAAYgAAAAIAAACCAAAABAAAAAcAAERB
AAAAcCgAAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAAAAAAAABwKAAAAAAAAIIAAAAIAAAAjQX//wAA
AAACAwAAAAAAAMoAAAAAAAAA0AAAAGIAAAABAAAAQgMAAAAAAABgAwAAYgAAAAIAAAAiAgAAAAAA
AM0BAAALAAAAIgIAAAAAAADDAQAAkQEAAHAoAABSBAAAAAAAAHIAAAAsAAAALAAAAAAAAAABAAAA
/////////////////////+YAAAAFAAAAxwEAAM0AAADKAAAAAAAAANAAAACQBAAAoAQAAAAAAAAT
AAAAmgEAAAAAAACaAAAAAAAAAMABAABSAAAACgAAAFB1c2hCdXR0b25iAAAAEQAAAAAAAACgAQAA
YgAAAAIAAACCAAAABAAAAAAgAUQBAAAAYCkAAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAAAAAAAABg
KQAAAAAAAIIAAAAIAAAAjQX//wAAAABGBRIABAAAAENvbW1hbmREZXNjcmlwdGlvbgAAAAC6AAAA
AAAAAFIAAAANAAAAb3BlbkRhc2hib2FyZFIAAAAOAAAAT3BlbiBEYXNoYm9hcmQBAAAAAQAAAAAA
AAAAAAAAAQAAAAIDAAAAAAAAygAAAAAAAADQAAAAYgAAAAMAAABCAwAAAAAAAGADAABiAAAAAgAA
ACICAAAAAAAAzQEAALkBAAAiAgAAAAAAAMkAAAA9AAAAYCkAAEIDAAAAAAAAwAUAAGIAAAABAAAA
IAAAAGApAABCAwAAAAAAALAYAABiAAAAAQAAAFIAAAAOAAAAT3BlbiBEYXNoYm9hcmRgKQAAUgQA
AAAAAAByAAAALAAAACwAAAAAAAAAAQAAAP/////////////////////mAAAA3AAAAEoBAAD6AAAA
ygAAAAAAAADQAAAAkAQAAKAEAAAAAAAAEwAAAJoBAAAAAAAAcCkAAGIAAAARAAAAAAAAAKABAABi
AAAAAgAAAIIAAAAEAAAAACABRAEAAAAQKwAAAAAAAAAAAAAAAAAABwAAAAAAAAAAAAAAAAAAABAr
AAAAAAAAggAAAAgAAACNBf//AAAAANIpAAAAAAAAugAAAAAAAABSAAAABwAAAHJlZnJlc2hSAAAA
BwAAAFJlZnJlc2gBAAAAAQAAAAAAAAAAAAAAAwAAAAIDAAAAAAAAygAAAAAAAADQAAAAYgAAAAMA
AABCAwAAAAAAAGADAABiAAAAAgAAACICAAAAAAAAxwIAALkBAAAiAgAAAAAAAMkAAAA9AAAAECsA
AEIDAAAAAAAAwAUAAGIAAAABAAAAIAAAABArAABCAwAAAAAAALAYAABiAAAAAQAAAFIAAAAHAAAA
UmVmcmVzaBArAABSBAAAAAAAAHIAAAAsAAAALAAAAAAAAAABAAAA/////////////////////2MB
AADcAAAAxwEAAPoAAADKAAAAAAAAANAAAACQBAAAoAQAAAAAAAATAAAAoAQAAAAAAAAVAAAARgUE
AAMAAABJY29uAAAAAAAAAAAQAAAADgIRAFNUQlNpbmdsZXRvblByb3h5AAAAAJoAAAAAAAAAUgAA
AAcAAABEb2xwaGluUgAAABgAAABJbWFnZVJlbGF0aXZlRmlsZUxvY2F0b3K6AAAAAAAAAFIAAAAH
AAAAY3VycmVudFIAAAANAAAAU2hlbGxWaWV3Lmljbw4CHwBTVEJFeHRlcm5hbFJlc291cmNlTGli
cmFyeVByb3h5AAAAAFIAAAAQAAAAZG9scGhpbmRyMDA1LmRsbAAAAAA='))!

(ResourceIdentifier class: HRPPSlipTextPresenter name: 'Default view') assign: (Object fromBinaryStoreBytes:
(ByteArray fromBase64String: 'IVNUQiAxIEYCDAABAAAAVmlld1Jlc291cmNlAAAAAA4BJABTVEJSZXNvdXJjZVNUQkJ5dGVBcnJh
eUFjY2Vzc29yUHJveHkAAAAAcgAAAH4EAAAhU1RCIDEgTggMAAoAAABTVEJWaWV3UHJveHkAAAAA
mgAAAAAAAABSAAAAEAAAAERvbHBoaW4gTVZQIEJhc2VSAAAACQAAAFNoZWxsVmlld2IAAAAbAAAA
AAAAAAAAAABiAAAAAgAAAAEAngEBAAIAoAEAAAAAAAAAAAAABgIFAFBvaW50AAAAACEDAAAJBwAA
BwAAAAAAAAAAAAAAAAAAAKABAAAGAhIAUHJvcG9ydGlvbmFsTGF5b3V0AAAAAOoAAAAAAAAA8AAA
AGIAAAAAAAAAIAAAAOoAAAAAAAAAAAEAAGIAAAACAAAAmgEAAAAAAACaAAAAAAAAAMABAABSAAAA
EQAAAE11bHRpbGluZVRleHRFZGl0YgAAABAAAAAAAAAAoAEAAGIAAAACAAAAggAAAAQAAABEESFE
AQQAAIACAAAAAAAAAAAAAAAAAAAHAAAAAAAAAAAAAAAAAAAAgAIAAAAAAACCAAAACAAAAI8F//8A
AAAABgINAE51bGxDb252ZXJ0ZXIAAAAAAAAAAAAAAAAJAAAABgEPAE1lc3NhZ2VTZXF1ZW5jZQAA
AADKAAAAAAAAANAAAABiAAAAAwAAAAYDCwBNZXNzYWdlU2VuZAAAAAC6AAAAAAAAAFIAAAAQAAAA
Y3JlYXRlQXQ6ZXh0ZW50OmIAAAACAAAAAgIAAAAAAAABAAAAAQAAAAICAAAAAAAAQwMAAMUGAACA
AgAAUgMAAAAAAAC6AAAAAAAAAFIAAAAPAAAAc2VsZWN0aW9uUmFuZ2U6YgAAAAEAAAAGAwgASW50
ZXJ2YWwAAAAAAwAAAAEAAAADAAAAgAIAAFIDAAAAAAAAugAAAAAAAABSAAAADwAAAGlzVGV4dE1v
ZGlmaWVkOmIAAAABAAAAIAAAAIACAAAGAQ8AV0lORE9XUExBQ0VNRU5UAAAAAHIAAAAsAAAALAAA
AAAAAAABAAAA/////////////////////wAAAAAAAAAAoQEAAGIDAADKAAAAAAAAANAAAABQAgAA
AgIAAAAAAADBAAAAwQAAAAAAAAATAAAAUgAAAAQAAAB0ZXh0AAAAAAAAAAAAAAAAAAAAAAAAAAAB
AAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAABIDAAAAAAAAygAAAAAAAADQAAAAYgAAAAMA
AABSAwAAAAAAAHADAABiAAAAAgAAAAICAAAAAAAAeQUAAAsAAAACAgAAAAAAAFMDAAAJBwAAoAEA
AFIDAAAAAAAAugAAAAAAAABSAAAABQAAAHRleHQ6YgAAAAEAAABSAAAADQAAAFBsYWNlcG90IFNs
aXCgAQAAUgMAAAAAAAC6AAAAAAAAAFIAAAAIAAAAbWVudUJhcjpiAAAAAQAAAAAAAACgAQAAYgQA
AAAAAAByAAAALAAAACwAAAAAAAAAAAAAAP////////////////////+8AgAABQAAAGUEAACJAwAA
ygAAAAAAAADQAAAAYgAAAAEAAACAAgAAoAQAAAAAAAAVAAAARgUEAAMAAABJY29uAAAAAAAAAAAQ
AAAADgIRAFNUQlNpbmdsZXRvblByb3h5AAAAAJoAAAAAAAAAUgAAAAcAAABEb2xwaGluUgAAABgA
AABJbWFnZVJlbGF0aXZlRmlsZUxvY2F0b3K6AAAAAAAAAFIAAAAHAAAAY3VycmVudFIAAAANAAAA
U2hlbGxWaWV3Lmljbw4CHwBTVEJFeHRlcm5hbFJlc291cmNlTGlicmFyeVByb3h5AAAAAFIAAAAQ
AAAAZG9scGhpbmRyMDA1LmRsbAAAAAA='))!

(ResourceIdentifier class: HRRacePresenter name: 'Default view') assign: (Object fromBinaryStoreBytes:
(ByteArray fromBase64String: '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
0gUAAAAAAAByAAAALAAAACwAAAAAAAAAAQAAAP////////////////////8aBAAADwAAAGUEAAAt
AAAAygAAAAAAAADQAAAAEAYAACAGAAAAAAAAEwAAADIGAAAAAAAAugAAAAAAAABSAAAADgAAAGZp
eGVkVmlld1JpZ2h0a////1AGAADf////kAYAAB8AAACwBgAAPQAAAJoBAAAAAAAAQAQAAGIAAAAQ
AAAAAAAAAKABAABiAAAAAgAAAIIAAAAEAAAAAAEARAEAAADACAAAAAAAAAAAAAAAAAAABwAAAAAA
AAAAAAAAAAAAAMAIAAAAAAAAggAAAAgAAABZBf//AAAAAKIEAAAAAAAAAAAAAAAAAAAAAAAAwgQA
AAAAAADKAAAAAAAAANAAAABiAAAAAgAAAAIFAAAAAAAAIAUAAGIAAAACAAAAUgUAAAAAAAAZBgAA
BwQAAFIFAAAAAAAAMwAAAB8AAADACAAAAgUAAAAAAACQBQAAYgAAAAEAAABSAAAABAAAAFBpY2vA
CAAA0gUAAAAAAAByAAAALAAAACwAAAAAAAAAAQAAAP////////////////////8MAwAAAwIAACUD
AAASAgAAygAAAAAAAADQAAAAEAYAACAGAAAAAAAAEwAAADIGAAAAAAAAugAAAAAAAABSAAAADwAA
AGZpeGVkUGFyZW50TGVmdBkGAABwBgAAMwAAALoAAAAAAAAAUgAAABEAAABmaXhlZFBhcmVudEJv
dHRvbZv///+wBgAAHwAAAJoBAAAAAAAAQAQAAGIAAAAQAAAAAAAAAKABAABiAAAAAgAAAIIAAAAE
AAAAAAEARAEAAABACgAAAAAAAAAAAAAAAAAABwAAAAAAAAAAAAAAAAAAAEAKAAAAAAAAggAAAAgA
AABZBf//AAAAAKIEAAAAAAAAAAAAAAAAAAAAAAAAwgQAAAAAAADKAAAAAAAAANAAAABiAAAAAgAA
AAIFAAAAAAAAIAUAAGIAAAACAAAAUgUAAAAAAAA/AwAAyQAAAFIFAAAAAAAAWwAAACkAAABACgAA
AgUAAAAAAACQBQAAYgAAAAEAAABSAAAACAAAAFJ1bm5lcnM6QAoAANIFAAAAAAAAcgAAACwAAAAs
AAAAAAAAAAEAAAD/////////////////////nwEAAGQAAADMAQAAeAAAAMoAAAAAAAAA0AAAABAG
AAAgBgAAAAAAABMAAAAyBgAAAAAAAAAKAAA/AwAAcAYAAFsAAACQBgAAyQAAALAGAAApAAAAmgEA
AAAAAACaAAAAAAAAAMABAABSAAAACAAAAFRleHRFZGl0YgAAABAAAAAAAAAAoAEAAGIAAAACAAAA
ggAAAAQAAACAAABEAQQAAIALAAAAAAAAAAAAAAAAAAAHAAAAAAAAAAAAAAAAAAAAgAsAAAAAAACC
AAAACAAAAI8F//8AAAAAogQAAAAAAAAAAAAAAAAAAAMAAADCBAAAAAAAAMoAAAAAAAAA0AAAAGIA
AAADAAAAAgUAAAAAAAAgBQAAYgAAAAIAAABSBQAAAAAAAGMCAAAvBAAAUgUAAAAAAAAFAQAAMwAA
AIALAAACBQAAAAAAALoAAAAAAAAAUgAAAA8AAABzZWxlY3Rpb25SYW5nZTpiAAAAAQAAAAYDCABJ
bnRlcnZhbAAAAAADAAAAAQAAAAMAAACACwAAAgUAAAAAAAC6AAAAAAAAAFIAAAAPAAAAaXNUZXh0
TW9kaWZpZWQ6YgAAAAEAAAAgAAAAgAsAANIFAAAAAAAAcgAAACwAAAAsAAAAAAAAAAEAAAD/////
////////////////MQEAABcCAACzAQAAMAIAAMoAAAAAAAAA0AAAABAGAAAgBgAAAAAAABMAAAAy
BgAAAAAAAAAKAABjAgAAcAYAAAUBAAAgCgAAw////7AGAAAzAAAAmgEAAAAAAACaAAAAAAAAAMAB
AABSAAAACAAAAENvbWJvQm94YgAAABEAAAAAAAAAoAEAAGIAAAACAAAAggAAAAQAAAADBjFEAQQA
AFANAABGAwkAAgAAAExpc3RNb2RlbAAAAADKAAAAAAAAANAAAAAQBgAAAAAAAA4CEQBTVEJTaW5n
bGV0b25Qcm94eQAAAACaAAAAAAAAAFIAAAAHAAAARG9scGhpblIAAAAMAAAAU2VhcmNoUG9saWN5
ugAAAAAAAABSAAAACAAAAGlkZW50aXR5AAAAAFIFAAAAAAAAQQYAALEEAAAHAgAAAAAAAAAAAAAA
AAAAUA0AAAAAAACCAAAACAAAAKkF//8AAAAABgQMAEJsb2NrQ2xvc3VyZQAAAAAmAw0ATWV0aG9k
Q29udGV4dAEAAAABAAAAJgUSAENvbXBpbGVkRXhwcmVzc2lvbgkAAACBAQAAmgAAAAAAAAAQDgAA
UgAAAA8AAABVbmRlZmluZWRPYmplY3RSAAAABAAAAGRvSXRiAAAAAgAAAFIAAACMAAAAWyA6ZWFj
aCB8IGVhY2ggbGVnIGRpc3BsYXlTdHJpbmcsICcgLSAnLCBlYWNoIHNob3J0MjRUaW1lLCAnIC0g
JywgZWFjaCBuYW1lLCAnIC0gJywgZWFjaCBkaXN0YW5jZSwgJyAtIHBsYWNlczogJywgZWFjaCBw
bGFjZXMgZGlzcGxheVN0cmluZ11iAAAAAQAAAMoAAAAAAAAAmgAAAAAAAAAQDgAAUgAAAA4AAABQ
b29sRGljdGlvbmFyeRAGAAByAAAAHwAAAPsBGgDRAJ6fH7ERorEfsRGjsR+xEaSxJLERpp+xamm6
AAAAAAAAAFIAAAADAAAAbGVnugAAAAAAAABSAAAADQAAAGRpc3BsYXlTdHJpbmdSAAAAAwAAACAt
ILoAAAAAAAAAUgAAAAEAAAAsugAAAAAAAABSAAAACwAAAHNob3J0MjRUaW1lugAAAAAAAABSAAAA
BAAAAG5hbWW6AAAAAAAAAFIAAAAIAAAAZGlzdGFuY2VSAAAACwAAACAtIHBsYWNlczogugAAAAAA
AABSAAAABgAAAHBsYWNlcwAAAAAAAAAAAwAAAAsAAADADgAAYgAAAAAAAACRAQAAwgQAAAAAAADK
AAAAAAAAANAAAABiAAAAAgAAAAIFAAAAAAAAIAUAAGIAAAACAAAAUgUAAAAAAACDAAAACwAAAFIF
AAAAAAAAvwUAACsAAABQDQAAAgUAAAAAAAC6AAAAAAAAAFIAAAAXAAAAYmFzaWNTZWxlY3Rpb25z
QnlJbmRleDpiAAAAAQAAAGIAAAAAAAAAUA0AANIFAAAAAAAAcgAAACwAAAAsAAAAAAAAAAEAAAD/
////////////////////QQAAAAUAAAAgAwAAGgAAAMoAAAAAAAAA0AAAABAGAAAgBgAAAAAAABMA
AAAyBgAAAAAAAAAKAACDAAAAUAYAAFX9//+QBgAACwAAALAGAAApAAAAmgEAAAAAAACQCwAAYgAA
ABAAAAAAAAAAoAEAAGIAAAACAAAAggAAAAQAAAAAIABEAQQAAIARAAAAAAAAAAAAAAAAAAAHAAAA
AAAAAAAAAAAAAAAAgBEAAAAAAACCAAAACAAAAI8F//8AAAAABgMNAEludGVnZXJUb1RleHQAAAAA
AAAAAFIAAAAAAAAAAAAAAAMAAADCBAAAAAAAAMoAAAAAAAAA0AAAAGIAAAADAAAAAgUAAAAAAAAg
BQAAYgAAAAIAAABSBQAAAAAAAKMDAADJAAAAUgUAAAAAAABRAAAAMwAAAIARAAACBQAAAAAAAIAM
AABiAAAAAQAAALIMAAAAAAAAAwAAAAEAAAADAAAAgBEAAAIFAAAAAAAA4AwAAGIAAAABAAAAIAAA
AIARAADSBQAAAAAAAHIAAAAsAAAALAAAAAAAAAABAAAA/////////////////////9EBAABkAAAA
+QEAAH0AAADKAAAAAAAAANAAAAAQBgAAIAYAAAAAAAATAAAAMgYAAAAAAAAACgAAowMAAHAGAABR
AAAAkAYAAMkAAACwBgAAMwAAAJoBAAAAAAAAkAsAAGIAAAAQAAAAAAAAAKABAABiAAAAAgAAAIIA
AAAEAAAAgAAARAEEAAAAEwAAAAAAAAAAAAAAAAAABwAAAAAAAAAAAAAAAAAAAAATAAAAAAAAggAA
AAgAAACPBf//AAAAAKIEAAAAAAAAAAAAAAAAAAADAAAAwgQAAAAAAADKAAAAAAAAANAAAABiAAAA
AwAAAAIFAAAAAAAAIAUAAGIAAAACAAAAUgUAAAAAAADDBgAAyQAAAFIFAAAAAAAAUQAAADMAAAAA
EwAAAgUAAAAAAACADAAAYgAAAAEAAACyDAAAAAAAAAMAAAABAAAAAwAAAAATAAACBQAAAAAAAOAM
AABiAAAAAQAAACAAAAAAEwAA0gUAAAAAAAByAAAALAAAACwAAAAAAAAAAQAAAP//////////////
//////9hAwAAZAAAAIkDAAB9AAAAygAAAAAAAADQAAAAEAYAACAGAAAAAAAAEwAAADIGAAAAAAAA
UAYAANf9//9wBgAAUQAAAJAGAADJAAAAsAYAADMAAACaAQAAAAAAAJALAABiAAAAEAAAAAAAAACg
AQAAYgAAAAIAAACCAAAABAAAAAAgAEQBBAAAYBQAAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAAAAAA
AABgFAAAAAAAAIIAAAAIAAAAjwX//wAAAADSEQAAAAAAAAAAAABSAAAAAAAAAAAAAAADAAAAwgQA
AAAAAADKAAAAAAAAANAAAABiAAAAAwAAAAIFAAAAAAAAIAUAAGIAAAACAAAAUgUAAAAAAAC9BwAA
FQAAAFIFAAAAAAAAUQAAADMAAABgFAAAAgUAAAAAAACADAAAYgAAAAEAAACyDAAAAAAAAAMAAAAB
AAAAAwAAAGAUAAACBQAAAAAAAOAMAABiAAAAAQAAACAAAABgFAAA0gUAAAAAAAByAAAALAAAACwA
AAAAAAAAAQAAAP/////////////////////eAwAACgAAAAYEAAAjAAAAygAAAAAAAADQAAAAEAYA
ACAGAAAAAAAAEwAAADIGAAAAAAAAoAgAALH///9QBgAAIf///5AGAAAVAAAAsAYAADMAAACaAQAA
AAAAAEAEAABiAAAAEAAAAAAAAACgAQAAYgAAAAIAAACCAAAABAAAAAABAEQBAAAA0BUAAAAAAAAA
AAAAAAAAAAcAAAAAAAAAAAAAAAAAAADQFQAAAAAAAIIAAAAIAAAAWQX//wAAAACiBAAAAAAAAAAA
AAAAAAAAAAAAAMIEAAAAAAAAygAAAAAAAADQAAAAYgAAAAIAAAACBQAAAAAAACAFAABiAAAAAgAA
AFIFAAAAAAAACwAAAAsAAABSBQAAAAAAAGUAAAAzAAAA0BUAAAIFAAAAAAAAkAUAAGIAAAABAAAA
UgAAAAYAAAAmUmFjZTrQFQAA0gUAAAAAAAByAAAALAAAACwAAAAAAAAAAQAAAP//////////////
//////8FAAAABQAAADcAAAAeAAAAygAAAAAAAADQAAAAEAYAACAGAAAAAAAAEwAAADIGAAAAAAAA
AAoAAAsAAABwBgAAZQAAAJAGAAALAAAAsAYAADMAAACaAQAAAAAAAEAEAABiAAAAEAAAAAAAAACg
AQAAYgAAAAIAAACCAAAABAAAAAABAEQBAAAAEBcAAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAAAAAA
AAAQFwAAAAAAAIIAAAAIAAAAWQX//wAAAACiBAAAAAAAAAAAAAAAAAAAAAAAAMIEAAAAAAAAygAA
AAAAAADQAAAAYgAAAAIAAAACBQAAAAAAACAFAABiAAAAAgAAAFIFAAAAAAAAJwcAAI0AAABSBQAA
AAAAAI0AAAApAAAAEBcAAAIFAAAAAAAAkAUAAGIAAAABAAAAUgAAAAwAAABSYWNlIGNoYW5jZToQ
FwAA0gUAAAAAAAByAAAALAAAACwAAAAAAAAAAQAAAP////////////////////+TAwAARgAAANkD
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
AAAMAAAAY29udGV4dE1lbnU6YgAAAAEAAABgGgAA0BkAAAIFAAAAAAAAkAUAAGIAAAABAAAAUgAA
AAMAAABOby7QGQAA0gUAAAAAAAByAAAALAAAACwAAAAAAAAAAQAAAP////////////////////8F
AAAAggAAAHEEAAD6AQAAygAAAAAAAADQAAAAEAYAACAGAAAAAAAAFwAAADIGAAAAAAAAAAoAAAsA
AABQBgAA9////5AGAAAFAQAAIAoAAIn///+aAQAAAAAAAEAEAABiAAAAEAAAAAAAAACgAQAAYgAA
AAIAAACCAAAABAAAAAABAEQBAAAAMDIAAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAwMgAA
AAAAAIIAAAAIAAAAWQX//wAAAACiBAAAAAAAAAAAAAAAAAAAAAAAAMIEAAAAAAAAygAAAAAAAADQ
AAAAYgAAAAIAAAACBQAAAAAAACAFAABiAAAAAgAAAFIFAAAAAAAAJwcAAMkAAABSBQAAAAAAAD0A
AAApAAAAMDIAAAIFAAAAAAAAkAUAAGIAAAABAAAAUgAAAAYAAABQaWNrczowMgAA0gUAAAAAAABy
AAAALAAAACwAAAAAAAAAAQAAAP////////////////////+TAwAAZAAAALEDAAB4AAAAygAAAAAA
AADQAAAAEAYAACAGAAAAAAAAEwAAADIGAAAAAAAAUAYAADv+//9wBgAAPQAAAJAGAADJAAAAsAYA
ACkAAACaAQAAAAAAAJALAABiAAAAEAAAAAAAAACgAQAAYgAAAAIAAACCAAAABAAAAAAgAEQBBAAA
cDMAAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAAAAAAAABwMwAAAAAAAIIAAAAIAAAAjwX//wAAAADS
EQAAAAAAAAAAAABSAAAAAAAAAAAAAAADAAAAwgQAAAAAAADKAAAAAAAAANAAAABiAAAAAwAAAAIF
AAAAAAAAIAUAAGIAAAACAAAAUgUAAAAAAAC9BwAAyQAAAFIFAAAAAAAAUQAAADMAAABwMwAAAgUA
AAAAAACADAAAYgAAAAEAAACyDAAAAAAAAAMAAAABAAAAAwAAAHAzAAACBQAAAAAAAOAMAABiAAAA
AQAAACAAAABwMwAA0gUAAAAAAAByAAAALAAAACwAAAAAAAAAAQAAAP/////////////////////e
AwAAZAAAAAYEAAB9AAAAygAAAAAAAADQAAAAEAYAACAGAAAAAAAAEwAAADIGAAAAAAAAoAgAALH/
//9QBgAAIf///5AGAADJAAAAsAYAADMAAACaAQAAAAAAAJALAABiAAAAEAAAAAAAAACgAQAAYgAA
AAIAAACCAAAABAAAAAAgAEQBBAAA4DQAAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAAAAAAAADgNAAA
AAAAAIIAAAAIAAAAjwX//wAAAACiGAAAAAAAAAAAAABSAAAAAAAAAAAAAAADAAAAwgQAAAAAAADK
AAAAAAAAANAAAABiAAAAAwAAAAIFAAAAAAAAIAUAAGIAAAACAAAAUgUAAAAAAAC9BwAAUQAAAFIF
AAAAAAAAUQAAADMAAADgNAAAAgUAAAAAAACADAAAYgAAAAEAAACyDAAAAAAAAAMAAAABAAAAAwAA
AOA0AAACBQAAAAAAAOAMAABiAAAAAQAAACAAAADgNAAA0gUAAAAAAAByAAAALAAAACwAAAAAAAAA
AQAAAP/////////////////////eAwAAKAAAAAYEAABBAAAAygAAAAAAAADQAAAAEAYAACAGAAAA
AAAAEwAAADIGAAAAAAAAoAgAALH///9QBgAAIf///5AGAABRAAAAsAYAADMAAACaAQAAAAAAAJAL
AABiAAAAEAAAAAAAAACgAQAAYgAAAAIAAACCAAAABAAAAIAAAEQBBAAAUDYAAAAAAAAAAAAAAAAA
AAcAAAAAAAAAAAAAAAAAAABQNgAAAAAAAIIAAAAIAAAAjwX//wAAAACiBAAAAAAAAAAAAAAAAAAA
AwAAAMIEAAAAAAAAygAAAAAAAADQAAAAYgAAAAMAAAACBQAAAAAAACAFAABiAAAAAgAAAFIFAAAA
AAAAgwAAAMkAAABSBQAAAAAAAKkCAAAzAAAAUDYAAAIFAAAAAAAAgAwAAGIAAAABAAAAsgwAAAAA
AAADAAAAAQAAAAMAAABQNgAAAgUAAAAAAADgDAAAYgAAAAEAAAAgAAAAUDYAANIFAAAAAAAAcgAA
ACwAAAAsAAAAAAAAAAEAAAD/////////////////////QQAAAGQAAACVAQAAfQAAAMoAAAAAAAAA
0AAAABAGAAAgBgAAAAAAABMAAAAyBgAAAAAAAAAKAACDAAAAcAYAAKkCAACQBgAAyQAAALAGAAAz
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
AAD/////////////////////EQMAABcCAAAlAwAAMAIAAMoAAAAAAAAA0AAAABAGAAAgBgAAAAAA
ABMAAAAyBgAAAAAAAAAKAAAjBgAAcAYAACkAAAAgCgAAw////7AGAAAzAAAAmgEAAAAAAABABAAA
YgAAABAAAAAAAAAAoAEAAGIAAAACAAAAggAAAAQAAAAAAQBEAQAAACBBAAAAAAAAAAAAAAAAAAAH
AAAAAAAAAAAAAAAAAAAAIEEAAAAAAACCAAAACAAAAFkF//8AAAAAogQAAAAAAAAAAAAAAAAAAAAA
AADCBAAAAAAAAMoAAAAAAAAA0AAAAGIAAAACAAAAAgUAAAAAAAAgBQAAYgAAAAIAAABSBQAAAAAA
AEsGAADJAAAAUgUAAAAAAABlAAAAMwAAACBBAAACBQAAAAAAAJAFAABiAAAAAQAAAFIAAAAJAAAA
VG90YWwgUFA6IEEAANIFAAAAAAAAcgAAACwAAAAsAAAAAAAAAAEAAAD/////////////////////
JQMAAGQAAABXAwAAfQAAAMoAAAAAAAAA0AAAABAGAAAgBgAAAAAAABMAAAAyBgAAAAAAAFAGAABf
/f//cAYAAGUAAACQBgAAyQAAALAGAAAzAAAAmgEAAAAAAACQCwAAYgAAABAAAAAAAAAAoAEAAGIA
AAACAAAAggAAAAQAAACAIAFEAQQAAGBCAAAAAAAAAAAAAAAAAAAHAAAAAAAAAAAAAAAAAAAAYEIA
AAAAAACCAAAACAAAAI8F//8AAAAA0hEAAAAAAAAAAAAAYCIAAAAAAAABAAAAwgQAAAAAAADKAAAA
AAAAANAAAABiAAAAAwAAAAIFAAAAAAAAIAUAAGIAAAACAAAAUgUAAAAAAAB5BQAAyQAAAFIFAAAA
AAAAUQAAADMAAABgQgAAAgUAAAAAAACADAAAYgAAAAEAAACyDAAAAAAAAAMAAAABAAAAAwAAAGBC
AAACBQAAAAAAAOAMAABiAAAAAQAAACAAAABgQgAA0gUAAAAAAAByAAAALAAAACwAAAAAAAAAAQAA
AP////////////////////+8AgAAZAAAAOQCAAB9AAAAygAAAAAAAADQAAAAEAYAACAGAAAAAAAA
EwAAADIGAAAAAAAAAAoAAHkFAABwBgAAUQAAAJAGAADJAAAAsAYAADMAAACaAQAAAAAAAEAEAABi
AAAAEAAAAAAAAACgAQAAYgAAAAIAAACCAAAABAAAAAABAEQBAAAAwEMAAAAAAAAAAAAAAAAAAAcA
AAAAAAAAAAAAAAAAAADAQwAAAAAAAIIAAAAIAAAAWQX//wAAAACiBAAAAAAAAAAAAAAAAAAAAAAA
AMIEAAAAAAAAygAAAAAAAADQAAAAYgAAAAIAAAACBQAAAAAAACAFAABiAAAAAgAAAFIFAAAAAAAA
cQMAAAcEAABSBQAAAAAAAFEAAAAfAAAAwEMAAAIFAAAAAAAAkAUAAGIAAAABAAAAUgAAAAQAAABS
UA0KwEMAANIFAAAAAAAAcgAAACwAAAAsAAAAAAAAAAEAAAD/////////////////////uAEAAAMC
AADgAQAAEgIAAMoAAAAAAAAA0AAAABAGAAAgBgAAAAAAABMAAAAyBgAAAAAAAAAKAABxAwAAcAYA
AFEAAAAgCgAAm////7AGAAAfAAAAmgEAAAAAAABABAAAYgAAABAAAAAAAAAAoAEAAGIAAAACAAAA
ggAAAAQAAAAAAQBEAQAAAABFAAAAAAAAAAAAAAAAAAAHAAAAAAAAAAAAAAAAAAAAAEUAAAAAAACC
AAAACAAAAFkF//8AAAAAogQAAAAAAAAAAAAAAAAAAAAAAADCBAAAAAAAAMoAAAAAAAAA0AAAAGIA
AAACAAAAAgUAAAAAAAAgBQAAYgAAAAIAAABSBQAAAAAAAEsGAAAVAAAAUgUAAAAAAABHAAAAHwAA
AABFAAACBQAAAAAAAJAFAABiAAAAAQAAAFIAAAAFAAAAU29ydDoARQAA0gUAAAAAAAByAAAALAAA
ACwAAAAAAAAAAQAAAP////////////////////8lAwAACgAAAEgDAAAZAAAAygAAAAAAAADQAAAA
EAYAACAGAAAAAAAAEwAAADIGAAAAAAAAUAYAAF/9//9wBgAARwAAAJAGAAAVAAAAsAYAAB8AAACa
AQAAAAAAAJALAABiAAAAEAAAAAAAAACgAQAAYgAAAAIAAACCAAAABAAAAAAgAEQBBAAAQEYAAAAA
AAAAAAAAAAAAAAcAAAAAAAAAAAAAAAAAAABARgAAAAAAAIIAAAAIAAAAjwX//wAAAADSEQAAAAAA
AAAAAABSAAAAAAAAAAAAAAADAAAAwgQAAAAAAADKAAAAAAAAANAAAABiAAAAAwAAAAIFAAAAAAAA
IAUAAGIAAAACAAAAUgUAAAAAAABhBAAAyQAAAFIFAAAAAAAAUQAAADMAAABARgAAAgUAAAAAAACA
DAAAYgAAAAEAAACyDAAAAAAAAAMAAAABAAAAAwAAAEBGAAACBQAAAAAAAOAMAABiAAAAAQAAACAA
AABARgAA0gUAAAAAAAByAAAALAAAACwAAAAAAAAAAQAAAP////////////////////8wAgAAZAAA
AFgCAAB9AAAAygAAAAAAAADQAAAAEAYAACAGAAAAAAAAEwAAADIGAAAAAAAAAAoAAGEEAABwBgAA
UQAAAJAGAADJAAAAsAYAADMAAACaAQAAAAAAAEAEAABiAAAAEAAAAAAAAACgAQAAYgAAAAIAAACC
AAAABAAAAAABAEQBAAAAsEcAAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAAAAAAAACwRwAAAAAAAIIA
AAAIAAAAWQX//wAAAACiBAAAAAAAAAAAAAAAAAAAAAAAAMIEAAAAAAAAygAAAAAAAADQAAAAYgAA
AAIAAAACBQAAAAAAACAFAABiAAAAAgAAAFIFAAAAAAAAqQcAAAcEAABSBQAAAAAAAC0BAAAfAAAA
sEcAAAIFAAAAAAAAkAUAAGIAAAABAAAAUgAAAAwAAABMYXN0IHVwZGF0ZTqwRwAA0gUAAAAAAABy
AAAALAAAACwAAAAAAAAAAQAAAP/////////////////////UAwAAAwIAAGoEAAASAgAAygAAAAAA
AADQAAAAEAYAACAGAAAAAAAAEwAAADIGAAAAAAAAUAYAAL3+//9wBgAALQEAACAKAACb////sAYA
AB8AAACaAQAAAAAAAEAEAABiAAAAEAAAAAAAAACgAQAAYgAAAAIAAACCAAAABAAAAAABAEQBAAAA
8EgAAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAAAAAAAADwSAAAAAAAAIIAAAAIAAAAWQX//wAAAACi
BAAAAAAAAAAAAAAAAAAAAAAAAMIEAAAAAAAAygAAAAAAAADQAAAAYgAAAAIAAAACBQAAAAAAACAF
AABiAAAAAgAAAFIFAAAAAAAAlwUAAAcEAABSBQAAAAAAAHkAAAAfAAAA8EgAAAIFAAAAAAAAkAUA
AGIAAAABAAAAUgAAAAwAAAAmUFAgRXN0aW1hdGXwSAAA0gUAAAAAAAByAAAALAAAACwAAAAAAAAA
AQAAAP/////////////////////LAgAAAwIAAAcDAAASAgAAygAAAAAAAADQAAAAEAYAACAGAAAA
AAAAEwAAADIGAAAAAAAAAAoAAJcFAABwBgAAeQAAACAKAACb////sAYAAB8AAACaAQAAAAAAAJAL
AABiAAAAEAAAAAAAAACgAQAAYgAAAAIAAACCAAAABAAAAAAAAUQBBAAAMEoAAAAAAAAAAAAAAAAA
AAcAAAAAAAAAAAAAAAAAAAAwSgAAAAAAAIIAAAAIAAAAjwX//wAAAACiGAAAAAAAAAAAAABSAAAA
AAAAAAAAAAABAAAAwgQAAAAAAADKAAAAAAAAANAAAABiAAAAAwAAAAIFAAAAAAAAIAUAAGIAAAAC
AAAAUgUAAAAAAAA9BQAALwQAAFIFAAAAAAAAUQAAADMAAAAwSgAAAgUAAAAAAACADAAAYgAAAAEA
AACyDAAAAAAAAAMAAAABAAAAAwAAADBKAAACBQAAAAAAAOAMAABiAAAAAQAAACAAAAAwSgAA0gUA
AAAAAAByAAAALAAAACwAAAAAAAAAAQAAAP////////////////////+eAgAAFwIAAMYCAAAwAgAA
ygAAAAAAAADQAAAAEAYAACAGAAAAAAAAEwAAADIGAAAAAAAAAAoAAD0FAABwBgAAUQAAACAKAADD
////sAYAADMAAACaAQAAAAAAAEAEAABiAAAAEAAAAAAAAACgAQAAYgAAAAIAAACCAAAABAAAAAAB
AEQBAAAAoEsAAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAAAAAAAACgSwAAAAAAAIIAAAAIAAAAWQX/
/wAAAACiBAAAAAAAAAAAAAAAAAAAAAAAAMIEAAAAAAAAygAAAAAAAADQAAAAYgAAAAIAAAACBQAA
AAAAACAFAABiAAAAAgAAAFIFAAAAAAAAAQUAAAcEAABSBQAAAAAAACkAAAAfAAAAoEsAAAIFAAAA
AAAAkAUAAGIAAAABAAAAUgAAAAMAAABOL1KgSwAA0gUAAAAAAAByAAAALAAAACwAAAAAAAAAAQAA
AP////////////////////+AAgAAAwIAAJQCAAASAgAAygAAAAAAAADQAAAAEAYAACAGAAAAAAAA
EwAAADIGAAAAAAAAAAoAAAEFAABwBgAAKQAAACAKAACb////sAYAAB8AAACaAQAAAAAAAOAGAABi
AAAAEQAAAAAAAACgAQAAYgAAAAIAAACCAAAABAAAAAAgAUQBAAAA4EwAAAAAAAAAAAAAAAAAAAcA
AAAAAAAAAAAAAAAAAADgTAAAAAAAAIIAAAAIAAAAcQb//wAAAAByAgAAAAAAALoAAAAAAAAAUgAA
AAkAAAB1cGRhdGVBbGxSAAAACgAAAFVwZGF0ZSBhbGwBAAAAAQAAAAAAAAAAAAAAAQAAAMIEAAAA
AAAAygAAAAAAAADQAAAAYgAAAAMAAAACBQAAAAAAACAFAABiAAAAAgAAAFIFAAAAAAAATQgAACUE
AABSBQAAAAAAAJcAAAA9AAAA4EwAAAIFAAAAAAAAAAgAAGIAAAABAAAAIAAAAOBMAAACBQAAAAAA
AJAFAABiAAAAAQAAAFIAAAAKAAAAVXBkYXRlIGFsbOBMAADSBQAAAAAAAHIAAAAsAAAALAAAAAAA
AAABAAAA/////////////////////yYEAAASAgAAcQQAADACAADKAAAAAAAAANAAAAAQBgAAIAYA
AAAAAAATAAAAMgYAAAAAAACgCAAAa////1AGAAD3////ugAAAAAAAABSAAAADwAAAGZpeGVkVmll
d0JvdHRvbcX///8gCgAA9f///5oBAAAAAAAAkAsAAGIAAAAQAAAAAAAAAKABAABiAAAAAgAAAIIA
AAAEAAAAgAAARAEEAACQTgAAAAAAAAAAAAAAAAAABwAAAAAAAAAAAAAAAAAAAJBOAAAAAAAAggAA
AAgAAACPBf//AAAAAKIEAAAAAAAAAAAAAAAAAAADAAAAwgQAAAAAAADKAAAAAAAAANAAAABiAAAA
AwAAAAIFAAAAAAAAIAUAAGIAAAACAAAAUgUAAAAAAAALAAAALwQAAFIFAAAAAAAAPQAAADMAAACQ
TgAAAgUAAAAAAACADAAAYgAAAAEAAACyDAAAAAAAAAMAAAABAAAAAwAAAJBOAAACBQAAAAAAAOAM
AABiAAAAAQAAACAAAACQTgAA0gUAAAAAAAByAAAALAAAACwAAAAAAAAAAQAAAP//////////////
//////8FAAAAFwIAACMAAAAwAgAAygAAAAAAAADQAAAAEAYAACAGAAAAAAAAEwAAADIGAAAAAAAA
AAoAAAsAAABwBgAAPQAAAHBOAADP////IAoAAPX///+aAQAAAAAAAJALAABiAAAAEAAAAAAAAACg
AQAAYgAAAAIAAACCAAAABAAAAAAgAUQBBAAA8E8AAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAAAAAA
AADwTwAAAAAAAIIAAAAIAAAAjwX//wAAAADSEQAAAAAAAAAAAABSAAAAAAAAAAAAAAADAAAAwgQA
AAAAAADKAAAAAAAAANAAAABiAAAAAwAAAAIFAAAAAAAAIAUAAGIAAAACAAAAUgUAAAAAAADDBgAA
jQAAAFIFAAAAAAAAUQAAADMAAADwTwAAAgUAAAAAAACADAAAYgAAAAEAAACyDAAAAAAAAAMAAAAB
AAAAAwAAAPBPAAACBQAAAAAAAOAMAABiAAAAAQAAACAAAADwTwAA0gUAAAAAAAByAAAALAAAACwA
AAAAAAAAAQAAAP////////////////////9hAwAARgAAAIkDAABfAAAAygAAAAAAAADQAAAAEAYA
ACAGAAAAAAAAEwAAADIGAAAAAAAAUAYAANf9//9wBgAAUQAAAJAGAACNAAAAsAYAADMAAACaAQAA
AAAAALA/AABiAAAAEAAAAAAAAACgAQAAYgAAAAIAAACCAAAABAAAAAMgAUQBAAAAYFEAAAJAAAAA
AAAAAAAAAAAAAAAgQAAAIAAAAAAAAAAAAAAABwAAAAAAAAAAAAAAAAAAAGBRAAAAAAAAggAAAAgA
AABxBv//AAAAAKIEAAAAAAAAAAAAAAAAAAAAAAAAwgQAAAAAAADKAAAAAAAAANAAAABiAAAAAQAA
AAIFAAAAAAAAIAUAAGIAAAACAAAAUgUAAAAAAAALBQAALwQAAFIFAAAAAAAAHwAAADMAAABgUQAA
0gUAAAAAAAByAAAALAAAACwAAAAAAAAAAQAAAP////////////////////+FAgAAFwIAAJQCAAAw
AgAAygAAAAAAAADQAAAAEAYAACAGAAAAAAAAEwAAADIGAAAAAAAAAAoAAAsFAABwBgAAHwAAACAK
AADD////sAYAADMAAACaAQAAAAAAAJALAABiAAAAEAAAAAAAAACgAQAAYgAAAAIAAACCAAAABAAA
AIAAAEQBBAAAgFIAAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAAAAAAAACAUgAAAAAAAIIAAAAIAAAA
jwX//wAAAACiBAAAAAAAAAAAAAAAAAAAAwAAAMIEAAAAAAAAygAAAAAAAADQAAAAYgAAAAMAAAAC
BQAAAAAAACAFAABiAAAAAgAAAFIFAAAAAAAAVQEAAC8EAABSBQAAAAAAAAUBAAAzAAAAgFIAAAIF
AAAAAAAAgAwAAGIAAAABAAAAsgwAAAAAAAADAAAAAQAAAAMAAACAUgAAAgUAAAAAAADgDAAAYgAA
AAEAAAAgAAAAgFIAANIFAAAAAAAAcgAAACwAAAAsAAAAAAAAAAEAAAD/////////////////////
qgAAABcCAAAsAQAAMAIAAMoAAAAAAAAA0AAAABAGAAAgBgAAAAAAABMAAAAyBgAAAAAAAAAKAABV
AQAAcAYAAAUBAAAgCgAAw////7AGAAAzAAAAmgEAAAAAAABABAAAYgAAABAAAAAAAAAAoAEAAGIA
AAACAAAAggAAAAQAAAAAAQBEAQAAAOBTAAAAAAAAAAAAAAAAAAAHAAAAAAAAAAAAAAAAAAAA4FMA
AAAAAACCAAAACAAAAFkF//8AAAAAogQAAAAAAAAAAAAAAAAAAAAAAADCBAAAAAAAAMoAAAAAAAAA
0AAAAGIAAAACAAAAAgUAAAAAAAAgBQAAYgAAAAIAAABSBQAAAAAAAAsAAAAHBAAAUgUAAAAAAAAz
AAAAHwAAAOBTAAACBQAAAAAAAJAFAABiAAAAAQAAAFIAAAADAAAATm8u4FMAANIFAAAAAAAAcgAA
ACwAAAAsAAAAAAAAAAEAAAD/////////////////////BQAAAAMCAAAeAAAAEgIAAMoAAAAAAAAA
0AAAABAGAAAgBgAAAAAAABMAAAAyBgAAAAAAAAAKAAALAAAAcAYAADMAAAAgCgAAm////7AGAAAf
AAAAmgEAAAAAAACwPwAAYgAAABAAAAAAAAAAoAEAAGIAAAACAAAAggAAAAQAAAADIAFEAQAAACBV
AAACQAAAAAAAAAAAAAAAAAAAIEAAACAAAAAAAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAgVQAAAAAA
AIIAAAAIAAAAcQb//wAAAACiBAAAAAAAAAAAAAAAAAAAAAAAAMIEAAAAAAAAygAAAAAAAADQAAAA
YgAAAAEAAAACBQAAAAAAACAFAABiAAAAAgAAAFIFAAAAAAAAwwYAAAsAAABSBQAAAAAAACkAAAAz
AAAAIFUAANIFAAAAAAAAcgAAACwAAAAsAAAAAAAAAAEAAAD/////////////////////YQMAAAUA
AAB1AwAAHgAAAMoAAAAAAAAA0AAAABAGAAAgBgAAAAAAABMAAAAyBgAAAAAAAFAGAADX/f//cAYA
ACkAAACQBgAACwAAALAGAAAzAAAAmgEAAAAAAABABAAAYgAAABAAAAAAAAAAoAEAAGIAAAACAAAA
ggAAAAQAAAAAAQBEAQAAAEBWAAAAAAAAAAAAAAAAAAAHAAAAAAAAAAAAAAAAAAAAQFYAAAAAAACC
AAAACAAAAFkF//8AAAAAogQAAAAAAAAAAAAAAAAAAAAAAADCBAAAAAAAAMoAAAAAAAAA0AAAAGIA
AAACAAAAAgUAAAAAAAAgBQAAYgAAAAIAAABSBQAAAAAAAD0FAAAHBAAAUgUAAAAAAABRAAAAHwAA
AEBWAAACBQAAAAAAAJAFAABiAAAAAQAAAFIAAAAHAAAAQmV0ZmFpckBWAADSBQAAAAAAAHIAAAAs
AAAALAAAAAAAAAABAAAA/////////////////////54CAAADAgAAxgIAABICAADKAAAAAAAAANAA
AAAQBgAAIAYAAAAAAAATAAAAMgYAAAAAAAAACgAAPQUAAHAGAABRAAAAIAoAAJv///+wBgAAHwAA
AJoBAAAAAAAAQAQAAGIAAAAQAAAAAAAAAKABAABiAAAAAgAAAIIAAAAEAAAAAAEARAEAAACAVwAA
AAAAAAAAAAAAAAAABwAAAAAAAAAAAAAAAAAAAIBXAAAAAAAAggAAAAgAAABZBf//AAAAAKIEAAAA
AAAAAAAAAAAAAAAAAAAAwgQAAAAAAADKAAAAAAAAANAAAABiAAAAAgAAAAIFAAAAAAAAIAUAAGIA
AAACAAAAUgUAAAAAAABVAQAABwQAAFIFAAAAAAAA8QAAAB8AAACAVwAAAgUAAAAAAACQBQAAYgAA
AAEAAABSAAAABgAAAEpvY2tleYBXAADSBQAAAAAAAHIAAAAsAAAALAAAAAAAAAABAAAA////////
/////////////6oAAAADAgAAIgEAABICAADKAAAAAAAAANAAAAAQBgAAIAYAAAAAAAATAAAAMgYA
AAAAAAAACgAAVQEAAHAGAADxAAAAIAoAAJv///+wBgAAHwAAAJoBAAAAAAAAQAQAAGIAAAAQAAAA
AAAAAKABAABiAAAAAgAAAIIAAAAEAAAAAAEARAEAAADAWAAAAAAAAAAAAAAAAAAABwAAAAAAAAAA
AAAAAAAAAMBYAAAAAAAAggAAAAgAAABZBf//AAAAAKIEAAAAAAAAAAAAAAAAAAAAAAAAwgQAAAAA
AADKAAAAAAAAANAAAABiAAAAAgAAAAIFAAAAAAAAIAUAAGIAAAACAAAAUgUAAAAAAADdBQAAyQAA
AFIFAAAAAAAAPQAAACkAAADAWAAAAgUAAAAAAACQBQAAYgAAAAEAAABSAAAABQAAAFBpY2s6wFgA
ANIFAAAAAAAAcgAAACwAAAAsAAAAAAAAAAEAAAD/////////////////////7gIAAGQAAAAMAwAA
eAAAAMoAAAAAAAAA0AAAABAGAAAgBgAAAAAAABMAAAAyBgAAAAAAAAAKAADdBQAAcAYAAD0AAACQ
BgAAyQAAALAGAAApAAAAmgEAAAAAAACQCwAAYgAAABAAAAAAAAAAoAEAAGIAAAACAAAAggAAAAQA
AACAAABEAQQAAABaAAAAAAAAAAAAAAAAAAAHAAAAAAAAAAAAAAAAAAAAAFoAAAAAAACCAAAACAAA
AI8F//8AAAAAogQAAAAAAAAAAAAAAAAAAAMAAADCBAAAAAAAAMoAAAAAAAAA0AAAAGIAAAADAAAA
AgUAAAAAAAAgBQAAYgAAAAIAAABSBQAAAAAAAFEAAAAvBAAAUgUAAAAAAAD7AAAAMwAAAABaAAAC
BQAAAAAAAIAMAABiAAAAAQAAALIMAAAAAAAAAwAAAAEAAAADAAAAAFoAAAIFAAAAAAAA4AwAAGIA
AAABAAAAIAAAAABaAADSBQAAAAAAAHIAAAAsAAAALAAAAAAAAAABAAAA////////////////////
/ygAAAAXAgAApQAAADACAADKAAAAAAAAANAAAAAQBgAAIAYAAAAAAAATAAAAMgYAAAAAAAAACgAA
UQAAAHAGAAD7AAAAIAoAAMP///+wBgAAMwAAAJoBAAAAAAAAmgAAAAAAAADAAQAAUgAAAAgAAABH
cm91cEJveGIAAAAOAAAAAAAAAKABAABiAAAAAgAAAIIAAAAEAAAABwAAREEAAABgWwAAAAAAAAAA
AAAAAAAABwAAAAAAAAAAAAAAAAAAAGBbAAAAAAAAggAAAAgAAABxBv//AAAAAMIEAAAAAAAAygAA
AAAAAADQAAAAYgAAAAEAAAACBQAAAAAAACAFAABiAAAAAgAAAFIFAAAAAAAAIQgAAAEAAABSBQAA
AAAAAL8AAAD7AAAAYFsAANIFAAAAAAAAcgAAACwAAAAsAAAAAAAAAAEAAAD/////////////////
////EAQAAAAAAABvBAAAfQAAAMoAAAAAAAAA0AAAABAGAAAgBgAAAAAAABMAAAAyBgAAAAAAAKAI
AABD////UAYAAPP///+QBgAAAQAAALAGAAD7AAAAmgEAAAAAAABABAAAYgAAABAAAAAAAAAAoAEA
AGIAAAACAAAAggAAAAQAAAAAAQBEAQAAAIBcAAAAAAAAAAAAAAAAAAAHAAAAAAAAAAAAAAAAAAAA
gFwAAAAAAACCAAAACAAAAFkF//8AAAAAogQAAAAAAAAAAAAAAAAAAAAAAADCBAAAAAAAAMoAAAAA
AAAA0AAAAGIAAAACAAAAAgUAAAAAAAAgBQAAYgAAAAIAAABSBQAAAAAAAGMCAAAHBAAAUgUAAAAA
AADxAAAAHwAAAIBcAAACBQAAAAAAAJAFAABiAAAAAQAAAFIAAAAHAAAAVHJhaW5lcoBcAADSBQAA
AAAAAHIAAAAsAAAALAAAAAAAAAABAAAA/////////////////////zEBAAADAgAAqQEAABICAADK
AAAAAAAAANAAAAAQBgAAIAYAAAAAAAATAAAAMgYAAAAAAAAACgAAYwIAAHAGAADxAAAAIAoAAJv/
//+wBgAAHwAAAJoBAAAAAAAAsD8AAGIAAAAQAAAAAAAAAKABAABiAAAAAgAAAIIAAAAEAAAAAyAB
RAEAAADAXQAAAkAAAAAAAAAAAAAAAAAAACBAAAAgAAAAAAAAAAAAAAAHAAAAAAAAAAAAAAAAAAAA
wF0AAAAAAACCAAAACAAAAHEG//8AAAAAogQAAAAAAAAAAAAAAAAAAAAAAADCBAAAAAAAAMoAAAAA
AAAA0AAAAGIAAAABAAAAAgUAAAAAAAAgBQAAYgAAAAIAAABSBQAAAAAAACMGAADJAAAAUgUAAAAA
AAAfAAAAKQAAAMBdAADSBQAAAAAAAHIAAAAsAAAALAAAAAAAAAABAAAA////////////////////
/xEDAABkAAAAIAMAAHgAAADKAAAAAAAAANAAAAAQBgAAIAYAAAAAAAATAAAAMgYAAAAAAAAACgAA
IwYAAHAGAAAfAAAAkAYAAMkAAACwBgAAKQAAAJoBAAAAAAAAQAQAAGIAAAAQAAAAAAAAAKABAABi
AAAAAgAAAIIAAAAEAAAAAAEARAEAAADgXgAAAAAAAAAAAAAAAAAABwAAAAAAAAAAAAAAAAAAAOBe
AAAAAAAAggAAAAgAAABZBf//AAAAAKIEAAAAAAAAAAAAAAAAAAAAAAAAwgQAAAAAAADKAAAAAAAA
ANAAAABiAAAAAgAAAAIFAAAAAAAAIAUAAGIAAAACAAAAUgUAAAAAAAAnBwAAFQAAAFIFAAAAAAAA
bwAAACkAAADgXgAAAgUAAAAAAACQBQAAYgAAAAEAAABSAAAADAAAAFRvdGFsIGxpbmVzOuBeAADS
BQAAAAAAAHIAAAAsAAAALAAAAAAAAAABAAAA/////////////////////5MDAAAKAAAAygMAAB4A
AADKAAAAAAAAANAAAAAQBgAAIAYAAAAAAAATAAAAMgYAAAAAAACgCAAAk////1AGAACp/v//kAYA
ABUAAACwBgAAKQAAAJoBAAAAAAAAQAQAAGIAAAAQAAAAAAAAAKABAABiAAAAAgAAAIIAAAAEAAAA
AAEARAEAAAAgYAAAAAAAAAAAAAAAAAAABwAAAAAAAAAAAAAAAAAAACBgAAAAAAAAggAAAAgAAABZ
Bf//AAAAAKIEAAAAAAAAAAAAAAAAAAAAAAAAwgQAAAAAAADKAAAAAAAAANAAAABiAAAAAgAAAAIF
AAAAAAAAIAUAAGIAAAACAAAAUgUAAAAAAADLAwAABwQAAFIFAAAAAAAA8QAAAB8AAAAgYAAAAgUA
AAAAAACQBQAAYgAAAAEAAABSAAAACQAAAExpdmUgc2hvdyBgAADSBQAAAAAAAHIAAAAsAAAALAAA
AAAAAAABAAAA/////////////////////+UBAAADAgAAXQIAABICAADKAAAAAAAAANAAAAAQBgAA
IAYAAAAAAAATAAAAMgYAAAAAAAAACgAAywMAAHAGAADxAAAAIAoAAJv///+wBgAAHwAAAJoBAAAA
AAAAkAsAAGIAAAAQAAAAAAAAAKABAABiAAAAAgAAAIIAAAAEAAAAAAAARAEEAABgYQAAAAAAAAAA
AAAAAAAABwAAAAAAAAAAAAAAAAAAAGBhAAAAAAAAggAAAAgAAACPBf//AAAAAKIYAAAAAAAAAAAA
AFIAAAAAAAAAAAAAAAMAAADCBAAAAAAAAMoAAAAAAAAA0AAAAGIAAAADAAAAAgUAAAAAAAAgBQAA
YgAAAAIAAABSBQAAAAAAAHEDAAAvBAAAUgUAAAAAAABRAAAAMwAAAGBhAAACBQAAAAAAAIAMAABi
AAAAAQAAALIMAAAAAAAAAwAAAAEAAAADAAAAYGEAAAIFAAAAAAAA4AwAAGIAAAABAAAAIAAAAGBh
AADSBQAAAAAAAHIAAAAsAAAALAAAAAAAAAABAAAA/////////////////////7gBAAAXAgAA4AEA
ADACAADKAAAAAAAAANAAAAAQBgAAIAYAAAAAAAATAAAAMgYAAAAAAAAACgAAcQMAAHAGAABRAAAA
IAoAAMP///+wBgAAMwAAAJoBAAAAAAAA4AYAAGIAAAARAAAAAAAAAKABAABiAAAAAgAAAIIAAAAE
AAAAACABRAEAAADQYgAAAAAAAAAAAAAAAAAABwAAAAAAAAAAAAAAAAAAANBiAAAAAAAAggAAAAgA
AABxBv//AAAAAHICAAAAAAAAugAAAAAAAABSAAAADgAAAHVwZGF0ZUxpdmVEYXRhUgAAAAwAAAAm
TGl2ZSB1cGRhdGUBAAAABQAAAAAAAAAAAAAAAQAAAMIEAAAAAAAAygAAAAAAAADQAAAAYgAAAAMA
AAACBQAAAAAAACAFAABiAAAAAgAAAFIFAAAAAAAAqQcAACUEAABSBQAAAAAAAJcAAAA9AAAA0GIA
AAIFAAAAAAAAAAgAAGIAAAABAAAAIAAAANBiAAACBQAAAAAAAJAFAABiAAAAAQAAAFIAAAAMAAAA
JkxpdmUgdXBkYXRl0GIAANIFAAAAAAAAcgAAACwAAAAsAAAAAAAAAAEAAAD/////////////////
////1AMAABICAAAfBAAAMAIAAMoAAAAAAAAA0AAAABAGAAAgBgAAAAAAABMAAAAyBgAAAAAAAKAI
AABr////UAYAAFP///9wTgAAxf///yAKAAD1////mgEAAAAAAABABAAAYgAAABAAAAAAAAAAoAEA
AGIAAAACAAAAggAAAAQAAAAAAQBEAQAAAGBkAAAAAAAAAAAAAAAAAAAHAAAAAAAAAAAAAAAAAAAA
YGQAAAAAAACCAAAACAAAAFkF//8AAAAAogQAAAAAAAAAAAAAAAAAAAAAAADCBAAAAAAAAMoAAAAA
AAAA0AAAAGIAAAACAAAAAgUAAAAAAAAgBQAAYgAAAAIAAABSBQAAAAAAAAsAAADJAAAAUgUAAAAA
AAB5AAAAKQAAAGBkAAACBQAAAAAAAJAFAABiAAAAAQAAAFIAAAAKAAAAUmFjZSB0eXBlOmBkAADS
BQAAAAAAAHIAAAAsAAAALAAAAAAAAAABAAAA/////////////////////wUAAABkAAAAQQAAAHgA
AADKAAAAAAAAANAAAAAQBgAAIAYAAAAAAAATAAAAMgYAAAAAAAAACgAACwAAAHAGAAB5AAAAkAYA
AMkAAACwBgAAKQAAAJoBAAAAAAAA4AYAAGIAAAARAAAAAAAAAKABAABiAAAAAgAAAIIAAAAEAAAA
ACABRAEAAACgZQAAAAAAAAAAAAAAAAAABwAAAAAAAAAAAAAAAAAAAKBlAAAAAAAAggAAAAgAAABx
Bv//AAAAAHICAAAAAAAAugAAAAAAAABSAAAABgAAAGVkaXRPS1IAAAACAAAAT0sBAAAAAQAAAAAA
AAAAAAAAAwAAAMIEAAAAAAAAygAAAAAAAADQAAAAYgAAAAMAAAACBQAAAAAAACAFAABiAAAAAgAA
AFIFAAAAAAAAaQYAACUEAABSBQAAAAAAAJcAAAA9AAAAoGUAAAIFAAAAAAAAAAgAAGIAAAABAAAA
IAAAAKBlAAACBQAAAAAAAJAFAABiAAAAAQAAAFIAAAACAAAAT0ugZQAA0gUAAAAAAAByAAAALAAA
ACwAAAAAAAAAAQAAAP////////////////////80AwAAEgIAAH8DAAAwAgAAygAAAAAAAADQAAAA
EAYAACAGAAAAAAAAEwAAADIGAAAAAAAAoAgAAGv///9QBgAAE/7//3BOAADF////IAoAAPX///+a
AQAAAAAAAJALAABiAAAAEAAAAAAAAACgAQAAYgAAAAIAAACCAAAABAAAAAAgAUQBBAAAMGcAAAAA
AAAAAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAwZwAAAAAAAIIAAAAIAAAAjwX//wAAAADSEQAAAAAA
AAAAAABSAAAAAAAAAAAAAAADAAAAwgQAAAAAAADKAAAAAAAAANAAAABiAAAAAwAAAAIFAAAAAAAA
IAUAAGIAAAACAAAAUgUAAAAAAADDBgAAUQAAAFIFAAAAAAAAUQAAADMAAAAwZwAAAgUAAAAAAACA
DAAAYgAAAAEAAACyDAAAAAAAAAMAAAABAAAAAwAAADBnAAACBQAAAAAAAOAMAABiAAAAAQAAACAA
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
AABtdGdPZGRzcDMAAFIAAAAKAAAAdG90YWxQaWNrc1AYAABSAAAACAAAAHJhY2VPZGRzkE4AAFIA
AAAFAAAAbmFnTm9gQgAAUgAAAAgAAABwcEZhdkVzdAATAABSAAAACgAAAHBwRXN0VG90YWzAXQAA
UgAAAAoAAAB1bm5hbWVkRmF2AAAAAAAAAAAAAAAAAAAAAAAAAAA9RQAAAAAAAAAAAAAAAAAAAAAA
AAEAAAAAAAAAAAAAAMIEAAAAAAAAygAAAAAAAADQAAAAYgAAAAMAAAACBQAAAAAAACAFAABiAAAA
AgAAAFIFAAAAAAAACwAAAAsAAABSBQAAAAAAAP0IAACxBAAAoAEAAAIFAAAAAAAAkDEAAGIAAAAB
AAAAMAIAAKABAAACBQAAAAAAALoAAAAAAAAAUgAAAAgAAABtZW51QmFyOmIAAAABAAAAAAAAAKAB
AADSBQAAAAAAAHIAAAAsAAAALAAAAAAAAAAAAAAA/////////////////////wUAAAAFAAAAgwQA
AF0CAADKAAAAAAAAANAAAABiAAAAOwAAANAVAABQDQAAoGgAAOBeAABgFAAAED4AAIBuAABgZAAA
UDYAAEAKAACAEQAAsDcAAEBGAABwOwAAYEIAACBBAAAAEwAAMDIAAHAzAADQGQAA4FMAAJBOAAAw
OgAAAFoAAIBXAACAUgAAgFwAAIALAADAQwAAYGEAACBgAACwPAAAoEsAAGBRAABAVgAAMEoAAPBI
AABAagAAwAgAAKA/AACgZQAA8GwAANBiAADgTAAAsGsAADAEAADwTwAAMGcAACBVAAAARQAA8DgA
ABAXAADgNAAAUBgAAGBbAADQBgAAsEcAAMBdAADAWAAAIAYAAAAAAAAVAAAARgUEAAMAAABJY29u
AAAAAAAAAAAQAAAADgIRAFNUQlNpbmdsZXRvblByb3h5AAAAAJoAAAAAAAAAUgAAAAcAAABEb2xw
aGluUgAAABgAAABJbWFnZVJlbGF0aXZlRmlsZUxvY2F0b3K6AAAAAAAAAFIAAAAHAAAAY3VycmVu
dFIAAAANAAAAU2hlbGxWaWV3Lmljbw4CHwBTVEJFeHRlcm5hbFJlc291cmNlTGlicmFyeVByb3h5
AAAAAFIAAAAQAAAAZG9scGhpbmRyMDA1LmRsbAAAAAA='))!

(ResourceIdentifier class: HRRacePresenter name: 'Limited view') assign: (Object fromBinaryStoreBytes:
(ByteArray fromBase64String: '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
KQAAACkAAAAAJAAAggUAAAAAAAByAAAALAAAACwAAAAAAAAAAQAAAP////////////////////8H
AwAAZAAAABsDAAB4AAAAygAAAAAAAADQAAAAwAUAANAFAAAAAAAAEwAAAOIFAAAAAAAAIAYAAFP/
//8QCAAAKQAAAEAGAADJAAAAYAYAACkAAACaAQAAAAAAAJAGAABiAAAAEAAAAAAAAACgAQAAYgAA
AAIAAACCAAAABAAAAAABAEQBAAAAgCUAAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAAAAAAAACAJQAA
AAAAAIIAAAAIAAAAxwj//wAAAADyBgAAAAAAAAAAAAAAAAAAAAAAADIEAAAAAAAAygAAAAAAAADQ
AAAAYgAAAAIAAAByBAAAAAAAAJAEAABiAAAAAgAAAMIEAAAAAAAAvQIAAMkAAADCBAAAAAAAAFsA
AAApAAAAgCUAAHIEAAAAAAAAQAUAAGIAAAABAAAAUgAAAAgAAABSdW5uZXJzOoAlAACCBQAAAAAA
AHIAAAAsAAAALAAAAAAAAAABAAAA/////////////////////14BAABkAAAAiwEAAHgAAADKAAAA
AAAAANAAAADABQAA0AUAAAAAAAATAAAA4gUAAAAAAADwBwAAvQIAABAIAABbAAAAQAYAAMkAAABg
BgAAKQAAAJoBAAAAAAAAECQAAGIAAAAQAAAAAAAAAKABAABiAAAAAgAAAIIAAAAEAAAAAyABRAEA
AADAJgAAYiQAAAAAAAAAAAAAAAAAAIAkAAAgAAAAAAAAAAAAAAAHAAAAAAAAAAAAAAAAAAAAwCYA
AAAAAACCAAAACAAAAOEI//8AAAAA8gYAAAAAAAAAAAAAAAAAAAAAAAAyBAAAAAAAAMoAAAAAAAAA
0AAAAGIAAAABAAAAcgQAAAAAAACQBAAAYgAAAAIAAADCBAAAAAAAAH0GAADJAAAAwgQAAAAAAAAp
AAAAKQAAAMAmAACCBQAAAAAAAHIAAAAsAAAALAAAAAAAAAABAAAA/////////////////////z4D
AABkAAAAUgMAAHgAAADKAAAAAAAAANAAAADABQAA0AUAAAAAAAATAAAA4gUAAAAAAADwBwAAfQYA
ABAIAAApAAAAQAYAAMkAAABgBgAAKQAAAJoBAAAAAAAAgAkAAGIAAAAQAAAAAAAAAKABAABiAAAA
AgAAAIIAAAAEAAAAACAARAEEAADgJwAAAAAAAAAAAAAAAAAABwAAAAAAAAAAAAAAAAAAAOAnAAAA
AAAAggAAAAgAAACJCP//AAAAAOIJAAAAAAAAAAAAAFIAAAAAAAAAAAAAAAMAAAAyBAAAAAAAAMoA
AAAAAAAA0AAAAGIAAAADAAAAcgQAAAAAAACQBAAAYgAAAAIAAADCBAAAAAAAAIkEAADJAAAAwgQA
AAAAAABRAAAAMwAAAOAnAAByBAAAAAAAAJAKAABiAAAAAQAAAMIKAAAAAAAAAwAAAAEAAAADAAAA
4CcAAHIEAAAAAAAA8AoAAGIAAAABAAAAIAAAAOAnAACCBQAAAAAAAHIAAAAsAAAALAAAAAAAAAAB
AAAA/////////////////////0QCAABkAAAAbAIAAH0AAADKAAAAAAAAANAAAADABQAA0AUAAAAA
AAATAAAA4gUAAAAAAAAABgAAsf///yAGAAAd/v//QAYAAMkAAABgBgAAMwAAAJoBAAAAAAAAkAMA
AGIAAAARAAAAAAAAAKABAABiAAAAAgAAAIIAAAAEAAAAACABRAEAAABQKQAAAAAAAAAAAAAAAAAA
BwAAAAAAAAAAAAAAAAAAAFApAAAAAAAAggAAAAgAAADhCP//AAAAAHICAAAAAAAAkAIAAFIAAAAJ
AAAARGFzaGJvYXJkAQAAAAEAAAAAAAAAAAAAAAEAAAAyBAAAAAAAAMoAAAAAAAAA0AAAAGIAAAAD
AAAAcgQAAAAAAACQBAAAYgAAAAIAAADCBAAAAAAAAB0GAAB5AAAAwgQAAAAAAACXAAAAPQAAAFAp
AAByBAAAAAAAAAAFAABiAAAAAQAAACAAAABQKQAAcgQAAAAAAABABQAAYgAAAAEAAABSAAAACQAA
AERhc2hib2FyZFApAACCBQAAAAAAAHIAAAAsAAAALAAAAAAAAAABAAAA////////////////////
/w4DAAA8AAAAWQMAAFoAAADKAAAAAAAAANAAAADABQAA0AUAAAAAAAATAAAA4gUAAAAAAAAABgAA
a////yAGAAD3////QAYAAHkAAABgBgAAPQAAAJoBAAAAAAAAkAYAAGIAAAAQAAAAAAAAAKABAABi
AAAAAgAAAIIAAAAEAAAAAAEARAEAAADAKgAAAAAAAAAAAAAAAAAABwAAAAAAAAAAAAAAAAAAAMAq
AAAAAAAAggAAAAgAAADHCP//AAAAAPIGAAAAAAAAAAAAAAAAAAAAAAAAMgQAAAAAAADKAAAAAAAA
ANAAAABiAAAAAgAAAHIEAAAAAAAAkAQAAGIAAAACAAAAwgQAAAAAAAALAAAACwAAAMIEAAAAAAAA
ZQAAADMAAADAKgAAcgQAAAAAAABABQAAYgAAAAEAAABSAAAABgAAACZSYWNlOsAqAACCBQAAAAAA
AHIAAAAsAAAALAAAAAAAAAABAAAA/////////////////////wUAAAAFAAAANwAAAB4AAADKAAAA
AAAAANAAAADABQAA0AUAAAAAAAATAAAA4gUAAAAAAADwBwAACwAAABAIAABlAAAAQAYAAAsAAABg
BgAAMwAAAJoBAAAAAAAAkAMAAGIAAAARAAAAAAAAAKABAABiAAAAAgAAAIIAAAAEAAAAACABRAEA
AAAALAAAAAAAAAAAAAAAAAAABwAAAAAAAAAAAAAAAAAAAAAsAAAAAAAAggAAAAgAAADhCP//AAAA
AHICAAAAAAAAugAAAAAAAABSAAAACQAAAHVwZGF0ZUFsbFIAAAAKAAAAVXBkYXRlIGFsbAEAAAAB
AAAAAAAAAAAAAAABAAAAMgQAAAAAAADKAAAAAAAAANAAAABiAAAAAwAAAHIEAAAAAAAAkAQAAGIA
AAACAAAAwgQAAAAAAAAdBgAAMwAAAMIEAAAAAAAAlwAAAD0AAAAALAAAcgQAAAAAAAAABQAAYgAA
AAEAAAAgAAAAACwAAHIEAAAAAAAAQAUAAGIAAAABAAAAUgAAAAoAAABVcGRhdGUgYWxsACwAAIIF
AAAAAAAAcgAAACwAAAAsAAAAAAAAAAEAAAD/////////////////////DgMAABkAAABZAwAANwAA
AMoAAAAAAAAA0AAAAMAFAADQBQAAAAAAABMAAADiBQAAAAAAAAAGAABr////IAYAAPf////AHwAA
xf///xAeAAAD/P//mgEAAAAAAACaAAAAAAAAAMABAABSAAAACAAAAENvbWJvQm94YgAAABEAAAAA
AAAAoAEAAGIAAAACAAAAggAAAAQAAAADBjFEAQQAAJAtAABSDgAAAAAAAMoAAAAAAAAA0AAAAMAF
AAAAAAAAkA4AAAAAAADCBAAAAAAAAEEGAACxBAAABwIAAAAAAAAAAAAAAAAAAJAtAAAAAAAAggAA
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
AQAAcgQAAAAAAAC6AAAAAAAAAFIAAAAMAAAAY29udGV4dE1lbnU6YgAAAAEAAAAwAgAAoAEAAHIE
AAAAAAAAugAAAAAAAABSAAAACAAAAG1lbnVCYXI6YgAAAAEAAAAAAAAAoAEAAIIFAAAAAAAAcgAA
ACwAAAAsAAAAAAAAAAAAAAD/////////////////////BQAAAAUAAABrAwAAXQIAAMoAAAAAAAAA
0AAAAGIAAAAXAAAAwCoAAJAtAADQMQAAwCIAAOAfAAAwCAAAcDMAAIAlAABQIQAAgAYAAHAJAACQ
MAAA4CcAAKAMAAAwHgAAgAMAAAAsAABQKQAAYAsAAAAkAADQNAAAwCYAAOANAADQBQAAAAAAABUA
AABGBQQAAwAAAEljb24AAAAAAAAAABAAAAAOAhEAU1RCU2luZ2xldG9uUHJveHkAAAAAmgAAAAAA
AABSAAAABwAAAERvbHBoaW5SAAAAGAAAAEltYWdlUmVsYXRpdmVGaWxlTG9jYXRvcroAAAAAAAAA
UgAAAAcAAABjdXJyZW50UgAAAA0AAABTaGVsbFZpZXcuaWNvDgIfAFNUQkV4dGVybmFsUmVzb3Vy
Y2VMaWJyYXJ5UHJveHkAAAAAUgAAABAAAABkb2xwaGluZHIwMDUuZGxsAAAAAA=='))!

(ResourceIdentifier class: HRRPLogonDialog name: 'Default view') assign: (Object fromBinaryStoreBytes:
(ByteArray fromBase64String: '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
ADwAAADKAAAAAAAAANAAAADQBQAA0AMAAAAAAAATAAAA8AUAAJoBAAAAAAAAEAkAAGIAAAAQAAAA
AAAAAKABAABiAAAAAgAAAIIAAAAEAAAAAAEARAEAAACACwAAAAAAAAAAAAAAAAAABwAAAAAAAAAA
AAAAAAAAAIALAAAAAAAAggAAAAQAAABwc+F3cgQAAAAAAAAAAAAAAAAAAAAAAADSAgAAAAAAAMoA
AAAAAAAA0AAAAGIAAAACAAAAEgMAAAAAAAAwAwAAYgAAAAIAAABiAwAAAAAAAAsAAACNAAAAYgMA
AAAAAACXAAAAKQAAAIALAAASAwAAAAAAAEAIAABiAAAAAQAAAFIAAAAKAAAAJlBhc3N3b3JkOoAL
AACSAwAAAAAAAHIAAAAsAAAALAAAAAAAAAABAAAA/////////////////////wUAAABGAAAAUAAA
AFoAAADKAAAAAAAAANAAAADQBQAA0AMAAAAAAAATAAAAAAQAACACAADQAwAAAAAAABUAAABGBQQA
AwAAAEljb24AAAAAAAAAABAAAAAOAhEAU1RCU2luZ2xldG9uUHJveHkAAAAAmgAAAAAAAABSAAAA
BwAAAERvbHBoaW5SAAAAGAAAAEltYWdlUmVsYXRpdmVGaWxlTG9jYXRvcroAAAAAAAAAUgAAAAcA
AABjdXJyZW50UgAAAA4AAABEaWFsb2dWaWV3Lmljbw4CHwBTVEJFeHRlcm5hbFJlc291cmNlTGli
cmFyeVByb3h5AAAAAFIAAAAQAAAAZG9scGhpbmRyMDA1LmRsbAAAAAA='))!

(ResourceIdentifier class: HRScheduleItemPresenter name: 'Default view') assign: (Object fromBinaryStoreBytes:
(ByteArray fromBase64String: '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
DwAAAAAAAIIAAAAEAAAAcHPhd3IEAAAAAAAAAAAAAAAAAAAAAAAA0gIAAAAAAADKAAAAAAAAANAA
AABiAAAAAgAAABIDAAAAAAAAMAMAAGIAAAACAAAAYgMAAAAAAAAVAAAAFQAAAGIDAAAAAAAAyQAA
ACkAAABADwAAEgMAAAAAAACgCQAAYgAAAAEAAABSAAAABwAAAE9iamVjdDpADwAAkgMAAAAAAABy
AAAALAAAACwAAAAAAAAAAQAAAP////////////////////8KAAAACgAAAG4AAAAeAAAAygAAAAAA
AADQAAAAEAYAANADAAAAAAAAEwAAADAGAACaAQAAAAAAAFAPAABiAAAAEAAAAAAAAACgAQAAYgAA
AAIAAACCAAAABAAAAAABAEQBAAAAkBAAAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAAAAAAAACQEAAA
AAAAAIIAAAAEAAAAcHPhd3IEAAAAAAAAAAAAAAAAAAAAAAAA0gIAAAAAAADKAAAAAAAAANAAAABi
AAAAAgAAABIDAAAAAAAAMAMAAGIAAAACAAAAYgMAAAAAAAAVAAAAUQAAAGIDAAAAAAAAyQAAACkA
AACQEAAAEgMAAAAAAACgCQAAYgAAAAEAAABSAAAACAAAAFByb2Nlc3M6kBAAAJIDAAAAAAAAcgAA
ACwAAAAsAAAAAAAAAAEAAAD/////////////////////CgAAACgAAABuAAAAPAAAAMoAAAAAAAAA
0AAAABAGAADQAwAAAAAAABMAAABgDAAAmgEAAAAAAABQDwAAYgAAABAAAAAAAAAAoAEAAGIAAAAC
AAAAggAAAAQAAAAAAQBEAQAAAMARAAAAAAAAAAAAAAAAAAAHAAAAAAAAAAAAAAAAAAAAwBEAAAAA
AACCAAAABAAAAHBz4XdyBAAAAAAAAAAAAAAAAAAAAAAAANICAAAAAAAAygAAAAAAAADQAAAAYgAA
AAIAAAASAwAAAAAAADADAABiAAAAAgAAAGIDAAAAAAAAFQAAAI0AAABiAwAAAAAAAMkAAAApAAAA
wBEAABIDAAAAAAAAoAkAAGIAAAABAAAAUgAAAAsAAABQYXJhbWV0ZXJzOsARAACSAwAAAAAAAHIA
AAAsAAAALAAAAAAAAAABAAAA/////////////////////woAAABGAAAAbgAAAFoAAADKAAAAAAAA
ANAAAAAQBgAA0AMAAAAAAAATAAAAAAQAAJoBAAAAAAAAUA8AAGIAAAAQAAAAAAAAAKABAABiAAAA
AgAAAIIAAAAEAAAAAAEARAEAAADwEgAAAAAAAAAAAAAAAAAABwAAAAAAAAAAAAAAAAAAAPASAAAA
AAAAggAAAAQAAABwc+F3cgQAAAAAAAAAAAAAAAAAAAAAAADSAgAAAAAAAMoAAAAAAAAA0AAAAGIA
AAACAAAAEgMAAAAAAAAwAwAAYgAAAAIAAABiAwAAAAAAABUAAADdAAAAYgMAAAAAAAC/AAAAKQAA
APASAAASAwAAAAAAAKAJAABiAAAAAQAAAFIAAAAFAAAARGF0ZTrwEgAAkgMAAAAAAAByAAAALAAA
ACwAAAAAAAAAAQAAAP////////////////////8KAAAAbgAAAGkAAACCAAAAygAAAAAAAADQAAAA
EAYAANADAAAAAAAAEwAAAHAKAACaAQAAAAAAAFAPAABiAAAAEAAAAAAAAACgAQAAYgAAAAIAAACC
AAAABAAAAAABAEQBAAAAIBQAAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAgFAAAAAAAAIIA
AAAEAAAAcHPhd3IEAAAAAAAAAAAAAAAAAAAAAAAA0gIAAAAAAADKAAAAAAAAANAAAABiAAAAAgAA
ABIDAAAAAAAAMAMAAGIAAAACAAAAYgMAAAAAAAAVAAAAGQEAAGIDAAAAAAAAyQAAACkAAAAgFAAA
EgMAAAAAAACgCQAAYgAAAAEAAABSAAAABQAAAFRpbWU6IBQAAJIDAAAAAAAAcgAAACwAAAAsAAAA
AAAAAAEAAAD/////////////////////CgAAAIwAAABuAAAAoAAAAMoAAAAAAAAA0AAAABAGAADQ
AwAAAAAAABMAAACwBwAAIAIAANADAAAAAAAAFQAAAEYFBAADAAAASWNvbgAAAAAAAAAAEAAAAA4C
EQBTVEJTaW5nbGV0b25Qcm94eQAAAACaAAAAAAAAAFIAAAAHAAAARG9scGhpblIAAAAYAAAASW1h
Z2VSZWxhdGl2ZUZpbGVMb2NhdG9yugAAAAAAAABSAAAABwAAAGN1cnJlbnRSAAAADgAAAERpYWxv
Z1ZpZXcuaWNvDgIfAFNUQkV4dGVybmFsUmVzb3VyY2VMaWJyYXJ5UHJveHkAAAAAUgAAABAAAABk
b2xwaGluZHIwMDUuZGxsAAAAAA=='))!

(ResourceIdentifier class: HRSchedulerPresenter name: 'Default view') assign: (Object fromBinaryStoreBytes:
(ByteArray fromBase64String: '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
////////////LQIAAIwAAAB9AgAAqgAAAMoAAAAAAAAA0AAAAOADAADwAwAAAAAAABMAAABiBwAA
AAAAABAKAABh////gAcAAPf////ABwAAGQEAAOAHAAA9AAAAmgEAAAAAAAAgFgAAYgAAABEAAAAA
AAAAUAUAAGIAAAACAAAAggAAAAQAAAAAIAFEAQAAAEAcAAAAAAAAAAAAAAAAAAAHAAAAAAAAAAAA
AAAAAAAAQBwAAAAAAACCAAAACAAAAE0F//8AAAAAkgsAAAAAAAC6AAAAAAAAAFIAAAAGAAAAdW5s
b2NrUgAAAAYAAABVbmxvY2sBAAAAAQAAAAAAAAAAAAAAAwAAAPICAAAAAAAAygAAAAAAAADQAAAA
YgAAAAMAAAAyAwAAAAAAAFADAABiAAAAAgAAANICAAAAAAAAWwQAAOEBAADSAgAAAAAAAKEAAAA9
AAAAQBwAADIDAAAAAAAAAAkAAGIAAAABAAAAIAAAAEAcAAAyAwAAAAAAAJAEAABiAAAAAQAAAFIA
AAAGAAAAVW5sb2NrQBwAAKIDAAAAAAAAcgAAACwAAAAsAAAAAAAAAAEAAAD/////////////////
////LQIAAPAAAAB9AgAADgEAAMoAAAAAAAAA0AAAAOADAADwAwAAAAAAABMAAABiBwAAAAAAABAK
AABh////gAcAAPf////ABwAA4QEAAOAHAAA9AAAAmgEAAAAAAAAQBgAAYgAAABAAAAAAAAAAUAUA
AGIAAAACAAAAggAAAAQAAAAAAQBEAQAAANAdAAAAAAAAAAAAAAAAAAAHAAAAAAAAAAAAAAAAAAAA
0B0AAAAAAACCAAAACAAAAB0F//8AAAAAcgYAAAAAAAAAAAAAAAAAAAAAAADyAgAAAAAAAMoAAAAA
AAAA0AAAAGIAAAACAAAAMgMAAAAAAABQAwAAYgAAAAIAAADSAgAAAAAAAFsEAABvAAAA0gIAAAAA
AACNAAAAHwAAANAdAAAyAwAAAAAAAJAEAABiAAAAAQAAAFIAAAAJAAAAUnVuIGRhdGU60B0AAKID
AAAAAAAAcgAAACwAAAAsAAAAAAAAAAEAAAD/////////////////////LQIAADcAAABzAgAARgAA
AMoAAAAAAAAA0AAAAOADAADwAwAAAAAAABMAAABiBwAAAAAAAIAHAABX////oAcAAI0AAADABwAA
bwAAAOAHAAAfAAAAmgEAAAAAAAAQCAAAYgAAABAAAAAAAAAAUAUAAGIAAAACAAAAggAAAAQAAAAA
AAFEAQQAABAfAAAAAAAAAAAAAAAAAAAHAAAAAAAAAAAAAAAAAAAAEB8AAAAAAACCAAAACAAAAEsF
//8AAAAARgQKAAEAAABEYXRlVG9UZXh0AAAAAAAAAABSAAAAAAAAAAAAAABSAAAACwAAAGRkIE1N
TSB5eXl5AQAAAPICAAAAAAAAygAAAAAAAADQAAAAYgAAAAMAAAAyAwAAAAAAAFADAABiAAAAAgAA
ANICAAAAAAAAWwQAAJcAAADSAgAAAAAAAKEAAAAzAAAAEB8AADIDAAAAAAAAQAkAAGIAAAABAAAA
cgkAAAAAAAADAAAAAQAAAAMAAAAQHwAAMgMAAAAAAACgCQAAYgAAAAEAAAAgAAAAEB8AAKIDAAAA
AAAAcgAAACwAAAAsAAAAAAAAAAEAAAD/////////////////////LQIAAEsAAAB9AgAAZAAAAMoA
AAAAAAAA0AAAAOADAADwAwAAAAAAABMAAABiBwAAAAAAABAKAABh////gAcAAPf////ABwAAlwAA
AOAHAAAzAAAA6gAAAAAAAAAAAQAAYgAAAAwAAAAQHwAAUgAAAAQAAABkYXRlMAoAAFIAAAAMAAAA
c2NoZWR1bGVMaXN0QBwAAFIAAAAGAAAAdW5sb2NrwBcAAFIAAAADAAAAcHdkIBkAAFIAAAAFAAAA
c3RhcnQACAAAUgAAAAYAAABzdGF0dXMAAAAA8gIAAAAAAADKAAAAAAAAANAAAABiAAAAAQAAADID
AAAAAAAAUAMAAGIAAAACAAAA0gIAAAAAAAABAAAAAQAAANICAAAAAAAABQUAADMCAABQBQAAogMA
AAAAAAByAAAALAAAACwAAAAAAAAAAQAAAP////////////////////8AAAAAAAAAAIICAAAZAQAA
ygAAAAAAAADQAAAAYgAAAAoAAAAABgAAAAgAAMAXAABAHAAAIBkAALAaAAAQFgAAMAoAANAdAAAQ
HwAA8AMAAAAAAAATAAAAYAIAAJoBAAAAAAAAYAUAAGIAAAAPAAAAAAAAAKABAABiAAAAAgAAAIIA
AAAEAAAAAAAARAEAAgDQIQAAAAAAAAICAAAAAAAAHwAAAAAAAAAHAAAAAAAAAAAAAAAAAAAA0CEA
AMIFAAAAAAAA6gAAAAAAAADwAAAAYgAAAAIAAACaAQAAAAAAAJoAAAAAAAAAwAEAAFIAAAARAAAA
TXVsdGlsaW5lVGV4dEVkaXRiAAAAEAAAAAAAAADQIQAAYgAAAAIAAACCAAAABAAAAEQRIEQBBAAA
UCIAAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAAAAAAAABQIgAAAAAAAIIAAAAIAAAASwX//wAAAABy
BgAAAAAAAAAAAAAAAAAACwAAAPICAAAAAAAAygAAAAAAAADQAAAAYgAAAAMAAAAyAwAAAAAAAFAD
AABiAAAAAgAAANICAAAAAAAACwAAAAEAAADSAgAAAAAAAPEEAAArAgAAUCIAADIDAAAAAAAAQAkA
AGIAAAABAAAAcgkAAAAAAAADAAAAAQAAAAMAAABQIgAAMgMAAAAAAACgCQAAYgAAAAEAAAAgAAAA
UCIAAKIDAAAAAAAAcgAAACwAAAAsAAAAAAAAAAEAAAD/////////////////////BQAAAAAAAAB9
AgAAFQEAAMoAAAAAAAAA0AAAAOADAADwAwAAAAAAABMAAABiBwAAAAAAANAVAAALAAAAgAcAAPf/
///ABwAAAQAAAPAVAAD3////6gAAAAAAAAAAAQAAYgAAAAIAAABQIgAAUgAAAAMAAABsb2cAAAAA
8gIAAAAAAADKAAAAAAAAANAAAABiAAAAAQAAADIDAAAAAAAAUAMAAGIAAAACAAAA0gIAAAAAAAAB
AAAAOQIAANICAAAAAAAABQUAADUCAADQIQAAogMAAAAAAAByAAAALAAAACwAAAAAAAAAAQAAAP//
//////////////////8AAAAAHAEAAIICAAA2AgAAygAAAAAAAADQAAAAYgAAAAEAAABQIgAA8AMA
AAAAAAATAAAA8AMAAAAAAAAVAAAARgUEAAMAAABJY29uAAAAAAAAAAAQAAAADgIRAFNUQlNpbmds
ZXRvblByb3h5AAAAAJoAAAAAAAAAUgAAAAcAAABEb2xwaGluUgAAABgAAABJbWFnZVJlbGF0aXZl
RmlsZUxvY2F0b3K6AAAAAAAAAFIAAAAHAAAAY3VycmVudFIAAAANAAAAU2hlbGxWaWV3Lmljbw4C
HwBTVEJFeHRlcm5hbFJlc291cmNlTGlicmFyeVByb3h5AAAAAFIAAAAQAAAAZG9scGhpbmRyMDA1
LmRsbAAAAAA='))!

(ResourceIdentifier class: HRSMSSlipPresenter name: 'Default view') assign: (Object fromBinaryStoreBytes:
(ByteArray fromBase64String: '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
AAC6AAAAAAAAAFIAAAANAAAAZGVsZXRlQWRkcmVzc1IAAAAGAAAARGVsZXRlAQAAAAEAAAAAAAAA
AAAAAAEAAADSAgAAAAAAAMoAAAAAAAAA0AAAAGIAAAADAAAAEgMAAAAAAAAwAwAAYgAAAAIAAABi
AwAAAAAAACMBAAAjAQAAYgMAAAAAAACDAAAAPQAAALAOAAASAwAAAAAAACALAABiAAAAAQAAACAA
AACwDgAAEgMAAAAAAAAgCQAAYgAAAAEAAABSAAAABgAAAERlbGV0ZbAOAAAyBAAAAAAAAHIAAAAs
AAAALAAAAAAAAAABAAAA/////////////////////5EAAACRAAAA0gAAAK8AAADKAAAAAAAAANAA
AABwBAAAgAQAAAAAAAATAAAAgAQAAAAAAAAVAAAARgUEAAMAAABJY29uAAAAAAAAAAAQAAAADgIR
AFNUQlNpbmdsZXRvblByb3h5AAAAAJoAAAAAAAAAUgAAAAcAAABEb2xwaGluUgAAABgAAABJbWFn
ZVJlbGF0aXZlRmlsZUxvY2F0b3K6AAAAAAAAAFIAAAAHAAAAY3VycmVudFIAAAANAAAAU2hlbGxW
aWV3Lmljbw4CHwBTVEJFeHRlcm5hbFJlc291cmNlTGlicmFyeVByb3h5AAAAAFIAAAAQAAAAZG9s
cGhpbmRyMDA1LmRsbAAAAAA='))!

!

"22:58:39, 17 November 2004: Image saved"!

"22:58:45, 17 November 2004: Image saved"!

"22:58:49, 17 November 2004: Image saved"!

"22:58:56, 17 November 2004: Dolphin Smalltalk Professional started"!

"22:59:03, 17 November 2004: Image saved"!

HRSchedulerPresenter show!

!

!

"22:59:47, 17 November 2004: Image saved"!

"12:54:24, 18 April 2005: Dolphin Smalltalk Professional started"!

"13:14:03, 18 April 2005: Image saved"!

"09:04:43, 20 April 2005: Dolphin Smalltalk Professional started"!

IdbToolShell allSubclasses do: [ :each | each uninitializeBeforeRemove; initializeAfterLoad ]!

"09:05:11, 20 April 2005: Image saved"!

"09:03:14, 29 April 2005: Dolphin Smalltalk Professional started"!

